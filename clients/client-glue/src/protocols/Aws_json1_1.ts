import {
  BatchCreatePartitionCommandInput,
  BatchCreatePartitionCommandOutput,
} from "../commands/BatchCreatePartitionCommand";
import {
  BatchDeleteConnectionCommandInput,
  BatchDeleteConnectionCommandOutput,
} from "../commands/BatchDeleteConnectionCommand";
import {
  BatchDeletePartitionCommandInput,
  BatchDeletePartitionCommandOutput,
} from "../commands/BatchDeletePartitionCommand";
import { BatchDeleteTableCommandInput, BatchDeleteTableCommandOutput } from "../commands/BatchDeleteTableCommand";
import {
  BatchDeleteTableVersionCommandInput,
  BatchDeleteTableVersionCommandOutput,
} from "../commands/BatchDeleteTableVersionCommand";
import { BatchGetCrawlersCommandInput, BatchGetCrawlersCommandOutput } from "../commands/BatchGetCrawlersCommand";
import {
  BatchGetDevEndpointsCommandInput,
  BatchGetDevEndpointsCommandOutput,
} from "../commands/BatchGetDevEndpointsCommand";
import { BatchGetJobsCommandInput, BatchGetJobsCommandOutput } from "../commands/BatchGetJobsCommand";
import { BatchGetPartitionCommandInput, BatchGetPartitionCommandOutput } from "../commands/BatchGetPartitionCommand";
import { BatchGetTriggersCommandInput, BatchGetTriggersCommandOutput } from "../commands/BatchGetTriggersCommand";
import { BatchGetWorkflowsCommandInput, BatchGetWorkflowsCommandOutput } from "../commands/BatchGetWorkflowsCommand";
import { BatchStopJobRunCommandInput, BatchStopJobRunCommandOutput } from "../commands/BatchStopJobRunCommand";
import { CancelMLTaskRunCommandInput, CancelMLTaskRunCommandOutput } from "../commands/CancelMLTaskRunCommand";
import { CreateClassifierCommandInput, CreateClassifierCommandOutput } from "../commands/CreateClassifierCommand";
import { CreateConnectionCommandInput, CreateConnectionCommandOutput } from "../commands/CreateConnectionCommand";
import { CreateCrawlerCommandInput, CreateCrawlerCommandOutput } from "../commands/CreateCrawlerCommand";
import { CreateDatabaseCommandInput, CreateDatabaseCommandOutput } from "../commands/CreateDatabaseCommand";
import { CreateDevEndpointCommandInput, CreateDevEndpointCommandOutput } from "../commands/CreateDevEndpointCommand";
import { CreateJobCommandInput, CreateJobCommandOutput } from "../commands/CreateJobCommand";
import { CreateMLTransformCommandInput, CreateMLTransformCommandOutput } from "../commands/CreateMLTransformCommand";
import { CreatePartitionCommandInput, CreatePartitionCommandOutput } from "../commands/CreatePartitionCommand";
import { CreateScriptCommandInput, CreateScriptCommandOutput } from "../commands/CreateScriptCommand";
import {
  CreateSecurityConfigurationCommandInput,
  CreateSecurityConfigurationCommandOutput,
} from "../commands/CreateSecurityConfigurationCommand";
import { CreateTableCommandInput, CreateTableCommandOutput } from "../commands/CreateTableCommand";
import { CreateTriggerCommandInput, CreateTriggerCommandOutput } from "../commands/CreateTriggerCommand";
import {
  CreateUserDefinedFunctionCommandInput,
  CreateUserDefinedFunctionCommandOutput,
} from "../commands/CreateUserDefinedFunctionCommand";
import { CreateWorkflowCommandInput, CreateWorkflowCommandOutput } from "../commands/CreateWorkflowCommand";
import { DeleteClassifierCommandInput, DeleteClassifierCommandOutput } from "../commands/DeleteClassifierCommand";
import { DeleteConnectionCommandInput, DeleteConnectionCommandOutput } from "../commands/DeleteConnectionCommand";
import { DeleteCrawlerCommandInput, DeleteCrawlerCommandOutput } from "../commands/DeleteCrawlerCommand";
import { DeleteDatabaseCommandInput, DeleteDatabaseCommandOutput } from "../commands/DeleteDatabaseCommand";
import { DeleteDevEndpointCommandInput, DeleteDevEndpointCommandOutput } from "../commands/DeleteDevEndpointCommand";
import { DeleteJobCommandInput, DeleteJobCommandOutput } from "../commands/DeleteJobCommand";
import { DeleteMLTransformCommandInput, DeleteMLTransformCommandOutput } from "../commands/DeleteMLTransformCommand";
import { DeletePartitionCommandInput, DeletePartitionCommandOutput } from "../commands/DeletePartitionCommand";
import {
  DeleteResourcePolicyCommandInput,
  DeleteResourcePolicyCommandOutput,
} from "../commands/DeleteResourcePolicyCommand";
import {
  DeleteSecurityConfigurationCommandInput,
  DeleteSecurityConfigurationCommandOutput,
} from "../commands/DeleteSecurityConfigurationCommand";
import { DeleteTableCommandInput, DeleteTableCommandOutput } from "../commands/DeleteTableCommand";
import { DeleteTableVersionCommandInput, DeleteTableVersionCommandOutput } from "../commands/DeleteTableVersionCommand";
import { DeleteTriggerCommandInput, DeleteTriggerCommandOutput } from "../commands/DeleteTriggerCommand";
import {
  DeleteUserDefinedFunctionCommandInput,
  DeleteUserDefinedFunctionCommandOutput,
} from "../commands/DeleteUserDefinedFunctionCommand";
import { DeleteWorkflowCommandInput, DeleteWorkflowCommandOutput } from "../commands/DeleteWorkflowCommand";
import {
  GetCatalogImportStatusCommandInput,
  GetCatalogImportStatusCommandOutput,
} from "../commands/GetCatalogImportStatusCommand";
import { GetClassifierCommandInput, GetClassifierCommandOutput } from "../commands/GetClassifierCommand";
import { GetClassifiersCommandInput, GetClassifiersCommandOutput } from "../commands/GetClassifiersCommand";
import { GetConnectionCommandInput, GetConnectionCommandOutput } from "../commands/GetConnectionCommand";
import { GetConnectionsCommandInput, GetConnectionsCommandOutput } from "../commands/GetConnectionsCommand";
import { GetCrawlerCommandInput, GetCrawlerCommandOutput } from "../commands/GetCrawlerCommand";
import { GetCrawlerMetricsCommandInput, GetCrawlerMetricsCommandOutput } from "../commands/GetCrawlerMetricsCommand";
import { GetCrawlersCommandInput, GetCrawlersCommandOutput } from "../commands/GetCrawlersCommand";
import {
  GetDataCatalogEncryptionSettingsCommandInput,
  GetDataCatalogEncryptionSettingsCommandOutput,
} from "../commands/GetDataCatalogEncryptionSettingsCommand";
import { GetDatabaseCommandInput, GetDatabaseCommandOutput } from "../commands/GetDatabaseCommand";
import { GetDatabasesCommandInput, GetDatabasesCommandOutput } from "../commands/GetDatabasesCommand";
import { GetDataflowGraphCommandInput, GetDataflowGraphCommandOutput } from "../commands/GetDataflowGraphCommand";
import { GetDevEndpointCommandInput, GetDevEndpointCommandOutput } from "../commands/GetDevEndpointCommand";
import { GetDevEndpointsCommandInput, GetDevEndpointsCommandOutput } from "../commands/GetDevEndpointsCommand";
import { GetJobBookmarkCommandInput, GetJobBookmarkCommandOutput } from "../commands/GetJobBookmarkCommand";
import { GetJobCommandInput, GetJobCommandOutput } from "../commands/GetJobCommand";
import { GetJobRunCommandInput, GetJobRunCommandOutput } from "../commands/GetJobRunCommand";
import { GetJobRunsCommandInput, GetJobRunsCommandOutput } from "../commands/GetJobRunsCommand";
import { GetJobsCommandInput, GetJobsCommandOutput } from "../commands/GetJobsCommand";
import { GetMLTaskRunCommandInput, GetMLTaskRunCommandOutput } from "../commands/GetMLTaskRunCommand";
import { GetMLTaskRunsCommandInput, GetMLTaskRunsCommandOutput } from "../commands/GetMLTaskRunsCommand";
import { GetMLTransformCommandInput, GetMLTransformCommandOutput } from "../commands/GetMLTransformCommand";
import { GetMLTransformsCommandInput, GetMLTransformsCommandOutput } from "../commands/GetMLTransformsCommand";
import { GetMappingCommandInput, GetMappingCommandOutput } from "../commands/GetMappingCommand";
import { GetPartitionCommandInput, GetPartitionCommandOutput } from "../commands/GetPartitionCommand";
import { GetPartitionsCommandInput, GetPartitionsCommandOutput } from "../commands/GetPartitionsCommand";
import { GetPlanCommandInput, GetPlanCommandOutput } from "../commands/GetPlanCommand";
import { GetResourcePolicyCommandInput, GetResourcePolicyCommandOutput } from "../commands/GetResourcePolicyCommand";
import {
  GetSecurityConfigurationCommandInput,
  GetSecurityConfigurationCommandOutput,
} from "../commands/GetSecurityConfigurationCommand";
import {
  GetSecurityConfigurationsCommandInput,
  GetSecurityConfigurationsCommandOutput,
} from "../commands/GetSecurityConfigurationsCommand";
import { GetTableCommandInput, GetTableCommandOutput } from "../commands/GetTableCommand";
import { GetTableVersionCommandInput, GetTableVersionCommandOutput } from "../commands/GetTableVersionCommand";
import { GetTableVersionsCommandInput, GetTableVersionsCommandOutput } from "../commands/GetTableVersionsCommand";
import { GetTablesCommandInput, GetTablesCommandOutput } from "../commands/GetTablesCommand";
import { GetTagsCommandInput, GetTagsCommandOutput } from "../commands/GetTagsCommand";
import { GetTriggerCommandInput, GetTriggerCommandOutput } from "../commands/GetTriggerCommand";
import { GetTriggersCommandInput, GetTriggersCommandOutput } from "../commands/GetTriggersCommand";
import {
  GetUserDefinedFunctionCommandInput,
  GetUserDefinedFunctionCommandOutput,
} from "../commands/GetUserDefinedFunctionCommand";
import {
  GetUserDefinedFunctionsCommandInput,
  GetUserDefinedFunctionsCommandOutput,
} from "../commands/GetUserDefinedFunctionsCommand";
import { GetWorkflowCommandInput, GetWorkflowCommandOutput } from "../commands/GetWorkflowCommand";
import { GetWorkflowRunCommandInput, GetWorkflowRunCommandOutput } from "../commands/GetWorkflowRunCommand";
import {
  GetWorkflowRunPropertiesCommandInput,
  GetWorkflowRunPropertiesCommandOutput,
} from "../commands/GetWorkflowRunPropertiesCommand";
import { GetWorkflowRunsCommandInput, GetWorkflowRunsCommandOutput } from "../commands/GetWorkflowRunsCommand";
import {
  ImportCatalogToGlueCommandInput,
  ImportCatalogToGlueCommandOutput,
} from "../commands/ImportCatalogToGlueCommand";
import { ListCrawlersCommandInput, ListCrawlersCommandOutput } from "../commands/ListCrawlersCommand";
import { ListDevEndpointsCommandInput, ListDevEndpointsCommandOutput } from "../commands/ListDevEndpointsCommand";
import { ListJobsCommandInput, ListJobsCommandOutput } from "../commands/ListJobsCommand";
import { ListTriggersCommandInput, ListTriggersCommandOutput } from "../commands/ListTriggersCommand";
import { ListWorkflowsCommandInput, ListWorkflowsCommandOutput } from "../commands/ListWorkflowsCommand";
import {
  PutDataCatalogEncryptionSettingsCommandInput,
  PutDataCatalogEncryptionSettingsCommandOutput,
} from "../commands/PutDataCatalogEncryptionSettingsCommand";
import { PutResourcePolicyCommandInput, PutResourcePolicyCommandOutput } from "../commands/PutResourcePolicyCommand";
import {
  PutWorkflowRunPropertiesCommandInput,
  PutWorkflowRunPropertiesCommandOutput,
} from "../commands/PutWorkflowRunPropertiesCommand";
import { ResetJobBookmarkCommandInput, ResetJobBookmarkCommandOutput } from "../commands/ResetJobBookmarkCommand";
import { SearchTablesCommandInput, SearchTablesCommandOutput } from "../commands/SearchTablesCommand";
import { StartCrawlerCommandInput, StartCrawlerCommandOutput } from "../commands/StartCrawlerCommand";
import {
  StartCrawlerScheduleCommandInput,
  StartCrawlerScheduleCommandOutput,
} from "../commands/StartCrawlerScheduleCommand";
import {
  StartExportLabelsTaskRunCommandInput,
  StartExportLabelsTaskRunCommandOutput,
} from "../commands/StartExportLabelsTaskRunCommand";
import {
  StartImportLabelsTaskRunCommandInput,
  StartImportLabelsTaskRunCommandOutput,
} from "../commands/StartImportLabelsTaskRunCommand";
import { StartJobRunCommandInput, StartJobRunCommandOutput } from "../commands/StartJobRunCommand";
import {
  StartMLEvaluationTaskRunCommandInput,
  StartMLEvaluationTaskRunCommandOutput,
} from "../commands/StartMLEvaluationTaskRunCommand";
import {
  StartMLLabelingSetGenerationTaskRunCommandInput,
  StartMLLabelingSetGenerationTaskRunCommandOutput,
} from "../commands/StartMLLabelingSetGenerationTaskRunCommand";
import { StartTriggerCommandInput, StartTriggerCommandOutput } from "../commands/StartTriggerCommand";
import { StartWorkflowRunCommandInput, StartWorkflowRunCommandOutput } from "../commands/StartWorkflowRunCommand";
import { StopCrawlerCommandInput, StopCrawlerCommandOutput } from "../commands/StopCrawlerCommand";
import {
  StopCrawlerScheduleCommandInput,
  StopCrawlerScheduleCommandOutput,
} from "../commands/StopCrawlerScheduleCommand";
import { StopTriggerCommandInput, StopTriggerCommandOutput } from "../commands/StopTriggerCommand";
import { TagResourceCommandInput, TagResourceCommandOutput } from "../commands/TagResourceCommand";
import { UntagResourceCommandInput, UntagResourceCommandOutput } from "../commands/UntagResourceCommand";
import { UpdateClassifierCommandInput, UpdateClassifierCommandOutput } from "../commands/UpdateClassifierCommand";
import { UpdateConnectionCommandInput, UpdateConnectionCommandOutput } from "../commands/UpdateConnectionCommand";
import { UpdateCrawlerCommandInput, UpdateCrawlerCommandOutput } from "../commands/UpdateCrawlerCommand";
import {
  UpdateCrawlerScheduleCommandInput,
  UpdateCrawlerScheduleCommandOutput,
} from "../commands/UpdateCrawlerScheduleCommand";
import { UpdateDatabaseCommandInput, UpdateDatabaseCommandOutput } from "../commands/UpdateDatabaseCommand";
import { UpdateDevEndpointCommandInput, UpdateDevEndpointCommandOutput } from "../commands/UpdateDevEndpointCommand";
import { UpdateJobCommandInput, UpdateJobCommandOutput } from "../commands/UpdateJobCommand";
import { UpdateMLTransformCommandInput, UpdateMLTransformCommandOutput } from "../commands/UpdateMLTransformCommand";
import { UpdatePartitionCommandInput, UpdatePartitionCommandOutput } from "../commands/UpdatePartitionCommand";
import { UpdateTableCommandInput, UpdateTableCommandOutput } from "../commands/UpdateTableCommand";
import { UpdateTriggerCommandInput, UpdateTriggerCommandOutput } from "../commands/UpdateTriggerCommand";
import {
  UpdateUserDefinedFunctionCommandInput,
  UpdateUserDefinedFunctionCommandOutput,
} from "../commands/UpdateUserDefinedFunctionCommand";
import { UpdateWorkflowCommandInput, UpdateWorkflowCommandOutput } from "../commands/UpdateWorkflowCommand";
import {
  AccessDeniedException,
  Action,
  AlreadyExistsException,
  BatchCreatePartitionRequest,
  BatchCreatePartitionResponse,
  BatchDeleteConnectionRequest,
  BatchDeleteConnectionResponse,
  BatchDeletePartitionRequest,
  BatchDeletePartitionResponse,
  BatchDeleteTableRequest,
  BatchDeleteTableResponse,
  BatchDeleteTableVersionRequest,
  BatchDeleteTableVersionResponse,
  BatchGetCrawlersRequest,
  BatchGetCrawlersResponse,
  BatchGetDevEndpointsRequest,
  BatchGetDevEndpointsResponse,
  BatchGetJobsRequest,
  BatchGetJobsResponse,
  BatchGetPartitionRequest,
  BatchGetPartitionResponse,
  BatchGetTriggersRequest,
  BatchGetTriggersResponse,
  BatchGetWorkflowsRequest,
  BatchGetWorkflowsResponse,
  BatchStopJobRunError,
  BatchStopJobRunRequest,
  BatchStopJobRunResponse,
  BatchStopJobRunSuccessfulSubmission,
  CancelMLTaskRunRequest,
  CancelMLTaskRunResponse,
  CatalogEntry,
  CatalogImportStatus,
  CatalogTarget,
  Classifier,
  CloudWatchEncryption,
  CodeGenEdge,
  CodeGenNode,
  CodeGenNodeArg,
  Column,
  ConcurrentModificationException,
  ConcurrentRunsExceededException,
  Condition,
  ConditionCheckFailureException,
  ConfusionMatrix,
  Connection,
  ConnectionInput,
  ConnectionPasswordEncryption,
  ConnectionPropertyKey,
  ConnectionsList,
  Crawl,
  Crawler,
  CrawlerMetrics,
  CrawlerNodeDetails,
  CrawlerNotRunningException,
  CrawlerRunningException,
  CrawlerStoppingException,
  CrawlerTargets,
  CreateClassifierRequest,
  CreateClassifierResponse,
  CreateConnectionRequest,
  CreateConnectionResponse,
  CreateCrawlerRequest,
  CreateCrawlerResponse,
  CreateCsvClassifierRequest,
  CreateDatabaseRequest,
  CreateDatabaseResponse,
  CreateDevEndpointRequest,
  CreateDevEndpointResponse,
  CreateGrokClassifierRequest,
  CreateJobRequest,
  CreateJobResponse,
  CreateJsonClassifierRequest,
  CreateMLTransformRequest,
  CreateMLTransformResponse,
  CreatePartitionRequest,
  CreatePartitionResponse,
  CreateScriptRequest,
  CreateScriptResponse,
  CreateSecurityConfigurationRequest,
  CreateSecurityConfigurationResponse,
  CreateTableRequest,
  CreateTableResponse,
  CreateTriggerRequest,
  CreateTriggerResponse,
  CreateUserDefinedFunctionRequest,
  CreateUserDefinedFunctionResponse,
  CreateWorkflowRequest,
  CreateWorkflowResponse,
  CreateXMLClassifierRequest,
  CsvClassifier,
  DataCatalogEncryptionSettings,
  DataLakePrincipal,
  Database,
  DatabaseInput,
  DeleteClassifierRequest,
  DeleteClassifierResponse,
  DeleteConnectionRequest,
  DeleteConnectionResponse,
  DeleteCrawlerRequest,
  DeleteCrawlerResponse,
  DeleteDatabaseRequest,
  DeleteDatabaseResponse,
  DeleteDevEndpointRequest,
  DeleteDevEndpointResponse,
  DeleteJobRequest,
  DeleteJobResponse,
  DeleteMLTransformRequest,
  DeleteMLTransformResponse,
  DeletePartitionRequest,
  DeletePartitionResponse,
  DeleteResourcePolicyRequest,
  DeleteResourcePolicyResponse,
  DeleteSecurityConfigurationRequest,
  DeleteSecurityConfigurationResponse,
  DeleteTableRequest,
  DeleteTableResponse,
  DeleteTableVersionRequest,
  DeleteTableVersionResponse,
  DeleteTriggerRequest,
  DeleteTriggerResponse,
  DeleteUserDefinedFunctionRequest,
  DeleteUserDefinedFunctionResponse,
  DeleteWorkflowRequest,
  DeleteWorkflowResponse,
  DevEndpoint,
  DevEndpointCustomLibraries,
  DynamoDBTarget,
  Edge,
  EncryptionAtRest,
  EncryptionConfiguration,
  EntityNotFoundException,
  ErrorDetail,
  EvaluationMetrics,
  ExecutionProperty,
  ExportLabelsTaskRunProperties,
  FindMatchesMetrics,
  FindMatchesParameters,
  FindMatchesTaskRunProperties,
  GetCatalogImportStatusRequest,
  GetCatalogImportStatusResponse,
  GetClassifierRequest,
  GetClassifierResponse,
  GetClassifiersRequest,
  GetClassifiersResponse,
  GetConnectionRequest,
  GetConnectionResponse,
  GetConnectionsFilter,
  GetConnectionsRequest,
  GetConnectionsResponse,
  GetCrawlerMetricsRequest,
  GetCrawlerMetricsResponse,
  GetCrawlerRequest,
  GetCrawlerResponse,
  GetCrawlersRequest,
  GetCrawlersResponse,
  GetDataCatalogEncryptionSettingsRequest,
  GetDataCatalogEncryptionSettingsResponse,
  GetDatabaseRequest,
  GetDatabaseResponse,
  GetDatabasesRequest,
  GetDatabasesResponse,
  GetDataflowGraphRequest,
  GetDataflowGraphResponse,
  GetDevEndpointRequest,
  GetDevEndpointResponse,
  GetDevEndpointsRequest,
  GetDevEndpointsResponse,
  GetJobBookmarkRequest,
  GetJobBookmarkResponse,
  GetJobRequest,
  GetJobResponse,
  GetJobRunRequest,
  GetJobRunResponse,
  GetJobRunsRequest,
  GetJobRunsResponse,
  GetJobsRequest,
  GetJobsResponse,
  GetMLTaskRunRequest,
  GetMLTaskRunResponse,
  GetMLTaskRunsRequest,
  GetMLTaskRunsResponse,
  GetMLTransformRequest,
  GetMLTransformResponse,
  GetMLTransformsRequest,
  GetMLTransformsResponse,
  GetMappingRequest,
  GetMappingResponse,
  GetPartitionRequest,
  GetPartitionResponse,
  GetPartitionsRequest,
  GetPartitionsResponse,
  GetPlanRequest,
  GetPlanResponse,
  GetResourcePolicyRequest,
  GetResourcePolicyResponse,
  GetSecurityConfigurationRequest,
  GetSecurityConfigurationResponse,
  GetSecurityConfigurationsRequest,
  GetSecurityConfigurationsResponse,
  GetTableRequest,
  GetTableResponse,
  GetTableVersionRequest,
  GetTableVersionResponse,
  GetTableVersionsRequest,
  GetTableVersionsResponse,
  GetTablesRequest,
  GetTablesResponse,
  GetTagsRequest,
  GetTagsResponse,
  GetTriggerRequest,
  GetTriggerResponse,
  GetTriggersRequest,
  GetTriggersResponse,
  GetUserDefinedFunctionRequest,
  GetUserDefinedFunctionResponse,
  GetUserDefinedFunctionsRequest,
  GetUserDefinedFunctionsResponse,
  GetWorkflowRequest,
  GetWorkflowResponse,
  GetWorkflowRunPropertiesRequest,
  GetWorkflowRunPropertiesResponse,
  GetWorkflowRunRequest,
  GetWorkflowRunResponse,
  GetWorkflowRunsRequest,
  GetWorkflowRunsResponse,
  GlueEncryptionException,
  GlueTable,
  GrokClassifier,
  IdempotentParameterMismatchException,
  ImportCatalogToGlueRequest,
  ImportCatalogToGlueResponse,
  ImportLabelsTaskRunProperties,
  InternalServiceException,
  InvalidInputException,
  JdbcTarget,
  Job,
  JobBookmarkEntry,
  JobBookmarksEncryption,
  JobCommand,
  JobNodeDetails,
  JobRun,
  JobUpdate,
  JsonClassifier,
  LabelingSetGenerationTaskRunProperties,
  LastCrawlInfo,
  ListCrawlersRequest,
  ListCrawlersResponse,
  ListDevEndpointsRequest,
  ListDevEndpointsResponse,
  ListJobsRequest,
  ListJobsResponse,
  ListTriggersRequest,
  ListTriggersResponse,
  ListWorkflowsRequest,
  ListWorkflowsResponse,
  Location,
  MLTransform,
  MLTransformNotReadyException,
  MappingEntry,
  NoScheduleException,
  Node,
  NotificationProperty,
  OperationTimeoutException,
  Order,
  Partition,
  PartitionError,
  PartitionInput,
  PartitionValueList,
  Permission,
  PhysicalConnectionRequirements,
  Predecessor,
  Predicate,
  PrincipalPermissions,
  PropertyPredicate,
  PutDataCatalogEncryptionSettingsRequest,
  PutDataCatalogEncryptionSettingsResponse,
  PutResourcePolicyRequest,
  PutResourcePolicyResponse,
  PutWorkflowRunPropertiesRequest,
  PutWorkflowRunPropertiesResponse,
  ResetJobBookmarkRequest,
  ResetJobBookmarkResponse,
  ResourceNumberLimitExceededException,
  ResourceUri,
  S3Encryption,
  S3Target,
  Schedule,
  SchedulerNotRunningException,
  SchedulerRunningException,
  SchedulerTransitioningException,
  SchemaChangePolicy,
  SchemaColumn,
  SearchTablesRequest,
  SearchTablesResponse,
  SecurityConfiguration,
  Segment,
  SerDeInfo,
  SkewedInfo,
  SortCriterion,
  StartCrawlerRequest,
  StartCrawlerResponse,
  StartCrawlerScheduleRequest,
  StartCrawlerScheduleResponse,
  StartExportLabelsTaskRunRequest,
  StartExportLabelsTaskRunResponse,
  StartImportLabelsTaskRunRequest,
  StartImportLabelsTaskRunResponse,
  StartJobRunRequest,
  StartJobRunResponse,
  StartMLEvaluationTaskRunRequest,
  StartMLEvaluationTaskRunResponse,
  StartMLLabelingSetGenerationTaskRunRequest,
  StartMLLabelingSetGenerationTaskRunResponse,
  StartTriggerRequest,
  StartTriggerResponse,
  StartWorkflowRunRequest,
  StartWorkflowRunResponse,
  StopCrawlerRequest,
  StopCrawlerResponse,
  StopCrawlerScheduleRequest,
  StopCrawlerScheduleResponse,
  StopTriggerRequest,
  StopTriggerResponse,
  StorageDescriptor,
  Table,
  TableError,
  TableInput,
  TableVersion,
  TableVersionError,
  TagResourceRequest,
  TagResourceResponse,
  TaskRun,
  TaskRunFilterCriteria,
  TaskRunProperties,
  TaskRunSortCriteria,
  TransformFilterCriteria,
  TransformParameters,
  TransformSortCriteria,
  Trigger,
  TriggerNodeDetails,
  TriggerUpdate,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateClassifierRequest,
  UpdateClassifierResponse,
  UpdateConnectionRequest,
  UpdateConnectionResponse,
  UpdateCrawlerRequest,
  UpdateCrawlerResponse,
  UpdateCrawlerScheduleRequest,
  UpdateCrawlerScheduleResponse,
  UpdateCsvClassifierRequest,
  UpdateDatabaseRequest,
  UpdateDatabaseResponse,
  UpdateDevEndpointRequest,
  UpdateDevEndpointResponse,
  UpdateGrokClassifierRequest,
  UpdateJobRequest,
  UpdateJobResponse,
  UpdateJsonClassifierRequest,
  UpdateMLTransformRequest,
  UpdateMLTransformResponse,
  UpdatePartitionRequest,
  UpdatePartitionResponse,
  UpdateTableRequest,
  UpdateTableResponse,
  UpdateTriggerRequest,
  UpdateTriggerResponse,
  UpdateUserDefinedFunctionRequest,
  UpdateUserDefinedFunctionResponse,
  UpdateWorkflowRequest,
  UpdateWorkflowResponse,
  UpdateXMLClassifierRequest,
  UserDefinedFunction,
  UserDefinedFunctionInput,
  ValidationException,
  VersionMismatchException,
  Workflow,
  WorkflowGraph,
  WorkflowRun,
  WorkflowRunStatistics,
  XMLClassifier,
} from "../models/index";
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext,
} from "@aws-sdk/types";

export const serializeAws_json1_1BatchCreatePartitionCommand = async (
  input: BatchCreatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchCreatePartition",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchCreatePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchDeleteConnectionCommand = async (
  input: BatchDeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchDeleteConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchDeleteConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchDeletePartitionCommand = async (
  input: BatchDeletePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchDeletePartition",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchDeletePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchDeleteTableCommand = async (
  input: BatchDeleteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchDeleteTable",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchDeleteTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchDeleteTableVersionCommand = async (
  input: BatchDeleteTableVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchDeleteTableVersion",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchDeleteTableVersionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchGetCrawlersCommand = async (
  input: BatchGetCrawlersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchGetCrawlers",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchGetCrawlersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchGetDevEndpointsCommand = async (
  input: BatchGetDevEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchGetDevEndpoints",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchGetDevEndpointsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchGetJobsCommand = async (
  input: BatchGetJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchGetJobs",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchGetJobsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchGetPartitionCommand = async (
  input: BatchGetPartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchGetPartition",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchGetPartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchGetTriggersCommand = async (
  input: BatchGetTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchGetTriggers",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchGetTriggersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchGetWorkflowsCommand = async (
  input: BatchGetWorkflowsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchGetWorkflows",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchGetWorkflowsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1BatchStopJobRunCommand = async (
  input: BatchStopJobRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.BatchStopJobRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1BatchStopJobRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CancelMLTaskRunCommand = async (
  input: CancelMLTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CancelMLTaskRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CancelMLTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateClassifierCommand = async (
  input: CreateClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateClassifier",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateClassifierRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateConnectionCommand = async (
  input: CreateConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateCrawlerCommand = async (
  input: CreateCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateCrawler",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateDatabaseCommand = async (
  input: CreateDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateDatabase",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateDatabaseRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateDevEndpointCommand = async (
  input: CreateDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateDevEndpoint",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateDevEndpointRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateJobCommand = async (
  input: CreateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateJob",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateMLTransformCommand = async (
  input: CreateMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateMLTransform",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateMLTransformRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreatePartitionCommand = async (
  input: CreatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreatePartition",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreatePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateScriptCommand = async (
  input: CreateScriptCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateScript",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateScriptRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateSecurityConfigurationCommand = async (
  input: CreateSecurityConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateSecurityConfiguration",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateSecurityConfigurationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateTableCommand = async (
  input: CreateTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateTable",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateTriggerCommand = async (
  input: CreateTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateTrigger",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateUserDefinedFunctionCommand = async (
  input: CreateUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateUserDefinedFunction",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateUserDefinedFunctionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateWorkflowCommand = async (
  input: CreateWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.CreateWorkflow",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateWorkflowRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteClassifierCommand = async (
  input: DeleteClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteClassifier",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteClassifierRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteConnectionCommand = async (
  input: DeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteCrawlerCommand = async (
  input: DeleteCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteCrawler",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteDatabaseCommand = async (
  input: DeleteDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteDatabase",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteDatabaseRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteDevEndpointCommand = async (
  input: DeleteDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteDevEndpoint",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteDevEndpointRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteJobCommand = async (
  input: DeleteJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteJob",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteMLTransformCommand = async (
  input: DeleteMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteMLTransform",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteMLTransformRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeletePartitionCommand = async (
  input: DeletePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeletePartition",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeletePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteResourcePolicyCommand = async (
  input: DeleteResourcePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteResourcePolicy",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteResourcePolicyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteSecurityConfigurationCommand = async (
  input: DeleteSecurityConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteSecurityConfiguration",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteSecurityConfigurationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteTableCommand = async (
  input: DeleteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteTable",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteTableVersionCommand = async (
  input: DeleteTableVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteTableVersion",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteTableVersionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteTriggerCommand = async (
  input: DeleteTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteTrigger",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteUserDefinedFunctionCommand = async (
  input: DeleteUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteUserDefinedFunction",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteUserDefinedFunctionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteWorkflowCommand = async (
  input: DeleteWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.DeleteWorkflow",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteWorkflowRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetCatalogImportStatusCommand = async (
  input: GetCatalogImportStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetCatalogImportStatus",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetCatalogImportStatusRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetClassifierCommand = async (
  input: GetClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetClassifier",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetClassifierRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetClassifiersCommand = async (
  input: GetClassifiersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetClassifiers",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetClassifiersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetConnectionCommand = async (
  input: GetConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetConnectionsCommand = async (
  input: GetConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetConnections",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetConnectionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetCrawlerCommand = async (
  input: GetCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetCrawler",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetCrawlerMetricsCommand = async (
  input: GetCrawlerMetricsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetCrawlerMetrics",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetCrawlerMetricsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetCrawlersCommand = async (
  input: GetCrawlersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetCrawlers",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetCrawlersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetDatabaseCommand = async (
  input: GetDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetDatabase",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetDatabaseRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetDatabasesCommand = async (
  input: GetDatabasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetDatabases",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetDatabasesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetDataCatalogEncryptionSettingsCommand = async (
  input: GetDataCatalogEncryptionSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetDataCatalogEncryptionSettings",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetDataCatalogEncryptionSettingsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetDataflowGraphCommand = async (
  input: GetDataflowGraphCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetDataflowGraph",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetDataflowGraphRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetDevEndpointCommand = async (
  input: GetDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetDevEndpoint",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetDevEndpointRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetDevEndpointsCommand = async (
  input: GetDevEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetDevEndpoints",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetDevEndpointsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetJobCommand = async (
  input: GetJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetJob",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetJobBookmarkCommand = async (
  input: GetJobBookmarkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetJobBookmark",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetJobBookmarkRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetJobRunCommand = async (
  input: GetJobRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetJobRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetJobRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetJobRunsCommand = async (
  input: GetJobRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetJobRuns",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetJobRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetJobsCommand = async (
  input: GetJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetJobs",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetJobsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetMappingCommand = async (
  input: GetMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetMapping",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetMappingRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetMLTaskRunCommand = async (
  input: GetMLTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetMLTaskRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetMLTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetMLTaskRunsCommand = async (
  input: GetMLTaskRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetMLTaskRuns",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetMLTaskRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetMLTransformCommand = async (
  input: GetMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetMLTransform",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetMLTransformRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetMLTransformsCommand = async (
  input: GetMLTransformsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetMLTransforms",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetMLTransformsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetPartitionCommand = async (
  input: GetPartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetPartition",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetPartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetPartitionsCommand = async (
  input: GetPartitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetPartitions",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetPartitionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetPlanCommand = async (
  input: GetPlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetPlan",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetPlanRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetResourcePolicyCommand = async (
  input: GetResourcePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetResourcePolicy",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetResourcePolicyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetSecurityConfigurationCommand = async (
  input: GetSecurityConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetSecurityConfiguration",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetSecurityConfigurationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetSecurityConfigurationsCommand = async (
  input: GetSecurityConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetSecurityConfigurations",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetSecurityConfigurationsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetTableCommand = async (
  input: GetTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetTable",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetTablesCommand = async (
  input: GetTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetTables",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTablesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetTableVersionCommand = async (
  input: GetTableVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetTableVersion",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTableVersionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetTableVersionsCommand = async (
  input: GetTableVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetTableVersions",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTableVersionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetTagsCommand = async (
  input: GetTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetTags",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTagsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetTriggerCommand = async (
  input: GetTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetTrigger",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetTriggersCommand = async (
  input: GetTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetTriggers",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTriggersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetUserDefinedFunctionCommand = async (
  input: GetUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetUserDefinedFunction",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetUserDefinedFunctionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetUserDefinedFunctionsCommand = async (
  input: GetUserDefinedFunctionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetUserDefinedFunctions",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetUserDefinedFunctionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetWorkflowCommand = async (
  input: GetWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetWorkflow",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetWorkflowRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetWorkflowRunCommand = async (
  input: GetWorkflowRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetWorkflowRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetWorkflowRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetWorkflowRunPropertiesCommand = async (
  input: GetWorkflowRunPropertiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetWorkflowRunProperties",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetWorkflowRunPropertiesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetWorkflowRunsCommand = async (
  input: GetWorkflowRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.GetWorkflowRuns",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetWorkflowRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ImportCatalogToGlueCommand = async (
  input: ImportCatalogToGlueCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.ImportCatalogToGlue",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ImportCatalogToGlueRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListCrawlersCommand = async (
  input: ListCrawlersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.ListCrawlers",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListCrawlersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListDevEndpointsCommand = async (
  input: ListDevEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.ListDevEndpoints",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListDevEndpointsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListJobsCommand = async (
  input: ListJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.ListJobs",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListJobsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListTriggersCommand = async (
  input: ListTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.ListTriggers",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListTriggersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListWorkflowsCommand = async (
  input: ListWorkflowsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.ListWorkflows",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListWorkflowsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1PutDataCatalogEncryptionSettingsCommand = async (
  input: PutDataCatalogEncryptionSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.PutDataCatalogEncryptionSettings",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1PutDataCatalogEncryptionSettingsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1PutResourcePolicyCommand = async (
  input: PutResourcePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.PutResourcePolicy",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1PutResourcePolicyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1PutWorkflowRunPropertiesCommand = async (
  input: PutWorkflowRunPropertiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.PutWorkflowRunProperties",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1PutWorkflowRunPropertiesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ResetJobBookmarkCommand = async (
  input: ResetJobBookmarkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.ResetJobBookmark",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ResetJobBookmarkRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1SearchTablesCommand = async (
  input: SearchTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.SearchTables",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1SearchTablesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartCrawlerCommand = async (
  input: StartCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StartCrawler",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartCrawlerScheduleCommand = async (
  input: StartCrawlerScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StartCrawlerSchedule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartCrawlerScheduleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartExportLabelsTaskRunCommand = async (
  input: StartExportLabelsTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StartExportLabelsTaskRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartExportLabelsTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartImportLabelsTaskRunCommand = async (
  input: StartImportLabelsTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StartImportLabelsTaskRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartImportLabelsTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartJobRunCommand = async (
  input: StartJobRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StartJobRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartJobRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartMLEvaluationTaskRunCommand = async (
  input: StartMLEvaluationTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StartMLEvaluationTaskRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartMLEvaluationTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommand = async (
  input: StartMLLabelingSetGenerationTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StartMLLabelingSetGenerationTaskRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartMLLabelingSetGenerationTaskRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartTriggerCommand = async (
  input: StartTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StartTrigger",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartWorkflowRunCommand = async (
  input: StartWorkflowRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StartWorkflowRun",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartWorkflowRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StopCrawlerCommand = async (
  input: StopCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StopCrawler",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StopCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StopCrawlerScheduleCommand = async (
  input: StopCrawlerScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StopCrawlerSchedule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StopCrawlerScheduleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StopTriggerCommand = async (
  input: StopTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.StopTrigger",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StopTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1TagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.TagResource",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UntagResource",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UntagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateClassifierCommand = async (
  input: UpdateClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateClassifier",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateClassifierRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateConnectionCommand = async (
  input: UpdateConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateCrawlerCommand = async (
  input: UpdateCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateCrawler",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateCrawlerScheduleCommand = async (
  input: UpdateCrawlerScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateCrawlerSchedule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateCrawlerScheduleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateDatabaseCommand = async (
  input: UpdateDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateDatabase",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateDatabaseRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateDevEndpointCommand = async (
  input: UpdateDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateDevEndpoint",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateDevEndpointRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateJobCommand = async (
  input: UpdateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateJob",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateMLTransformCommand = async (
  input: UpdateMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateMLTransform",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateMLTransformRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdatePartitionCommand = async (
  input: UpdatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdatePartition",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdatePartitionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateTableCommand = async (
  input: UpdateTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateTable",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateTriggerCommand = async (
  input: UpdateTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateTrigger",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateUserDefinedFunctionCommand = async (
  input: UpdateUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateUserDefinedFunction",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateUserDefinedFunctionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateWorkflowCommand = async (
  input: UpdateWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSGlue.UpdateWorkflow",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateWorkflowRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const deserializeAws_json1_1BatchCreatePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreatePartitionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchCreatePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchCreatePartitionResponse(data, context);
  const response: BatchCreatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchCreatePartitionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchCreatePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreatePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchDeleteConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDeleteConnectionResponse(data, context);
  const response: BatchDeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeleteConnectionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchDeleteConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchDeletePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeletePartitionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDeletePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDeletePartitionResponse(data, context);
  const response: BatchDeletePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeletePartitionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchDeletePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeletePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchDeleteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDeleteTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDeleteTableResponse(data, context);
  const response: BatchDeleteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeleteTableResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchDeleteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchDeleteTableVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableVersionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDeleteTableVersionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDeleteTableVersionResponse(data, context);
  const response: BatchDeleteTableVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeleteTableVersionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchDeleteTableVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchGetCrawlersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCrawlersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetCrawlersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetCrawlersResponse(data, context);
  const response: BatchGetCrawlersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetCrawlersResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchGetCrawlersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCrawlersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchGetDevEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetDevEndpointsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetDevEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetDevEndpointsResponse(data, context);
  const response: BatchGetDevEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetDevEndpointsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchGetDevEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetDevEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchGetJobsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetJobsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetJobsResponse(data, context);
  const response: BatchGetJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetJobsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchGetJobsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetJobsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchGetPartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetPartitionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetPartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetPartitionResponse(data, context);
  const response: BatchGetPartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetPartitionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchGetPartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetPartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchGetTriggersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetTriggersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetTriggersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetTriggersResponse(data, context);
  const response: BatchGetTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetTriggersResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchGetTriggersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetTriggersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchGetWorkflowsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetWorkflowsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetWorkflowsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetWorkflowsResponse(data, context);
  const response: BatchGetWorkflowsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetWorkflowsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchGetWorkflowsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetWorkflowsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1BatchStopJobRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchStopJobRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchStopJobRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchStopJobRunResponse(data, context);
  const response: BatchStopJobRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchStopJobRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1BatchStopJobRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchStopJobRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CancelMLTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelMLTaskRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CancelMLTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CancelMLTaskRunResponse(data, context);
  const response: CancelMLTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelMLTaskRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CancelMLTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelMLTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateClassifierCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClassifierCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateClassifierResponse(data, context);
  const response: CreateClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateClassifierResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateClassifierCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClassifierCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateConnectionResponse(data, context);
  const response: CreateConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateConnectionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCrawlerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateCrawlerResponse(data, context);
  const response: CreateCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCrawlerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateDatabaseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDatabaseCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDatabaseResponse(data, context);
  const response: CreateDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDatabaseResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateDatabaseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDatabaseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateDevEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDevEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDevEndpointResponse(data, context);
  const response: CreateDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDevEndpointResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateDevEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDevEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateJobResponse(data, context);
  const response: CreateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateJobResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateMLTransformCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMLTransformCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateMLTransformResponse(data, context);
  const response: CreateMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMLTransformResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateMLTransformCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMLTransformCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreatePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePartitionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreatePartitionResponse(data, context);
  const response: CreatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePartitionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreatePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateScriptCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScriptCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateScriptCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateScriptResponse(data, context);
  const response: CreateScriptCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateScriptResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateScriptCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScriptCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateSecurityConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityConfigurationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateSecurityConfigurationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateSecurityConfigurationResponse(data, context);
  const response: CreateSecurityConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSecurityConfigurationResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateSecurityConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTableResponse(data, context);
  const response: CreateTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTableResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTriggerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTriggerResponse(data, context);
  const response: CreateTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTriggerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue#IdempotentParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateUserDefinedFunctionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserDefinedFunctionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateUserDefinedFunctionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateUserDefinedFunctionResponse(data, context);
  const response: CreateUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateUserDefinedFunctionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateUserDefinedFunctionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserDefinedFunctionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateWorkflowCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWorkflowCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateWorkflowResponse(data, context);
  const response: CreateWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateWorkflowResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateWorkflowCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWorkflowCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteClassifierCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClassifierCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteClassifierResponse(data, context);
  const response: DeleteClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteClassifierResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteClassifierCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClassifierCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteConnectionResponse(data, context);
  const response: DeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteConnectionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCrawlerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteCrawlerResponse(data, context);
  const response: DeleteCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCrawlerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CrawlerRunningException":
    case "com.amazonaws.glue#CrawlerRunningException":
      response = {
        ...(await deserializeAws_json1_1CrawlerRunningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "SchedulerTransitioningException":
    case "com.amazonaws.glue#SchedulerTransitioningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteDatabaseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDatabaseCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDatabaseResponse(data, context);
  const response: DeleteDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDatabaseResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteDatabaseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDatabaseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteDevEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDevEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDevEndpointResponse(data, context);
  const response: DeleteDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDevEndpointResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteDevEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDevEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteJobResponse(data, context);
  const response: DeleteJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteJobResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteMLTransformCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMLTransformCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteMLTransformResponse(data, context);
  const response: DeleteMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteMLTransformResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteMLTransformCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMLTransformCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeletePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePartitionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeletePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeletePartitionResponse(data, context);
  const response: DeletePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeletePartitionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeletePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteResourcePolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourcePolicyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteResourcePolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteResourcePolicyResponse(data, context);
  const response: DeleteResourcePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteResourcePolicyResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteResourcePolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourcePolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConditionCheckFailureException":
    case "com.amazonaws.glue#ConditionCheckFailureException":
      response = {
        ...(await deserializeAws_json1_1ConditionCheckFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteSecurityConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityConfigurationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteSecurityConfigurationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteSecurityConfigurationResponse(data, context);
  const response: DeleteSecurityConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSecurityConfigurationResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteSecurityConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTableResponse(data, context);
  const response: DeleteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTableResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteTableVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableVersionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTableVersionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTableVersionResponse(data, context);
  const response: DeleteTableVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTableVersionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteTableVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTriggerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTriggerResponse(data, context);
  const response: DeleteTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTriggerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteUserDefinedFunctionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserDefinedFunctionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteUserDefinedFunctionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteUserDefinedFunctionResponse(data, context);
  const response: DeleteUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteUserDefinedFunctionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteUserDefinedFunctionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserDefinedFunctionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteWorkflowCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWorkflowCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteWorkflowResponse(data, context);
  const response: DeleteWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteWorkflowResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteWorkflowCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWorkflowCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetCatalogImportStatusCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCatalogImportStatusCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCatalogImportStatusCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCatalogImportStatusResponse(data, context);
  const response: GetCatalogImportStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCatalogImportStatusResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetCatalogImportStatusCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCatalogImportStatusCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetClassifierCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifierCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetClassifierResponse(data, context);
  const response: GetClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetClassifierResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetClassifierCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifierCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetClassifiersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifiersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetClassifiersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetClassifiersResponse(data, context);
  const response: GetClassifiersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetClassifiersResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetClassifiersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifiersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetConnectionResponse(data, context);
  const response: GetConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConnectionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetConnectionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetConnectionsResponse(data, context);
  const response: GetConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConnectionsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCrawlerResponse(data, context);
  const response: GetCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCrawlerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetCrawlerMetricsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerMetricsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCrawlerMetricsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCrawlerMetricsResponse(data, context);
  const response: GetCrawlerMetricsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCrawlerMetricsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetCrawlerMetricsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerMetricsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetCrawlersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCrawlersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCrawlersResponse(data, context);
  const response: GetCrawlersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCrawlersResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetCrawlersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetDatabaseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabaseCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDatabaseResponse(data, context);
  const response: GetDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDatabaseResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetDatabaseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabaseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetDatabasesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabasesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDatabasesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDatabasesResponse(data, context);
  const response: GetDatabasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDatabasesResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetDatabasesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabasesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataCatalogEncryptionSettingsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDataCatalogEncryptionSettingsResponse(data, context);
  const response: GetDataCatalogEncryptionSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDataCatalogEncryptionSettingsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataCatalogEncryptionSettingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetDataflowGraphCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataflowGraphCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDataflowGraphCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDataflowGraphResponse(data, context);
  const response: GetDataflowGraphCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDataflowGraphResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetDataflowGraphCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataflowGraphCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetDevEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDevEndpointResponse(data, context);
  const response: GetDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDevEndpointResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetDevEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetDevEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDevEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDevEndpointsResponse(data, context);
  const response: GetDevEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDevEndpointsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetDevEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobResponse(data, context);
  const response: GetJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetJobBookmarkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobBookmarkCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobBookmarkCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobBookmarkResponse(data, context);
  const response: GetJobBookmarkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobBookmarkResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetJobBookmarkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobBookmarkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetJobRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobRunResponse(data, context);
  const response: GetJobRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetJobRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetJobRunsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobRunsResponse(data, context);
  const response: GetJobRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobRunsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetJobRunsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetJobsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobsResponse(data, context);
  const response: GetJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetJobsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetMappingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMappingCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMappingCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMappingResponse(data, context);
  const response: GetMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMappingResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetMappingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMappingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetMLTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMLTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMLTaskRunResponse(data, context);
  const response: GetMLTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMLTaskRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetMLTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetMLTaskRunsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMLTaskRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMLTaskRunsResponse(data, context);
  const response: GetMLTaskRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMLTaskRunsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetMLTaskRunsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetMLTransformCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMLTransformResponse(data, context);
  const response: GetMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMLTransformResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetMLTransformCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetMLTransformsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMLTransformsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMLTransformsResponse(data, context);
  const response: GetMLTransformsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMLTransformsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetMLTransformsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetPartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPartitionResponse(data, context);
  const response: GetPartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPartitionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetPartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetPartitionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPartitionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPartitionsResponse(data, context);
  const response: GetPartitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPartitionsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetPartitionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetPlanCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPlanCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPlanCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPlanResponse(data, context);
  const response: GetPlanCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPlanResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetPlanCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPlanCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetResourcePolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcePolicyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetResourcePolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetResourcePolicyResponse(data, context);
  const response: GetResourcePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetResourcePolicyResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetResourcePolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcePolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetSecurityConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSecurityConfigurationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSecurityConfigurationResponse(data, context);
  const response: GetSecurityConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSecurityConfigurationResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetSecurityConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetSecurityConfigurationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSecurityConfigurationsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSecurityConfigurationsResponse(data, context);
  const response: GetSecurityConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSecurityConfigurationsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetSecurityConfigurationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTableResponse(data, context);
  const response: GetTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTableResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetTablesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTablesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTablesResponse(data, context);
  const response: GetTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTablesResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetTablesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTablesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetTableVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTableVersionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTableVersionResponse(data, context);
  const response: GetTableVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTableVersionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetTableVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetTableVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTableVersionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTableVersionsResponse(data, context);
  const response: GetTableVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTableVersionsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetTableVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTagsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTagsResponse(data, context);
  const response: GetTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTagsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTriggerResponse(data, context);
  const response: GetTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTriggerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetTriggersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTriggersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTriggersResponse(data, context);
  const response: GetTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTriggersResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetTriggersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetUserDefinedFunctionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetUserDefinedFunctionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetUserDefinedFunctionResponse(data, context);
  const response: GetUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetUserDefinedFunctionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetUserDefinedFunctionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetUserDefinedFunctionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetUserDefinedFunctionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetUserDefinedFunctionsResponse(data, context);
  const response: GetUserDefinedFunctionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetUserDefinedFunctionsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetUserDefinedFunctionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetWorkflowCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWorkflowResponse(data, context);
  const response: GetWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWorkflowResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetWorkflowCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetWorkflowRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWorkflowRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWorkflowRunResponse(data, context);
  const response: GetWorkflowRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWorkflowRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetWorkflowRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetWorkflowRunPropertiesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunPropertiesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWorkflowRunPropertiesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWorkflowRunPropertiesResponse(data, context);
  const response: GetWorkflowRunPropertiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWorkflowRunPropertiesResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetWorkflowRunPropertiesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunPropertiesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetWorkflowRunsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWorkflowRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWorkflowRunsResponse(data, context);
  const response: GetWorkflowRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWorkflowRunsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetWorkflowRunsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ImportCatalogToGlueCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCatalogToGlueCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ImportCatalogToGlueCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ImportCatalogToGlueResponse(data, context);
  const response: ImportCatalogToGlueCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportCatalogToGlueResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ImportCatalogToGlueCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCatalogToGlueCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListCrawlersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCrawlersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListCrawlersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListCrawlersResponse(data, context);
  const response: ListCrawlersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCrawlersResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListCrawlersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCrawlersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListDevEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDevEndpointsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDevEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDevEndpointsResponse(data, context);
  const response: ListDevEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDevEndpointsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListDevEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDevEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListJobsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListJobsResponse(data, context);
  const response: ListJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListJobsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListJobsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListTriggersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTriggersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTriggersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTriggersResponse(data, context);
  const response: ListTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTriggersResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListTriggersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTriggersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListWorkflowsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWorkflowsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListWorkflowsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListWorkflowsResponse(data, context);
  const response: ListWorkflowsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListWorkflowsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListWorkflowsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWorkflowsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutDataCatalogEncryptionSettingsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutDataCatalogEncryptionSettingsResponse(data, context);
  const response: PutDataCatalogEncryptionSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutDataCatalogEncryptionSettingsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutDataCatalogEncryptionSettingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1PutResourcePolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutResourcePolicyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutResourcePolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutResourcePolicyResponse(data, context);
  const response: PutResourcePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutResourcePolicyResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1PutResourcePolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutResourcePolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConditionCheckFailureException":
    case "com.amazonaws.glue#ConditionCheckFailureException":
      response = {
        ...(await deserializeAws_json1_1ConditionCheckFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1PutWorkflowRunPropertiesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutWorkflowRunPropertiesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutWorkflowRunPropertiesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutWorkflowRunPropertiesResponse(data, context);
  const response: PutWorkflowRunPropertiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutWorkflowRunPropertiesResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1PutWorkflowRunPropertiesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutWorkflowRunPropertiesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ResetJobBookmarkCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetJobBookmarkCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ResetJobBookmarkCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ResetJobBookmarkResponse(data, context);
  const response: ResetJobBookmarkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResetJobBookmarkResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ResetJobBookmarkCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetJobBookmarkCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1SearchTablesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTablesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchTablesResponse(data, context);
  const response: SearchTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchTablesResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1SearchTablesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTablesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartCrawlerResponse(data, context);
  const response: StartCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartCrawlerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CrawlerRunningException":
    case "com.amazonaws.glue#CrawlerRunningException":
      response = {
        ...(await deserializeAws_json1_1CrawlerRunningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartCrawlerScheduleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerScheduleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartCrawlerScheduleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartCrawlerScheduleResponse(data, context);
  const response: StartCrawlerScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartCrawlerScheduleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartCrawlerScheduleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerScheduleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NoScheduleException":
    case "com.amazonaws.glue#NoScheduleException":
      response = {
        ...(await deserializeAws_json1_1NoScheduleExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "SchedulerRunningException":
    case "com.amazonaws.glue#SchedulerRunningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerRunningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "SchedulerTransitioningException":
    case "com.amazonaws.glue#SchedulerTransitioningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartExportLabelsTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartExportLabelsTaskRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartExportLabelsTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartExportLabelsTaskRunResponse(data, context);
  const response: StartExportLabelsTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartExportLabelsTaskRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartExportLabelsTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartExportLabelsTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartImportLabelsTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartImportLabelsTaskRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartImportLabelsTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartImportLabelsTaskRunResponse(data, context);
  const response: StartImportLabelsTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartImportLabelsTaskRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartImportLabelsTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartImportLabelsTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartJobRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartJobRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartJobRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartJobRunResponse(data, context);
  const response: StartJobRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartJobRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartJobRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartJobRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartMLEvaluationTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLEvaluationTaskRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartMLEvaluationTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartMLEvaluationTaskRunResponse(data, context);
  const response: StartMLEvaluationTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartMLEvaluationTaskRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartMLEvaluationTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLEvaluationTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MLTransformNotReadyException":
    case "com.amazonaws.glue#MLTransformNotReadyException":
      response = {
        ...(await deserializeAws_json1_1MLTransformNotReadyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLLabelingSetGenerationTaskRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunResponse(data, context);
  const response: StartMLLabelingSetGenerationTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartMLLabelingSetGenerationTaskRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLLabelingSetGenerationTaskRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTriggerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartTriggerResponse(data, context);
  const response: StartTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartTriggerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartWorkflowRunCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartWorkflowRunCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartWorkflowRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartWorkflowRunResponse(data, context);
  const response: StartWorkflowRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartWorkflowRunResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartWorkflowRunCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartWorkflowRunCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StopCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopCrawlerResponse(data, context);
  const response: StopCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopCrawlerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StopCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CrawlerNotRunningException":
    case "com.amazonaws.glue#CrawlerNotRunningException":
      response = {
        ...(await deserializeAws_json1_1CrawlerNotRunningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CrawlerStoppingException":
    case "com.amazonaws.glue#CrawlerStoppingException":
      response = {
        ...(await deserializeAws_json1_1CrawlerStoppingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StopCrawlerScheduleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerScheduleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopCrawlerScheduleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopCrawlerScheduleResponse(data, context);
  const response: StopCrawlerScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopCrawlerScheduleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StopCrawlerScheduleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerScheduleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "SchedulerNotRunningException":
    case "com.amazonaws.glue#SchedulerNotRunningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerNotRunningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "SchedulerTransitioningException":
    case "com.amazonaws.glue#SchedulerTransitioningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StopTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTriggerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopTriggerResponse(data, context);
  const response: StopTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopTriggerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StopTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1TagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1TagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateClassifierCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateClassifierCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateClassifierResponse(data, context);
  const response: UpdateClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateClassifierResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateClassifierCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateClassifierCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionMismatchException":
    case "com.amazonaws.glue#VersionMismatchException":
      response = {
        ...(await deserializeAws_json1_1VersionMismatchExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateConnectionResponse(data, context);
  const response: UpdateConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateConnectionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateCrawlerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateCrawlerResponse(data, context);
  const response: UpdateCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCrawlerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateCrawlerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CrawlerRunningException":
    case "com.amazonaws.glue#CrawlerRunningException":
      response = {
        ...(await deserializeAws_json1_1CrawlerRunningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionMismatchException":
    case "com.amazonaws.glue#VersionMismatchException":
      response = {
        ...(await deserializeAws_json1_1VersionMismatchExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateCrawlerScheduleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerScheduleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateCrawlerScheduleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateCrawlerScheduleResponse(data, context);
  const response: UpdateCrawlerScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCrawlerScheduleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateCrawlerScheduleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerScheduleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "SchedulerTransitioningException":
    case "com.amazonaws.glue#SchedulerTransitioningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionMismatchException":
    case "com.amazonaws.glue#VersionMismatchException":
      response = {
        ...(await deserializeAws_json1_1VersionMismatchExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateDatabaseCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDatabaseCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDatabaseResponse(data, context);
  const response: UpdateDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDatabaseResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateDatabaseCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDatabaseCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateDevEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDevEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDevEndpointResponse(data, context);
  const response: UpdateDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDevEndpointResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateDevEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDevEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ValidationException":
    case "com.amazonaws.glue#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateJobResponse(data, context);
  const response: UpdateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateJobResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateMLTransformCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMLTransformCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateMLTransformResponse(data, context);
  const response: UpdateMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateMLTransformResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateMLTransformCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMLTransformCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue#AccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdatePartitionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePartitionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdatePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdatePartitionResponse(data, context);
  const response: UpdatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePartitionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdatePartitionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePartitionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateTableCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTableCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateTableResponse(data, context);
  const response: UpdateTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTableResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateTableCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTableCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateTriggerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTriggerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateTriggerResponse(data, context);
  const response: UpdateTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTriggerResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateTriggerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTriggerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateUserDefinedFunctionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserDefinedFunctionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateUserDefinedFunctionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateUserDefinedFunctionResponse(data, context);
  const response: UpdateUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateUserDefinedFunctionResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateUserDefinedFunctionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserDefinedFunctionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateWorkflowCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkflowCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateWorkflowResponse(data, context);
  const response: UpdateWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateWorkflowResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateWorkflowCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkflowCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_json1_1AccessDeniedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessDeniedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AccessDeniedException(body, context);
  const contents: AccessDeniedException = {
    name: "AccessDeniedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1AlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AlreadyExistsException(body, context);
  const contents: AlreadyExistsException = {
    name: "AlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1ConcurrentModificationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentModificationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConcurrentModificationException(body, context);
  const contents: ConcurrentModificationException = {
    name: "ConcurrentModificationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentRunsExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConcurrentRunsExceededException(body, context);
  const contents: ConcurrentRunsExceededException = {
    name: "ConcurrentRunsExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1ConditionCheckFailureExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConditionCheckFailureException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConditionCheckFailureException(body, context);
  const contents: ConditionCheckFailureException = {
    name: "ConditionCheckFailureException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1CrawlerNotRunningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CrawlerNotRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CrawlerNotRunningException(body, context);
  const contents: CrawlerNotRunningException = {
    name: "CrawlerNotRunningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1CrawlerRunningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CrawlerRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CrawlerRunningException(body, context);
  const contents: CrawlerRunningException = {
    name: "CrawlerRunningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1CrawlerStoppingExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CrawlerStoppingException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CrawlerStoppingException(body, context);
  const contents: CrawlerStoppingException = {
    name: "CrawlerStoppingException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1EntityNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EntityNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1EntityNotFoundException(body, context);
  const contents: EntityNotFoundException = {
    name: "EntityNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1GlueEncryptionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<GlueEncryptionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1GlueEncryptionException(body, context);
  const contents: GlueEncryptionException = {
    name: "GlueEncryptionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IdempotentParameterMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1IdempotentParameterMismatchException(body, context);
  const contents: IdempotentParameterMismatchException = {
    name: "IdempotentParameterMismatchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1InternalServiceExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalServiceException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InternalServiceException(body, context);
  const contents: InternalServiceException = {
    name: "InternalServiceException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1InvalidInputExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInputException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidInputException(body, context);
  const contents: InvalidInputException = {
    name: "InvalidInputException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1MLTransformNotReadyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MLTransformNotReadyException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MLTransformNotReadyException(body, context);
  const contents: MLTransformNotReadyException = {
    name: "MLTransformNotReadyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1NoScheduleExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoScheduleException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NoScheduleException(body, context);
  const contents: NoScheduleException = {
    name: "NoScheduleException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1OperationTimeoutExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OperationTimeoutException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1OperationTimeoutException(body, context);
  const contents: OperationTimeoutException = {
    name: "OperationTimeoutException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNumberLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceNumberLimitExceededException(body, context);
  const contents: ResourceNumberLimitExceededException = {
    name: "ResourceNumberLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1SchedulerNotRunningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SchedulerNotRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SchedulerNotRunningException(body, context);
  const contents: SchedulerNotRunningException = {
    name: "SchedulerNotRunningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1SchedulerRunningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SchedulerRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SchedulerRunningException(body, context);
  const contents: SchedulerRunningException = {
    name: "SchedulerRunningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1SchedulerTransitioningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SchedulerTransitioningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SchedulerTransitioningException(body, context);
  const contents: SchedulerTransitioningException = {
    name: "SchedulerTransitioningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1ValidationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ValidationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ValidationException(body, context);
  const contents: ValidationException = {
    name: "ValidationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1VersionMismatchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<VersionMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1VersionMismatchException(body, context);
  const contents: VersionMismatchException = {
    name: "VersionMismatchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const serializeAws_json1_1Action = (input: Action, context: __SerdeContext): any => {
  return {
    ...(input.Arguments !== undefined && { Arguments: serializeAws_json1_1GenericMap(input.Arguments, context) }),
    ...(input.CrawlerName !== undefined && { CrawlerName: input.CrawlerName }),
    ...(input.JobName !== undefined && { JobName: input.JobName }),
    ...(input.NotificationProperty !== undefined && {
      NotificationProperty: serializeAws_json1_1NotificationProperty(input.NotificationProperty, context),
    }),
    ...(input.SecurityConfiguration !== undefined && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.Timeout !== undefined && { Timeout: input.Timeout }),
  };
};

const serializeAws_json1_1ActionList = (input: Action[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1Action(entry, context));
};

const serializeAws_json1_1BatchCreatePartitionRequest = (
  input: BatchCreatePartitionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionInputList !== undefined && {
      PartitionInputList: serializeAws_json1_1PartitionInputList(input.PartitionInputList, context),
    }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1BatchDeleteConnectionRequest = (
  input: BatchDeleteConnectionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.ConnectionNameList !== undefined && {
      ConnectionNameList: serializeAws_json1_1DeleteConnectionNameList(input.ConnectionNameList, context),
    }),
  };
};

const serializeAws_json1_1BatchDeletePartitionRequest = (
  input: BatchDeletePartitionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionsToDelete !== undefined && {
      PartitionsToDelete: serializeAws_json1_1BatchDeletePartitionValueList(input.PartitionsToDelete, context),
    }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1BatchDeletePartitionValueList = (
  input: PartitionValueList[],
  context: __SerdeContext
): any => {
  return input.map((entry) => serializeAws_json1_1PartitionValueList(entry, context));
};

const serializeAws_json1_1BatchDeleteTableNameList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1BatchDeleteTableRequest = (input: BatchDeleteTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.TablesToDelete !== undefined && {
      TablesToDelete: serializeAws_json1_1BatchDeleteTableNameList(input.TablesToDelete, context),
    }),
  };
};

const serializeAws_json1_1BatchDeleteTableVersionList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1BatchDeleteTableVersionRequest = (
  input: BatchDeleteTableVersionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
    ...(input.VersionIds !== undefined && {
      VersionIds: serializeAws_json1_1BatchDeleteTableVersionList(input.VersionIds, context),
    }),
  };
};

const serializeAws_json1_1BatchGetCrawlersRequest = (input: BatchGetCrawlersRequest, context: __SerdeContext): any => {
  return {
    ...(input.CrawlerNames !== undefined && {
      CrawlerNames: serializeAws_json1_1CrawlerNameList(input.CrawlerNames, context),
    }),
  };
};

const serializeAws_json1_1BatchGetDevEndpointsRequest = (
  input: BatchGetDevEndpointsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.DevEndpointNames !== undefined && {
      DevEndpointNames: serializeAws_json1_1DevEndpointNames(input.DevEndpointNames, context),
    }),
  };
};

const serializeAws_json1_1BatchGetJobsRequest = (input: BatchGetJobsRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobNames !== undefined && { JobNames: serializeAws_json1_1JobNameList(input.JobNames, context) }),
  };
};

const serializeAws_json1_1BatchGetPartitionRequest = (
  input: BatchGetPartitionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionsToGet !== undefined && {
      PartitionsToGet: serializeAws_json1_1BatchGetPartitionValueList(input.PartitionsToGet, context),
    }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1BatchGetPartitionValueList = (input: PartitionValueList[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1PartitionValueList(entry, context));
};

const serializeAws_json1_1BatchGetTriggersRequest = (input: BatchGetTriggersRequest, context: __SerdeContext): any => {
  return {
    ...(input.TriggerNames !== undefined && {
      TriggerNames: serializeAws_json1_1TriggerNameList(input.TriggerNames, context),
    }),
  };
};

const serializeAws_json1_1BatchGetWorkflowsRequest = (
  input: BatchGetWorkflowsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.IncludeGraph !== undefined && { IncludeGraph: input.IncludeGraph }),
    ...(input.Names !== undefined && { Names: serializeAws_json1_1WorkflowNames(input.Names, context) }),
  };
};

const serializeAws_json1_1BatchStopJobRunJobRunIdList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1BatchStopJobRunRequest = (input: BatchStopJobRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName !== undefined && { JobName: input.JobName }),
    ...(input.JobRunIds !== undefined && {
      JobRunIds: serializeAws_json1_1BatchStopJobRunJobRunIdList(input.JobRunIds, context),
    }),
  };
};

const serializeAws_json1_1BoundedPartitionValueList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1CancelMLTaskRunRequest = (input: CancelMLTaskRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.TaskRunId !== undefined && { TaskRunId: input.TaskRunId }),
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
  };
};

const serializeAws_json1_1CatalogEntries = (input: CatalogEntry[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1CatalogEntry(entry, context));
};

const serializeAws_json1_1CatalogEntry = (input: CatalogEntry, context: __SerdeContext): any => {
  return {
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1CatalogTablesList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1CatalogTarget = (input: CatalogTarget, context: __SerdeContext): any => {
  return {
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.Tables !== undefined && { Tables: serializeAws_json1_1CatalogTablesList(input.Tables, context) }),
  };
};

const serializeAws_json1_1CatalogTargetList = (input: CatalogTarget[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1CatalogTarget(entry, context));
};

const serializeAws_json1_1ClassifierNameList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1CloudWatchEncryption = (input: CloudWatchEncryption, context: __SerdeContext): any => {
  return {
    ...(input.CloudWatchEncryptionMode !== undefined && { CloudWatchEncryptionMode: input.CloudWatchEncryptionMode }),
    ...(input.KmsKeyArn !== undefined && { KmsKeyArn: input.KmsKeyArn }),
  };
};

const serializeAws_json1_1CodeGenEdge = (input: CodeGenEdge, context: __SerdeContext): any => {
  return {
    ...(input.Source !== undefined && { Source: input.Source }),
    ...(input.Target !== undefined && { Target: input.Target }),
    ...(input.TargetParameter !== undefined && { TargetParameter: input.TargetParameter }),
  };
};

const serializeAws_json1_1CodeGenNode = (input: CodeGenNode, context: __SerdeContext): any => {
  return {
    ...(input.Args !== undefined && { Args: serializeAws_json1_1CodeGenNodeArgs(input.Args, context) }),
    ...(input.Id !== undefined && { Id: input.Id }),
    ...(input.LineNumber !== undefined && { LineNumber: input.LineNumber }),
    ...(input.NodeType !== undefined && { NodeType: input.NodeType }),
  };
};

const serializeAws_json1_1CodeGenNodeArg = (input: CodeGenNodeArg, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Param !== undefined && { Param: input.Param }),
    ...(input.Value !== undefined && { Value: input.Value }),
  };
};

const serializeAws_json1_1CodeGenNodeArgs = (input: CodeGenNodeArg[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1CodeGenNodeArg(entry, context));
};

const serializeAws_json1_1Column = (input: Column, context: __SerdeContext): any => {
  return {
    ...(input.Comment !== undefined && { Comment: input.Comment }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Parameters !== undefined && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
    ...(input.Type !== undefined && { Type: input.Type }),
  };
};

const serializeAws_json1_1ColumnList = (input: Column[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1Column(entry, context));
};

const serializeAws_json1_1ColumnValueStringList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1Condition = (input: Condition, context: __SerdeContext): any => {
  return {
    ...(input.CrawlState !== undefined && { CrawlState: input.CrawlState }),
    ...(input.CrawlerName !== undefined && { CrawlerName: input.CrawlerName }),
    ...(input.JobName !== undefined && { JobName: input.JobName }),
    ...(input.LogicalOperator !== undefined && { LogicalOperator: input.LogicalOperator }),
    ...(input.State !== undefined && { State: input.State }),
  };
};

const serializeAws_json1_1ConditionList = (input: Condition[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1Condition(entry, context));
};

const serializeAws_json1_1ConnectionInput = (input: ConnectionInput, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionProperties !== undefined && {
      ConnectionProperties: serializeAws_json1_1ConnectionProperties(input.ConnectionProperties, context),
    }),
    ...(input.ConnectionType !== undefined && { ConnectionType: input.ConnectionType }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.MatchCriteria !== undefined && {
      MatchCriteria: serializeAws_json1_1MatchCriteria(input.MatchCriteria, context),
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.PhysicalConnectionRequirements !== undefined && {
      PhysicalConnectionRequirements: serializeAws_json1_1PhysicalConnectionRequirements(
        input.PhysicalConnectionRequirements,
        context
      ),
    }),
  };
};

const serializeAws_json1_1ConnectionPasswordEncryption = (
  input: ConnectionPasswordEncryption,
  context: __SerdeContext
): any => {
  return {
    ...(input.AwsKmsKeyId !== undefined && { AwsKmsKeyId: input.AwsKmsKeyId }),
    ...(input.ReturnConnectionPasswordEncrypted !== undefined && {
      ReturnConnectionPasswordEncrypted: input.ReturnConnectionPasswordEncrypted,
    }),
  };
};

const serializeAws_json1_1ConnectionProperties = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [ConnectionPropertyKey | string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const serializeAws_json1_1ConnectionsList = (input: ConnectionsList, context: __SerdeContext): any => {
  return {
    ...(input.Connections !== undefined && {
      Connections: serializeAws_json1_1OrchestrationStringList(input.Connections, context),
    }),
  };
};

const serializeAws_json1_1CrawlerNameList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1CrawlerTargets = (input: CrawlerTargets, context: __SerdeContext): any => {
  return {
    ...(input.CatalogTargets !== undefined && {
      CatalogTargets: serializeAws_json1_1CatalogTargetList(input.CatalogTargets, context),
    }),
    ...(input.DynamoDBTargets !== undefined && {
      DynamoDBTargets: serializeAws_json1_1DynamoDBTargetList(input.DynamoDBTargets, context),
    }),
    ...(input.JdbcTargets !== undefined && {
      JdbcTargets: serializeAws_json1_1JdbcTargetList(input.JdbcTargets, context),
    }),
    ...(input.S3Targets !== undefined && { S3Targets: serializeAws_json1_1S3TargetList(input.S3Targets, context) }),
  };
};

const serializeAws_json1_1CreateClassifierRequest = (input: CreateClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.CsvClassifier !== undefined && {
      CsvClassifier: serializeAws_json1_1CreateCsvClassifierRequest(input.CsvClassifier, context),
    }),
    ...(input.GrokClassifier !== undefined && {
      GrokClassifier: serializeAws_json1_1CreateGrokClassifierRequest(input.GrokClassifier, context),
    }),
    ...(input.JsonClassifier !== undefined && {
      JsonClassifier: serializeAws_json1_1CreateJsonClassifierRequest(input.JsonClassifier, context),
    }),
    ...(input.XMLClassifier !== undefined && {
      XMLClassifier: serializeAws_json1_1CreateXMLClassifierRequest(input.XMLClassifier, context),
    }),
  };
};

const serializeAws_json1_1CreateConnectionRequest = (input: CreateConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.ConnectionInput !== undefined && {
      ConnectionInput: serializeAws_json1_1ConnectionInput(input.ConnectionInput, context),
    }),
  };
};

const serializeAws_json1_1CreateCrawlerRequest = (input: CreateCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Classifiers !== undefined && {
      Classifiers: serializeAws_json1_1ClassifierNameList(input.Classifiers, context),
    }),
    ...(input.Configuration !== undefined && { Configuration: input.Configuration }),
    ...(input.CrawlerSecurityConfiguration !== undefined && {
      CrawlerSecurityConfiguration: input.CrawlerSecurityConfiguration,
    }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Role !== undefined && { Role: input.Role }),
    ...(input.Schedule !== undefined && { Schedule: input.Schedule }),
    ...(input.SchemaChangePolicy !== undefined && {
      SchemaChangePolicy: serializeAws_json1_1SchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
    ...(input.TablePrefix !== undefined && { TablePrefix: input.TablePrefix }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    ...(input.Targets !== undefined && { Targets: serializeAws_json1_1CrawlerTargets(input.Targets, context) }),
  };
};

const serializeAws_json1_1CreateCsvClassifierRequest = (
  input: CreateCsvClassifierRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AllowSingleColumn !== undefined && { AllowSingleColumn: input.AllowSingleColumn }),
    ...(input.ContainsHeader !== undefined && { ContainsHeader: input.ContainsHeader }),
    ...(input.Delimiter !== undefined && { Delimiter: input.Delimiter }),
    ...(input.DisableValueTrimming !== undefined && { DisableValueTrimming: input.DisableValueTrimming }),
    ...(input.Header !== undefined && { Header: serializeAws_json1_1CsvHeader(input.Header, context) }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.QuoteSymbol !== undefined && { QuoteSymbol: input.QuoteSymbol }),
  };
};

const serializeAws_json1_1CreateDatabaseRequest = (input: CreateDatabaseRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseInput !== undefined && {
      DatabaseInput: serializeAws_json1_1DatabaseInput(input.DatabaseInput, context),
    }),
  };
};

const serializeAws_json1_1CreateDevEndpointRequest = (
  input: CreateDevEndpointRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Arguments !== undefined && { Arguments: serializeAws_json1_1MapValue(input.Arguments, context) }),
    ...(input.EndpointName !== undefined && { EndpointName: input.EndpointName }),
    ...(input.ExtraJarsS3Path !== undefined && { ExtraJarsS3Path: input.ExtraJarsS3Path }),
    ...(input.ExtraPythonLibsS3Path !== undefined && { ExtraPythonLibsS3Path: input.ExtraPythonLibsS3Path }),
    ...(input.GlueVersion !== undefined && { GlueVersion: input.GlueVersion }),
    ...(input.NumberOfNodes !== undefined && { NumberOfNodes: input.NumberOfNodes }),
    ...(input.NumberOfWorkers !== undefined && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.PublicKey !== undefined && { PublicKey: input.PublicKey }),
    ...(input.PublicKeys !== undefined && {
      PublicKeys: serializeAws_json1_1PublicKeysList(input.PublicKeys, context),
    }),
    ...(input.RoleArn !== undefined && { RoleArn: input.RoleArn }),
    ...(input.SecurityConfiguration !== undefined && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.SecurityGroupIds !== undefined && {
      SecurityGroupIds: serializeAws_json1_1StringList(input.SecurityGroupIds, context),
    }),
    ...(input.SubnetId !== undefined && { SubnetId: input.SubnetId }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    ...(input.WorkerType !== undefined && { WorkerType: input.WorkerType }),
  };
};

const serializeAws_json1_1CreateGrokClassifierRequest = (
  input: CreateGrokClassifierRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Classification !== undefined && { Classification: input.Classification }),
    ...(input.CustomPatterns !== undefined && { CustomPatterns: input.CustomPatterns }),
    ...(input.GrokPattern !== undefined && { GrokPattern: input.GrokPattern }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateJobRequest = (input: CreateJobRequest, context: __SerdeContext): any => {
  return {
    ...(input.AllocatedCapacity !== undefined && { AllocatedCapacity: input.AllocatedCapacity }),
    ...(input.Command !== undefined && { Command: serializeAws_json1_1JobCommand(input.Command, context) }),
    ...(input.Connections !== undefined && {
      Connections: serializeAws_json1_1ConnectionsList(input.Connections, context),
    }),
    ...(input.DefaultArguments !== undefined && {
      DefaultArguments: serializeAws_json1_1GenericMap(input.DefaultArguments, context),
    }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.ExecutionProperty !== undefined && {
      ExecutionProperty: serializeAws_json1_1ExecutionProperty(input.ExecutionProperty, context),
    }),
    ...(input.GlueVersion !== undefined && { GlueVersion: input.GlueVersion }),
    ...(input.LogUri !== undefined && { LogUri: input.LogUri }),
    ...(input.MaxCapacity !== undefined && { MaxCapacity: input.MaxCapacity }),
    ...(input.MaxRetries !== undefined && { MaxRetries: input.MaxRetries }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.NotificationProperty !== undefined && {
      NotificationProperty: serializeAws_json1_1NotificationProperty(input.NotificationProperty, context),
    }),
    ...(input.NumberOfWorkers !== undefined && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Role !== undefined && { Role: input.Role }),
    ...(input.SecurityConfiguration !== undefined && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    ...(input.Timeout !== undefined && { Timeout: input.Timeout }),
    ...(input.WorkerType !== undefined && { WorkerType: input.WorkerType }),
  };
};

const serializeAws_json1_1CreateJsonClassifierRequest = (
  input: CreateJsonClassifierRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.JsonPath !== undefined && { JsonPath: input.JsonPath }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateMLTransformRequest = (
  input: CreateMLTransformRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.GlueVersion !== undefined && { GlueVersion: input.GlueVersion }),
    ...(input.InputRecordTables !== undefined && {
      InputRecordTables: serializeAws_json1_1GlueTables(input.InputRecordTables, context),
    }),
    ...(input.MaxCapacity !== undefined && { MaxCapacity: input.MaxCapacity }),
    ...(input.MaxRetries !== undefined && { MaxRetries: input.MaxRetries }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.NumberOfWorkers !== undefined && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Parameters !== undefined && {
      Parameters: serializeAws_json1_1TransformParameters(input.Parameters, context),
    }),
    ...(input.Role !== undefined && { Role: input.Role }),
    ...(input.Timeout !== undefined && { Timeout: input.Timeout }),
    ...(input.WorkerType !== undefined && { WorkerType: input.WorkerType }),
  };
};

const serializeAws_json1_1CreatePartitionRequest = (input: CreatePartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionInput !== undefined && {
      PartitionInput: serializeAws_json1_1PartitionInput(input.PartitionInput, context),
    }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1CreateScriptRequest = (input: CreateScriptRequest, context: __SerdeContext): any => {
  return {
    ...(input.DagEdges !== undefined && { DagEdges: serializeAws_json1_1DagEdges(input.DagEdges, context) }),
    ...(input.DagNodes !== undefined && { DagNodes: serializeAws_json1_1DagNodes(input.DagNodes, context) }),
    ...(input.Language !== undefined && { Language: input.Language }),
  };
};

const serializeAws_json1_1CreateSecurityConfigurationRequest = (
  input: CreateSecurityConfigurationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.EncryptionConfiguration !== undefined && {
      EncryptionConfiguration: serializeAws_json1_1EncryptionConfiguration(input.EncryptionConfiguration, context),
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateTableRequest = (input: CreateTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.TableInput !== undefined && { TableInput: serializeAws_json1_1TableInput(input.TableInput, context) }),
  };
};

const serializeAws_json1_1CreateTriggerRequest = (input: CreateTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Actions !== undefined && { Actions: serializeAws_json1_1ActionList(input.Actions, context) }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Predicate !== undefined && { Predicate: serializeAws_json1_1Predicate(input.Predicate, context) }),
    ...(input.Schedule !== undefined && { Schedule: input.Schedule }),
    ...(input.StartOnCreation !== undefined && { StartOnCreation: input.StartOnCreation }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    ...(input.Type !== undefined && { Type: input.Type }),
    ...(input.WorkflowName !== undefined && { WorkflowName: input.WorkflowName }),
  };
};

const serializeAws_json1_1CreateUserDefinedFunctionRequest = (
  input: CreateUserDefinedFunctionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.FunctionInput !== undefined && {
      FunctionInput: serializeAws_json1_1UserDefinedFunctionInput(input.FunctionInput, context),
    }),
  };
};

const serializeAws_json1_1CreateWorkflowRequest = (input: CreateWorkflowRequest, context: __SerdeContext): any => {
  return {
    ...(input.DefaultRunProperties !== undefined && {
      DefaultRunProperties: serializeAws_json1_1WorkflowRunProperties(input.DefaultRunProperties, context),
    }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
  };
};

const serializeAws_json1_1CreateXMLClassifierRequest = (
  input: CreateXMLClassifierRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Classification !== undefined && { Classification: input.Classification }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.RowTag !== undefined && { RowTag: input.RowTag }),
  };
};

const serializeAws_json1_1CsvHeader = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1DagEdges = (input: CodeGenEdge[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1CodeGenEdge(entry, context));
};

const serializeAws_json1_1DagNodes = (input: CodeGenNode[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1CodeGenNode(entry, context));
};

const serializeAws_json1_1DatabaseInput = (input: DatabaseInput, context: __SerdeContext): any => {
  return {
    ...(input.CreateTableDefaultPermissions !== undefined && {
      CreateTableDefaultPermissions: serializeAws_json1_1PrincipalPermissionsList(
        input.CreateTableDefaultPermissions,
        context
      ),
    }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.LocationUri !== undefined && { LocationUri: input.LocationUri }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Parameters !== undefined && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
  };
};

const serializeAws_json1_1DataCatalogEncryptionSettings = (
  input: DataCatalogEncryptionSettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.ConnectionPasswordEncryption !== undefined && {
      ConnectionPasswordEncryption: serializeAws_json1_1ConnectionPasswordEncryption(
        input.ConnectionPasswordEncryption,
        context
      ),
    }),
    ...(input.EncryptionAtRest !== undefined && {
      EncryptionAtRest: serializeAws_json1_1EncryptionAtRest(input.EncryptionAtRest, context),
    }),
  };
};

const serializeAws_json1_1DataLakePrincipal = (input: DataLakePrincipal, context: __SerdeContext): any => {
  return {
    ...(input.DataLakePrincipalIdentifier !== undefined && {
      DataLakePrincipalIdentifier: input.DataLakePrincipalIdentifier,
    }),
  };
};

const serializeAws_json1_1DeleteClassifierRequest = (input: DeleteClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1DeleteConnectionNameList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1DeleteConnectionRequest = (input: DeleteConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.ConnectionName !== undefined && { ConnectionName: input.ConnectionName }),
  };
};

const serializeAws_json1_1DeleteCrawlerRequest = (input: DeleteCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1DeleteDatabaseRequest = (input: DeleteDatabaseRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1DeleteDevEndpointRequest = (
  input: DeleteDevEndpointRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.EndpointName !== undefined && { EndpointName: input.EndpointName }),
  };
};

const serializeAws_json1_1DeleteJobRequest = (input: DeleteJobRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName !== undefined && { JobName: input.JobName }),
  };
};

const serializeAws_json1_1DeleteMLTransformRequest = (
  input: DeleteMLTransformRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
  };
};

const serializeAws_json1_1DeletePartitionRequest = (input: DeletePartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionValues !== undefined && {
      PartitionValues: serializeAws_json1_1ValueStringList(input.PartitionValues, context),
    }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1DeleteResourcePolicyRequest = (
  input: DeleteResourcePolicyRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.PolicyHashCondition !== undefined && { PolicyHashCondition: input.PolicyHashCondition }),
  };
};

const serializeAws_json1_1DeleteSecurityConfigurationRequest = (
  input: DeleteSecurityConfigurationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1DeleteTableRequest = (input: DeleteTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1DeleteTableVersionRequest = (
  input: DeleteTableVersionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
    ...(input.VersionId !== undefined && { VersionId: input.VersionId }),
  };
};

const serializeAws_json1_1DeleteTriggerRequest = (input: DeleteTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1DeleteUserDefinedFunctionRequest = (
  input: DeleteUserDefinedFunctionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.FunctionName !== undefined && { FunctionName: input.FunctionName }),
  };
};

const serializeAws_json1_1DeleteWorkflowRequest = (input: DeleteWorkflowRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1DevEndpointCustomLibraries = (
  input: DevEndpointCustomLibraries,
  context: __SerdeContext
): any => {
  return {
    ...(input.ExtraJarsS3Path !== undefined && { ExtraJarsS3Path: input.ExtraJarsS3Path }),
    ...(input.ExtraPythonLibsS3Path !== undefined && { ExtraPythonLibsS3Path: input.ExtraPythonLibsS3Path }),
  };
};

const serializeAws_json1_1DevEndpointNames = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1DynamoDBTarget = (input: DynamoDBTarget, context: __SerdeContext): any => {
  return {
    ...(input.Path !== undefined && { Path: input.Path }),
  };
};

const serializeAws_json1_1DynamoDBTargetList = (input: DynamoDBTarget[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1DynamoDBTarget(entry, context));
};

const serializeAws_json1_1EncryptionAtRest = (input: EncryptionAtRest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogEncryptionMode !== undefined && { CatalogEncryptionMode: input.CatalogEncryptionMode }),
    ...(input.SseAwsKmsKeyId !== undefined && { SseAwsKmsKeyId: input.SseAwsKmsKeyId }),
  };
};

const serializeAws_json1_1EncryptionConfiguration = (input: EncryptionConfiguration, context: __SerdeContext): any => {
  return {
    ...(input.CloudWatchEncryption !== undefined && {
      CloudWatchEncryption: serializeAws_json1_1CloudWatchEncryption(input.CloudWatchEncryption, context),
    }),
    ...(input.JobBookmarksEncryption !== undefined && {
      JobBookmarksEncryption: serializeAws_json1_1JobBookmarksEncryption(input.JobBookmarksEncryption, context),
    }),
    ...(input.S3Encryption !== undefined && {
      S3Encryption: serializeAws_json1_1S3EncryptionList(input.S3Encryption, context),
    }),
  };
};

const serializeAws_json1_1ExecutionProperty = (input: ExecutionProperty, context: __SerdeContext): any => {
  return {
    ...(input.MaxConcurrentRuns !== undefined && { MaxConcurrentRuns: input.MaxConcurrentRuns }),
  };
};

const serializeAws_json1_1FindMatchesParameters = (input: FindMatchesParameters, context: __SerdeContext): any => {
  return {
    ...(input.AccuracyCostTradeoff !== undefined && { AccuracyCostTradeoff: input.AccuracyCostTradeoff }),
    ...(input.EnforceProvidedLabels !== undefined && { EnforceProvidedLabels: input.EnforceProvidedLabels }),
    ...(input.PrecisionRecallTradeoff !== undefined && { PrecisionRecallTradeoff: input.PrecisionRecallTradeoff }),
    ...(input.PrimaryKeyColumnName !== undefined && { PrimaryKeyColumnName: input.PrimaryKeyColumnName }),
  };
};

const serializeAws_json1_1GenericMap = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const serializeAws_json1_1GetCatalogImportStatusRequest = (
  input: GetCatalogImportStatusRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
  };
};

const serializeAws_json1_1GetClassifierRequest = (input: GetClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1GetClassifiersRequest = (input: GetClassifiersRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetConnectionRequest = (input: GetConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.HidePassword !== undefined && { HidePassword: input.HidePassword }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1GetConnectionsFilter = (input: GetConnectionsFilter, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionType !== undefined && { ConnectionType: input.ConnectionType }),
    ...(input.MatchCriteria !== undefined && {
      MatchCriteria: serializeAws_json1_1MatchCriteria(input.MatchCriteria, context),
    }),
  };
};

const serializeAws_json1_1GetConnectionsRequest = (input: GetConnectionsRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.Filter !== undefined && { Filter: serializeAws_json1_1GetConnectionsFilter(input.Filter, context) }),
    ...(input.HidePassword !== undefined && { HidePassword: input.HidePassword }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetCrawlerMetricsRequest = (
  input: GetCrawlerMetricsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CrawlerNameList !== undefined && {
      CrawlerNameList: serializeAws_json1_1CrawlerNameList(input.CrawlerNameList, context),
    }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetCrawlerRequest = (input: GetCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1GetCrawlersRequest = (input: GetCrawlersRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetDatabaseRequest = (input: GetDatabaseRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1GetDatabasesRequest = (input: GetDatabasesRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetDataCatalogEncryptionSettingsRequest = (
  input: GetDataCatalogEncryptionSettingsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
  };
};

const serializeAws_json1_1GetDataflowGraphRequest = (input: GetDataflowGraphRequest, context: __SerdeContext): any => {
  return {
    ...(input.PythonScript !== undefined && { PythonScript: input.PythonScript }),
  };
};

const serializeAws_json1_1GetDevEndpointRequest = (input: GetDevEndpointRequest, context: __SerdeContext): any => {
  return {
    ...(input.EndpointName !== undefined && { EndpointName: input.EndpointName }),
  };
};

const serializeAws_json1_1GetDevEndpointsRequest = (input: GetDevEndpointsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetJobBookmarkRequest = (input: GetJobBookmarkRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName !== undefined && { JobName: input.JobName }),
    ...(input.RunId !== undefined && { RunId: input.RunId }),
  };
};

const serializeAws_json1_1GetJobRequest = (input: GetJobRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName !== undefined && { JobName: input.JobName }),
  };
};

const serializeAws_json1_1GetJobRunRequest = (input: GetJobRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName !== undefined && { JobName: input.JobName }),
    ...(input.PredecessorsIncluded !== undefined && { PredecessorsIncluded: input.PredecessorsIncluded }),
    ...(input.RunId !== undefined && { RunId: input.RunId }),
  };
};

const serializeAws_json1_1GetJobRunsRequest = (input: GetJobRunsRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName !== undefined && { JobName: input.JobName }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetJobsRequest = (input: GetJobsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetMappingRequest = (input: GetMappingRequest, context: __SerdeContext): any => {
  return {
    ...(input.Location !== undefined && { Location: serializeAws_json1_1Location(input.Location, context) }),
    ...(input.Sinks !== undefined && { Sinks: serializeAws_json1_1CatalogEntries(input.Sinks, context) }),
    ...(input.Source !== undefined && { Source: serializeAws_json1_1CatalogEntry(input.Source, context) }),
  };
};

const serializeAws_json1_1GetMLTaskRunRequest = (input: GetMLTaskRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.TaskRunId !== undefined && { TaskRunId: input.TaskRunId }),
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
  };
};

const serializeAws_json1_1GetMLTaskRunsRequest = (input: GetMLTaskRunsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Filter !== undefined && { Filter: serializeAws_json1_1TaskRunFilterCriteria(input.Filter, context) }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.Sort !== undefined && { Sort: serializeAws_json1_1TaskRunSortCriteria(input.Sort, context) }),
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
  };
};

const serializeAws_json1_1GetMLTransformRequest = (input: GetMLTransformRequest, context: __SerdeContext): any => {
  return {
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
  };
};

const serializeAws_json1_1GetMLTransformsRequest = (input: GetMLTransformsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Filter !== undefined && { Filter: serializeAws_json1_1TransformFilterCriteria(input.Filter, context) }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.Sort !== undefined && { Sort: serializeAws_json1_1TransformSortCriteria(input.Sort, context) }),
  };
};

const serializeAws_json1_1GetPartitionRequest = (input: GetPartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionValues !== undefined && {
      PartitionValues: serializeAws_json1_1ValueStringList(input.PartitionValues, context),
    }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1GetPartitionsRequest = (input: GetPartitionsRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.Expression !== undefined && { Expression: input.Expression }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.Segment !== undefined && { Segment: serializeAws_json1_1Segment(input.Segment, context) }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1GetPlanRequest = (input: GetPlanRequest, context: __SerdeContext): any => {
  return {
    ...(input.Language !== undefined && { Language: input.Language }),
    ...(input.Location !== undefined && { Location: serializeAws_json1_1Location(input.Location, context) }),
    ...(input.Mapping !== undefined && { Mapping: serializeAws_json1_1MappingList(input.Mapping, context) }),
    ...(input.Sinks !== undefined && { Sinks: serializeAws_json1_1CatalogEntries(input.Sinks, context) }),
    ...(input.Source !== undefined && { Source: serializeAws_json1_1CatalogEntry(input.Source, context) }),
  };
};

const serializeAws_json1_1GetResourcePolicyRequest = (
  input: GetResourcePolicyRequest,
  context: __SerdeContext
): any => {
  return {};
};

const serializeAws_json1_1GetSecurityConfigurationRequest = (
  input: GetSecurityConfigurationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1GetSecurityConfigurationsRequest = (
  input: GetSecurityConfigurationsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetTableRequest = (input: GetTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1GetTablesRequest = (input: GetTablesRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.Expression !== undefined && { Expression: input.Expression }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetTableVersionRequest = (input: GetTableVersionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
    ...(input.VersionId !== undefined && { VersionId: input.VersionId }),
  };
};

const serializeAws_json1_1GetTableVersionsRequest = (input: GetTableVersionsRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1GetTagsRequest = (input: GetTagsRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
  };
};

const serializeAws_json1_1GetTriggerRequest = (input: GetTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1GetTriggersRequest = (input: GetTriggersRequest, context: __SerdeContext): any => {
  return {
    ...(input.DependentJobName !== undefined && { DependentJobName: input.DependentJobName }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GetUserDefinedFunctionRequest = (
  input: GetUserDefinedFunctionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.FunctionName !== undefined && { FunctionName: input.FunctionName }),
  };
};

const serializeAws_json1_1GetUserDefinedFunctionsRequest = (
  input: GetUserDefinedFunctionsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.Pattern !== undefined && { Pattern: input.Pattern }),
  };
};

const serializeAws_json1_1GetWorkflowRequest = (input: GetWorkflowRequest, context: __SerdeContext): any => {
  return {
    ...(input.IncludeGraph !== undefined && { IncludeGraph: input.IncludeGraph }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1GetWorkflowRunPropertiesRequest = (
  input: GetWorkflowRunPropertiesRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.RunId !== undefined && { RunId: input.RunId }),
  };
};

const serializeAws_json1_1GetWorkflowRunRequest = (input: GetWorkflowRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.IncludeGraph !== undefined && { IncludeGraph: input.IncludeGraph }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.RunId !== undefined && { RunId: input.RunId }),
  };
};

const serializeAws_json1_1GetWorkflowRunsRequest = (input: GetWorkflowRunsRequest, context: __SerdeContext): any => {
  return {
    ...(input.IncludeGraph !== undefined && { IncludeGraph: input.IncludeGraph }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1GlueTable = (input: GlueTable, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.ConnectionName !== undefined && { ConnectionName: input.ConnectionName }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1GlueTables = (input: GlueTable[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1GlueTable(entry, context));
};

const serializeAws_json1_1ImportCatalogToGlueRequest = (
  input: ImportCatalogToGlueRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
  };
};

const serializeAws_json1_1JdbcTarget = (input: JdbcTarget, context: __SerdeContext): any => {
  return {
    ...(input.ConnectionName !== undefined && { ConnectionName: input.ConnectionName }),
    ...(input.Exclusions !== undefined && { Exclusions: serializeAws_json1_1PathList(input.Exclusions, context) }),
    ...(input.Path !== undefined && { Path: input.Path }),
  };
};

const serializeAws_json1_1JdbcTargetList = (input: JdbcTarget[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1JdbcTarget(entry, context));
};

const serializeAws_json1_1JobBookmarksEncryption = (input: JobBookmarksEncryption, context: __SerdeContext): any => {
  return {
    ...(input.JobBookmarksEncryptionMode !== undefined && {
      JobBookmarksEncryptionMode: input.JobBookmarksEncryptionMode,
    }),
    ...(input.KmsKeyArn !== undefined && { KmsKeyArn: input.KmsKeyArn }),
  };
};

const serializeAws_json1_1JobCommand = (input: JobCommand, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.PythonVersion !== undefined && { PythonVersion: input.PythonVersion }),
    ...(input.ScriptLocation !== undefined && { ScriptLocation: input.ScriptLocation }),
  };
};

const serializeAws_json1_1JobNameList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1JobUpdate = (input: JobUpdate, context: __SerdeContext): any => {
  return {
    ...(input.AllocatedCapacity !== undefined && { AllocatedCapacity: input.AllocatedCapacity }),
    ...(input.Command !== undefined && { Command: serializeAws_json1_1JobCommand(input.Command, context) }),
    ...(input.Connections !== undefined && {
      Connections: serializeAws_json1_1ConnectionsList(input.Connections, context),
    }),
    ...(input.DefaultArguments !== undefined && {
      DefaultArguments: serializeAws_json1_1GenericMap(input.DefaultArguments, context),
    }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.ExecutionProperty !== undefined && {
      ExecutionProperty: serializeAws_json1_1ExecutionProperty(input.ExecutionProperty, context),
    }),
    ...(input.GlueVersion !== undefined && { GlueVersion: input.GlueVersion }),
    ...(input.LogUri !== undefined && { LogUri: input.LogUri }),
    ...(input.MaxCapacity !== undefined && { MaxCapacity: input.MaxCapacity }),
    ...(input.MaxRetries !== undefined && { MaxRetries: input.MaxRetries }),
    ...(input.NotificationProperty !== undefined && {
      NotificationProperty: serializeAws_json1_1NotificationProperty(input.NotificationProperty, context),
    }),
    ...(input.NumberOfWorkers !== undefined && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Role !== undefined && { Role: input.Role }),
    ...(input.SecurityConfiguration !== undefined && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.Timeout !== undefined && { Timeout: input.Timeout }),
    ...(input.WorkerType !== undefined && { WorkerType: input.WorkerType }),
  };
};

const serializeAws_json1_1ListCrawlersRequest = (input: ListCrawlersRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
  };
};

const serializeAws_json1_1ListDevEndpointsRequest = (input: ListDevEndpointsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
  };
};

const serializeAws_json1_1ListJobsRequest = (input: ListJobsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
  };
};

const serializeAws_json1_1ListTriggersRequest = (input: ListTriggersRequest, context: __SerdeContext): any => {
  return {
    ...(input.DependentJobName !== undefined && { DependentJobName: input.DependentJobName }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
  };
};

const serializeAws_json1_1ListWorkflowsRequest = (input: ListWorkflowsRequest, context: __SerdeContext): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
  };
};

const serializeAws_json1_1Location = (input: Location, context: __SerdeContext): any => {
  return {
    ...(input.DynamoDB !== undefined && { DynamoDB: serializeAws_json1_1CodeGenNodeArgs(input.DynamoDB, context) }),
    ...(input.Jdbc !== undefined && { Jdbc: serializeAws_json1_1CodeGenNodeArgs(input.Jdbc, context) }),
    ...(input.S3 !== undefined && { S3: serializeAws_json1_1CodeGenNodeArgs(input.S3, context) }),
  };
};

const serializeAws_json1_1LocationMap = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const serializeAws_json1_1MappingEntry = (input: MappingEntry, context: __SerdeContext): any => {
  return {
    ...(input.SourcePath !== undefined && { SourcePath: input.SourcePath }),
    ...(input.SourceTable !== undefined && { SourceTable: input.SourceTable }),
    ...(input.SourceType !== undefined && { SourceType: input.SourceType }),
    ...(input.TargetPath !== undefined && { TargetPath: input.TargetPath }),
    ...(input.TargetTable !== undefined && { TargetTable: input.TargetTable }),
    ...(input.TargetType !== undefined && { TargetType: input.TargetType }),
  };
};

const serializeAws_json1_1MappingList = (input: MappingEntry[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1MappingEntry(entry, context));
};

const serializeAws_json1_1MapValue = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const serializeAws_json1_1MatchCriteria = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1NameStringList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1NotificationProperty = (input: NotificationProperty, context: __SerdeContext): any => {
  return {
    ...(input.NotifyDelayAfter !== undefined && { NotifyDelayAfter: input.NotifyDelayAfter }),
  };
};

const serializeAws_json1_1OrchestrationStringList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1Order = (input: Order, context: __SerdeContext): any => {
  return {
    ...(input.Column !== undefined && { Column: input.Column }),
    ...(input.SortOrder !== undefined && { SortOrder: input.SortOrder }),
  };
};

const serializeAws_json1_1OrderList = (input: Order[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1Order(entry, context));
};

const serializeAws_json1_1ParametersMap = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const serializeAws_json1_1PartitionInput = (input: PartitionInput, context: __SerdeContext): any => {
  return {
    ...(input.LastAccessTime !== undefined && { LastAccessTime: Math.round(input.LastAccessTime.getTime() / 1000) }),
    ...(input.LastAnalyzedTime !== undefined && {
      LastAnalyzedTime: Math.round(input.LastAnalyzedTime.getTime() / 1000),
    }),
    ...(input.Parameters !== undefined && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
    ...(input.StorageDescriptor !== undefined && {
      StorageDescriptor: serializeAws_json1_1StorageDescriptor(input.StorageDescriptor, context),
    }),
    ...(input.Values !== undefined && { Values: serializeAws_json1_1ValueStringList(input.Values, context) }),
  };
};

const serializeAws_json1_1PartitionInputList = (input: PartitionInput[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1PartitionInput(entry, context));
};

const serializeAws_json1_1PartitionValueList = (input: PartitionValueList, context: __SerdeContext): any => {
  return {
    ...(input.Values !== undefined && { Values: serializeAws_json1_1ValueStringList(input.Values, context) }),
  };
};

const serializeAws_json1_1PathList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1PermissionList = (input: (Permission | string)[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1PhysicalConnectionRequirements = (
  input: PhysicalConnectionRequirements,
  context: __SerdeContext
): any => {
  return {
    ...(input.AvailabilityZone !== undefined && { AvailabilityZone: input.AvailabilityZone }),
    ...(input.SecurityGroupIdList !== undefined && {
      SecurityGroupIdList: serializeAws_json1_1SecurityGroupIdList(input.SecurityGroupIdList, context),
    }),
    ...(input.SubnetId !== undefined && { SubnetId: input.SubnetId }),
  };
};

const serializeAws_json1_1Predicate = (input: Predicate, context: __SerdeContext): any => {
  return {
    ...(input.Conditions !== undefined && { Conditions: serializeAws_json1_1ConditionList(input.Conditions, context) }),
    ...(input.Logical !== undefined && { Logical: input.Logical }),
  };
};

const serializeAws_json1_1PrincipalPermissions = (input: PrincipalPermissions, context: __SerdeContext): any => {
  return {
    ...(input.Permissions !== undefined && {
      Permissions: serializeAws_json1_1PermissionList(input.Permissions, context),
    }),
    ...(input.Principal !== undefined && {
      Principal: serializeAws_json1_1DataLakePrincipal(input.Principal, context),
    }),
  };
};

const serializeAws_json1_1PrincipalPermissionsList = (input: PrincipalPermissions[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1PrincipalPermissions(entry, context));
};

const serializeAws_json1_1PropertyPredicate = (input: PropertyPredicate, context: __SerdeContext): any => {
  return {
    ...(input.Comparator !== undefined && { Comparator: input.Comparator }),
    ...(input.Key !== undefined && { Key: input.Key }),
    ...(input.Value !== undefined && { Value: input.Value }),
  };
};

const serializeAws_json1_1PublicKeysList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1PutDataCatalogEncryptionSettingsRequest = (
  input: PutDataCatalogEncryptionSettingsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DataCatalogEncryptionSettings !== undefined && {
      DataCatalogEncryptionSettings: serializeAws_json1_1DataCatalogEncryptionSettings(
        input.DataCatalogEncryptionSettings,
        context
      ),
    }),
  };
};

const serializeAws_json1_1PutResourcePolicyRequest = (
  input: PutResourcePolicyRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.PolicyExistsCondition !== undefined && { PolicyExistsCondition: input.PolicyExistsCondition }),
    ...(input.PolicyHashCondition !== undefined && { PolicyHashCondition: input.PolicyHashCondition }),
    ...(input.PolicyInJson !== undefined && { PolicyInJson: input.PolicyInJson }),
  };
};

const serializeAws_json1_1PutWorkflowRunPropertiesRequest = (
  input: PutWorkflowRunPropertiesRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.RunId !== undefined && { RunId: input.RunId }),
    ...(input.RunProperties !== undefined && {
      RunProperties: serializeAws_json1_1WorkflowRunProperties(input.RunProperties, context),
    }),
  };
};

const serializeAws_json1_1ResetJobBookmarkRequest = (input: ResetJobBookmarkRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName !== undefined && { JobName: input.JobName }),
    ...(input.RunId !== undefined && { RunId: input.RunId }),
  };
};

const serializeAws_json1_1ResourceUri = (input: ResourceUri, context: __SerdeContext): any => {
  return {
    ...(input.ResourceType !== undefined && { ResourceType: input.ResourceType }),
    ...(input.Uri !== undefined && { Uri: input.Uri }),
  };
};

const serializeAws_json1_1ResourceUriList = (input: ResourceUri[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1ResourceUri(entry, context));
};

const serializeAws_json1_1S3Encryption = (input: S3Encryption, context: __SerdeContext): any => {
  return {
    ...(input.KmsKeyArn !== undefined && { KmsKeyArn: input.KmsKeyArn }),
    ...(input.S3EncryptionMode !== undefined && { S3EncryptionMode: input.S3EncryptionMode }),
  };
};

const serializeAws_json1_1S3EncryptionList = (input: S3Encryption[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1S3Encryption(entry, context));
};

const serializeAws_json1_1S3Target = (input: S3Target, context: __SerdeContext): any => {
  return {
    ...(input.Exclusions !== undefined && { Exclusions: serializeAws_json1_1PathList(input.Exclusions, context) }),
    ...(input.Path !== undefined && { Path: input.Path }),
  };
};

const serializeAws_json1_1S3TargetList = (input: S3Target[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1S3Target(entry, context));
};

const serializeAws_json1_1SchemaChangePolicy = (input: SchemaChangePolicy, context: __SerdeContext): any => {
  return {
    ...(input.DeleteBehavior !== undefined && { DeleteBehavior: input.DeleteBehavior }),
    ...(input.UpdateBehavior !== undefined && { UpdateBehavior: input.UpdateBehavior }),
  };
};

const serializeAws_json1_1SchemaColumn = (input: SchemaColumn, context: __SerdeContext): any => {
  return {
    ...(input.DataType !== undefined && { DataType: input.DataType }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1SearchPropertyPredicates = (input: PropertyPredicate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1PropertyPredicate(entry, context));
};

const serializeAws_json1_1SearchTablesRequest = (input: SearchTablesRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1SearchPropertyPredicates(input.Filters, context),
    }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.SearchText !== undefined && { SearchText: input.SearchText }),
    ...(input.SortCriteria !== undefined && {
      SortCriteria: serializeAws_json1_1SortCriteria(input.SortCriteria, context),
    }),
  };
};

const serializeAws_json1_1SecurityGroupIdList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1Segment = (input: Segment, context: __SerdeContext): any => {
  return {
    ...(input.SegmentNumber !== undefined && { SegmentNumber: input.SegmentNumber }),
    ...(input.TotalSegments !== undefined && { TotalSegments: input.TotalSegments }),
  };
};

const serializeAws_json1_1SerDeInfo = (input: SerDeInfo, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Parameters !== undefined && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
    ...(input.SerializationLibrary !== undefined && { SerializationLibrary: input.SerializationLibrary }),
  };
};

const serializeAws_json1_1SkewedInfo = (input: SkewedInfo, context: __SerdeContext): any => {
  return {
    ...(input.SkewedColumnNames !== undefined && {
      SkewedColumnNames: serializeAws_json1_1NameStringList(input.SkewedColumnNames, context),
    }),
    ...(input.SkewedColumnValueLocationMaps !== undefined && {
      SkewedColumnValueLocationMaps: serializeAws_json1_1LocationMap(input.SkewedColumnValueLocationMaps, context),
    }),
    ...(input.SkewedColumnValues !== undefined && {
      SkewedColumnValues: serializeAws_json1_1ColumnValueStringList(input.SkewedColumnValues, context),
    }),
  };
};

const serializeAws_json1_1SortCriteria = (input: SortCriterion[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1SortCriterion(entry, context));
};

const serializeAws_json1_1SortCriterion = (input: SortCriterion, context: __SerdeContext): any => {
  return {
    ...(input.FieldName !== undefined && { FieldName: input.FieldName }),
    ...(input.Sort !== undefined && { Sort: input.Sort }),
  };
};

const serializeAws_json1_1StartCrawlerRequest = (input: StartCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1StartCrawlerScheduleRequest = (
  input: StartCrawlerScheduleRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CrawlerName !== undefined && { CrawlerName: input.CrawlerName }),
  };
};

const serializeAws_json1_1StartExportLabelsTaskRunRequest = (
  input: StartExportLabelsTaskRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.OutputS3Path !== undefined && { OutputS3Path: input.OutputS3Path }),
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
  };
};

const serializeAws_json1_1StartImportLabelsTaskRunRequest = (
  input: StartImportLabelsTaskRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InputS3Path !== undefined && { InputS3Path: input.InputS3Path }),
    ...(input.ReplaceAllLabels !== undefined && { ReplaceAllLabels: input.ReplaceAllLabels }),
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
  };
};

const serializeAws_json1_1StartJobRunRequest = (input: StartJobRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.AllocatedCapacity !== undefined && { AllocatedCapacity: input.AllocatedCapacity }),
    ...(input.Arguments !== undefined && { Arguments: serializeAws_json1_1GenericMap(input.Arguments, context) }),
    ...(input.JobName !== undefined && { JobName: input.JobName }),
    ...(input.JobRunId !== undefined && { JobRunId: input.JobRunId }),
    ...(input.MaxCapacity !== undefined && { MaxCapacity: input.MaxCapacity }),
    ...(input.NotificationProperty !== undefined && {
      NotificationProperty: serializeAws_json1_1NotificationProperty(input.NotificationProperty, context),
    }),
    ...(input.NumberOfWorkers !== undefined && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.SecurityConfiguration !== undefined && { SecurityConfiguration: input.SecurityConfiguration }),
    ...(input.Timeout !== undefined && { Timeout: input.Timeout }),
    ...(input.WorkerType !== undefined && { WorkerType: input.WorkerType }),
  };
};

const serializeAws_json1_1StartMLEvaluationTaskRunRequest = (
  input: StartMLEvaluationTaskRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
  };
};

const serializeAws_json1_1StartMLLabelingSetGenerationTaskRunRequest = (
  input: StartMLLabelingSetGenerationTaskRunRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.OutputS3Path !== undefined && { OutputS3Path: input.OutputS3Path }),
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
  };
};

const serializeAws_json1_1StartTriggerRequest = (input: StartTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1StartWorkflowRunRequest = (input: StartWorkflowRunRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1StopCrawlerRequest = (input: StopCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1StopCrawlerScheduleRequest = (
  input: StopCrawlerScheduleRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CrawlerName !== undefined && { CrawlerName: input.CrawlerName }),
  };
};

const serializeAws_json1_1StopTriggerRequest = (input: StopTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1StorageDescriptor = (input: StorageDescriptor, context: __SerdeContext): any => {
  return {
    ...(input.BucketColumns !== undefined && {
      BucketColumns: serializeAws_json1_1NameStringList(input.BucketColumns, context),
    }),
    ...(input.Columns !== undefined && { Columns: serializeAws_json1_1ColumnList(input.Columns, context) }),
    ...(input.Compressed !== undefined && { Compressed: input.Compressed }),
    ...(input.InputFormat !== undefined && { InputFormat: input.InputFormat }),
    ...(input.Location !== undefined && { Location: input.Location }),
    ...(input.NumberOfBuckets !== undefined && { NumberOfBuckets: input.NumberOfBuckets }),
    ...(input.OutputFormat !== undefined && { OutputFormat: input.OutputFormat }),
    ...(input.Parameters !== undefined && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
    ...(input.SerdeInfo !== undefined && { SerdeInfo: serializeAws_json1_1SerDeInfo(input.SerdeInfo, context) }),
    ...(input.SkewedInfo !== undefined && { SkewedInfo: serializeAws_json1_1SkewedInfo(input.SkewedInfo, context) }),
    ...(input.SortColumns !== undefined && { SortColumns: serializeAws_json1_1OrderList(input.SortColumns, context) }),
    ...(input.StoredAsSubDirectories !== undefined && { StoredAsSubDirectories: input.StoredAsSubDirectories }),
  };
};

const serializeAws_json1_1StringList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1TableInput = (input: TableInput, context: __SerdeContext): any => {
  return {
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.LastAccessTime !== undefined && { LastAccessTime: Math.round(input.LastAccessTime.getTime() / 1000) }),
    ...(input.LastAnalyzedTime !== undefined && {
      LastAnalyzedTime: Math.round(input.LastAnalyzedTime.getTime() / 1000),
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Owner !== undefined && { Owner: input.Owner }),
    ...(input.Parameters !== undefined && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
    ...(input.PartitionKeys !== undefined && {
      PartitionKeys: serializeAws_json1_1ColumnList(input.PartitionKeys, context),
    }),
    ...(input.Retention !== undefined && { Retention: input.Retention }),
    ...(input.StorageDescriptor !== undefined && {
      StorageDescriptor: serializeAws_json1_1StorageDescriptor(input.StorageDescriptor, context),
    }),
    ...(input.TableType !== undefined && { TableType: input.TableType }),
    ...(input.ViewExpandedText !== undefined && { ViewExpandedText: input.ViewExpandedText }),
    ...(input.ViewOriginalText !== undefined && { ViewOriginalText: input.ViewOriginalText }),
  };
};

const serializeAws_json1_1TagKeysList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1TagResourceRequest = (input: TagResourceRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
    ...(input.TagsToAdd !== undefined && { TagsToAdd: serializeAws_json1_1TagsMap(input.TagsToAdd, context) }),
  };
};

const serializeAws_json1_1TagsMap = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const serializeAws_json1_1TaskRunFilterCriteria = (input: TaskRunFilterCriteria, context: __SerdeContext): any => {
  return {
    ...(input.StartedAfter !== undefined && { StartedAfter: Math.round(input.StartedAfter.getTime() / 1000) }),
    ...(input.StartedBefore !== undefined && { StartedBefore: Math.round(input.StartedBefore.getTime() / 1000) }),
    ...(input.Status !== undefined && { Status: input.Status }),
    ...(input.TaskRunType !== undefined && { TaskRunType: input.TaskRunType }),
  };
};

const serializeAws_json1_1TaskRunSortCriteria = (input: TaskRunSortCriteria, context: __SerdeContext): any => {
  return {
    ...(input.Column !== undefined && { Column: input.Column }),
    ...(input.SortDirection !== undefined && { SortDirection: input.SortDirection }),
  };
};

const serializeAws_json1_1TransformFilterCriteria = (input: TransformFilterCriteria, context: __SerdeContext): any => {
  return {
    ...(input.CreatedAfter !== undefined && { CreatedAfter: Math.round(input.CreatedAfter.getTime() / 1000) }),
    ...(input.CreatedBefore !== undefined && { CreatedBefore: Math.round(input.CreatedBefore.getTime() / 1000) }),
    ...(input.GlueVersion !== undefined && { GlueVersion: input.GlueVersion }),
    ...(input.LastModifiedAfter !== undefined && {
      LastModifiedAfter: Math.round(input.LastModifiedAfter.getTime() / 1000),
    }),
    ...(input.LastModifiedBefore !== undefined && {
      LastModifiedBefore: Math.round(input.LastModifiedBefore.getTime() / 1000),
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Schema !== undefined && { Schema: serializeAws_json1_1TransformSchema(input.Schema, context) }),
    ...(input.Status !== undefined && { Status: input.Status }),
    ...(input.TransformType !== undefined && { TransformType: input.TransformType }),
  };
};

const serializeAws_json1_1TransformParameters = (input: TransformParameters, context: __SerdeContext): any => {
  return {
    ...(input.FindMatchesParameters !== undefined && {
      FindMatchesParameters: serializeAws_json1_1FindMatchesParameters(input.FindMatchesParameters, context),
    }),
    ...(input.TransformType !== undefined && { TransformType: input.TransformType }),
  };
};

const serializeAws_json1_1TransformSchema = (input: SchemaColumn[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1SchemaColumn(entry, context));
};

const serializeAws_json1_1TransformSortCriteria = (input: TransformSortCriteria, context: __SerdeContext): any => {
  return {
    ...(input.Column !== undefined && { Column: input.Column }),
    ...(input.SortDirection !== undefined && { SortDirection: input.SortDirection }),
  };
};

const serializeAws_json1_1TriggerNameList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1TriggerUpdate = (input: TriggerUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Actions !== undefined && { Actions: serializeAws_json1_1ActionList(input.Actions, context) }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Predicate !== undefined && { Predicate: serializeAws_json1_1Predicate(input.Predicate, context) }),
    ...(input.Schedule !== undefined && { Schedule: input.Schedule }),
  };
};

const serializeAws_json1_1UntagResourceRequest = (input: UntagResourceRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
    ...(input.TagsToRemove !== undefined && {
      TagsToRemove: serializeAws_json1_1TagKeysList(input.TagsToRemove, context),
    }),
  };
};

const serializeAws_json1_1UpdateClassifierRequest = (input: UpdateClassifierRequest, context: __SerdeContext): any => {
  return {
    ...(input.CsvClassifier !== undefined && {
      CsvClassifier: serializeAws_json1_1UpdateCsvClassifierRequest(input.CsvClassifier, context),
    }),
    ...(input.GrokClassifier !== undefined && {
      GrokClassifier: serializeAws_json1_1UpdateGrokClassifierRequest(input.GrokClassifier, context),
    }),
    ...(input.JsonClassifier !== undefined && {
      JsonClassifier: serializeAws_json1_1UpdateJsonClassifierRequest(input.JsonClassifier, context),
    }),
    ...(input.XMLClassifier !== undefined && {
      XMLClassifier: serializeAws_json1_1UpdateXMLClassifierRequest(input.XMLClassifier, context),
    }),
  };
};

const serializeAws_json1_1UpdateConnectionRequest = (input: UpdateConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.ConnectionInput !== undefined && {
      ConnectionInput: serializeAws_json1_1ConnectionInput(input.ConnectionInput, context),
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1UpdateCrawlerRequest = (input: UpdateCrawlerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Classifiers !== undefined && {
      Classifiers: serializeAws_json1_1ClassifierNameList(input.Classifiers, context),
    }),
    ...(input.Configuration !== undefined && { Configuration: input.Configuration }),
    ...(input.CrawlerSecurityConfiguration !== undefined && {
      CrawlerSecurityConfiguration: input.CrawlerSecurityConfiguration,
    }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Role !== undefined && { Role: input.Role }),
    ...(input.Schedule !== undefined && { Schedule: input.Schedule }),
    ...(input.SchemaChangePolicy !== undefined && {
      SchemaChangePolicy: serializeAws_json1_1SchemaChangePolicy(input.SchemaChangePolicy, context),
    }),
    ...(input.TablePrefix !== undefined && { TablePrefix: input.TablePrefix }),
    ...(input.Targets !== undefined && { Targets: serializeAws_json1_1CrawlerTargets(input.Targets, context) }),
  };
};

const serializeAws_json1_1UpdateCrawlerScheduleRequest = (
  input: UpdateCrawlerScheduleRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CrawlerName !== undefined && { CrawlerName: input.CrawlerName }),
    ...(input.Schedule !== undefined && { Schedule: input.Schedule }),
  };
};

const serializeAws_json1_1UpdateCsvClassifierRequest = (
  input: UpdateCsvClassifierRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AllowSingleColumn !== undefined && { AllowSingleColumn: input.AllowSingleColumn }),
    ...(input.ContainsHeader !== undefined && { ContainsHeader: input.ContainsHeader }),
    ...(input.Delimiter !== undefined && { Delimiter: input.Delimiter }),
    ...(input.DisableValueTrimming !== undefined && { DisableValueTrimming: input.DisableValueTrimming }),
    ...(input.Header !== undefined && { Header: serializeAws_json1_1CsvHeader(input.Header, context) }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.QuoteSymbol !== undefined && { QuoteSymbol: input.QuoteSymbol }),
  };
};

const serializeAws_json1_1UpdateDatabaseRequest = (input: UpdateDatabaseRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseInput !== undefined && {
      DatabaseInput: serializeAws_json1_1DatabaseInput(input.DatabaseInput, context),
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1UpdateDevEndpointRequest = (
  input: UpdateDevEndpointRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AddArguments !== undefined && {
      AddArguments: serializeAws_json1_1MapValue(input.AddArguments, context),
    }),
    ...(input.AddPublicKeys !== undefined && {
      AddPublicKeys: serializeAws_json1_1PublicKeysList(input.AddPublicKeys, context),
    }),
    ...(input.CustomLibraries !== undefined && {
      CustomLibraries: serializeAws_json1_1DevEndpointCustomLibraries(input.CustomLibraries, context),
    }),
    ...(input.DeleteArguments !== undefined && {
      DeleteArguments: serializeAws_json1_1StringList(input.DeleteArguments, context),
    }),
    ...(input.DeletePublicKeys !== undefined && {
      DeletePublicKeys: serializeAws_json1_1PublicKeysList(input.DeletePublicKeys, context),
    }),
    ...(input.EndpointName !== undefined && { EndpointName: input.EndpointName }),
    ...(input.PublicKey !== undefined && { PublicKey: input.PublicKey }),
    ...(input.UpdateEtlLibraries !== undefined && { UpdateEtlLibraries: input.UpdateEtlLibraries }),
  };
};

const serializeAws_json1_1UpdateGrokClassifierRequest = (
  input: UpdateGrokClassifierRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Classification !== undefined && { Classification: input.Classification }),
    ...(input.CustomPatterns !== undefined && { CustomPatterns: input.CustomPatterns }),
    ...(input.GrokPattern !== undefined && { GrokPattern: input.GrokPattern }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1UpdateJobRequest = (input: UpdateJobRequest, context: __SerdeContext): any => {
  return {
    ...(input.JobName !== undefined && { JobName: input.JobName }),
    ...(input.JobUpdate !== undefined && { JobUpdate: serializeAws_json1_1JobUpdate(input.JobUpdate, context) }),
  };
};

const serializeAws_json1_1UpdateJsonClassifierRequest = (
  input: UpdateJsonClassifierRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.JsonPath !== undefined && { JsonPath: input.JsonPath }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1UpdateMLTransformRequest = (
  input: UpdateMLTransformRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.GlueVersion !== undefined && { GlueVersion: input.GlueVersion }),
    ...(input.MaxCapacity !== undefined && { MaxCapacity: input.MaxCapacity }),
    ...(input.MaxRetries !== undefined && { MaxRetries: input.MaxRetries }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.NumberOfWorkers !== undefined && { NumberOfWorkers: input.NumberOfWorkers }),
    ...(input.Parameters !== undefined && {
      Parameters: serializeAws_json1_1TransformParameters(input.Parameters, context),
    }),
    ...(input.Role !== undefined && { Role: input.Role }),
    ...(input.Timeout !== undefined && { Timeout: input.Timeout }),
    ...(input.TransformId !== undefined && { TransformId: input.TransformId }),
    ...(input.WorkerType !== undefined && { WorkerType: input.WorkerType }),
  };
};

const serializeAws_json1_1UpdatePartitionRequest = (input: UpdatePartitionRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.PartitionInput !== undefined && {
      PartitionInput: serializeAws_json1_1PartitionInput(input.PartitionInput, context),
    }),
    ...(input.PartitionValueList !== undefined && {
      PartitionValueList: serializeAws_json1_1BoundedPartitionValueList(input.PartitionValueList, context),
    }),
    ...(input.TableName !== undefined && { TableName: input.TableName }),
  };
};

const serializeAws_json1_1UpdateTableRequest = (input: UpdateTableRequest, context: __SerdeContext): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.SkipArchive !== undefined && { SkipArchive: input.SkipArchive }),
    ...(input.TableInput !== undefined && { TableInput: serializeAws_json1_1TableInput(input.TableInput, context) }),
  };
};

const serializeAws_json1_1UpdateTriggerRequest = (input: UpdateTriggerRequest, context: __SerdeContext): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.TriggerUpdate !== undefined && {
      TriggerUpdate: serializeAws_json1_1TriggerUpdate(input.TriggerUpdate, context),
    }),
  };
};

const serializeAws_json1_1UpdateUserDefinedFunctionRequest = (
  input: UpdateUserDefinedFunctionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CatalogId !== undefined && { CatalogId: input.CatalogId }),
    ...(input.DatabaseName !== undefined && { DatabaseName: input.DatabaseName }),
    ...(input.FunctionInput !== undefined && {
      FunctionInput: serializeAws_json1_1UserDefinedFunctionInput(input.FunctionInput, context),
    }),
    ...(input.FunctionName !== undefined && { FunctionName: input.FunctionName }),
  };
};

const serializeAws_json1_1UpdateWorkflowRequest = (input: UpdateWorkflowRequest, context: __SerdeContext): any => {
  return {
    ...(input.DefaultRunProperties !== undefined && {
      DefaultRunProperties: serializeAws_json1_1WorkflowRunProperties(input.DefaultRunProperties, context),
    }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1UpdateXMLClassifierRequest = (
  input: UpdateXMLClassifierRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Classification !== undefined && { Classification: input.Classification }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.RowTag !== undefined && { RowTag: input.RowTag }),
  };
};

const serializeAws_json1_1UserDefinedFunctionInput = (
  input: UserDefinedFunctionInput,
  context: __SerdeContext
): any => {
  return {
    ...(input.ClassName !== undefined && { ClassName: input.ClassName }),
    ...(input.FunctionName !== undefined && { FunctionName: input.FunctionName }),
    ...(input.OwnerName !== undefined && { OwnerName: input.OwnerName }),
    ...(input.OwnerType !== undefined && { OwnerType: input.OwnerType }),
    ...(input.ResourceUris !== undefined && {
      ResourceUris: serializeAws_json1_1ResourceUriList(input.ResourceUris, context),
    }),
  };
};

const serializeAws_json1_1ValueStringList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1WorkflowNames = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1WorkflowRunProperties = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const deserializeAws_json1_1AccessDeniedException = (output: any, context: __SerdeContext): AccessDeniedException => {
  return {
    __type: "AccessDeniedException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1Action = (output: any, context: __SerdeContext): Action => {
  return {
    __type: "Action",
    Arguments:
      output.Arguments !== undefined && output.Arguments !== null
        ? deserializeAws_json1_1GenericMap(output.Arguments, context)
        : undefined,
    CrawlerName: output.CrawlerName !== undefined && output.CrawlerName !== null ? output.CrawlerName : undefined,
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
    NotificationProperty:
      output.NotificationProperty !== undefined && output.NotificationProperty !== null
        ? deserializeAws_json1_1NotificationProperty(output.NotificationProperty, context)
        : undefined,
    SecurityConfiguration:
      output.SecurityConfiguration !== undefined && output.SecurityConfiguration !== null
        ? output.SecurityConfiguration
        : undefined,
    Timeout: output.Timeout !== undefined && output.Timeout !== null ? output.Timeout : undefined,
  } as any;
};

const deserializeAws_json1_1ActionList = (output: any, context: __SerdeContext): Action[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Action(entry, context));
};

const deserializeAws_json1_1AlreadyExistsException = (output: any, context: __SerdeContext): AlreadyExistsException => {
  return {
    __type: "AlreadyExistsException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1BatchCreatePartitionResponse = (
  output: any,
  context: __SerdeContext
): BatchCreatePartitionResponse => {
  return {
    __type: "BatchCreatePartitionResponse",
    Errors:
      output.Errors !== undefined && output.Errors !== null
        ? deserializeAws_json1_1PartitionErrors(output.Errors, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchDeleteConnectionResponse = (
  output: any,
  context: __SerdeContext
): BatchDeleteConnectionResponse => {
  return {
    __type: "BatchDeleteConnectionResponse",
    Errors:
      output.Errors !== undefined && output.Errors !== null
        ? deserializeAws_json1_1ErrorByName(output.Errors, context)
        : undefined,
    Succeeded:
      output.Succeeded !== undefined && output.Succeeded !== null
        ? deserializeAws_json1_1NameStringList(output.Succeeded, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchDeletePartitionResponse = (
  output: any,
  context: __SerdeContext
): BatchDeletePartitionResponse => {
  return {
    __type: "BatchDeletePartitionResponse",
    Errors:
      output.Errors !== undefined && output.Errors !== null
        ? deserializeAws_json1_1PartitionErrors(output.Errors, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchDeleteTableResponse = (
  output: any,
  context: __SerdeContext
): BatchDeleteTableResponse => {
  return {
    __type: "BatchDeleteTableResponse",
    Errors:
      output.Errors !== undefined && output.Errors !== null
        ? deserializeAws_json1_1TableErrors(output.Errors, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchDeleteTableVersionResponse = (
  output: any,
  context: __SerdeContext
): BatchDeleteTableVersionResponse => {
  return {
    __type: "BatchDeleteTableVersionResponse",
    Errors:
      output.Errors !== undefined && output.Errors !== null
        ? deserializeAws_json1_1TableVersionErrors(output.Errors, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchGetCrawlersResponse = (
  output: any,
  context: __SerdeContext
): BatchGetCrawlersResponse => {
  return {
    __type: "BatchGetCrawlersResponse",
    Crawlers:
      output.Crawlers !== undefined && output.Crawlers !== null
        ? deserializeAws_json1_1CrawlerList(output.Crawlers, context)
        : undefined,
    CrawlersNotFound:
      output.CrawlersNotFound !== undefined && output.CrawlersNotFound !== null
        ? deserializeAws_json1_1CrawlerNameList(output.CrawlersNotFound, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchGetDevEndpointsResponse = (
  output: any,
  context: __SerdeContext
): BatchGetDevEndpointsResponse => {
  return {
    __type: "BatchGetDevEndpointsResponse",
    DevEndpoints:
      output.DevEndpoints !== undefined && output.DevEndpoints !== null
        ? deserializeAws_json1_1DevEndpointList(output.DevEndpoints, context)
        : undefined,
    DevEndpointsNotFound:
      output.DevEndpointsNotFound !== undefined && output.DevEndpointsNotFound !== null
        ? deserializeAws_json1_1DevEndpointNames(output.DevEndpointsNotFound, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchGetJobsResponse = (output: any, context: __SerdeContext): BatchGetJobsResponse => {
  return {
    __type: "BatchGetJobsResponse",
    Jobs:
      output.Jobs !== undefined && output.Jobs !== null
        ? deserializeAws_json1_1JobList(output.Jobs, context)
        : undefined,
    JobsNotFound:
      output.JobsNotFound !== undefined && output.JobsNotFound !== null
        ? deserializeAws_json1_1JobNameList(output.JobsNotFound, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchGetPartitionResponse = (
  output: any,
  context: __SerdeContext
): BatchGetPartitionResponse => {
  return {
    __type: "BatchGetPartitionResponse",
    Partitions:
      output.Partitions !== undefined && output.Partitions !== null
        ? deserializeAws_json1_1PartitionList(output.Partitions, context)
        : undefined,
    UnprocessedKeys:
      output.UnprocessedKeys !== undefined && output.UnprocessedKeys !== null
        ? deserializeAws_json1_1BatchGetPartitionValueList(output.UnprocessedKeys, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchGetPartitionValueList = (
  output: any,
  context: __SerdeContext
): PartitionValueList[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1PartitionValueList(entry, context));
};

const deserializeAws_json1_1BatchGetTriggersResponse = (
  output: any,
  context: __SerdeContext
): BatchGetTriggersResponse => {
  return {
    __type: "BatchGetTriggersResponse",
    Triggers:
      output.Triggers !== undefined && output.Triggers !== null
        ? deserializeAws_json1_1TriggerList(output.Triggers, context)
        : undefined,
    TriggersNotFound:
      output.TriggersNotFound !== undefined && output.TriggersNotFound !== null
        ? deserializeAws_json1_1TriggerNameList(output.TriggersNotFound, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchGetWorkflowsResponse = (
  output: any,
  context: __SerdeContext
): BatchGetWorkflowsResponse => {
  return {
    __type: "BatchGetWorkflowsResponse",
    MissingWorkflows:
      output.MissingWorkflows !== undefined && output.MissingWorkflows !== null
        ? deserializeAws_json1_1WorkflowNames(output.MissingWorkflows, context)
        : undefined,
    Workflows:
      output.Workflows !== undefined && output.Workflows !== null
        ? deserializeAws_json1_1Workflows(output.Workflows, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchStopJobRunError = (output: any, context: __SerdeContext): BatchStopJobRunError => {
  return {
    __type: "BatchStopJobRunError",
    ErrorDetail:
      output.ErrorDetail !== undefined && output.ErrorDetail !== null
        ? deserializeAws_json1_1ErrorDetail(output.ErrorDetail, context)
        : undefined,
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
    JobRunId: output.JobRunId !== undefined && output.JobRunId !== null ? output.JobRunId : undefined,
  } as any;
};

const deserializeAws_json1_1BatchStopJobRunErrorList = (
  output: any,
  context: __SerdeContext
): BatchStopJobRunError[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1BatchStopJobRunError(entry, context));
};

const deserializeAws_json1_1BatchStopJobRunResponse = (
  output: any,
  context: __SerdeContext
): BatchStopJobRunResponse => {
  return {
    __type: "BatchStopJobRunResponse",
    Errors:
      output.Errors !== undefined && output.Errors !== null
        ? deserializeAws_json1_1BatchStopJobRunErrorList(output.Errors, context)
        : undefined,
    SuccessfulSubmissions:
      output.SuccessfulSubmissions !== undefined && output.SuccessfulSubmissions !== null
        ? deserializeAws_json1_1BatchStopJobRunSuccessfulSubmissionList(output.SuccessfulSubmissions, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1BatchStopJobRunSuccessfulSubmission = (
  output: any,
  context: __SerdeContext
): BatchStopJobRunSuccessfulSubmission => {
  return {
    __type: "BatchStopJobRunSuccessfulSubmission",
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
    JobRunId: output.JobRunId !== undefined && output.JobRunId !== null ? output.JobRunId : undefined,
  } as any;
};

const deserializeAws_json1_1BatchStopJobRunSuccessfulSubmissionList = (
  output: any,
  context: __SerdeContext
): BatchStopJobRunSuccessfulSubmission[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1BatchStopJobRunSuccessfulSubmission(entry, context));
};

const deserializeAws_json1_1CancelMLTaskRunResponse = (
  output: any,
  context: __SerdeContext
): CancelMLTaskRunResponse => {
  return {
    __type: "CancelMLTaskRunResponse",
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    TaskRunId: output.TaskRunId !== undefined && output.TaskRunId !== null ? output.TaskRunId : undefined,
    TransformId: output.TransformId !== undefined && output.TransformId !== null ? output.TransformId : undefined,
  } as any;
};

const deserializeAws_json1_1CatalogImportStatus = (output: any, context: __SerdeContext): CatalogImportStatus => {
  return {
    __type: "CatalogImportStatus",
    ImportCompleted:
      output.ImportCompleted !== undefined && output.ImportCompleted !== null ? output.ImportCompleted : undefined,
    ImportTime:
      output.ImportTime !== undefined && output.ImportTime !== null
        ? new Date(Math.round(output.ImportTime * 1000))
        : undefined,
    ImportedBy: output.ImportedBy !== undefined && output.ImportedBy !== null ? output.ImportedBy : undefined,
  } as any;
};

const deserializeAws_json1_1CatalogTablesList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1CatalogTarget = (output: any, context: __SerdeContext): CatalogTarget => {
  return {
    __type: "CatalogTarget",
    DatabaseName: output.DatabaseName !== undefined && output.DatabaseName !== null ? output.DatabaseName : undefined,
    Tables:
      output.Tables !== undefined && output.Tables !== null
        ? deserializeAws_json1_1CatalogTablesList(output.Tables, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CatalogTargetList = (output: any, context: __SerdeContext): CatalogTarget[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1CatalogTarget(entry, context));
};

const deserializeAws_json1_1Classifier = (output: any, context: __SerdeContext): Classifier => {
  return {
    __type: "Classifier",
    CsvClassifier:
      output.CsvClassifier !== undefined && output.CsvClassifier !== null
        ? deserializeAws_json1_1CsvClassifier(output.CsvClassifier, context)
        : undefined,
    GrokClassifier:
      output.GrokClassifier !== undefined && output.GrokClassifier !== null
        ? deserializeAws_json1_1GrokClassifier(output.GrokClassifier, context)
        : undefined,
    JsonClassifier:
      output.JsonClassifier !== undefined && output.JsonClassifier !== null
        ? deserializeAws_json1_1JsonClassifier(output.JsonClassifier, context)
        : undefined,
    XMLClassifier:
      output.XMLClassifier !== undefined && output.XMLClassifier !== null
        ? deserializeAws_json1_1XMLClassifier(output.XMLClassifier, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ClassifierList = (output: any, context: __SerdeContext): Classifier[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Classifier(entry, context));
};

const deserializeAws_json1_1ClassifierNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1CloudWatchEncryption = (output: any, context: __SerdeContext): CloudWatchEncryption => {
  return {
    __type: "CloudWatchEncryption",
    CloudWatchEncryptionMode:
      output.CloudWatchEncryptionMode !== undefined && output.CloudWatchEncryptionMode !== null
        ? output.CloudWatchEncryptionMode
        : undefined,
    KmsKeyArn: output.KmsKeyArn !== undefined && output.KmsKeyArn !== null ? output.KmsKeyArn : undefined,
  } as any;
};

const deserializeAws_json1_1CodeGenEdge = (output: any, context: __SerdeContext): CodeGenEdge => {
  return {
    __type: "CodeGenEdge",
    Source: output.Source !== undefined && output.Source !== null ? output.Source : undefined,
    Target: output.Target !== undefined && output.Target !== null ? output.Target : undefined,
    TargetParameter:
      output.TargetParameter !== undefined && output.TargetParameter !== null ? output.TargetParameter : undefined,
  } as any;
};

const deserializeAws_json1_1CodeGenNode = (output: any, context: __SerdeContext): CodeGenNode => {
  return {
    __type: "CodeGenNode",
    Args:
      output.Args !== undefined && output.Args !== null
        ? deserializeAws_json1_1CodeGenNodeArgs(output.Args, context)
        : undefined,
    Id: output.Id !== undefined && output.Id !== null ? output.Id : undefined,
    LineNumber: output.LineNumber !== undefined && output.LineNumber !== null ? output.LineNumber : undefined,
    NodeType: output.NodeType !== undefined && output.NodeType !== null ? output.NodeType : undefined,
  } as any;
};

const deserializeAws_json1_1CodeGenNodeArg = (output: any, context: __SerdeContext): CodeGenNodeArg => {
  return {
    __type: "CodeGenNodeArg",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Param: output.Param !== undefined && output.Param !== null ? output.Param : undefined,
    Value: output.Value !== undefined && output.Value !== null ? output.Value : undefined,
  } as any;
};

const deserializeAws_json1_1CodeGenNodeArgs = (output: any, context: __SerdeContext): CodeGenNodeArg[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1CodeGenNodeArg(entry, context));
};

const deserializeAws_json1_1Column = (output: any, context: __SerdeContext): Column => {
  return {
    __type: "Column",
    Comment: output.Comment !== undefined && output.Comment !== null ? output.Comment : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Parameters:
      output.Parameters !== undefined && output.Parameters !== null
        ? deserializeAws_json1_1ParametersMap(output.Parameters, context)
        : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  } as any;
};

const deserializeAws_json1_1ColumnList = (output: any, context: __SerdeContext): Column[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Column(entry, context));
};

const deserializeAws_json1_1ColumnValueStringList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ConcurrentModificationException = (
  output: any,
  context: __SerdeContext
): ConcurrentModificationException => {
  return {
    __type: "ConcurrentModificationException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1ConcurrentRunsExceededException = (
  output: any,
  context: __SerdeContext
): ConcurrentRunsExceededException => {
  return {
    __type: "ConcurrentRunsExceededException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1Condition = (output: any, context: __SerdeContext): Condition => {
  return {
    __type: "Condition",
    CrawlState: output.CrawlState !== undefined && output.CrawlState !== null ? output.CrawlState : undefined,
    CrawlerName: output.CrawlerName !== undefined && output.CrawlerName !== null ? output.CrawlerName : undefined,
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
    LogicalOperator:
      output.LogicalOperator !== undefined && output.LogicalOperator !== null ? output.LogicalOperator : undefined,
    State: output.State !== undefined && output.State !== null ? output.State : undefined,
  } as any;
};

const deserializeAws_json1_1ConditionCheckFailureException = (
  output: any,
  context: __SerdeContext
): ConditionCheckFailureException => {
  return {
    __type: "ConditionCheckFailureException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1ConditionList = (output: any, context: __SerdeContext): Condition[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Condition(entry, context));
};

const deserializeAws_json1_1ConfusionMatrix = (output: any, context: __SerdeContext): ConfusionMatrix => {
  return {
    __type: "ConfusionMatrix",
    NumFalseNegatives:
      output.NumFalseNegatives !== undefined && output.NumFalseNegatives !== null
        ? output.NumFalseNegatives
        : undefined,
    NumFalsePositives:
      output.NumFalsePositives !== undefined && output.NumFalsePositives !== null
        ? output.NumFalsePositives
        : undefined,
    NumTrueNegatives:
      output.NumTrueNegatives !== undefined && output.NumTrueNegatives !== null ? output.NumTrueNegatives : undefined,
    NumTruePositives:
      output.NumTruePositives !== undefined && output.NumTruePositives !== null ? output.NumTruePositives : undefined,
  } as any;
};

const deserializeAws_json1_1Connection = (output: any, context: __SerdeContext): Connection => {
  return {
    __type: "Connection",
    ConnectionProperties:
      output.ConnectionProperties !== undefined && output.ConnectionProperties !== null
        ? deserializeAws_json1_1ConnectionProperties(output.ConnectionProperties, context)
        : undefined,
    ConnectionType:
      output.ConnectionType !== undefined && output.ConnectionType !== null ? output.ConnectionType : undefined,
    CreationTime:
      output.CreationTime !== undefined && output.CreationTime !== null
        ? new Date(Math.round(output.CreationTime * 1000))
        : undefined,
    Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
    LastUpdatedBy:
      output.LastUpdatedBy !== undefined && output.LastUpdatedBy !== null ? output.LastUpdatedBy : undefined,
    LastUpdatedTime:
      output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null
        ? new Date(Math.round(output.LastUpdatedTime * 1000))
        : undefined,
    MatchCriteria:
      output.MatchCriteria !== undefined && output.MatchCriteria !== null
        ? deserializeAws_json1_1MatchCriteria(output.MatchCriteria, context)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    PhysicalConnectionRequirements:
      output.PhysicalConnectionRequirements !== undefined && output.PhysicalConnectionRequirements !== null
        ? deserializeAws_json1_1PhysicalConnectionRequirements(output.PhysicalConnectionRequirements, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ConnectionList = (output: any, context: __SerdeContext): Connection[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Connection(entry, context));
};

const deserializeAws_json1_1ConnectionPasswordEncryption = (
  output: any,
  context: __SerdeContext
): ConnectionPasswordEncryption => {
  return {
    __type: "ConnectionPasswordEncryption",
    AwsKmsKeyId: output.AwsKmsKeyId !== undefined && output.AwsKmsKeyId !== null ? output.AwsKmsKeyId : undefined,
    ReturnConnectionPasswordEncrypted:
      output.ReturnConnectionPasswordEncrypted !== undefined && output.ReturnConnectionPasswordEncrypted !== null
        ? output.ReturnConnectionPasswordEncrypted
        : undefined,
  } as any;
};

const deserializeAws_json1_1ConnectionProperties = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [ConnectionPropertyKey | string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const deserializeAws_json1_1ConnectionsList = (output: any, context: __SerdeContext): ConnectionsList => {
  return {
    __type: "ConnectionsList",
    Connections:
      output.Connections !== undefined && output.Connections !== null
        ? deserializeAws_json1_1OrchestrationStringList(output.Connections, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1Crawl = (output: any, context: __SerdeContext): Crawl => {
  return {
    __type: "Crawl",
    CompletedOn:
      output.CompletedOn !== undefined && output.CompletedOn !== null
        ? new Date(Math.round(output.CompletedOn * 1000))
        : undefined,
    ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
    LogGroup: output.LogGroup !== undefined && output.LogGroup !== null ? output.LogGroup : undefined,
    LogStream: output.LogStream !== undefined && output.LogStream !== null ? output.LogStream : undefined,
    StartedOn:
      output.StartedOn !== undefined && output.StartedOn !== null
        ? new Date(Math.round(output.StartedOn * 1000))
        : undefined,
    State: output.State !== undefined && output.State !== null ? output.State : undefined,
  } as any;
};

const deserializeAws_json1_1Crawler = (output: any, context: __SerdeContext): Crawler => {
  return {
    __type: "Crawler",
    Classifiers:
      output.Classifiers !== undefined && output.Classifiers !== null
        ? deserializeAws_json1_1ClassifierNameList(output.Classifiers, context)
        : undefined,
    Configuration:
      output.Configuration !== undefined && output.Configuration !== null ? output.Configuration : undefined,
    CrawlElapsedTime:
      output.CrawlElapsedTime !== undefined && output.CrawlElapsedTime !== null ? output.CrawlElapsedTime : undefined,
    CrawlerSecurityConfiguration:
      output.CrawlerSecurityConfiguration !== undefined && output.CrawlerSecurityConfiguration !== null
        ? output.CrawlerSecurityConfiguration
        : undefined,
    CreationTime:
      output.CreationTime !== undefined && output.CreationTime !== null
        ? new Date(Math.round(output.CreationTime * 1000))
        : undefined,
    DatabaseName: output.DatabaseName !== undefined && output.DatabaseName !== null ? output.DatabaseName : undefined,
    Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
    LastCrawl:
      output.LastCrawl !== undefined && output.LastCrawl !== null
        ? deserializeAws_json1_1LastCrawlInfo(output.LastCrawl, context)
        : undefined,
    LastUpdated:
      output.LastUpdated !== undefined && output.LastUpdated !== null
        ? new Date(Math.round(output.LastUpdated * 1000))
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Role: output.Role !== undefined && output.Role !== null ? output.Role : undefined,
    Schedule:
      output.Schedule !== undefined && output.Schedule !== null
        ? deserializeAws_json1_1Schedule(output.Schedule, context)
        : undefined,
    SchemaChangePolicy:
      output.SchemaChangePolicy !== undefined && output.SchemaChangePolicy !== null
        ? deserializeAws_json1_1SchemaChangePolicy(output.SchemaChangePolicy, context)
        : undefined,
    State: output.State !== undefined && output.State !== null ? output.State : undefined,
    TablePrefix: output.TablePrefix !== undefined && output.TablePrefix !== null ? output.TablePrefix : undefined,
    Targets:
      output.Targets !== undefined && output.Targets !== null
        ? deserializeAws_json1_1CrawlerTargets(output.Targets, context)
        : undefined,
    Version: output.Version !== undefined && output.Version !== null ? output.Version : undefined,
  } as any;
};

const deserializeAws_json1_1CrawlerList = (output: any, context: __SerdeContext): Crawler[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Crawler(entry, context));
};

const deserializeAws_json1_1CrawlerMetrics = (output: any, context: __SerdeContext): CrawlerMetrics => {
  return {
    __type: "CrawlerMetrics",
    CrawlerName: output.CrawlerName !== undefined && output.CrawlerName !== null ? output.CrawlerName : undefined,
    LastRuntimeSeconds:
      output.LastRuntimeSeconds !== undefined && output.LastRuntimeSeconds !== null
        ? output.LastRuntimeSeconds
        : undefined,
    MedianRuntimeSeconds:
      output.MedianRuntimeSeconds !== undefined && output.MedianRuntimeSeconds !== null
        ? output.MedianRuntimeSeconds
        : undefined,
    StillEstimating:
      output.StillEstimating !== undefined && output.StillEstimating !== null ? output.StillEstimating : undefined,
    TablesCreated:
      output.TablesCreated !== undefined && output.TablesCreated !== null ? output.TablesCreated : undefined,
    TablesDeleted:
      output.TablesDeleted !== undefined && output.TablesDeleted !== null ? output.TablesDeleted : undefined,
    TablesUpdated:
      output.TablesUpdated !== undefined && output.TablesUpdated !== null ? output.TablesUpdated : undefined,
    TimeLeftSeconds:
      output.TimeLeftSeconds !== undefined && output.TimeLeftSeconds !== null ? output.TimeLeftSeconds : undefined,
  } as any;
};

const deserializeAws_json1_1CrawlerMetricsList = (output: any, context: __SerdeContext): CrawlerMetrics[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1CrawlerMetrics(entry, context));
};

const deserializeAws_json1_1CrawlerNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1CrawlerNodeDetails = (output: any, context: __SerdeContext): CrawlerNodeDetails => {
  return {
    __type: "CrawlerNodeDetails",
    Crawls:
      output.Crawls !== undefined && output.Crawls !== null
        ? deserializeAws_json1_1CrawlList(output.Crawls, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CrawlerNotRunningException = (
  output: any,
  context: __SerdeContext
): CrawlerNotRunningException => {
  return {
    __type: "CrawlerNotRunningException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1CrawlerRunningException = (
  output: any,
  context: __SerdeContext
): CrawlerRunningException => {
  return {
    __type: "CrawlerRunningException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1CrawlerStoppingException = (
  output: any,
  context: __SerdeContext
): CrawlerStoppingException => {
  return {
    __type: "CrawlerStoppingException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1CrawlerTargets = (output: any, context: __SerdeContext): CrawlerTargets => {
  return {
    __type: "CrawlerTargets",
    CatalogTargets:
      output.CatalogTargets !== undefined && output.CatalogTargets !== null
        ? deserializeAws_json1_1CatalogTargetList(output.CatalogTargets, context)
        : undefined,
    DynamoDBTargets:
      output.DynamoDBTargets !== undefined && output.DynamoDBTargets !== null
        ? deserializeAws_json1_1DynamoDBTargetList(output.DynamoDBTargets, context)
        : undefined,
    JdbcTargets:
      output.JdbcTargets !== undefined && output.JdbcTargets !== null
        ? deserializeAws_json1_1JdbcTargetList(output.JdbcTargets, context)
        : undefined,
    S3Targets:
      output.S3Targets !== undefined && output.S3Targets !== null
        ? deserializeAws_json1_1S3TargetList(output.S3Targets, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CrawlList = (output: any, context: __SerdeContext): Crawl[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Crawl(entry, context));
};

const deserializeAws_json1_1CreateClassifierResponse = (
  output: any,
  context: __SerdeContext
): CreateClassifierResponse => {
  return {
    __type: "CreateClassifierResponse",
  } as any;
};

const deserializeAws_json1_1CreateConnectionResponse = (
  output: any,
  context: __SerdeContext
): CreateConnectionResponse => {
  return {
    __type: "CreateConnectionResponse",
  } as any;
};

const deserializeAws_json1_1CreateCrawlerResponse = (output: any, context: __SerdeContext): CreateCrawlerResponse => {
  return {
    __type: "CreateCrawlerResponse",
  } as any;
};

const deserializeAws_json1_1CreateDatabaseResponse = (output: any, context: __SerdeContext): CreateDatabaseResponse => {
  return {
    __type: "CreateDatabaseResponse",
  } as any;
};

const deserializeAws_json1_1CreateDevEndpointResponse = (
  output: any,
  context: __SerdeContext
): CreateDevEndpointResponse => {
  return {
    __type: "CreateDevEndpointResponse",
    Arguments:
      output.Arguments !== undefined && output.Arguments !== null
        ? deserializeAws_json1_1MapValue(output.Arguments, context)
        : undefined,
    AvailabilityZone:
      output.AvailabilityZone !== undefined && output.AvailabilityZone !== null ? output.AvailabilityZone : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    EndpointName: output.EndpointName !== undefined && output.EndpointName !== null ? output.EndpointName : undefined,
    ExtraJarsS3Path:
      output.ExtraJarsS3Path !== undefined && output.ExtraJarsS3Path !== null ? output.ExtraJarsS3Path : undefined,
    ExtraPythonLibsS3Path:
      output.ExtraPythonLibsS3Path !== undefined && output.ExtraPythonLibsS3Path !== null
        ? output.ExtraPythonLibsS3Path
        : undefined,
    FailureReason:
      output.FailureReason !== undefined && output.FailureReason !== null ? output.FailureReason : undefined,
    GlueVersion: output.GlueVersion !== undefined && output.GlueVersion !== null ? output.GlueVersion : undefined,
    NumberOfNodes:
      output.NumberOfNodes !== undefined && output.NumberOfNodes !== null ? output.NumberOfNodes : undefined,
    NumberOfWorkers:
      output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null ? output.NumberOfWorkers : undefined,
    RoleArn: output.RoleArn !== undefined && output.RoleArn !== null ? output.RoleArn : undefined,
    SecurityConfiguration:
      output.SecurityConfiguration !== undefined && output.SecurityConfiguration !== null
        ? output.SecurityConfiguration
        : undefined,
    SecurityGroupIds:
      output.SecurityGroupIds !== undefined && output.SecurityGroupIds !== null
        ? deserializeAws_json1_1StringList(output.SecurityGroupIds, context)
        : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    SubnetId: output.SubnetId !== undefined && output.SubnetId !== null ? output.SubnetId : undefined,
    VpcId: output.VpcId !== undefined && output.VpcId !== null ? output.VpcId : undefined,
    WorkerType: output.WorkerType !== undefined && output.WorkerType !== null ? output.WorkerType : undefined,
    YarnEndpointAddress:
      output.YarnEndpointAddress !== undefined && output.YarnEndpointAddress !== null
        ? output.YarnEndpointAddress
        : undefined,
    ZeppelinRemoteSparkInterpreterPort:
      output.ZeppelinRemoteSparkInterpreterPort !== undefined && output.ZeppelinRemoteSparkInterpreterPort !== null
        ? output.ZeppelinRemoteSparkInterpreterPort
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateJobResponse = (output: any, context: __SerdeContext): CreateJobResponse => {
  return {
    __type: "CreateJobResponse",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1CreateMLTransformResponse = (
  output: any,
  context: __SerdeContext
): CreateMLTransformResponse => {
  return {
    __type: "CreateMLTransformResponse",
    TransformId: output.TransformId !== undefined && output.TransformId !== null ? output.TransformId : undefined,
  } as any;
};

const deserializeAws_json1_1CreatePartitionResponse = (
  output: any,
  context: __SerdeContext
): CreatePartitionResponse => {
  return {
    __type: "CreatePartitionResponse",
  } as any;
};

const deserializeAws_json1_1CreateScriptResponse = (output: any, context: __SerdeContext): CreateScriptResponse => {
  return {
    __type: "CreateScriptResponse",
    PythonScript: output.PythonScript !== undefined && output.PythonScript !== null ? output.PythonScript : undefined,
    ScalaCode: output.ScalaCode !== undefined && output.ScalaCode !== null ? output.ScalaCode : undefined,
  } as any;
};

const deserializeAws_json1_1CreateSecurityConfigurationResponse = (
  output: any,
  context: __SerdeContext
): CreateSecurityConfigurationResponse => {
  return {
    __type: "CreateSecurityConfigurationResponse",
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1CreateTableResponse = (output: any, context: __SerdeContext): CreateTableResponse => {
  return {
    __type: "CreateTableResponse",
  } as any;
};

const deserializeAws_json1_1CreateTriggerResponse = (output: any, context: __SerdeContext): CreateTriggerResponse => {
  return {
    __type: "CreateTriggerResponse",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1CreateUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): CreateUserDefinedFunctionResponse => {
  return {
    __type: "CreateUserDefinedFunctionResponse",
  } as any;
};

const deserializeAws_json1_1CreateWorkflowResponse = (output: any, context: __SerdeContext): CreateWorkflowResponse => {
  return {
    __type: "CreateWorkflowResponse",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1CsvClassifier = (output: any, context: __SerdeContext): CsvClassifier => {
  return {
    __type: "CsvClassifier",
    AllowSingleColumn:
      output.AllowSingleColumn !== undefined && output.AllowSingleColumn !== null
        ? output.AllowSingleColumn
        : undefined,
    ContainsHeader:
      output.ContainsHeader !== undefined && output.ContainsHeader !== null ? output.ContainsHeader : undefined,
    CreationTime:
      output.CreationTime !== undefined && output.CreationTime !== null
        ? new Date(Math.round(output.CreationTime * 1000))
        : undefined,
    Delimiter: output.Delimiter !== undefined && output.Delimiter !== null ? output.Delimiter : undefined,
    DisableValueTrimming:
      output.DisableValueTrimming !== undefined && output.DisableValueTrimming !== null
        ? output.DisableValueTrimming
        : undefined,
    Header:
      output.Header !== undefined && output.Header !== null
        ? deserializeAws_json1_1CsvHeader(output.Header, context)
        : undefined,
    LastUpdated:
      output.LastUpdated !== undefined && output.LastUpdated !== null
        ? new Date(Math.round(output.LastUpdated * 1000))
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    QuoteSymbol: output.QuoteSymbol !== undefined && output.QuoteSymbol !== null ? output.QuoteSymbol : undefined,
    Version: output.Version !== undefined && output.Version !== null ? output.Version : undefined,
  } as any;
};

const deserializeAws_json1_1CsvHeader = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1DagEdges = (output: any, context: __SerdeContext): CodeGenEdge[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1CodeGenEdge(entry, context));
};

const deserializeAws_json1_1DagNodes = (output: any, context: __SerdeContext): CodeGenNode[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1CodeGenNode(entry, context));
};

const deserializeAws_json1_1Database = (output: any, context: __SerdeContext): Database => {
  return {
    __type: "Database",
    CreateTableDefaultPermissions:
      output.CreateTableDefaultPermissions !== undefined && output.CreateTableDefaultPermissions !== null
        ? deserializeAws_json1_1PrincipalPermissionsList(output.CreateTableDefaultPermissions, context)
        : undefined,
    CreateTime:
      output.CreateTime !== undefined && output.CreateTime !== null
        ? new Date(Math.round(output.CreateTime * 1000))
        : undefined,
    Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
    LocationUri: output.LocationUri !== undefined && output.LocationUri !== null ? output.LocationUri : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Parameters:
      output.Parameters !== undefined && output.Parameters !== null
        ? deserializeAws_json1_1ParametersMap(output.Parameters, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DatabaseList = (output: any, context: __SerdeContext): Database[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Database(entry, context));
};

const deserializeAws_json1_1DataCatalogEncryptionSettings = (
  output: any,
  context: __SerdeContext
): DataCatalogEncryptionSettings => {
  return {
    __type: "DataCatalogEncryptionSettings",
    ConnectionPasswordEncryption:
      output.ConnectionPasswordEncryption !== undefined && output.ConnectionPasswordEncryption !== null
        ? deserializeAws_json1_1ConnectionPasswordEncryption(output.ConnectionPasswordEncryption, context)
        : undefined,
    EncryptionAtRest:
      output.EncryptionAtRest !== undefined && output.EncryptionAtRest !== null
        ? deserializeAws_json1_1EncryptionAtRest(output.EncryptionAtRest, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DataLakePrincipal = (output: any, context: __SerdeContext): DataLakePrincipal => {
  return {
    __type: "DataLakePrincipal",
    DataLakePrincipalIdentifier:
      output.DataLakePrincipalIdentifier !== undefined && output.DataLakePrincipalIdentifier !== null
        ? output.DataLakePrincipalIdentifier
        : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteClassifierResponse = (
  output: any,
  context: __SerdeContext
): DeleteClassifierResponse => {
  return {
    __type: "DeleteClassifierResponse",
  } as any;
};

const deserializeAws_json1_1DeleteConnectionResponse = (
  output: any,
  context: __SerdeContext
): DeleteConnectionResponse => {
  return {
    __type: "DeleteConnectionResponse",
  } as any;
};

const deserializeAws_json1_1DeleteCrawlerResponse = (output: any, context: __SerdeContext): DeleteCrawlerResponse => {
  return {
    __type: "DeleteCrawlerResponse",
  } as any;
};

const deserializeAws_json1_1DeleteDatabaseResponse = (output: any, context: __SerdeContext): DeleteDatabaseResponse => {
  return {
    __type: "DeleteDatabaseResponse",
  } as any;
};

const deserializeAws_json1_1DeleteDevEndpointResponse = (
  output: any,
  context: __SerdeContext
): DeleteDevEndpointResponse => {
  return {
    __type: "DeleteDevEndpointResponse",
  } as any;
};

const deserializeAws_json1_1DeleteJobResponse = (output: any, context: __SerdeContext): DeleteJobResponse => {
  return {
    __type: "DeleteJobResponse",
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteMLTransformResponse = (
  output: any,
  context: __SerdeContext
): DeleteMLTransformResponse => {
  return {
    __type: "DeleteMLTransformResponse",
    TransformId: output.TransformId !== undefined && output.TransformId !== null ? output.TransformId : undefined,
  } as any;
};

const deserializeAws_json1_1DeletePartitionResponse = (
  output: any,
  context: __SerdeContext
): DeletePartitionResponse => {
  return {
    __type: "DeletePartitionResponse",
  } as any;
};

const deserializeAws_json1_1DeleteResourcePolicyResponse = (
  output: any,
  context: __SerdeContext
): DeleteResourcePolicyResponse => {
  return {
    __type: "DeleteResourcePolicyResponse",
  } as any;
};

const deserializeAws_json1_1DeleteSecurityConfigurationResponse = (
  output: any,
  context: __SerdeContext
): DeleteSecurityConfigurationResponse => {
  return {
    __type: "DeleteSecurityConfigurationResponse",
  } as any;
};

const deserializeAws_json1_1DeleteTableResponse = (output: any, context: __SerdeContext): DeleteTableResponse => {
  return {
    __type: "DeleteTableResponse",
  } as any;
};

const deserializeAws_json1_1DeleteTableVersionResponse = (
  output: any,
  context: __SerdeContext
): DeleteTableVersionResponse => {
  return {
    __type: "DeleteTableVersionResponse",
  } as any;
};

const deserializeAws_json1_1DeleteTriggerResponse = (output: any, context: __SerdeContext): DeleteTriggerResponse => {
  return {
    __type: "DeleteTriggerResponse",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): DeleteUserDefinedFunctionResponse => {
  return {
    __type: "DeleteUserDefinedFunctionResponse",
  } as any;
};

const deserializeAws_json1_1DeleteWorkflowResponse = (output: any, context: __SerdeContext): DeleteWorkflowResponse => {
  return {
    __type: "DeleteWorkflowResponse",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1DevEndpoint = (output: any, context: __SerdeContext): DevEndpoint => {
  return {
    __type: "DevEndpoint",
    Arguments:
      output.Arguments !== undefined && output.Arguments !== null
        ? deserializeAws_json1_1MapValue(output.Arguments, context)
        : undefined,
    AvailabilityZone:
      output.AvailabilityZone !== undefined && output.AvailabilityZone !== null ? output.AvailabilityZone : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    EndpointName: output.EndpointName !== undefined && output.EndpointName !== null ? output.EndpointName : undefined,
    ExtraJarsS3Path:
      output.ExtraJarsS3Path !== undefined && output.ExtraJarsS3Path !== null ? output.ExtraJarsS3Path : undefined,
    ExtraPythonLibsS3Path:
      output.ExtraPythonLibsS3Path !== undefined && output.ExtraPythonLibsS3Path !== null
        ? output.ExtraPythonLibsS3Path
        : undefined,
    FailureReason:
      output.FailureReason !== undefined && output.FailureReason !== null ? output.FailureReason : undefined,
    GlueVersion: output.GlueVersion !== undefined && output.GlueVersion !== null ? output.GlueVersion : undefined,
    LastModifiedTimestamp:
      output.LastModifiedTimestamp !== undefined && output.LastModifiedTimestamp !== null
        ? new Date(Math.round(output.LastModifiedTimestamp * 1000))
        : undefined,
    LastUpdateStatus:
      output.LastUpdateStatus !== undefined && output.LastUpdateStatus !== null ? output.LastUpdateStatus : undefined,
    NumberOfNodes:
      output.NumberOfNodes !== undefined && output.NumberOfNodes !== null ? output.NumberOfNodes : undefined,
    NumberOfWorkers:
      output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null ? output.NumberOfWorkers : undefined,
    PrivateAddress:
      output.PrivateAddress !== undefined && output.PrivateAddress !== null ? output.PrivateAddress : undefined,
    PublicAddress:
      output.PublicAddress !== undefined && output.PublicAddress !== null ? output.PublicAddress : undefined,
    PublicKey: output.PublicKey !== undefined && output.PublicKey !== null ? output.PublicKey : undefined,
    PublicKeys:
      output.PublicKeys !== undefined && output.PublicKeys !== null
        ? deserializeAws_json1_1PublicKeysList(output.PublicKeys, context)
        : undefined,
    RoleArn: output.RoleArn !== undefined && output.RoleArn !== null ? output.RoleArn : undefined,
    SecurityConfiguration:
      output.SecurityConfiguration !== undefined && output.SecurityConfiguration !== null
        ? output.SecurityConfiguration
        : undefined,
    SecurityGroupIds:
      output.SecurityGroupIds !== undefined && output.SecurityGroupIds !== null
        ? deserializeAws_json1_1StringList(output.SecurityGroupIds, context)
        : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    SubnetId: output.SubnetId !== undefined && output.SubnetId !== null ? output.SubnetId : undefined,
    VpcId: output.VpcId !== undefined && output.VpcId !== null ? output.VpcId : undefined,
    WorkerType: output.WorkerType !== undefined && output.WorkerType !== null ? output.WorkerType : undefined,
    YarnEndpointAddress:
      output.YarnEndpointAddress !== undefined && output.YarnEndpointAddress !== null
        ? output.YarnEndpointAddress
        : undefined,
    ZeppelinRemoteSparkInterpreterPort:
      output.ZeppelinRemoteSparkInterpreterPort !== undefined && output.ZeppelinRemoteSparkInterpreterPort !== null
        ? output.ZeppelinRemoteSparkInterpreterPort
        : undefined,
  } as any;
};

const deserializeAws_json1_1DevEndpointList = (output: any, context: __SerdeContext): DevEndpoint[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1DevEndpoint(entry, context));
};

const deserializeAws_json1_1DevEndpointNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1DevEndpointNames = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1DynamoDBTarget = (output: any, context: __SerdeContext): DynamoDBTarget => {
  return {
    __type: "DynamoDBTarget",
    Path: output.Path !== undefined && output.Path !== null ? output.Path : undefined,
  } as any;
};

const deserializeAws_json1_1DynamoDBTargetList = (output: any, context: __SerdeContext): DynamoDBTarget[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1DynamoDBTarget(entry, context));
};

const deserializeAws_json1_1Edge = (output: any, context: __SerdeContext): Edge => {
  return {
    __type: "Edge",
    DestinationId:
      output.DestinationId !== undefined && output.DestinationId !== null ? output.DestinationId : undefined,
    SourceId: output.SourceId !== undefined && output.SourceId !== null ? output.SourceId : undefined,
  } as any;
};

const deserializeAws_json1_1EdgeList = (output: any, context: __SerdeContext): Edge[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Edge(entry, context));
};

const deserializeAws_json1_1EncryptionAtRest = (output: any, context: __SerdeContext): EncryptionAtRest => {
  return {
    __type: "EncryptionAtRest",
    CatalogEncryptionMode:
      output.CatalogEncryptionMode !== undefined && output.CatalogEncryptionMode !== null
        ? output.CatalogEncryptionMode
        : undefined,
    SseAwsKmsKeyId:
      output.SseAwsKmsKeyId !== undefined && output.SseAwsKmsKeyId !== null ? output.SseAwsKmsKeyId : undefined,
  } as any;
};

const deserializeAws_json1_1EncryptionConfiguration = (
  output: any,
  context: __SerdeContext
): EncryptionConfiguration => {
  return {
    __type: "EncryptionConfiguration",
    CloudWatchEncryption:
      output.CloudWatchEncryption !== undefined && output.CloudWatchEncryption !== null
        ? deserializeAws_json1_1CloudWatchEncryption(output.CloudWatchEncryption, context)
        : undefined,
    JobBookmarksEncryption:
      output.JobBookmarksEncryption !== undefined && output.JobBookmarksEncryption !== null
        ? deserializeAws_json1_1JobBookmarksEncryption(output.JobBookmarksEncryption, context)
        : undefined,
    S3Encryption:
      output.S3Encryption !== undefined && output.S3Encryption !== null
        ? deserializeAws_json1_1S3EncryptionList(output.S3Encryption, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1EntityNotFoundException = (
  output: any,
  context: __SerdeContext
): EntityNotFoundException => {
  return {
    __type: "EntityNotFoundException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1ErrorByName = (output: any, context: __SerdeContext): { [key: string]: ErrorDetail } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: ErrorDetail }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: deserializeAws_json1_1ErrorDetail(value, context),
    }),
    {}
  );
};

const deserializeAws_json1_1ErrorDetail = (output: any, context: __SerdeContext): ErrorDetail => {
  return {
    __type: "ErrorDetail",
    ErrorCode: output.ErrorCode !== undefined && output.ErrorCode !== null ? output.ErrorCode : undefined,
    ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
  } as any;
};

const deserializeAws_json1_1EvaluationMetrics = (output: any, context: __SerdeContext): EvaluationMetrics => {
  return {
    __type: "EvaluationMetrics",
    FindMatchesMetrics:
      output.FindMatchesMetrics !== undefined && output.FindMatchesMetrics !== null
        ? deserializeAws_json1_1FindMatchesMetrics(output.FindMatchesMetrics, context)
        : undefined,
    TransformType:
      output.TransformType !== undefined && output.TransformType !== null ? output.TransformType : undefined,
  } as any;
};

const deserializeAws_json1_1ExecutionProperty = (output: any, context: __SerdeContext): ExecutionProperty => {
  return {
    __type: "ExecutionProperty",
    MaxConcurrentRuns:
      output.MaxConcurrentRuns !== undefined && output.MaxConcurrentRuns !== null
        ? output.MaxConcurrentRuns
        : undefined,
  } as any;
};

const deserializeAws_json1_1ExportLabelsTaskRunProperties = (
  output: any,
  context: __SerdeContext
): ExportLabelsTaskRunProperties => {
  return {
    __type: "ExportLabelsTaskRunProperties",
    OutputS3Path: output.OutputS3Path !== undefined && output.OutputS3Path !== null ? output.OutputS3Path : undefined,
  } as any;
};

const deserializeAws_json1_1FindMatchesMetrics = (output: any, context: __SerdeContext): FindMatchesMetrics => {
  return {
    __type: "FindMatchesMetrics",
    AreaUnderPRCurve:
      output.AreaUnderPRCurve !== undefined && output.AreaUnderPRCurve !== null ? output.AreaUnderPRCurve : undefined,
    ConfusionMatrix:
      output.ConfusionMatrix !== undefined && output.ConfusionMatrix !== null
        ? deserializeAws_json1_1ConfusionMatrix(output.ConfusionMatrix, context)
        : undefined,
    F1: output.F1 !== undefined && output.F1 !== null ? output.F1 : undefined,
    Precision: output.Precision !== undefined && output.Precision !== null ? output.Precision : undefined,
    Recall: output.Recall !== undefined && output.Recall !== null ? output.Recall : undefined,
  } as any;
};

const deserializeAws_json1_1FindMatchesParameters = (output: any, context: __SerdeContext): FindMatchesParameters => {
  return {
    __type: "FindMatchesParameters",
    AccuracyCostTradeoff:
      output.AccuracyCostTradeoff !== undefined && output.AccuracyCostTradeoff !== null
        ? output.AccuracyCostTradeoff
        : undefined,
    EnforceProvidedLabels:
      output.EnforceProvidedLabels !== undefined && output.EnforceProvidedLabels !== null
        ? output.EnforceProvidedLabels
        : undefined,
    PrecisionRecallTradeoff:
      output.PrecisionRecallTradeoff !== undefined && output.PrecisionRecallTradeoff !== null
        ? output.PrecisionRecallTradeoff
        : undefined,
    PrimaryKeyColumnName:
      output.PrimaryKeyColumnName !== undefined && output.PrimaryKeyColumnName !== null
        ? output.PrimaryKeyColumnName
        : undefined,
  } as any;
};

const deserializeAws_json1_1FindMatchesTaskRunProperties = (
  output: any,
  context: __SerdeContext
): FindMatchesTaskRunProperties => {
  return {
    __type: "FindMatchesTaskRunProperties",
    JobId: output.JobId !== undefined && output.JobId !== null ? output.JobId : undefined,
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
    JobRunId: output.JobRunId !== undefined && output.JobRunId !== null ? output.JobRunId : undefined,
  } as any;
};

const deserializeAws_json1_1GenericMap = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const deserializeAws_json1_1GetCatalogImportStatusResponse = (
  output: any,
  context: __SerdeContext
): GetCatalogImportStatusResponse => {
  return {
    __type: "GetCatalogImportStatusResponse",
    ImportStatus:
      output.ImportStatus !== undefined && output.ImportStatus !== null
        ? deserializeAws_json1_1CatalogImportStatus(output.ImportStatus, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetClassifierResponse = (output: any, context: __SerdeContext): GetClassifierResponse => {
  return {
    __type: "GetClassifierResponse",
    Classifier:
      output.Classifier !== undefined && output.Classifier !== null
        ? deserializeAws_json1_1Classifier(output.Classifier, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetClassifiersResponse = (output: any, context: __SerdeContext): GetClassifiersResponse => {
  return {
    __type: "GetClassifiersResponse",
    Classifiers:
      output.Classifiers !== undefined && output.Classifiers !== null
        ? deserializeAws_json1_1ClassifierList(output.Classifiers, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1GetConnectionResponse = (output: any, context: __SerdeContext): GetConnectionResponse => {
  return {
    __type: "GetConnectionResponse",
    Connection:
      output.Connection !== undefined && output.Connection !== null
        ? deserializeAws_json1_1Connection(output.Connection, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetConnectionsResponse = (output: any, context: __SerdeContext): GetConnectionsResponse => {
  return {
    __type: "GetConnectionsResponse",
    ConnectionList:
      output.ConnectionList !== undefined && output.ConnectionList !== null
        ? deserializeAws_json1_1ConnectionList(output.ConnectionList, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1GetCrawlerMetricsResponse = (
  output: any,
  context: __SerdeContext
): GetCrawlerMetricsResponse => {
  return {
    __type: "GetCrawlerMetricsResponse",
    CrawlerMetricsList:
      output.CrawlerMetricsList !== undefined && output.CrawlerMetricsList !== null
        ? deserializeAws_json1_1CrawlerMetricsList(output.CrawlerMetricsList, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1GetCrawlerResponse = (output: any, context: __SerdeContext): GetCrawlerResponse => {
  return {
    __type: "GetCrawlerResponse",
    Crawler:
      output.Crawler !== undefined && output.Crawler !== null
        ? deserializeAws_json1_1Crawler(output.Crawler, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetCrawlersResponse = (output: any, context: __SerdeContext): GetCrawlersResponse => {
  return {
    __type: "GetCrawlersResponse",
    Crawlers:
      output.Crawlers !== undefined && output.Crawlers !== null
        ? deserializeAws_json1_1CrawlerList(output.Crawlers, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1GetDatabaseResponse = (output: any, context: __SerdeContext): GetDatabaseResponse => {
  return {
    __type: "GetDatabaseResponse",
    Database:
      output.Database !== undefined && output.Database !== null
        ? deserializeAws_json1_1Database(output.Database, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetDatabasesResponse = (output: any, context: __SerdeContext): GetDatabasesResponse => {
  return {
    __type: "GetDatabasesResponse",
    DatabaseList:
      output.DatabaseList !== undefined && output.DatabaseList !== null
        ? deserializeAws_json1_1DatabaseList(output.DatabaseList, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1GetDataCatalogEncryptionSettingsResponse = (
  output: any,
  context: __SerdeContext
): GetDataCatalogEncryptionSettingsResponse => {
  return {
    __type: "GetDataCatalogEncryptionSettingsResponse",
    DataCatalogEncryptionSettings:
      output.DataCatalogEncryptionSettings !== undefined && output.DataCatalogEncryptionSettings !== null
        ? deserializeAws_json1_1DataCatalogEncryptionSettings(output.DataCatalogEncryptionSettings, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetDataflowGraphResponse = (
  output: any,
  context: __SerdeContext
): GetDataflowGraphResponse => {
  return {
    __type: "GetDataflowGraphResponse",
    DagEdges:
      output.DagEdges !== undefined && output.DagEdges !== null
        ? deserializeAws_json1_1DagEdges(output.DagEdges, context)
        : undefined,
    DagNodes:
      output.DagNodes !== undefined && output.DagNodes !== null
        ? deserializeAws_json1_1DagNodes(output.DagNodes, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetDevEndpointResponse = (output: any, context: __SerdeContext): GetDevEndpointResponse => {
  return {
    __type: "GetDevEndpointResponse",
    DevEndpoint:
      output.DevEndpoint !== undefined && output.DevEndpoint !== null
        ? deserializeAws_json1_1DevEndpoint(output.DevEndpoint, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetDevEndpointsResponse = (
  output: any,
  context: __SerdeContext
): GetDevEndpointsResponse => {
  return {
    __type: "GetDevEndpointsResponse",
    DevEndpoints:
      output.DevEndpoints !== undefined && output.DevEndpoints !== null
        ? deserializeAws_json1_1DevEndpointList(output.DevEndpoints, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1GetJobBookmarkResponse = (output: any, context: __SerdeContext): GetJobBookmarkResponse => {
  return {
    __type: "GetJobBookmarkResponse",
    JobBookmarkEntry:
      output.JobBookmarkEntry !== undefined && output.JobBookmarkEntry !== null
        ? deserializeAws_json1_1JobBookmarkEntry(output.JobBookmarkEntry, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetJobResponse = (output: any, context: __SerdeContext): GetJobResponse => {
  return {
    __type: "GetJobResponse",
    Job: output.Job !== undefined && output.Job !== null ? deserializeAws_json1_1Job(output.Job, context) : undefined,
  } as any;
};

const deserializeAws_json1_1GetJobRunResponse = (output: any, context: __SerdeContext): GetJobRunResponse => {
  return {
    __type: "GetJobRunResponse",
    JobRun:
      output.JobRun !== undefined && output.JobRun !== null
        ? deserializeAws_json1_1JobRun(output.JobRun, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetJobRunsResponse = (output: any, context: __SerdeContext): GetJobRunsResponse => {
  return {
    __type: "GetJobRunsResponse",
    JobRuns:
      output.JobRuns !== undefined && output.JobRuns !== null
        ? deserializeAws_json1_1JobRunList(output.JobRuns, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1GetJobsResponse = (output: any, context: __SerdeContext): GetJobsResponse => {
  return {
    __type: "GetJobsResponse",
    Jobs:
      output.Jobs !== undefined && output.Jobs !== null
        ? deserializeAws_json1_1JobList(output.Jobs, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1GetMappingResponse = (output: any, context: __SerdeContext): GetMappingResponse => {
  return {
    __type: "GetMappingResponse",
    Mapping:
      output.Mapping !== undefined && output.Mapping !== null
        ? deserializeAws_json1_1MappingList(output.Mapping, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetMLTaskRunResponse = (output: any, context: __SerdeContext): GetMLTaskRunResponse => {
  return {
    __type: "GetMLTaskRunResponse",
    CompletedOn:
      output.CompletedOn !== undefined && output.CompletedOn !== null
        ? new Date(Math.round(output.CompletedOn * 1000))
        : undefined,
    ErrorString: output.ErrorString !== undefined && output.ErrorString !== null ? output.ErrorString : undefined,
    ExecutionTime:
      output.ExecutionTime !== undefined && output.ExecutionTime !== null ? output.ExecutionTime : undefined,
    LastModifiedOn:
      output.LastModifiedOn !== undefined && output.LastModifiedOn !== null
        ? new Date(Math.round(output.LastModifiedOn * 1000))
        : undefined,
    LogGroupName: output.LogGroupName !== undefined && output.LogGroupName !== null ? output.LogGroupName : undefined,
    Properties:
      output.Properties !== undefined && output.Properties !== null
        ? deserializeAws_json1_1TaskRunProperties(output.Properties, context)
        : undefined,
    StartedOn:
      output.StartedOn !== undefined && output.StartedOn !== null
        ? new Date(Math.round(output.StartedOn * 1000))
        : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    TaskRunId: output.TaskRunId !== undefined && output.TaskRunId !== null ? output.TaskRunId : undefined,
    TransformId: output.TransformId !== undefined && output.TransformId !== null ? output.TransformId : undefined,
  } as any;
};

const deserializeAws_json1_1GetMLTaskRunsResponse = (output: any, context: __SerdeContext): GetMLTaskRunsResponse => {
  return {
    __type: "GetMLTaskRunsResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    TaskRuns:
      output.TaskRuns !== undefined && output.TaskRuns !== null
        ? deserializeAws_json1_1TaskRunList(output.TaskRuns, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetMLTransformResponse = (output: any, context: __SerdeContext): GetMLTransformResponse => {
  return {
    __type: "GetMLTransformResponse",
    CreatedOn:
      output.CreatedOn !== undefined && output.CreatedOn !== null
        ? new Date(Math.round(output.CreatedOn * 1000))
        : undefined,
    Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
    EvaluationMetrics:
      output.EvaluationMetrics !== undefined && output.EvaluationMetrics !== null
        ? deserializeAws_json1_1EvaluationMetrics(output.EvaluationMetrics, context)
        : undefined,
    GlueVersion: output.GlueVersion !== undefined && output.GlueVersion !== null ? output.GlueVersion : undefined,
    InputRecordTables:
      output.InputRecordTables !== undefined && output.InputRecordTables !== null
        ? deserializeAws_json1_1GlueTables(output.InputRecordTables, context)
        : undefined,
    LabelCount: output.LabelCount !== undefined && output.LabelCount !== null ? output.LabelCount : undefined,
    LastModifiedOn:
      output.LastModifiedOn !== undefined && output.LastModifiedOn !== null
        ? new Date(Math.round(output.LastModifiedOn * 1000))
        : undefined,
    MaxCapacity: output.MaxCapacity !== undefined && output.MaxCapacity !== null ? output.MaxCapacity : undefined,
    MaxRetries: output.MaxRetries !== undefined && output.MaxRetries !== null ? output.MaxRetries : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    NumberOfWorkers:
      output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null ? output.NumberOfWorkers : undefined,
    Parameters:
      output.Parameters !== undefined && output.Parameters !== null
        ? deserializeAws_json1_1TransformParameters(output.Parameters, context)
        : undefined,
    Role: output.Role !== undefined && output.Role !== null ? output.Role : undefined,
    Schema:
      output.Schema !== undefined && output.Schema !== null
        ? deserializeAws_json1_1TransformSchema(output.Schema, context)
        : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    Timeout: output.Timeout !== undefined && output.Timeout !== null ? output.Timeout : undefined,
    TransformId: output.TransformId !== undefined && output.TransformId !== null ? output.TransformId : undefined,
    WorkerType: output.WorkerType !== undefined && output.WorkerType !== null ? output.WorkerType : undefined,
  } as any;
};

const deserializeAws_json1_1GetMLTransformsResponse = (
  output: any,
  context: __SerdeContext
): GetMLTransformsResponse => {
  return {
    __type: "GetMLTransformsResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    Transforms:
      output.Transforms !== undefined && output.Transforms !== null
        ? deserializeAws_json1_1TransformList(output.Transforms, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetPartitionResponse = (output: any, context: __SerdeContext): GetPartitionResponse => {
  return {
    __type: "GetPartitionResponse",
    Partition:
      output.Partition !== undefined && output.Partition !== null
        ? deserializeAws_json1_1Partition(output.Partition, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetPartitionsResponse = (output: any, context: __SerdeContext): GetPartitionsResponse => {
  return {
    __type: "GetPartitionsResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    Partitions:
      output.Partitions !== undefined && output.Partitions !== null
        ? deserializeAws_json1_1PartitionList(output.Partitions, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetPlanResponse = (output: any, context: __SerdeContext): GetPlanResponse => {
  return {
    __type: "GetPlanResponse",
    PythonScript: output.PythonScript !== undefined && output.PythonScript !== null ? output.PythonScript : undefined,
    ScalaCode: output.ScalaCode !== undefined && output.ScalaCode !== null ? output.ScalaCode : undefined,
  } as any;
};

const deserializeAws_json1_1GetResourcePolicyResponse = (
  output: any,
  context: __SerdeContext
): GetResourcePolicyResponse => {
  return {
    __type: "GetResourcePolicyResponse",
    CreateTime:
      output.CreateTime !== undefined && output.CreateTime !== null
        ? new Date(Math.round(output.CreateTime * 1000))
        : undefined,
    PolicyHash: output.PolicyHash !== undefined && output.PolicyHash !== null ? output.PolicyHash : undefined,
    PolicyInJson: output.PolicyInJson !== undefined && output.PolicyInJson !== null ? output.PolicyInJson : undefined,
    UpdateTime:
      output.UpdateTime !== undefined && output.UpdateTime !== null
        ? new Date(Math.round(output.UpdateTime * 1000))
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetSecurityConfigurationResponse = (
  output: any,
  context: __SerdeContext
): GetSecurityConfigurationResponse => {
  return {
    __type: "GetSecurityConfigurationResponse",
    SecurityConfiguration:
      output.SecurityConfiguration !== undefined && output.SecurityConfiguration !== null
        ? deserializeAws_json1_1SecurityConfiguration(output.SecurityConfiguration, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetSecurityConfigurationsResponse = (
  output: any,
  context: __SerdeContext
): GetSecurityConfigurationsResponse => {
  return {
    __type: "GetSecurityConfigurationsResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    SecurityConfigurations:
      output.SecurityConfigurations !== undefined && output.SecurityConfigurations !== null
        ? deserializeAws_json1_1SecurityConfigurationList(output.SecurityConfigurations, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetTableResponse = (output: any, context: __SerdeContext): GetTableResponse => {
  return {
    __type: "GetTableResponse",
    Table:
      output.Table !== undefined && output.Table !== null
        ? deserializeAws_json1_1Table(output.Table, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetTablesResponse = (output: any, context: __SerdeContext): GetTablesResponse => {
  return {
    __type: "GetTablesResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    TableList:
      output.TableList !== undefined && output.TableList !== null
        ? deserializeAws_json1_1TableList(output.TableList, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetTableVersionResponse = (
  output: any,
  context: __SerdeContext
): GetTableVersionResponse => {
  return {
    __type: "GetTableVersionResponse",
    TableVersion:
      output.TableVersion !== undefined && output.TableVersion !== null
        ? deserializeAws_json1_1TableVersion(output.TableVersion, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetTableVersionsList = (output: any, context: __SerdeContext): TableVersion[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1TableVersion(entry, context));
};

const deserializeAws_json1_1GetTableVersionsResponse = (
  output: any,
  context: __SerdeContext
): GetTableVersionsResponse => {
  return {
    __type: "GetTableVersionsResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    TableVersions:
      output.TableVersions !== undefined && output.TableVersions !== null
        ? deserializeAws_json1_1GetTableVersionsList(output.TableVersions, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetTagsResponse = (output: any, context: __SerdeContext): GetTagsResponse => {
  return {
    __type: "GetTagsResponse",
    Tags:
      output.Tags !== undefined && output.Tags !== null
        ? deserializeAws_json1_1TagsMap(output.Tags, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetTriggerResponse = (output: any, context: __SerdeContext): GetTriggerResponse => {
  return {
    __type: "GetTriggerResponse",
    Trigger:
      output.Trigger !== undefined && output.Trigger !== null
        ? deserializeAws_json1_1Trigger(output.Trigger, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetTriggersResponse = (output: any, context: __SerdeContext): GetTriggersResponse => {
  return {
    __type: "GetTriggersResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    Triggers:
      output.Triggers !== undefined && output.Triggers !== null
        ? deserializeAws_json1_1TriggerList(output.Triggers, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): GetUserDefinedFunctionResponse => {
  return {
    __type: "GetUserDefinedFunctionResponse",
    UserDefinedFunction:
      output.UserDefinedFunction !== undefined && output.UserDefinedFunction !== null
        ? deserializeAws_json1_1UserDefinedFunction(output.UserDefinedFunction, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetUserDefinedFunctionsResponse = (
  output: any,
  context: __SerdeContext
): GetUserDefinedFunctionsResponse => {
  return {
    __type: "GetUserDefinedFunctionsResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    UserDefinedFunctions:
      output.UserDefinedFunctions !== undefined && output.UserDefinedFunctions !== null
        ? deserializeAws_json1_1UserDefinedFunctionList(output.UserDefinedFunctions, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetWorkflowResponse = (output: any, context: __SerdeContext): GetWorkflowResponse => {
  return {
    __type: "GetWorkflowResponse",
    Workflow:
      output.Workflow !== undefined && output.Workflow !== null
        ? deserializeAws_json1_1Workflow(output.Workflow, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetWorkflowRunPropertiesResponse = (
  output: any,
  context: __SerdeContext
): GetWorkflowRunPropertiesResponse => {
  return {
    __type: "GetWorkflowRunPropertiesResponse",
    RunProperties:
      output.RunProperties !== undefined && output.RunProperties !== null
        ? deserializeAws_json1_1WorkflowRunProperties(output.RunProperties, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetWorkflowRunResponse = (output: any, context: __SerdeContext): GetWorkflowRunResponse => {
  return {
    __type: "GetWorkflowRunResponse",
    Run:
      output.Run !== undefined && output.Run !== null
        ? deserializeAws_json1_1WorkflowRun(output.Run, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetWorkflowRunsResponse = (
  output: any,
  context: __SerdeContext
): GetWorkflowRunsResponse => {
  return {
    __type: "GetWorkflowRunsResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    Runs:
      output.Runs !== undefined && output.Runs !== null
        ? deserializeAws_json1_1WorkflowRuns(output.Runs, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GlueEncryptionException = (
  output: any,
  context: __SerdeContext
): GlueEncryptionException => {
  return {
    __type: "GlueEncryptionException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1GlueTable = (output: any, context: __SerdeContext): GlueTable => {
  return {
    __type: "GlueTable",
    CatalogId: output.CatalogId !== undefined && output.CatalogId !== null ? output.CatalogId : undefined,
    ConnectionName:
      output.ConnectionName !== undefined && output.ConnectionName !== null ? output.ConnectionName : undefined,
    DatabaseName: output.DatabaseName !== undefined && output.DatabaseName !== null ? output.DatabaseName : undefined,
    TableName: output.TableName !== undefined && output.TableName !== null ? output.TableName : undefined,
  } as any;
};

const deserializeAws_json1_1GlueTables = (output: any, context: __SerdeContext): GlueTable[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1GlueTable(entry, context));
};

const deserializeAws_json1_1GrokClassifier = (output: any, context: __SerdeContext): GrokClassifier => {
  return {
    __type: "GrokClassifier",
    Classification:
      output.Classification !== undefined && output.Classification !== null ? output.Classification : undefined,
    CreationTime:
      output.CreationTime !== undefined && output.CreationTime !== null
        ? new Date(Math.round(output.CreationTime * 1000))
        : undefined,
    CustomPatterns:
      output.CustomPatterns !== undefined && output.CustomPatterns !== null ? output.CustomPatterns : undefined,
    GrokPattern: output.GrokPattern !== undefined && output.GrokPattern !== null ? output.GrokPattern : undefined,
    LastUpdated:
      output.LastUpdated !== undefined && output.LastUpdated !== null
        ? new Date(Math.round(output.LastUpdated * 1000))
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Version: output.Version !== undefined && output.Version !== null ? output.Version : undefined,
  } as any;
};

const deserializeAws_json1_1IdempotentParameterMismatchException = (
  output: any,
  context: __SerdeContext
): IdempotentParameterMismatchException => {
  return {
    __type: "IdempotentParameterMismatchException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1ImportCatalogToGlueResponse = (
  output: any,
  context: __SerdeContext
): ImportCatalogToGlueResponse => {
  return {
    __type: "ImportCatalogToGlueResponse",
  } as any;
};

const deserializeAws_json1_1ImportLabelsTaskRunProperties = (
  output: any,
  context: __SerdeContext
): ImportLabelsTaskRunProperties => {
  return {
    __type: "ImportLabelsTaskRunProperties",
    InputS3Path: output.InputS3Path !== undefined && output.InputS3Path !== null ? output.InputS3Path : undefined,
    Replace: output.Replace !== undefined && output.Replace !== null ? output.Replace : undefined,
  } as any;
};

const deserializeAws_json1_1InternalServiceException = (
  output: any,
  context: __SerdeContext
): InternalServiceException => {
  return {
    __type: "InternalServiceException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1InvalidInputException = (output: any, context: __SerdeContext): InvalidInputException => {
  return {
    __type: "InvalidInputException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1JdbcTarget = (output: any, context: __SerdeContext): JdbcTarget => {
  return {
    __type: "JdbcTarget",
    ConnectionName:
      output.ConnectionName !== undefined && output.ConnectionName !== null ? output.ConnectionName : undefined,
    Exclusions:
      output.Exclusions !== undefined && output.Exclusions !== null
        ? deserializeAws_json1_1PathList(output.Exclusions, context)
        : undefined,
    Path: output.Path !== undefined && output.Path !== null ? output.Path : undefined,
  } as any;
};

const deserializeAws_json1_1JdbcTargetList = (output: any, context: __SerdeContext): JdbcTarget[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1JdbcTarget(entry, context));
};

const deserializeAws_json1_1Job = (output: any, context: __SerdeContext): Job => {
  return {
    __type: "Job",
    AllocatedCapacity:
      output.AllocatedCapacity !== undefined && output.AllocatedCapacity !== null
        ? output.AllocatedCapacity
        : undefined,
    Command:
      output.Command !== undefined && output.Command !== null
        ? deserializeAws_json1_1JobCommand(output.Command, context)
        : undefined,
    Connections:
      output.Connections !== undefined && output.Connections !== null
        ? deserializeAws_json1_1ConnectionsList(output.Connections, context)
        : undefined,
    CreatedOn:
      output.CreatedOn !== undefined && output.CreatedOn !== null
        ? new Date(Math.round(output.CreatedOn * 1000))
        : undefined,
    DefaultArguments:
      output.DefaultArguments !== undefined && output.DefaultArguments !== null
        ? deserializeAws_json1_1GenericMap(output.DefaultArguments, context)
        : undefined,
    Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
    ExecutionProperty:
      output.ExecutionProperty !== undefined && output.ExecutionProperty !== null
        ? deserializeAws_json1_1ExecutionProperty(output.ExecutionProperty, context)
        : undefined,
    GlueVersion: output.GlueVersion !== undefined && output.GlueVersion !== null ? output.GlueVersion : undefined,
    LastModifiedOn:
      output.LastModifiedOn !== undefined && output.LastModifiedOn !== null
        ? new Date(Math.round(output.LastModifiedOn * 1000))
        : undefined,
    LogUri: output.LogUri !== undefined && output.LogUri !== null ? output.LogUri : undefined,
    MaxCapacity: output.MaxCapacity !== undefined && output.MaxCapacity !== null ? output.MaxCapacity : undefined,
    MaxRetries: output.MaxRetries !== undefined && output.MaxRetries !== null ? output.MaxRetries : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    NotificationProperty:
      output.NotificationProperty !== undefined && output.NotificationProperty !== null
        ? deserializeAws_json1_1NotificationProperty(output.NotificationProperty, context)
        : undefined,
    NumberOfWorkers:
      output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null ? output.NumberOfWorkers : undefined,
    Role: output.Role !== undefined && output.Role !== null ? output.Role : undefined,
    SecurityConfiguration:
      output.SecurityConfiguration !== undefined && output.SecurityConfiguration !== null
        ? output.SecurityConfiguration
        : undefined,
    Timeout: output.Timeout !== undefined && output.Timeout !== null ? output.Timeout : undefined,
    WorkerType: output.WorkerType !== undefined && output.WorkerType !== null ? output.WorkerType : undefined,
  } as any;
};

const deserializeAws_json1_1JobBookmarkEntry = (output: any, context: __SerdeContext): JobBookmarkEntry => {
  return {
    __type: "JobBookmarkEntry",
    Attempt: output.Attempt !== undefined && output.Attempt !== null ? output.Attempt : undefined,
    JobBookmark: output.JobBookmark !== undefined && output.JobBookmark !== null ? output.JobBookmark : undefined,
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
    PreviousRunId:
      output.PreviousRunId !== undefined && output.PreviousRunId !== null ? output.PreviousRunId : undefined,
    Run: output.Run !== undefined && output.Run !== null ? output.Run : undefined,
    RunId: output.RunId !== undefined && output.RunId !== null ? output.RunId : undefined,
    Version: output.Version !== undefined && output.Version !== null ? output.Version : undefined,
  } as any;
};

const deserializeAws_json1_1JobBookmarksEncryption = (output: any, context: __SerdeContext): JobBookmarksEncryption => {
  return {
    __type: "JobBookmarksEncryption",
    JobBookmarksEncryptionMode:
      output.JobBookmarksEncryptionMode !== undefined && output.JobBookmarksEncryptionMode !== null
        ? output.JobBookmarksEncryptionMode
        : undefined,
    KmsKeyArn: output.KmsKeyArn !== undefined && output.KmsKeyArn !== null ? output.KmsKeyArn : undefined,
  } as any;
};

const deserializeAws_json1_1JobCommand = (output: any, context: __SerdeContext): JobCommand => {
  return {
    __type: "JobCommand",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    PythonVersion:
      output.PythonVersion !== undefined && output.PythonVersion !== null ? output.PythonVersion : undefined,
    ScriptLocation:
      output.ScriptLocation !== undefined && output.ScriptLocation !== null ? output.ScriptLocation : undefined,
  } as any;
};

const deserializeAws_json1_1JobList = (output: any, context: __SerdeContext): Job[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Job(entry, context));
};

const deserializeAws_json1_1JobNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1JobNodeDetails = (output: any, context: __SerdeContext): JobNodeDetails => {
  return {
    __type: "JobNodeDetails",
    JobRuns:
      output.JobRuns !== undefined && output.JobRuns !== null
        ? deserializeAws_json1_1JobRunList(output.JobRuns, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1JobRun = (output: any, context: __SerdeContext): JobRun => {
  return {
    __type: "JobRun",
    AllocatedCapacity:
      output.AllocatedCapacity !== undefined && output.AllocatedCapacity !== null
        ? output.AllocatedCapacity
        : undefined,
    Arguments:
      output.Arguments !== undefined && output.Arguments !== null
        ? deserializeAws_json1_1GenericMap(output.Arguments, context)
        : undefined,
    Attempt: output.Attempt !== undefined && output.Attempt !== null ? output.Attempt : undefined,
    CompletedOn:
      output.CompletedOn !== undefined && output.CompletedOn !== null
        ? new Date(Math.round(output.CompletedOn * 1000))
        : undefined,
    ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
    ExecutionTime:
      output.ExecutionTime !== undefined && output.ExecutionTime !== null ? output.ExecutionTime : undefined,
    GlueVersion: output.GlueVersion !== undefined && output.GlueVersion !== null ? output.GlueVersion : undefined,
    Id: output.Id !== undefined && output.Id !== null ? output.Id : undefined,
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
    JobRunState: output.JobRunState !== undefined && output.JobRunState !== null ? output.JobRunState : undefined,
    LastModifiedOn:
      output.LastModifiedOn !== undefined && output.LastModifiedOn !== null
        ? new Date(Math.round(output.LastModifiedOn * 1000))
        : undefined,
    LogGroupName: output.LogGroupName !== undefined && output.LogGroupName !== null ? output.LogGroupName : undefined,
    MaxCapacity: output.MaxCapacity !== undefined && output.MaxCapacity !== null ? output.MaxCapacity : undefined,
    NotificationProperty:
      output.NotificationProperty !== undefined && output.NotificationProperty !== null
        ? deserializeAws_json1_1NotificationProperty(output.NotificationProperty, context)
        : undefined,
    NumberOfWorkers:
      output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null ? output.NumberOfWorkers : undefined,
    PredecessorRuns:
      output.PredecessorRuns !== undefined && output.PredecessorRuns !== null
        ? deserializeAws_json1_1PredecessorList(output.PredecessorRuns, context)
        : undefined,
    PreviousRunId:
      output.PreviousRunId !== undefined && output.PreviousRunId !== null ? output.PreviousRunId : undefined,
    SecurityConfiguration:
      output.SecurityConfiguration !== undefined && output.SecurityConfiguration !== null
        ? output.SecurityConfiguration
        : undefined,
    StartedOn:
      output.StartedOn !== undefined && output.StartedOn !== null
        ? new Date(Math.round(output.StartedOn * 1000))
        : undefined,
    Timeout: output.Timeout !== undefined && output.Timeout !== null ? output.Timeout : undefined,
    TriggerName: output.TriggerName !== undefined && output.TriggerName !== null ? output.TriggerName : undefined,
    WorkerType: output.WorkerType !== undefined && output.WorkerType !== null ? output.WorkerType : undefined,
  } as any;
};

const deserializeAws_json1_1JobRunList = (output: any, context: __SerdeContext): JobRun[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1JobRun(entry, context));
};

const deserializeAws_json1_1JsonClassifier = (output: any, context: __SerdeContext): JsonClassifier => {
  return {
    __type: "JsonClassifier",
    CreationTime:
      output.CreationTime !== undefined && output.CreationTime !== null
        ? new Date(Math.round(output.CreationTime * 1000))
        : undefined,
    JsonPath: output.JsonPath !== undefined && output.JsonPath !== null ? output.JsonPath : undefined,
    LastUpdated:
      output.LastUpdated !== undefined && output.LastUpdated !== null
        ? new Date(Math.round(output.LastUpdated * 1000))
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Version: output.Version !== undefined && output.Version !== null ? output.Version : undefined,
  } as any;
};

const deserializeAws_json1_1LabelingSetGenerationTaskRunProperties = (
  output: any,
  context: __SerdeContext
): LabelingSetGenerationTaskRunProperties => {
  return {
    __type: "LabelingSetGenerationTaskRunProperties",
    OutputS3Path: output.OutputS3Path !== undefined && output.OutputS3Path !== null ? output.OutputS3Path : undefined,
  } as any;
};

const deserializeAws_json1_1LastCrawlInfo = (output: any, context: __SerdeContext): LastCrawlInfo => {
  return {
    __type: "LastCrawlInfo",
    ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
    LogGroup: output.LogGroup !== undefined && output.LogGroup !== null ? output.LogGroup : undefined,
    LogStream: output.LogStream !== undefined && output.LogStream !== null ? output.LogStream : undefined,
    MessagePrefix:
      output.MessagePrefix !== undefined && output.MessagePrefix !== null ? output.MessagePrefix : undefined,
    StartTime:
      output.StartTime !== undefined && output.StartTime !== null
        ? new Date(Math.round(output.StartTime * 1000))
        : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
  } as any;
};

const deserializeAws_json1_1ListCrawlersResponse = (output: any, context: __SerdeContext): ListCrawlersResponse => {
  return {
    __type: "ListCrawlersResponse",
    CrawlerNames:
      output.CrawlerNames !== undefined && output.CrawlerNames !== null
        ? deserializeAws_json1_1CrawlerNameList(output.CrawlerNames, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1ListDevEndpointsResponse = (
  output: any,
  context: __SerdeContext
): ListDevEndpointsResponse => {
  return {
    __type: "ListDevEndpointsResponse",
    DevEndpointNames:
      output.DevEndpointNames !== undefined && output.DevEndpointNames !== null
        ? deserializeAws_json1_1DevEndpointNameList(output.DevEndpointNames, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1ListJobsResponse = (output: any, context: __SerdeContext): ListJobsResponse => {
  return {
    __type: "ListJobsResponse",
    JobNames:
      output.JobNames !== undefined && output.JobNames !== null
        ? deserializeAws_json1_1JobNameList(output.JobNames, context)
        : undefined,
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
  } as any;
};

const deserializeAws_json1_1ListTriggersResponse = (output: any, context: __SerdeContext): ListTriggersResponse => {
  return {
    __type: "ListTriggersResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    TriggerNames:
      output.TriggerNames !== undefined && output.TriggerNames !== null
        ? deserializeAws_json1_1TriggerNameList(output.TriggerNames, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListWorkflowsResponse = (output: any, context: __SerdeContext): ListWorkflowsResponse => {
  return {
    __type: "ListWorkflowsResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    Workflows:
      output.Workflows !== undefined && output.Workflows !== null
        ? deserializeAws_json1_1WorkflowNames(output.Workflows, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1LocationMap = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const deserializeAws_json1_1MappingEntry = (output: any, context: __SerdeContext): MappingEntry => {
  return {
    __type: "MappingEntry",
    SourcePath: output.SourcePath !== undefined && output.SourcePath !== null ? output.SourcePath : undefined,
    SourceTable: output.SourceTable !== undefined && output.SourceTable !== null ? output.SourceTable : undefined,
    SourceType: output.SourceType !== undefined && output.SourceType !== null ? output.SourceType : undefined,
    TargetPath: output.TargetPath !== undefined && output.TargetPath !== null ? output.TargetPath : undefined,
    TargetTable: output.TargetTable !== undefined && output.TargetTable !== null ? output.TargetTable : undefined,
    TargetType: output.TargetType !== undefined && output.TargetType !== null ? output.TargetType : undefined,
  } as any;
};

const deserializeAws_json1_1MappingList = (output: any, context: __SerdeContext): MappingEntry[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1MappingEntry(entry, context));
};

const deserializeAws_json1_1MapValue = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const deserializeAws_json1_1MatchCriteria = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1MLTransform = (output: any, context: __SerdeContext): MLTransform => {
  return {
    __type: "MLTransform",
    CreatedOn:
      output.CreatedOn !== undefined && output.CreatedOn !== null
        ? new Date(Math.round(output.CreatedOn * 1000))
        : undefined,
    Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
    EvaluationMetrics:
      output.EvaluationMetrics !== undefined && output.EvaluationMetrics !== null
        ? deserializeAws_json1_1EvaluationMetrics(output.EvaluationMetrics, context)
        : undefined,
    GlueVersion: output.GlueVersion !== undefined && output.GlueVersion !== null ? output.GlueVersion : undefined,
    InputRecordTables:
      output.InputRecordTables !== undefined && output.InputRecordTables !== null
        ? deserializeAws_json1_1GlueTables(output.InputRecordTables, context)
        : undefined,
    LabelCount: output.LabelCount !== undefined && output.LabelCount !== null ? output.LabelCount : undefined,
    LastModifiedOn:
      output.LastModifiedOn !== undefined && output.LastModifiedOn !== null
        ? new Date(Math.round(output.LastModifiedOn * 1000))
        : undefined,
    MaxCapacity: output.MaxCapacity !== undefined && output.MaxCapacity !== null ? output.MaxCapacity : undefined,
    MaxRetries: output.MaxRetries !== undefined && output.MaxRetries !== null ? output.MaxRetries : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    NumberOfWorkers:
      output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null ? output.NumberOfWorkers : undefined,
    Parameters:
      output.Parameters !== undefined && output.Parameters !== null
        ? deserializeAws_json1_1TransformParameters(output.Parameters, context)
        : undefined,
    Role: output.Role !== undefined && output.Role !== null ? output.Role : undefined,
    Schema:
      output.Schema !== undefined && output.Schema !== null
        ? deserializeAws_json1_1TransformSchema(output.Schema, context)
        : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    Timeout: output.Timeout !== undefined && output.Timeout !== null ? output.Timeout : undefined,
    TransformId: output.TransformId !== undefined && output.TransformId !== null ? output.TransformId : undefined,
    WorkerType: output.WorkerType !== undefined && output.WorkerType !== null ? output.WorkerType : undefined,
  } as any;
};

const deserializeAws_json1_1MLTransformNotReadyException = (
  output: any,
  context: __SerdeContext
): MLTransformNotReadyException => {
  return {
    __type: "MLTransformNotReadyException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1NameStringList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Node = (output: any, context: __SerdeContext): Node => {
  return {
    __type: "Node",
    CrawlerDetails:
      output.CrawlerDetails !== undefined && output.CrawlerDetails !== null
        ? deserializeAws_json1_1CrawlerNodeDetails(output.CrawlerDetails, context)
        : undefined,
    JobDetails:
      output.JobDetails !== undefined && output.JobDetails !== null
        ? deserializeAws_json1_1JobNodeDetails(output.JobDetails, context)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    TriggerDetails:
      output.TriggerDetails !== undefined && output.TriggerDetails !== null
        ? deserializeAws_json1_1TriggerNodeDetails(output.TriggerDetails, context)
        : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    UniqueId: output.UniqueId !== undefined && output.UniqueId !== null ? output.UniqueId : undefined,
  } as any;
};

const deserializeAws_json1_1NodeList = (output: any, context: __SerdeContext): Node[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Node(entry, context));
};

const deserializeAws_json1_1NoScheduleException = (output: any, context: __SerdeContext): NoScheduleException => {
  return {
    __type: "NoScheduleException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1NotificationProperty = (output: any, context: __SerdeContext): NotificationProperty => {
  return {
    __type: "NotificationProperty",
    NotifyDelayAfter:
      output.NotifyDelayAfter !== undefined && output.NotifyDelayAfter !== null ? output.NotifyDelayAfter : undefined,
  } as any;
};

const deserializeAws_json1_1OperationTimeoutException = (
  output: any,
  context: __SerdeContext
): OperationTimeoutException => {
  return {
    __type: "OperationTimeoutException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1OrchestrationStringList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Order = (output: any, context: __SerdeContext): Order => {
  return {
    __type: "Order",
    Column: output.Column !== undefined && output.Column !== null ? output.Column : undefined,
    SortOrder: output.SortOrder !== undefined && output.SortOrder !== null ? output.SortOrder : undefined,
  } as any;
};

const deserializeAws_json1_1OrderList = (output: any, context: __SerdeContext): Order[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Order(entry, context));
};

const deserializeAws_json1_1ParametersMap = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const deserializeAws_json1_1Partition = (output: any, context: __SerdeContext): Partition => {
  return {
    __type: "Partition",
    CreationTime:
      output.CreationTime !== undefined && output.CreationTime !== null
        ? new Date(Math.round(output.CreationTime * 1000))
        : undefined,
    DatabaseName: output.DatabaseName !== undefined && output.DatabaseName !== null ? output.DatabaseName : undefined,
    LastAccessTime:
      output.LastAccessTime !== undefined && output.LastAccessTime !== null
        ? new Date(Math.round(output.LastAccessTime * 1000))
        : undefined,
    LastAnalyzedTime:
      output.LastAnalyzedTime !== undefined && output.LastAnalyzedTime !== null
        ? new Date(Math.round(output.LastAnalyzedTime * 1000))
        : undefined,
    Parameters:
      output.Parameters !== undefined && output.Parameters !== null
        ? deserializeAws_json1_1ParametersMap(output.Parameters, context)
        : undefined,
    StorageDescriptor:
      output.StorageDescriptor !== undefined && output.StorageDescriptor !== null
        ? deserializeAws_json1_1StorageDescriptor(output.StorageDescriptor, context)
        : undefined,
    TableName: output.TableName !== undefined && output.TableName !== null ? output.TableName : undefined,
    Values:
      output.Values !== undefined && output.Values !== null
        ? deserializeAws_json1_1ValueStringList(output.Values, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1PartitionError = (output: any, context: __SerdeContext): PartitionError => {
  return {
    __type: "PartitionError",
    ErrorDetail:
      output.ErrorDetail !== undefined && output.ErrorDetail !== null
        ? deserializeAws_json1_1ErrorDetail(output.ErrorDetail, context)
        : undefined,
    PartitionValues:
      output.PartitionValues !== undefined && output.PartitionValues !== null
        ? deserializeAws_json1_1ValueStringList(output.PartitionValues, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1PartitionErrors = (output: any, context: __SerdeContext): PartitionError[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1PartitionError(entry, context));
};

const deserializeAws_json1_1PartitionList = (output: any, context: __SerdeContext): Partition[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Partition(entry, context));
};

const deserializeAws_json1_1PartitionValueList = (output: any, context: __SerdeContext): PartitionValueList => {
  return {
    __type: "PartitionValueList",
    Values:
      output.Values !== undefined && output.Values !== null
        ? deserializeAws_json1_1ValueStringList(output.Values, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1PathList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PermissionList = (output: any, context: __SerdeContext): (Permission | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PhysicalConnectionRequirements = (
  output: any,
  context: __SerdeContext
): PhysicalConnectionRequirements => {
  return {
    __type: "PhysicalConnectionRequirements",
    AvailabilityZone:
      output.AvailabilityZone !== undefined && output.AvailabilityZone !== null ? output.AvailabilityZone : undefined,
    SecurityGroupIdList:
      output.SecurityGroupIdList !== undefined && output.SecurityGroupIdList !== null
        ? deserializeAws_json1_1SecurityGroupIdList(output.SecurityGroupIdList, context)
        : undefined,
    SubnetId: output.SubnetId !== undefined && output.SubnetId !== null ? output.SubnetId : undefined,
  } as any;
};

const deserializeAws_json1_1Predecessor = (output: any, context: __SerdeContext): Predecessor => {
  return {
    __type: "Predecessor",
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
    RunId: output.RunId !== undefined && output.RunId !== null ? output.RunId : undefined,
  } as any;
};

const deserializeAws_json1_1PredecessorList = (output: any, context: __SerdeContext): Predecessor[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Predecessor(entry, context));
};

const deserializeAws_json1_1Predicate = (output: any, context: __SerdeContext): Predicate => {
  return {
    __type: "Predicate",
    Conditions:
      output.Conditions !== undefined && output.Conditions !== null
        ? deserializeAws_json1_1ConditionList(output.Conditions, context)
        : undefined,
    Logical: output.Logical !== undefined && output.Logical !== null ? output.Logical : undefined,
  } as any;
};

const deserializeAws_json1_1PrincipalPermissions = (output: any, context: __SerdeContext): PrincipalPermissions => {
  return {
    __type: "PrincipalPermissions",
    Permissions:
      output.Permissions !== undefined && output.Permissions !== null
        ? deserializeAws_json1_1PermissionList(output.Permissions, context)
        : undefined,
    Principal:
      output.Principal !== undefined && output.Principal !== null
        ? deserializeAws_json1_1DataLakePrincipal(output.Principal, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1PrincipalPermissionsList = (
  output: any,
  context: __SerdeContext
): PrincipalPermissions[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1PrincipalPermissions(entry, context));
};

const deserializeAws_json1_1PublicKeysList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PutDataCatalogEncryptionSettingsResponse = (
  output: any,
  context: __SerdeContext
): PutDataCatalogEncryptionSettingsResponse => {
  return {
    __type: "PutDataCatalogEncryptionSettingsResponse",
  } as any;
};

const deserializeAws_json1_1PutResourcePolicyResponse = (
  output: any,
  context: __SerdeContext
): PutResourcePolicyResponse => {
  return {
    __type: "PutResourcePolicyResponse",
    PolicyHash: output.PolicyHash !== undefined && output.PolicyHash !== null ? output.PolicyHash : undefined,
  } as any;
};

const deserializeAws_json1_1PutWorkflowRunPropertiesResponse = (
  output: any,
  context: __SerdeContext
): PutWorkflowRunPropertiesResponse => {
  return {
    __type: "PutWorkflowRunPropertiesResponse",
  } as any;
};

const deserializeAws_json1_1ResetJobBookmarkResponse = (
  output: any,
  context: __SerdeContext
): ResetJobBookmarkResponse => {
  return {
    __type: "ResetJobBookmarkResponse",
    JobBookmarkEntry:
      output.JobBookmarkEntry !== undefined && output.JobBookmarkEntry !== null
        ? deserializeAws_json1_1JobBookmarkEntry(output.JobBookmarkEntry, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ResourceNumberLimitExceededException = (
  output: any,
  context: __SerdeContext
): ResourceNumberLimitExceededException => {
  return {
    __type: "ResourceNumberLimitExceededException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1ResourceUri = (output: any, context: __SerdeContext): ResourceUri => {
  return {
    __type: "ResourceUri",
    ResourceType: output.ResourceType !== undefined && output.ResourceType !== null ? output.ResourceType : undefined,
    Uri: output.Uri !== undefined && output.Uri !== null ? output.Uri : undefined,
  } as any;
};

const deserializeAws_json1_1ResourceUriList = (output: any, context: __SerdeContext): ResourceUri[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1ResourceUri(entry, context));
};

const deserializeAws_json1_1S3Encryption = (output: any, context: __SerdeContext): S3Encryption => {
  return {
    __type: "S3Encryption",
    KmsKeyArn: output.KmsKeyArn !== undefined && output.KmsKeyArn !== null ? output.KmsKeyArn : undefined,
    S3EncryptionMode:
      output.S3EncryptionMode !== undefined && output.S3EncryptionMode !== null ? output.S3EncryptionMode : undefined,
  } as any;
};

const deserializeAws_json1_1S3EncryptionList = (output: any, context: __SerdeContext): S3Encryption[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1S3Encryption(entry, context));
};

const deserializeAws_json1_1S3Target = (output: any, context: __SerdeContext): S3Target => {
  return {
    __type: "S3Target",
    Exclusions:
      output.Exclusions !== undefined && output.Exclusions !== null
        ? deserializeAws_json1_1PathList(output.Exclusions, context)
        : undefined,
    Path: output.Path !== undefined && output.Path !== null ? output.Path : undefined,
  } as any;
};

const deserializeAws_json1_1S3TargetList = (output: any, context: __SerdeContext): S3Target[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1S3Target(entry, context));
};

const deserializeAws_json1_1Schedule = (output: any, context: __SerdeContext): Schedule => {
  return {
    __type: "Schedule",
    ScheduleExpression:
      output.ScheduleExpression !== undefined && output.ScheduleExpression !== null
        ? output.ScheduleExpression
        : undefined,
    State: output.State !== undefined && output.State !== null ? output.State : undefined,
  } as any;
};

const deserializeAws_json1_1SchedulerNotRunningException = (
  output: any,
  context: __SerdeContext
): SchedulerNotRunningException => {
  return {
    __type: "SchedulerNotRunningException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1SchedulerRunningException = (
  output: any,
  context: __SerdeContext
): SchedulerRunningException => {
  return {
    __type: "SchedulerRunningException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1SchedulerTransitioningException = (
  output: any,
  context: __SerdeContext
): SchedulerTransitioningException => {
  return {
    __type: "SchedulerTransitioningException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1SchemaChangePolicy = (output: any, context: __SerdeContext): SchemaChangePolicy => {
  return {
    __type: "SchemaChangePolicy",
    DeleteBehavior:
      output.DeleteBehavior !== undefined && output.DeleteBehavior !== null ? output.DeleteBehavior : undefined,
    UpdateBehavior:
      output.UpdateBehavior !== undefined && output.UpdateBehavior !== null ? output.UpdateBehavior : undefined,
  } as any;
};

const deserializeAws_json1_1SchemaColumn = (output: any, context: __SerdeContext): SchemaColumn => {
  return {
    __type: "SchemaColumn",
    DataType: output.DataType !== undefined && output.DataType !== null ? output.DataType : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1SearchTablesResponse = (output: any, context: __SerdeContext): SearchTablesResponse => {
  return {
    __type: "SearchTablesResponse",
    NextToken: output.NextToken !== undefined && output.NextToken !== null ? output.NextToken : undefined,
    TableList:
      output.TableList !== undefined && output.TableList !== null
        ? deserializeAws_json1_1TableList(output.TableList, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1SecurityConfiguration = (output: any, context: __SerdeContext): SecurityConfiguration => {
  return {
    __type: "SecurityConfiguration",
    CreatedTimeStamp:
      output.CreatedTimeStamp !== undefined && output.CreatedTimeStamp !== null
        ? new Date(Math.round(output.CreatedTimeStamp * 1000))
        : undefined,
    EncryptionConfiguration:
      output.EncryptionConfiguration !== undefined && output.EncryptionConfiguration !== null
        ? deserializeAws_json1_1EncryptionConfiguration(output.EncryptionConfiguration, context)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1SecurityConfigurationList = (
  output: any,
  context: __SerdeContext
): SecurityConfiguration[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1SecurityConfiguration(entry, context));
};

const deserializeAws_json1_1SecurityGroupIdList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SerDeInfo = (output: any, context: __SerdeContext): SerDeInfo => {
  return {
    __type: "SerDeInfo",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Parameters:
      output.Parameters !== undefined && output.Parameters !== null
        ? deserializeAws_json1_1ParametersMap(output.Parameters, context)
        : undefined,
    SerializationLibrary:
      output.SerializationLibrary !== undefined && output.SerializationLibrary !== null
        ? output.SerializationLibrary
        : undefined,
  } as any;
};

const deserializeAws_json1_1SkewedInfo = (output: any, context: __SerdeContext): SkewedInfo => {
  return {
    __type: "SkewedInfo",
    SkewedColumnNames:
      output.SkewedColumnNames !== undefined && output.SkewedColumnNames !== null
        ? deserializeAws_json1_1NameStringList(output.SkewedColumnNames, context)
        : undefined,
    SkewedColumnValueLocationMaps:
      output.SkewedColumnValueLocationMaps !== undefined && output.SkewedColumnValueLocationMaps !== null
        ? deserializeAws_json1_1LocationMap(output.SkewedColumnValueLocationMaps, context)
        : undefined,
    SkewedColumnValues:
      output.SkewedColumnValues !== undefined && output.SkewedColumnValues !== null
        ? deserializeAws_json1_1ColumnValueStringList(output.SkewedColumnValues, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1StartCrawlerResponse = (output: any, context: __SerdeContext): StartCrawlerResponse => {
  return {
    __type: "StartCrawlerResponse",
  } as any;
};

const deserializeAws_json1_1StartCrawlerScheduleResponse = (
  output: any,
  context: __SerdeContext
): StartCrawlerScheduleResponse => {
  return {
    __type: "StartCrawlerScheduleResponse",
  } as any;
};

const deserializeAws_json1_1StartExportLabelsTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartExportLabelsTaskRunResponse => {
  return {
    __type: "StartExportLabelsTaskRunResponse",
    TaskRunId: output.TaskRunId !== undefined && output.TaskRunId !== null ? output.TaskRunId : undefined,
  } as any;
};

const deserializeAws_json1_1StartImportLabelsTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartImportLabelsTaskRunResponse => {
  return {
    __type: "StartImportLabelsTaskRunResponse",
    TaskRunId: output.TaskRunId !== undefined && output.TaskRunId !== null ? output.TaskRunId : undefined,
  } as any;
};

const deserializeAws_json1_1StartJobRunResponse = (output: any, context: __SerdeContext): StartJobRunResponse => {
  return {
    __type: "StartJobRunResponse",
    JobRunId: output.JobRunId !== undefined && output.JobRunId !== null ? output.JobRunId : undefined,
  } as any;
};

const deserializeAws_json1_1StartMLEvaluationTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartMLEvaluationTaskRunResponse => {
  return {
    __type: "StartMLEvaluationTaskRunResponse",
    TaskRunId: output.TaskRunId !== undefined && output.TaskRunId !== null ? output.TaskRunId : undefined,
  } as any;
};

const deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartMLLabelingSetGenerationTaskRunResponse => {
  return {
    __type: "StartMLLabelingSetGenerationTaskRunResponse",
    TaskRunId: output.TaskRunId !== undefined && output.TaskRunId !== null ? output.TaskRunId : undefined,
  } as any;
};

const deserializeAws_json1_1StartTriggerResponse = (output: any, context: __SerdeContext): StartTriggerResponse => {
  return {
    __type: "StartTriggerResponse",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1StartWorkflowRunResponse = (
  output: any,
  context: __SerdeContext
): StartWorkflowRunResponse => {
  return {
    __type: "StartWorkflowRunResponse",
    RunId: output.RunId !== undefined && output.RunId !== null ? output.RunId : undefined,
  } as any;
};

const deserializeAws_json1_1StopCrawlerResponse = (output: any, context: __SerdeContext): StopCrawlerResponse => {
  return {
    __type: "StopCrawlerResponse",
  } as any;
};

const deserializeAws_json1_1StopCrawlerScheduleResponse = (
  output: any,
  context: __SerdeContext
): StopCrawlerScheduleResponse => {
  return {
    __type: "StopCrawlerScheduleResponse",
  } as any;
};

const deserializeAws_json1_1StopTriggerResponse = (output: any, context: __SerdeContext): StopTriggerResponse => {
  return {
    __type: "StopTriggerResponse",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1StorageDescriptor = (output: any, context: __SerdeContext): StorageDescriptor => {
  return {
    __type: "StorageDescriptor",
    BucketColumns:
      output.BucketColumns !== undefined && output.BucketColumns !== null
        ? deserializeAws_json1_1NameStringList(output.BucketColumns, context)
        : undefined,
    Columns:
      output.Columns !== undefined && output.Columns !== null
        ? deserializeAws_json1_1ColumnList(output.Columns, context)
        : undefined,
    Compressed: output.Compressed !== undefined && output.Compressed !== null ? output.Compressed : undefined,
    InputFormat: output.InputFormat !== undefined && output.InputFormat !== null ? output.InputFormat : undefined,
    Location: output.Location !== undefined && output.Location !== null ? output.Location : undefined,
    NumberOfBuckets:
      output.NumberOfBuckets !== undefined && output.NumberOfBuckets !== null ? output.NumberOfBuckets : undefined,
    OutputFormat: output.OutputFormat !== undefined && output.OutputFormat !== null ? output.OutputFormat : undefined,
    Parameters:
      output.Parameters !== undefined && output.Parameters !== null
        ? deserializeAws_json1_1ParametersMap(output.Parameters, context)
        : undefined,
    SerdeInfo:
      output.SerdeInfo !== undefined && output.SerdeInfo !== null
        ? deserializeAws_json1_1SerDeInfo(output.SerdeInfo, context)
        : undefined,
    SkewedInfo:
      output.SkewedInfo !== undefined && output.SkewedInfo !== null
        ? deserializeAws_json1_1SkewedInfo(output.SkewedInfo, context)
        : undefined,
    SortColumns:
      output.SortColumns !== undefined && output.SortColumns !== null
        ? deserializeAws_json1_1OrderList(output.SortColumns, context)
        : undefined,
    StoredAsSubDirectories:
      output.StoredAsSubDirectories !== undefined && output.StoredAsSubDirectories !== null
        ? output.StoredAsSubDirectories
        : undefined,
  } as any;
};

const deserializeAws_json1_1StringList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Table = (output: any, context: __SerdeContext): Table => {
  return {
    __type: "Table",
    CreateTime:
      output.CreateTime !== undefined && output.CreateTime !== null
        ? new Date(Math.round(output.CreateTime * 1000))
        : undefined,
    CreatedBy: output.CreatedBy !== undefined && output.CreatedBy !== null ? output.CreatedBy : undefined,
    DatabaseName: output.DatabaseName !== undefined && output.DatabaseName !== null ? output.DatabaseName : undefined,
    Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
    IsRegisteredWithLakeFormation:
      output.IsRegisteredWithLakeFormation !== undefined && output.IsRegisteredWithLakeFormation !== null
        ? output.IsRegisteredWithLakeFormation
        : undefined,
    LastAccessTime:
      output.LastAccessTime !== undefined && output.LastAccessTime !== null
        ? new Date(Math.round(output.LastAccessTime * 1000))
        : undefined,
    LastAnalyzedTime:
      output.LastAnalyzedTime !== undefined && output.LastAnalyzedTime !== null
        ? new Date(Math.round(output.LastAnalyzedTime * 1000))
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Owner: output.Owner !== undefined && output.Owner !== null ? output.Owner : undefined,
    Parameters:
      output.Parameters !== undefined && output.Parameters !== null
        ? deserializeAws_json1_1ParametersMap(output.Parameters, context)
        : undefined,
    PartitionKeys:
      output.PartitionKeys !== undefined && output.PartitionKeys !== null
        ? deserializeAws_json1_1ColumnList(output.PartitionKeys, context)
        : undefined,
    Retention: output.Retention !== undefined && output.Retention !== null ? output.Retention : undefined,
    StorageDescriptor:
      output.StorageDescriptor !== undefined && output.StorageDescriptor !== null
        ? deserializeAws_json1_1StorageDescriptor(output.StorageDescriptor, context)
        : undefined,
    TableType: output.TableType !== undefined && output.TableType !== null ? output.TableType : undefined,
    UpdateTime:
      output.UpdateTime !== undefined && output.UpdateTime !== null
        ? new Date(Math.round(output.UpdateTime * 1000))
        : undefined,
    ViewExpandedText:
      output.ViewExpandedText !== undefined && output.ViewExpandedText !== null ? output.ViewExpandedText : undefined,
    ViewOriginalText:
      output.ViewOriginalText !== undefined && output.ViewOriginalText !== null ? output.ViewOriginalText : undefined,
  } as any;
};

const deserializeAws_json1_1TableError = (output: any, context: __SerdeContext): TableError => {
  return {
    __type: "TableError",
    ErrorDetail:
      output.ErrorDetail !== undefined && output.ErrorDetail !== null
        ? deserializeAws_json1_1ErrorDetail(output.ErrorDetail, context)
        : undefined,
    TableName: output.TableName !== undefined && output.TableName !== null ? output.TableName : undefined,
  } as any;
};

const deserializeAws_json1_1TableErrors = (output: any, context: __SerdeContext): TableError[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1TableError(entry, context));
};

const deserializeAws_json1_1TableList = (output: any, context: __SerdeContext): Table[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Table(entry, context));
};

const deserializeAws_json1_1TableVersion = (output: any, context: __SerdeContext): TableVersion => {
  return {
    __type: "TableVersion",
    Table:
      output.Table !== undefined && output.Table !== null
        ? deserializeAws_json1_1Table(output.Table, context)
        : undefined,
    VersionId: output.VersionId !== undefined && output.VersionId !== null ? output.VersionId : undefined,
  } as any;
};

const deserializeAws_json1_1TableVersionError = (output: any, context: __SerdeContext): TableVersionError => {
  return {
    __type: "TableVersionError",
    ErrorDetail:
      output.ErrorDetail !== undefined && output.ErrorDetail !== null
        ? deserializeAws_json1_1ErrorDetail(output.ErrorDetail, context)
        : undefined,
    TableName: output.TableName !== undefined && output.TableName !== null ? output.TableName : undefined,
    VersionId: output.VersionId !== undefined && output.VersionId !== null ? output.VersionId : undefined,
  } as any;
};

const deserializeAws_json1_1TableVersionErrors = (output: any, context: __SerdeContext): TableVersionError[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1TableVersionError(entry, context));
};

const deserializeAws_json1_1TagResourceResponse = (output: any, context: __SerdeContext): TagResourceResponse => {
  return {
    __type: "TagResourceResponse",
  } as any;
};

const deserializeAws_json1_1TagsMap = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const deserializeAws_json1_1TaskRun = (output: any, context: __SerdeContext): TaskRun => {
  return {
    __type: "TaskRun",
    CompletedOn:
      output.CompletedOn !== undefined && output.CompletedOn !== null
        ? new Date(Math.round(output.CompletedOn * 1000))
        : undefined,
    ErrorString: output.ErrorString !== undefined && output.ErrorString !== null ? output.ErrorString : undefined,
    ExecutionTime:
      output.ExecutionTime !== undefined && output.ExecutionTime !== null ? output.ExecutionTime : undefined,
    LastModifiedOn:
      output.LastModifiedOn !== undefined && output.LastModifiedOn !== null
        ? new Date(Math.round(output.LastModifiedOn * 1000))
        : undefined,
    LogGroupName: output.LogGroupName !== undefined && output.LogGroupName !== null ? output.LogGroupName : undefined,
    Properties:
      output.Properties !== undefined && output.Properties !== null
        ? deserializeAws_json1_1TaskRunProperties(output.Properties, context)
        : undefined,
    StartedOn:
      output.StartedOn !== undefined && output.StartedOn !== null
        ? new Date(Math.round(output.StartedOn * 1000))
        : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    TaskRunId: output.TaskRunId !== undefined && output.TaskRunId !== null ? output.TaskRunId : undefined,
    TransformId: output.TransformId !== undefined && output.TransformId !== null ? output.TransformId : undefined,
  } as any;
};

const deserializeAws_json1_1TaskRunList = (output: any, context: __SerdeContext): TaskRun[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1TaskRun(entry, context));
};

const deserializeAws_json1_1TaskRunProperties = (output: any, context: __SerdeContext): TaskRunProperties => {
  return {
    __type: "TaskRunProperties",
    ExportLabelsTaskRunProperties:
      output.ExportLabelsTaskRunProperties !== undefined && output.ExportLabelsTaskRunProperties !== null
        ? deserializeAws_json1_1ExportLabelsTaskRunProperties(output.ExportLabelsTaskRunProperties, context)
        : undefined,
    FindMatchesTaskRunProperties:
      output.FindMatchesTaskRunProperties !== undefined && output.FindMatchesTaskRunProperties !== null
        ? deserializeAws_json1_1FindMatchesTaskRunProperties(output.FindMatchesTaskRunProperties, context)
        : undefined,
    ImportLabelsTaskRunProperties:
      output.ImportLabelsTaskRunProperties !== undefined && output.ImportLabelsTaskRunProperties !== null
        ? deserializeAws_json1_1ImportLabelsTaskRunProperties(output.ImportLabelsTaskRunProperties, context)
        : undefined,
    LabelingSetGenerationTaskRunProperties:
      output.LabelingSetGenerationTaskRunProperties !== undefined &&
      output.LabelingSetGenerationTaskRunProperties !== null
        ? deserializeAws_json1_1LabelingSetGenerationTaskRunProperties(
            output.LabelingSetGenerationTaskRunProperties,
            context
          )
        : undefined,
    TaskType: output.TaskType !== undefined && output.TaskType !== null ? output.TaskType : undefined,
  } as any;
};

const deserializeAws_json1_1TransformList = (output: any, context: __SerdeContext): MLTransform[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1MLTransform(entry, context));
};

const deserializeAws_json1_1TransformParameters = (output: any, context: __SerdeContext): TransformParameters => {
  return {
    __type: "TransformParameters",
    FindMatchesParameters:
      output.FindMatchesParameters !== undefined && output.FindMatchesParameters !== null
        ? deserializeAws_json1_1FindMatchesParameters(output.FindMatchesParameters, context)
        : undefined,
    TransformType:
      output.TransformType !== undefined && output.TransformType !== null ? output.TransformType : undefined,
  } as any;
};

const deserializeAws_json1_1TransformSchema = (output: any, context: __SerdeContext): SchemaColumn[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1SchemaColumn(entry, context));
};

const deserializeAws_json1_1Trigger = (output: any, context: __SerdeContext): Trigger => {
  return {
    __type: "Trigger",
    Actions:
      output.Actions !== undefined && output.Actions !== null
        ? deserializeAws_json1_1ActionList(output.Actions, context)
        : undefined,
    Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
    Id: output.Id !== undefined && output.Id !== null ? output.Id : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Predicate:
      output.Predicate !== undefined && output.Predicate !== null
        ? deserializeAws_json1_1Predicate(output.Predicate, context)
        : undefined,
    Schedule: output.Schedule !== undefined && output.Schedule !== null ? output.Schedule : undefined,
    State: output.State !== undefined && output.State !== null ? output.State : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    WorkflowName: output.WorkflowName !== undefined && output.WorkflowName !== null ? output.WorkflowName : undefined,
  } as any;
};

const deserializeAws_json1_1TriggerList = (output: any, context: __SerdeContext): Trigger[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Trigger(entry, context));
};

const deserializeAws_json1_1TriggerNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1TriggerNodeDetails = (output: any, context: __SerdeContext): TriggerNodeDetails => {
  return {
    __type: "TriggerNodeDetails",
    Trigger:
      output.Trigger !== undefined && output.Trigger !== null
        ? deserializeAws_json1_1Trigger(output.Trigger, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1UntagResourceResponse = (output: any, context: __SerdeContext): UntagResourceResponse => {
  return {
    __type: "UntagResourceResponse",
  } as any;
};

const deserializeAws_json1_1UpdateClassifierResponse = (
  output: any,
  context: __SerdeContext
): UpdateClassifierResponse => {
  return {
    __type: "UpdateClassifierResponse",
  } as any;
};

const deserializeAws_json1_1UpdateConnectionResponse = (
  output: any,
  context: __SerdeContext
): UpdateConnectionResponse => {
  return {
    __type: "UpdateConnectionResponse",
  } as any;
};

const deserializeAws_json1_1UpdateCrawlerResponse = (output: any, context: __SerdeContext): UpdateCrawlerResponse => {
  return {
    __type: "UpdateCrawlerResponse",
  } as any;
};

const deserializeAws_json1_1UpdateCrawlerScheduleResponse = (
  output: any,
  context: __SerdeContext
): UpdateCrawlerScheduleResponse => {
  return {
    __type: "UpdateCrawlerScheduleResponse",
  } as any;
};

const deserializeAws_json1_1UpdateDatabaseResponse = (output: any, context: __SerdeContext): UpdateDatabaseResponse => {
  return {
    __type: "UpdateDatabaseResponse",
  } as any;
};

const deserializeAws_json1_1UpdateDevEndpointResponse = (
  output: any,
  context: __SerdeContext
): UpdateDevEndpointResponse => {
  return {
    __type: "UpdateDevEndpointResponse",
  } as any;
};

const deserializeAws_json1_1UpdateJobResponse = (output: any, context: __SerdeContext): UpdateJobResponse => {
  return {
    __type: "UpdateJobResponse",
    JobName: output.JobName !== undefined && output.JobName !== null ? output.JobName : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateMLTransformResponse = (
  output: any,
  context: __SerdeContext
): UpdateMLTransformResponse => {
  return {
    __type: "UpdateMLTransformResponse",
    TransformId: output.TransformId !== undefined && output.TransformId !== null ? output.TransformId : undefined,
  } as any;
};

const deserializeAws_json1_1UpdatePartitionResponse = (
  output: any,
  context: __SerdeContext
): UpdatePartitionResponse => {
  return {
    __type: "UpdatePartitionResponse",
  } as any;
};

const deserializeAws_json1_1UpdateTableResponse = (output: any, context: __SerdeContext): UpdateTableResponse => {
  return {
    __type: "UpdateTableResponse",
  } as any;
};

const deserializeAws_json1_1UpdateTriggerResponse = (output: any, context: __SerdeContext): UpdateTriggerResponse => {
  return {
    __type: "UpdateTriggerResponse",
    Trigger:
      output.Trigger !== undefined && output.Trigger !== null
        ? deserializeAws_json1_1Trigger(output.Trigger, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): UpdateUserDefinedFunctionResponse => {
  return {
    __type: "UpdateUserDefinedFunctionResponse",
  } as any;
};

const deserializeAws_json1_1UpdateWorkflowResponse = (output: any, context: __SerdeContext): UpdateWorkflowResponse => {
  return {
    __type: "UpdateWorkflowResponse",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1UserDefinedFunction = (output: any, context: __SerdeContext): UserDefinedFunction => {
  return {
    __type: "UserDefinedFunction",
    ClassName: output.ClassName !== undefined && output.ClassName !== null ? output.ClassName : undefined,
    CreateTime:
      output.CreateTime !== undefined && output.CreateTime !== null
        ? new Date(Math.round(output.CreateTime * 1000))
        : undefined,
    FunctionName: output.FunctionName !== undefined && output.FunctionName !== null ? output.FunctionName : undefined,
    OwnerName: output.OwnerName !== undefined && output.OwnerName !== null ? output.OwnerName : undefined,
    OwnerType: output.OwnerType !== undefined && output.OwnerType !== null ? output.OwnerType : undefined,
    ResourceUris:
      output.ResourceUris !== undefined && output.ResourceUris !== null
        ? deserializeAws_json1_1ResourceUriList(output.ResourceUris, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1UserDefinedFunctionList = (output: any, context: __SerdeContext): UserDefinedFunction[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1UserDefinedFunction(entry, context));
};

const deserializeAws_json1_1ValidationException = (output: any, context: __SerdeContext): ValidationException => {
  return {
    __type: "ValidationException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1ValueStringList = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1VersionMismatchException = (
  output: any,
  context: __SerdeContext
): VersionMismatchException => {
  return {
    __type: "VersionMismatchException",
    Message: output.Message !== undefined && output.Message !== null ? output.Message : undefined,
  } as any;
};

const deserializeAws_json1_1Workflow = (output: any, context: __SerdeContext): Workflow => {
  return {
    __type: "Workflow",
    CreatedOn:
      output.CreatedOn !== undefined && output.CreatedOn !== null
        ? new Date(Math.round(output.CreatedOn * 1000))
        : undefined,
    DefaultRunProperties:
      output.DefaultRunProperties !== undefined && output.DefaultRunProperties !== null
        ? deserializeAws_json1_1WorkflowRunProperties(output.DefaultRunProperties, context)
        : undefined,
    Description: output.Description !== undefined && output.Description !== null ? output.Description : undefined,
    Graph:
      output.Graph !== undefined && output.Graph !== null
        ? deserializeAws_json1_1WorkflowGraph(output.Graph, context)
        : undefined,
    LastModifiedOn:
      output.LastModifiedOn !== undefined && output.LastModifiedOn !== null
        ? new Date(Math.round(output.LastModifiedOn * 1000))
        : undefined,
    LastRun:
      output.LastRun !== undefined && output.LastRun !== null
        ? deserializeAws_json1_1WorkflowRun(output.LastRun, context)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1WorkflowGraph = (output: any, context: __SerdeContext): WorkflowGraph => {
  return {
    __type: "WorkflowGraph",
    Edges:
      output.Edges !== undefined && output.Edges !== null
        ? deserializeAws_json1_1EdgeList(output.Edges, context)
        : undefined,
    Nodes:
      output.Nodes !== undefined && output.Nodes !== null
        ? deserializeAws_json1_1NodeList(output.Nodes, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1WorkflowNames = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1WorkflowRun = (output: any, context: __SerdeContext): WorkflowRun => {
  return {
    __type: "WorkflowRun",
    CompletedOn:
      output.CompletedOn !== undefined && output.CompletedOn !== null
        ? new Date(Math.round(output.CompletedOn * 1000))
        : undefined,
    Graph:
      output.Graph !== undefined && output.Graph !== null
        ? deserializeAws_json1_1WorkflowGraph(output.Graph, context)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    StartedOn:
      output.StartedOn !== undefined && output.StartedOn !== null
        ? new Date(Math.round(output.StartedOn * 1000))
        : undefined,
    Statistics:
      output.Statistics !== undefined && output.Statistics !== null
        ? deserializeAws_json1_1WorkflowRunStatistics(output.Statistics, context)
        : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    WorkflowRunId:
      output.WorkflowRunId !== undefined && output.WorkflowRunId !== null ? output.WorkflowRunId : undefined,
    WorkflowRunProperties:
      output.WorkflowRunProperties !== undefined && output.WorkflowRunProperties !== null
        ? deserializeAws_json1_1WorkflowRunProperties(output.WorkflowRunProperties, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1WorkflowRunProperties = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value,
    }),
    {}
  );
};

const deserializeAws_json1_1WorkflowRuns = (output: any, context: __SerdeContext): WorkflowRun[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1WorkflowRun(entry, context));
};

const deserializeAws_json1_1WorkflowRunStatistics = (output: any, context: __SerdeContext): WorkflowRunStatistics => {
  return {
    __type: "WorkflowRunStatistics",
    FailedActions:
      output.FailedActions !== undefined && output.FailedActions !== null ? output.FailedActions : undefined,
    RunningActions:
      output.RunningActions !== undefined && output.RunningActions !== null ? output.RunningActions : undefined,
    StoppedActions:
      output.StoppedActions !== undefined && output.StoppedActions !== null ? output.StoppedActions : undefined,
    SucceededActions:
      output.SucceededActions !== undefined && output.SucceededActions !== null ? output.SucceededActions : undefined,
    TimeoutActions:
      output.TimeoutActions !== undefined && output.TimeoutActions !== null ? output.TimeoutActions : undefined,
    TotalActions: output.TotalActions !== undefined && output.TotalActions !== null ? output.TotalActions : undefined,
  } as any;
};

const deserializeAws_json1_1Workflows = (output: any, context: __SerdeContext): Workflow[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Workflow(entry, context));
};

const deserializeAws_json1_1XMLClassifier = (output: any, context: __SerdeContext): XMLClassifier => {
  return {
    __type: "XMLClassifier",
    Classification:
      output.Classification !== undefined && output.Classification !== null ? output.Classification : undefined,
    CreationTime:
      output.CreationTime !== undefined && output.CreationTime !== null
        ? new Date(Math.round(output.CreationTime * 1000))
        : undefined,
    LastUpdated:
      output.LastUpdated !== undefined && output.LastUpdated !== null
        ? new Date(Math.round(output.LastUpdated * 1000))
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RowTag: output.RowTag !== undefined && output.RowTag !== null ? output.RowTag : undefined,
    Version: output.Version !== undefined && output.Version !== null ? output.Version : undefined,
  } as any;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"],
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody: any = new Uint8Array(), context: __SerdeContext): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody: any, context: __SerdeContext): Promise<string> =>
  collectBody(streamBody, context).then((body) => context.utf8Encoder(body));

const buildHttpRpcRequest = async (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port } = await context.endpoint();
  const contents: any = {
    protocol,
    hostname,
    port,
    method: "POST",
    path,
    headers,
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
