import {
  BatchCreatePartitionCommandInput,
  BatchCreatePartitionCommandOutput
} from "../commands/BatchCreatePartitionCommand";
import {
  BatchDeleteConnectionCommandInput,
  BatchDeleteConnectionCommandOutput
} from "../commands/BatchDeleteConnectionCommand";
import {
  BatchDeletePartitionCommandInput,
  BatchDeletePartitionCommandOutput
} from "../commands/BatchDeletePartitionCommand";
import {
  BatchDeleteTableCommandInput,
  BatchDeleteTableCommandOutput
} from "../commands/BatchDeleteTableCommand";
import {
  BatchDeleteTableVersionCommandInput,
  BatchDeleteTableVersionCommandOutput
} from "../commands/BatchDeleteTableVersionCommand";
import {
  BatchGetCrawlersCommandInput,
  BatchGetCrawlersCommandOutput
} from "../commands/BatchGetCrawlersCommand";
import {
  BatchGetDevEndpointsCommandInput,
  BatchGetDevEndpointsCommandOutput
} from "../commands/BatchGetDevEndpointsCommand";
import {
  BatchGetJobsCommandInput,
  BatchGetJobsCommandOutput
} from "../commands/BatchGetJobsCommand";
import {
  BatchGetPartitionCommandInput,
  BatchGetPartitionCommandOutput
} from "../commands/BatchGetPartitionCommand";
import {
  BatchGetTriggersCommandInput,
  BatchGetTriggersCommandOutput
} from "../commands/BatchGetTriggersCommand";
import {
  BatchGetWorkflowsCommandInput,
  BatchGetWorkflowsCommandOutput
} from "../commands/BatchGetWorkflowsCommand";
import {
  BatchStopJobRunCommandInput,
  BatchStopJobRunCommandOutput
} from "../commands/BatchStopJobRunCommand";
import {
  CancelMLTaskRunCommandInput,
  CancelMLTaskRunCommandOutput
} from "../commands/CancelMLTaskRunCommand";
import {
  CreateClassifierCommandInput,
  CreateClassifierCommandOutput
} from "../commands/CreateClassifierCommand";
import {
  CreateConnectionCommandInput,
  CreateConnectionCommandOutput
} from "../commands/CreateConnectionCommand";
import {
  CreateCrawlerCommandInput,
  CreateCrawlerCommandOutput
} from "../commands/CreateCrawlerCommand";
import {
  CreateDatabaseCommandInput,
  CreateDatabaseCommandOutput
} from "../commands/CreateDatabaseCommand";
import {
  CreateDevEndpointCommandInput,
  CreateDevEndpointCommandOutput
} from "../commands/CreateDevEndpointCommand";
import {
  CreateJobCommandInput,
  CreateJobCommandOutput
} from "../commands/CreateJobCommand";
import {
  CreateMLTransformCommandInput,
  CreateMLTransformCommandOutput
} from "../commands/CreateMLTransformCommand";
import {
  CreatePartitionCommandInput,
  CreatePartitionCommandOutput
} from "../commands/CreatePartitionCommand";
import {
  CreateScriptCommandInput,
  CreateScriptCommandOutput
} from "../commands/CreateScriptCommand";
import {
  CreateSecurityConfigurationCommandInput,
  CreateSecurityConfigurationCommandOutput
} from "../commands/CreateSecurityConfigurationCommand";
import {
  CreateTableCommandInput,
  CreateTableCommandOutput
} from "../commands/CreateTableCommand";
import {
  CreateTriggerCommandInput,
  CreateTriggerCommandOutput
} from "../commands/CreateTriggerCommand";
import {
  CreateUserDefinedFunctionCommandInput,
  CreateUserDefinedFunctionCommandOutput
} from "../commands/CreateUserDefinedFunctionCommand";
import {
  CreateWorkflowCommandInput,
  CreateWorkflowCommandOutput
} from "../commands/CreateWorkflowCommand";
import {
  DeleteClassifierCommandInput,
  DeleteClassifierCommandOutput
} from "../commands/DeleteClassifierCommand";
import {
  DeleteConnectionCommandInput,
  DeleteConnectionCommandOutput
} from "../commands/DeleteConnectionCommand";
import {
  DeleteCrawlerCommandInput,
  DeleteCrawlerCommandOutput
} from "../commands/DeleteCrawlerCommand";
import {
  DeleteDatabaseCommandInput,
  DeleteDatabaseCommandOutput
} from "../commands/DeleteDatabaseCommand";
import {
  DeleteDevEndpointCommandInput,
  DeleteDevEndpointCommandOutput
} from "../commands/DeleteDevEndpointCommand";
import {
  DeleteJobCommandInput,
  DeleteJobCommandOutput
} from "../commands/DeleteJobCommand";
import {
  DeleteMLTransformCommandInput,
  DeleteMLTransformCommandOutput
} from "../commands/DeleteMLTransformCommand";
import {
  DeletePartitionCommandInput,
  DeletePartitionCommandOutput
} from "../commands/DeletePartitionCommand";
import {
  DeleteResourcePolicyCommandInput,
  DeleteResourcePolicyCommandOutput
} from "../commands/DeleteResourcePolicyCommand";
import {
  DeleteSecurityConfigurationCommandInput,
  DeleteSecurityConfigurationCommandOutput
} from "../commands/DeleteSecurityConfigurationCommand";
import {
  DeleteTableCommandInput,
  DeleteTableCommandOutput
} from "../commands/DeleteTableCommand";
import {
  DeleteTableVersionCommandInput,
  DeleteTableVersionCommandOutput
} from "../commands/DeleteTableVersionCommand";
import {
  DeleteTriggerCommandInput,
  DeleteTriggerCommandOutput
} from "../commands/DeleteTriggerCommand";
import {
  DeleteUserDefinedFunctionCommandInput,
  DeleteUserDefinedFunctionCommandOutput
} from "../commands/DeleteUserDefinedFunctionCommand";
import {
  DeleteWorkflowCommandInput,
  DeleteWorkflowCommandOutput
} from "../commands/DeleteWorkflowCommand";
import {
  GetCatalogImportStatusCommandInput,
  GetCatalogImportStatusCommandOutput
} from "../commands/GetCatalogImportStatusCommand";
import {
  GetClassifierCommandInput,
  GetClassifierCommandOutput
} from "../commands/GetClassifierCommand";
import {
  GetClassifiersCommandInput,
  GetClassifiersCommandOutput
} from "../commands/GetClassifiersCommand";
import {
  GetConnectionCommandInput,
  GetConnectionCommandOutput
} from "../commands/GetConnectionCommand";
import {
  GetConnectionsCommandInput,
  GetConnectionsCommandOutput
} from "../commands/GetConnectionsCommand";
import {
  GetCrawlerCommandInput,
  GetCrawlerCommandOutput
} from "../commands/GetCrawlerCommand";
import {
  GetCrawlerMetricsCommandInput,
  GetCrawlerMetricsCommandOutput
} from "../commands/GetCrawlerMetricsCommand";
import {
  GetCrawlersCommandInput,
  GetCrawlersCommandOutput
} from "../commands/GetCrawlersCommand";
import {
  GetDataCatalogEncryptionSettingsCommandInput,
  GetDataCatalogEncryptionSettingsCommandOutput
} from "../commands/GetDataCatalogEncryptionSettingsCommand";
import {
  GetDatabaseCommandInput,
  GetDatabaseCommandOutput
} from "../commands/GetDatabaseCommand";
import {
  GetDatabasesCommandInput,
  GetDatabasesCommandOutput
} from "../commands/GetDatabasesCommand";
import {
  GetDataflowGraphCommandInput,
  GetDataflowGraphCommandOutput
} from "../commands/GetDataflowGraphCommand";
import {
  GetDevEndpointCommandInput,
  GetDevEndpointCommandOutput
} from "../commands/GetDevEndpointCommand";
import {
  GetDevEndpointsCommandInput,
  GetDevEndpointsCommandOutput
} from "../commands/GetDevEndpointsCommand";
import {
  GetJobBookmarkCommandInput,
  GetJobBookmarkCommandOutput
} from "../commands/GetJobBookmarkCommand";
import {
  GetJobCommandInput,
  GetJobCommandOutput
} from "../commands/GetJobCommand";
import {
  GetJobRunCommandInput,
  GetJobRunCommandOutput
} from "../commands/GetJobRunCommand";
import {
  GetJobRunsCommandInput,
  GetJobRunsCommandOutput
} from "../commands/GetJobRunsCommand";
import {
  GetJobsCommandInput,
  GetJobsCommandOutput
} from "../commands/GetJobsCommand";
import {
  GetMLTaskRunCommandInput,
  GetMLTaskRunCommandOutput
} from "../commands/GetMLTaskRunCommand";
import {
  GetMLTaskRunsCommandInput,
  GetMLTaskRunsCommandOutput
} from "../commands/GetMLTaskRunsCommand";
import {
  GetMLTransformCommandInput,
  GetMLTransformCommandOutput
} from "../commands/GetMLTransformCommand";
import {
  GetMLTransformsCommandInput,
  GetMLTransformsCommandOutput
} from "../commands/GetMLTransformsCommand";
import {
  GetMappingCommandInput,
  GetMappingCommandOutput
} from "../commands/GetMappingCommand";
import {
  GetPartitionCommandInput,
  GetPartitionCommandOutput
} from "../commands/GetPartitionCommand";
import {
  GetPartitionsCommandInput,
  GetPartitionsCommandOutput
} from "../commands/GetPartitionsCommand";
import {
  GetPlanCommandInput,
  GetPlanCommandOutput
} from "../commands/GetPlanCommand";
import {
  GetResourcePolicyCommandInput,
  GetResourcePolicyCommandOutput
} from "../commands/GetResourcePolicyCommand";
import {
  GetSecurityConfigurationCommandInput,
  GetSecurityConfigurationCommandOutput
} from "../commands/GetSecurityConfigurationCommand";
import {
  GetSecurityConfigurationsCommandInput,
  GetSecurityConfigurationsCommandOutput
} from "../commands/GetSecurityConfigurationsCommand";
import {
  GetTableCommandInput,
  GetTableCommandOutput
} from "../commands/GetTableCommand";
import {
  GetTableVersionCommandInput,
  GetTableVersionCommandOutput
} from "../commands/GetTableVersionCommand";
import {
  GetTableVersionsCommandInput,
  GetTableVersionsCommandOutput
} from "../commands/GetTableVersionsCommand";
import {
  GetTablesCommandInput,
  GetTablesCommandOutput
} from "../commands/GetTablesCommand";
import {
  GetTagsCommandInput,
  GetTagsCommandOutput
} from "../commands/GetTagsCommand";
import {
  GetTriggerCommandInput,
  GetTriggerCommandOutput
} from "../commands/GetTriggerCommand";
import {
  GetTriggersCommandInput,
  GetTriggersCommandOutput
} from "../commands/GetTriggersCommand";
import {
  GetUserDefinedFunctionCommandInput,
  GetUserDefinedFunctionCommandOutput
} from "../commands/GetUserDefinedFunctionCommand";
import {
  GetUserDefinedFunctionsCommandInput,
  GetUserDefinedFunctionsCommandOutput
} from "../commands/GetUserDefinedFunctionsCommand";
import {
  GetWorkflowCommandInput,
  GetWorkflowCommandOutput
} from "../commands/GetWorkflowCommand";
import {
  GetWorkflowRunCommandInput,
  GetWorkflowRunCommandOutput
} from "../commands/GetWorkflowRunCommand";
import {
  GetWorkflowRunPropertiesCommandInput,
  GetWorkflowRunPropertiesCommandOutput
} from "../commands/GetWorkflowRunPropertiesCommand";
import {
  GetWorkflowRunsCommandInput,
  GetWorkflowRunsCommandOutput
} from "../commands/GetWorkflowRunsCommand";
import {
  ImportCatalogToGlueCommandInput,
  ImportCatalogToGlueCommandOutput
} from "../commands/ImportCatalogToGlueCommand";
import {
  ListCrawlersCommandInput,
  ListCrawlersCommandOutput
} from "../commands/ListCrawlersCommand";
import {
  ListDevEndpointsCommandInput,
  ListDevEndpointsCommandOutput
} from "../commands/ListDevEndpointsCommand";
import {
  ListJobsCommandInput,
  ListJobsCommandOutput
} from "../commands/ListJobsCommand";
import {
  ListTriggersCommandInput,
  ListTriggersCommandOutput
} from "../commands/ListTriggersCommand";
import {
  ListWorkflowsCommandInput,
  ListWorkflowsCommandOutput
} from "../commands/ListWorkflowsCommand";
import {
  PutDataCatalogEncryptionSettingsCommandInput,
  PutDataCatalogEncryptionSettingsCommandOutput
} from "../commands/PutDataCatalogEncryptionSettingsCommand";
import {
  PutResourcePolicyCommandInput,
  PutResourcePolicyCommandOutput
} from "../commands/PutResourcePolicyCommand";
import {
  PutWorkflowRunPropertiesCommandInput,
  PutWorkflowRunPropertiesCommandOutput
} from "../commands/PutWorkflowRunPropertiesCommand";
import {
  ResetJobBookmarkCommandInput,
  ResetJobBookmarkCommandOutput
} from "../commands/ResetJobBookmarkCommand";
import {
  SearchTablesCommandInput,
  SearchTablesCommandOutput
} from "../commands/SearchTablesCommand";
import {
  StartCrawlerCommandInput,
  StartCrawlerCommandOutput
} from "../commands/StartCrawlerCommand";
import {
  StartCrawlerScheduleCommandInput,
  StartCrawlerScheduleCommandOutput
} from "../commands/StartCrawlerScheduleCommand";
import {
  StartExportLabelsTaskRunCommandInput,
  StartExportLabelsTaskRunCommandOutput
} from "../commands/StartExportLabelsTaskRunCommand";
import {
  StartImportLabelsTaskRunCommandInput,
  StartImportLabelsTaskRunCommandOutput
} from "../commands/StartImportLabelsTaskRunCommand";
import {
  StartJobRunCommandInput,
  StartJobRunCommandOutput
} from "../commands/StartJobRunCommand";
import {
  StartMLEvaluationTaskRunCommandInput,
  StartMLEvaluationTaskRunCommandOutput
} from "../commands/StartMLEvaluationTaskRunCommand";
import {
  StartMLLabelingSetGenerationTaskRunCommandInput,
  StartMLLabelingSetGenerationTaskRunCommandOutput
} from "../commands/StartMLLabelingSetGenerationTaskRunCommand";
import {
  StartTriggerCommandInput,
  StartTriggerCommandOutput
} from "../commands/StartTriggerCommand";
import {
  StartWorkflowRunCommandInput,
  StartWorkflowRunCommandOutput
} from "../commands/StartWorkflowRunCommand";
import {
  StopCrawlerCommandInput,
  StopCrawlerCommandOutput
} from "../commands/StopCrawlerCommand";
import {
  StopCrawlerScheduleCommandInput,
  StopCrawlerScheduleCommandOutput
} from "../commands/StopCrawlerScheduleCommand";
import {
  StopTriggerCommandInput,
  StopTriggerCommandOutput
} from "../commands/StopTriggerCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateClassifierCommandInput,
  UpdateClassifierCommandOutput
} from "../commands/UpdateClassifierCommand";
import {
  UpdateConnectionCommandInput,
  UpdateConnectionCommandOutput
} from "../commands/UpdateConnectionCommand";
import {
  UpdateCrawlerCommandInput,
  UpdateCrawlerCommandOutput
} from "../commands/UpdateCrawlerCommand";
import {
  UpdateCrawlerScheduleCommandInput,
  UpdateCrawlerScheduleCommandOutput
} from "../commands/UpdateCrawlerScheduleCommand";
import {
  UpdateDatabaseCommandInput,
  UpdateDatabaseCommandOutput
} from "../commands/UpdateDatabaseCommand";
import {
  UpdateDevEndpointCommandInput,
  UpdateDevEndpointCommandOutput
} from "../commands/UpdateDevEndpointCommand";
import {
  UpdateJobCommandInput,
  UpdateJobCommandOutput
} from "../commands/UpdateJobCommand";
import {
  UpdateMLTransformCommandInput,
  UpdateMLTransformCommandOutput
} from "../commands/UpdateMLTransformCommand";
import {
  UpdatePartitionCommandInput,
  UpdatePartitionCommandOutput
} from "../commands/UpdatePartitionCommand";
import {
  UpdateTableCommandInput,
  UpdateTableCommandOutput
} from "../commands/UpdateTableCommand";
import {
  UpdateTriggerCommandInput,
  UpdateTriggerCommandOutput
} from "../commands/UpdateTriggerCommand";
import {
  UpdateUserDefinedFunctionCommandInput,
  UpdateUserDefinedFunctionCommandOutput
} from "../commands/UpdateUserDefinedFunctionCommand";
import {
  UpdateWorkflowCommandInput,
  UpdateWorkflowCommandOutput
} from "../commands/UpdateWorkflowCommand";
import {
  AccessDeniedException,
  Action,
  AlreadyExistsException,
  BatchCreatePartitionRequest,
  BatchCreatePartitionResponse,
  BatchDeleteConnectionRequest,
  BatchDeleteConnectionResponse,
  BatchDeletePartitionRequest,
  BatchDeletePartitionResponse,
  BatchDeleteTableRequest,
  BatchDeleteTableResponse,
  BatchDeleteTableVersionRequest,
  BatchDeleteTableVersionResponse,
  BatchGetCrawlersRequest,
  BatchGetCrawlersResponse,
  BatchGetDevEndpointsRequest,
  BatchGetDevEndpointsResponse,
  BatchGetJobsRequest,
  BatchGetJobsResponse,
  BatchGetPartitionRequest,
  BatchGetPartitionResponse,
  BatchGetTriggersRequest,
  BatchGetTriggersResponse,
  BatchGetWorkflowsRequest,
  BatchGetWorkflowsResponse,
  BatchStopJobRunError,
  BatchStopJobRunRequest,
  BatchStopJobRunResponse,
  BatchStopJobRunSuccessfulSubmission,
  CancelMLTaskRunRequest,
  CancelMLTaskRunResponse,
  CatalogEntry,
  CatalogImportStatus,
  CatalogTarget,
  Classifier,
  CloudWatchEncryption,
  CodeGenEdge,
  CodeGenNode,
  CodeGenNodeArg,
  Column,
  ConcurrentModificationException,
  ConcurrentRunsExceededException,
  Condition,
  ConditionCheckFailureException,
  ConfusionMatrix,
  Connection,
  ConnectionInput,
  ConnectionPasswordEncryption,
  ConnectionsList,
  Crawl,
  Crawler,
  CrawlerMetrics,
  CrawlerNodeDetails,
  CrawlerNotRunningException,
  CrawlerRunningException,
  CrawlerStoppingException,
  CrawlerTargets,
  CreateClassifierRequest,
  CreateClassifierResponse,
  CreateConnectionRequest,
  CreateConnectionResponse,
  CreateCrawlerRequest,
  CreateCrawlerResponse,
  CreateCsvClassifierRequest,
  CreateDatabaseRequest,
  CreateDatabaseResponse,
  CreateDevEndpointRequest,
  CreateDevEndpointResponse,
  CreateGrokClassifierRequest,
  CreateJobRequest,
  CreateJobResponse,
  CreateJsonClassifierRequest,
  CreateMLTransformRequest,
  CreateMLTransformResponse,
  CreatePartitionRequest,
  CreatePartitionResponse,
  CreateScriptRequest,
  CreateScriptResponse,
  CreateSecurityConfigurationRequest,
  CreateSecurityConfigurationResponse,
  CreateTableRequest,
  CreateTableResponse,
  CreateTriggerRequest,
  CreateTriggerResponse,
  CreateUserDefinedFunctionRequest,
  CreateUserDefinedFunctionResponse,
  CreateWorkflowRequest,
  CreateWorkflowResponse,
  CreateXMLClassifierRequest,
  CsvClassifier,
  DataCatalogEncryptionSettings,
  DataLakePrincipal,
  Database,
  DatabaseInput,
  DeleteClassifierRequest,
  DeleteClassifierResponse,
  DeleteConnectionRequest,
  DeleteConnectionResponse,
  DeleteCrawlerRequest,
  DeleteCrawlerResponse,
  DeleteDatabaseRequest,
  DeleteDatabaseResponse,
  DeleteDevEndpointRequest,
  DeleteDevEndpointResponse,
  DeleteJobRequest,
  DeleteJobResponse,
  DeleteMLTransformRequest,
  DeleteMLTransformResponse,
  DeletePartitionRequest,
  DeletePartitionResponse,
  DeleteResourcePolicyRequest,
  DeleteResourcePolicyResponse,
  DeleteSecurityConfigurationRequest,
  DeleteSecurityConfigurationResponse,
  DeleteTableRequest,
  DeleteTableResponse,
  DeleteTableVersionRequest,
  DeleteTableVersionResponse,
  DeleteTriggerRequest,
  DeleteTriggerResponse,
  DeleteUserDefinedFunctionRequest,
  DeleteUserDefinedFunctionResponse,
  DeleteWorkflowRequest,
  DeleteWorkflowResponse,
  DevEndpoint,
  DevEndpointCustomLibraries,
  DynamoDBTarget,
  Edge,
  EncryptionAtRest,
  EncryptionConfiguration,
  EntityNotFoundException,
  ErrorDetail,
  EvaluationMetrics,
  ExecutionProperty,
  ExportLabelsTaskRunProperties,
  FindMatchesMetrics,
  FindMatchesParameters,
  FindMatchesTaskRunProperties,
  GetCatalogImportStatusRequest,
  GetCatalogImportStatusResponse,
  GetClassifierRequest,
  GetClassifierResponse,
  GetClassifiersRequest,
  GetClassifiersResponse,
  GetConnectionRequest,
  GetConnectionResponse,
  GetConnectionsFilter,
  GetConnectionsRequest,
  GetConnectionsResponse,
  GetCrawlerMetricsRequest,
  GetCrawlerMetricsResponse,
  GetCrawlerRequest,
  GetCrawlerResponse,
  GetCrawlersRequest,
  GetCrawlersResponse,
  GetDataCatalogEncryptionSettingsRequest,
  GetDataCatalogEncryptionSettingsResponse,
  GetDatabaseRequest,
  GetDatabaseResponse,
  GetDatabasesRequest,
  GetDatabasesResponse,
  GetDataflowGraphRequest,
  GetDataflowGraphResponse,
  GetDevEndpointRequest,
  GetDevEndpointResponse,
  GetDevEndpointsRequest,
  GetDevEndpointsResponse,
  GetJobBookmarkRequest,
  GetJobBookmarkResponse,
  GetJobRequest,
  GetJobResponse,
  GetJobRunRequest,
  GetJobRunResponse,
  GetJobRunsRequest,
  GetJobRunsResponse,
  GetJobsRequest,
  GetJobsResponse,
  GetMLTaskRunRequest,
  GetMLTaskRunResponse,
  GetMLTaskRunsRequest,
  GetMLTaskRunsResponse,
  GetMLTransformRequest,
  GetMLTransformResponse,
  GetMLTransformsRequest,
  GetMLTransformsResponse,
  GetMappingRequest,
  GetMappingResponse,
  GetPartitionRequest,
  GetPartitionResponse,
  GetPartitionsRequest,
  GetPartitionsResponse,
  GetPlanRequest,
  GetPlanResponse,
  GetResourcePolicyRequest,
  GetResourcePolicyResponse,
  GetSecurityConfigurationRequest,
  GetSecurityConfigurationResponse,
  GetSecurityConfigurationsRequest,
  GetSecurityConfigurationsResponse,
  GetTableRequest,
  GetTableResponse,
  GetTableVersionRequest,
  GetTableVersionResponse,
  GetTableVersionsRequest,
  GetTableVersionsResponse,
  GetTablesRequest,
  GetTablesResponse,
  GetTagsRequest,
  GetTagsResponse,
  GetTriggerRequest,
  GetTriggerResponse,
  GetTriggersRequest,
  GetTriggersResponse,
  GetUserDefinedFunctionRequest,
  GetUserDefinedFunctionResponse,
  GetUserDefinedFunctionsRequest,
  GetUserDefinedFunctionsResponse,
  GetWorkflowRequest,
  GetWorkflowResponse,
  GetWorkflowRunPropertiesRequest,
  GetWorkflowRunPropertiesResponse,
  GetWorkflowRunRequest,
  GetWorkflowRunResponse,
  GetWorkflowRunsRequest,
  GetWorkflowRunsResponse,
  GlueEncryptionException,
  GlueTable,
  GrokClassifier,
  IdempotentParameterMismatchException,
  ImportCatalogToGlueRequest,
  ImportCatalogToGlueResponse,
  ImportLabelsTaskRunProperties,
  InternalServiceException,
  InvalidInputException,
  JdbcTarget,
  Job,
  JobBookmarkEntry,
  JobBookmarksEncryption,
  JobCommand,
  JobNodeDetails,
  JobRun,
  JobUpdate,
  JsonClassifier,
  LabelingSetGenerationTaskRunProperties,
  LastCrawlInfo,
  ListCrawlersRequest,
  ListCrawlersResponse,
  ListDevEndpointsRequest,
  ListDevEndpointsResponse,
  ListJobsRequest,
  ListJobsResponse,
  ListTriggersRequest,
  ListTriggersResponse,
  ListWorkflowsRequest,
  ListWorkflowsResponse,
  Location,
  MLTransform,
  MLTransformNotReadyException,
  MappingEntry,
  NoScheduleException,
  Node,
  NotificationProperty,
  OperationTimeoutException,
  Order,
  Partition,
  PartitionError,
  PartitionInput,
  PartitionValueList,
  Permission,
  PhysicalConnectionRequirements,
  Predecessor,
  Predicate,
  PrincipalPermissions,
  PropertyPredicate,
  PutDataCatalogEncryptionSettingsRequest,
  PutDataCatalogEncryptionSettingsResponse,
  PutResourcePolicyRequest,
  PutResourcePolicyResponse,
  PutWorkflowRunPropertiesRequest,
  PutWorkflowRunPropertiesResponse,
  ResetJobBookmarkRequest,
  ResetJobBookmarkResponse,
  ResourceNumberLimitExceededException,
  ResourceUri,
  S3Encryption,
  S3Target,
  Schedule,
  SchedulerNotRunningException,
  SchedulerRunningException,
  SchedulerTransitioningException,
  SchemaChangePolicy,
  SchemaColumn,
  SearchTablesRequest,
  SearchTablesResponse,
  SecurityConfiguration,
  Segment,
  SerDeInfo,
  SkewedInfo,
  SortCriterion,
  StartCrawlerRequest,
  StartCrawlerResponse,
  StartCrawlerScheduleRequest,
  StartCrawlerScheduleResponse,
  StartExportLabelsTaskRunRequest,
  StartExportLabelsTaskRunResponse,
  StartImportLabelsTaskRunRequest,
  StartImportLabelsTaskRunResponse,
  StartJobRunRequest,
  StartJobRunResponse,
  StartMLEvaluationTaskRunRequest,
  StartMLEvaluationTaskRunResponse,
  StartMLLabelingSetGenerationTaskRunRequest,
  StartMLLabelingSetGenerationTaskRunResponse,
  StartTriggerRequest,
  StartTriggerResponse,
  StartWorkflowRunRequest,
  StartWorkflowRunResponse,
  StopCrawlerRequest,
  StopCrawlerResponse,
  StopCrawlerScheduleRequest,
  StopCrawlerScheduleResponse,
  StopTriggerRequest,
  StopTriggerResponse,
  StorageDescriptor,
  Table,
  TableError,
  TableInput,
  TableVersion,
  TableVersionError,
  TagResourceRequest,
  TagResourceResponse,
  TaskRun,
  TaskRunFilterCriteria,
  TaskRunProperties,
  TaskRunSortCriteria,
  TransformFilterCriteria,
  TransformParameters,
  TransformSortCriteria,
  Trigger,
  TriggerNodeDetails,
  TriggerUpdate,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateClassifierRequest,
  UpdateClassifierResponse,
  UpdateConnectionRequest,
  UpdateConnectionResponse,
  UpdateCrawlerRequest,
  UpdateCrawlerResponse,
  UpdateCrawlerScheduleRequest,
  UpdateCrawlerScheduleResponse,
  UpdateCsvClassifierRequest,
  UpdateDatabaseRequest,
  UpdateDatabaseResponse,
  UpdateDevEndpointRequest,
  UpdateDevEndpointResponse,
  UpdateGrokClassifierRequest,
  UpdateJobRequest,
  UpdateJobResponse,
  UpdateJsonClassifierRequest,
  UpdateMLTransformRequest,
  UpdateMLTransformResponse,
  UpdatePartitionRequest,
  UpdatePartitionResponse,
  UpdateTableRequest,
  UpdateTableResponse,
  UpdateTriggerRequest,
  UpdateTriggerResponse,
  UpdateUserDefinedFunctionRequest,
  UpdateUserDefinedFunctionResponse,
  UpdateWorkflowRequest,
  UpdateWorkflowResponse,
  UpdateXMLClassifierRequest,
  UserDefinedFunction,
  UserDefinedFunctionInput,
  ValidationException,
  VersionMismatchException,
  Workflow,
  WorkflowGraph,
  WorkflowRun,
  WorkflowRunStatistics,
  XMLClassifier
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_json1_1GetTagsCommand(
  input: GetTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetTags";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTagsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.TagResource";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UntagResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UntagResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchCreatePartitionCommand(
  input: BatchCreatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchCreatePartition";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchCreatePartitionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDeleteConnectionCommand(
  input: BatchDeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchDeleteConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDeleteConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDeletePartitionCommand(
  input: BatchDeletePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchDeletePartition";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDeletePartitionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDeleteTableCommand(
  input: BatchDeleteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchDeleteTable";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDeleteTableRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDeleteTableVersionCommand(
  input: BatchDeleteTableVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchDeleteTableVersion";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDeleteTableVersionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchGetPartitionCommand(
  input: BatchGetPartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchGetPartition";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchGetPartitionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateConnectionCommand(
  input: CreateConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateDatabaseCommand(
  input: CreateDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateDatabase";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateDatabaseRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreatePartitionCommand(
  input: CreatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreatePartition";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreatePartitionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateTableCommand(
  input: CreateTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateTable";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateUserDefinedFunctionCommand(
  input: CreateUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateUserDefinedFunction";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateUserDefinedFunctionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteConnectionCommand(
  input: DeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDatabaseCommand(
  input: DeleteDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteDatabase";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDatabaseRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeletePartitionCommand(
  input: DeletePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeletePartition";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeletePartitionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteResourcePolicyCommand(
  input: DeleteResourcePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteResourcePolicy";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteResourcePolicyRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteTableCommand(
  input: DeleteTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteTable";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteTableVersionCommand(
  input: DeleteTableVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteTableVersion";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteTableVersionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteUserDefinedFunctionCommand(
  input: DeleteUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteUserDefinedFunction";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteUserDefinedFunctionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCatalogImportStatusCommand(
  input: GetCatalogImportStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetCatalogImportStatus";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetCatalogImportStatusRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetConnectionCommand(
  input: GetConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetConnectionsCommand(
  input: GetConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetConnections";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetConnectionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDataCatalogEncryptionSettingsCommand(
  input: GetDataCatalogEncryptionSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetDataCatalogEncryptionSettings";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetDataCatalogEncryptionSettingsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDatabaseCommand(
  input: GetDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetDatabase";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetDatabaseRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDatabasesCommand(
  input: GetDatabasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetDatabases";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetDatabasesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetPartitionCommand(
  input: GetPartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetPartition";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetPartitionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetPartitionsCommand(
  input: GetPartitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetPartitions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetPartitionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetResourcePolicyCommand(
  input: GetResourcePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetResourcePolicy";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetResourcePolicyRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetTableCommand(
  input: GetTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetTable";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetTableVersionCommand(
  input: GetTableVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetTableVersion";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetTableVersionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetTableVersionsCommand(
  input: GetTableVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetTableVersions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetTableVersionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetTablesCommand(
  input: GetTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetTables";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTablesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetUserDefinedFunctionCommand(
  input: GetUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetUserDefinedFunction";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetUserDefinedFunctionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetUserDefinedFunctionsCommand(
  input: GetUserDefinedFunctionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetUserDefinedFunctions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetUserDefinedFunctionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ImportCatalogToGlueCommand(
  input: ImportCatalogToGlueCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.ImportCatalogToGlue";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ImportCatalogToGlueRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutDataCatalogEncryptionSettingsCommand(
  input: PutDataCatalogEncryptionSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.PutDataCatalogEncryptionSettings";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutDataCatalogEncryptionSettingsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutResourcePolicyCommand(
  input: PutResourcePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.PutResourcePolicy";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutResourcePolicyRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchTablesCommand(
  input: SearchTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.SearchTables";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SearchTablesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateConnectionCommand(
  input: UpdateConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateDatabaseCommand(
  input: UpdateDatabaseCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateDatabase";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateDatabaseRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdatePartitionCommand(
  input: UpdatePartitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdatePartition";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdatePartitionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateTableCommand(
  input: UpdateTableCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateTable";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateTableRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateUserDefinedFunctionCommand(
  input: UpdateUserDefinedFunctionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateUserDefinedFunction";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateUserDefinedFunctionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchGetDevEndpointsCommand(
  input: BatchGetDevEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchGetDevEndpoints";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchGetDevEndpointsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateDevEndpointCommand(
  input: CreateDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateDevEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateDevEndpointRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateSecurityConfigurationCommand(
  input: CreateSecurityConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateSecurityConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateSecurityConfigurationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDevEndpointCommand(
  input: DeleteDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteDevEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDevEndpointRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteSecurityConfigurationCommand(
  input: DeleteSecurityConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteSecurityConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteSecurityConfigurationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDevEndpointCommand(
  input: GetDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetDevEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetDevEndpointRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDevEndpointsCommand(
  input: GetDevEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetDevEndpoints";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetDevEndpointsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetJobBookmarkCommand(
  input: GetJobBookmarkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetJobBookmark";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetJobBookmarkRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetSecurityConfigurationCommand(
  input: GetSecurityConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetSecurityConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetSecurityConfigurationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetSecurityConfigurationsCommand(
  input: GetSecurityConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetSecurityConfigurations";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetSecurityConfigurationsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListDevEndpointsCommand(
  input: ListDevEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.ListDevEndpoints";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListDevEndpointsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ResetJobBookmarkCommand(
  input: ResetJobBookmarkCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.ResetJobBookmark";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ResetJobBookmarkRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateDevEndpointCommand(
  input: UpdateDevEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateDevEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateDevEndpointRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CancelMLTaskRunCommand(
  input: CancelMLTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CancelMLTaskRun";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CancelMLTaskRunRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateMLTransformCommand(
  input: CreateMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateMLTransform";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateMLTransformRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteMLTransformCommand(
  input: DeleteMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteMLTransform";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteMLTransformRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMLTaskRunCommand(
  input: GetMLTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetMLTaskRun";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMLTaskRunRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMLTaskRunsCommand(
  input: GetMLTaskRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetMLTaskRuns";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMLTaskRunsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMLTransformCommand(
  input: GetMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetMLTransform";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMLTransformRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMLTransformsCommand(
  input: GetMLTransformsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetMLTransforms";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMLTransformsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartExportLabelsTaskRunCommand(
  input: StartExportLabelsTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StartExportLabelsTaskRun";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartExportLabelsTaskRunRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartImportLabelsTaskRunCommand(
  input: StartImportLabelsTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StartImportLabelsTaskRun";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartImportLabelsTaskRunRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartMLEvaluationTaskRunCommand(
  input: StartMLEvaluationTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StartMLEvaluationTaskRun";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartMLEvaluationTaskRunRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommand(
  input: StartMLLabelingSetGenerationTaskRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StartMLLabelingSetGenerationTaskRun";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartMLLabelingSetGenerationTaskRunRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateMLTransformCommand(
  input: UpdateMLTransformCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateMLTransform";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateMLTransformRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchGetJobsCommand(
  input: BatchGetJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchGetJobs";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchGetJobsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchGetTriggersCommand(
  input: BatchGetTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchGetTriggers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchGetTriggersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchGetWorkflowsCommand(
  input: BatchGetWorkflowsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchGetWorkflows";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchGetWorkflowsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchStopJobRunCommand(
  input: BatchStopJobRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchStopJobRun";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchStopJobRunRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateJobCommand(
  input: CreateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateJob";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateTriggerCommand(
  input: CreateTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateTrigger";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateTriggerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateWorkflowCommand(
  input: CreateWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateWorkflow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateWorkflowRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteJobCommand(
  input: DeleteJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteJob";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteTriggerCommand(
  input: DeleteTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteTrigger";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteTriggerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteWorkflowCommand(
  input: DeleteWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteWorkflow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteWorkflowRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetJobCommand(
  input: GetJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetJob";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetJobRunCommand(
  input: GetJobRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetJobRun";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetJobRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetJobRunsCommand(
  input: GetJobRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetJobRuns";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetJobRunsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetJobsCommand(
  input: GetJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetJobs";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetJobsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetTriggerCommand(
  input: GetTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetTrigger";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetTriggersCommand(
  input: GetTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetTriggers";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetTriggersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetWorkflowCommand(
  input: GetWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetWorkflow";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetWorkflowRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetWorkflowRunCommand(
  input: GetWorkflowRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetWorkflowRun";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetWorkflowRunRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetWorkflowRunPropertiesCommand(
  input: GetWorkflowRunPropertiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetWorkflowRunProperties";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetWorkflowRunPropertiesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetWorkflowRunsCommand(
  input: GetWorkflowRunsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetWorkflowRuns";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetWorkflowRunsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListJobsCommand(
  input: ListJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.ListJobs";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListJobsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListTriggersCommand(
  input: ListTriggersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.ListTriggers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListTriggersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListWorkflowsCommand(
  input: ListWorkflowsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.ListWorkflows";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListWorkflowsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutWorkflowRunPropertiesCommand(
  input: PutWorkflowRunPropertiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.PutWorkflowRunProperties";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutWorkflowRunPropertiesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartJobRunCommand(
  input: StartJobRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StartJobRun";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartJobRunRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartTriggerCommand(
  input: StartTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StartTrigger";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartTriggerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartWorkflowRunCommand(
  input: StartWorkflowRunCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StartWorkflowRun";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartWorkflowRunRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopTriggerCommand(
  input: StopTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StopTrigger";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StopTriggerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateJobCommand(
  input: UpdateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateJob";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateJobRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateTriggerCommand(
  input: UpdateTriggerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateTrigger";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateTriggerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateWorkflowCommand(
  input: UpdateWorkflowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateWorkflow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateWorkflowRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchGetCrawlersCommand(
  input: BatchGetCrawlersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.BatchGetCrawlers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchGetCrawlersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateClassifierCommand(
  input: CreateClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateClassifier";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateClassifierRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateCrawlerCommand(
  input: CreateCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateCrawler";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateCrawlerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateScriptCommand(
  input: CreateScriptCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.CreateScript";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateScriptRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteClassifierCommand(
  input: DeleteClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteClassifier";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteClassifierRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteCrawlerCommand(
  input: DeleteCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.DeleteCrawler";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteCrawlerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetClassifierCommand(
  input: GetClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetClassifier";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetClassifierRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetClassifiersCommand(
  input: GetClassifiersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetClassifiers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetClassifiersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCrawlerCommand(
  input: GetCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetCrawler";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCrawlerMetricsCommand(
  input: GetCrawlerMetricsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetCrawlerMetrics";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetCrawlerMetricsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCrawlersCommand(
  input: GetCrawlersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetCrawlers";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetCrawlersRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDataflowGraphCommand(
  input: GetDataflowGraphCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetDataflowGraph";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetDataflowGraphRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMappingCommand(
  input: GetMappingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetMapping";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetMappingRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetPlanCommand(
  input: GetPlanCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.GetPlan";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetPlanRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListCrawlersCommand(
  input: ListCrawlersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.ListCrawlers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListCrawlersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartCrawlerCommand(
  input: StartCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StartCrawler";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartCrawlerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartCrawlerScheduleCommand(
  input: StartCrawlerScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StartCrawlerSchedule";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartCrawlerScheduleRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopCrawlerCommand(
  input: StopCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StopCrawler";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StopCrawlerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopCrawlerScheduleCommand(
  input: StopCrawlerScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.StopCrawlerSchedule";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopCrawlerScheduleRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateClassifierCommand(
  input: UpdateClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateClassifier";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateClassifierRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateCrawlerCommand(
  input: UpdateCrawlerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateCrawler";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateCrawlerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateCrawlerScheduleCommand(
  input: UpdateCrawlerScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSGlue.UpdateCrawlerSchedule";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateCrawlerScheduleRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_json1_1GetTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTagsResponse(data, context);
  const response: GetTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTagsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchCreatePartitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreatePartitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchCreatePartitionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchCreatePartitionResponse(data, context);
  const response: BatchCreatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchCreatePartitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchCreatePartitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreatePartitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDeleteConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDeleteConnectionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDeleteConnectionResponse(data, context);
  const response: BatchDeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeleteConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDeleteConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDeletePartitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeletePartitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDeletePartitionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDeletePartitionResponse(data, context);
  const response: BatchDeletePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeletePartitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDeletePartitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeletePartitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDeleteTableCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDeleteTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDeleteTableResponse(data, context);
  const response: BatchDeleteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeleteTableResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDeleteTableCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDeleteTableVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableVersionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDeleteTableVersionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDeleteTableVersionResponse(
    data,
    context
  );
  const response: BatchDeleteTableVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeleteTableVersionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDeleteTableVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeleteTableVersionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchGetPartitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetPartitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetPartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetPartitionResponse(data, context);
  const response: BatchGetPartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetPartitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchGetPartitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetPartitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateConnectionResponse(data, context);
  const response: CreateConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateDatabaseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDatabaseCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDatabaseResponse(data, context);
  const response: CreateDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDatabaseResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDatabaseCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDatabaseCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePartitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePartitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreatePartitionResponse(data, context);
  const response: CreatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePartitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePartitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePartitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateTableCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTableCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTableResponse(data, context);
  const response: CreateTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTableResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateTableCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTableCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateUserDefinedFunctionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserDefinedFunctionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateUserDefinedFunctionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateUserDefinedFunctionResponse(
    data,
    context
  );
  const response: CreateUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateUserDefinedFunctionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateUserDefinedFunctionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserDefinedFunctionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteConnectionResponse(data, context);
  const response: DeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDatabaseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDatabaseCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDatabaseResponse(data, context);
  const response: DeleteDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDatabaseResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDatabaseCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDatabaseCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeletePartitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePartitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeletePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeletePartitionResponse(data, context);
  const response: DeletePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeletePartitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeletePartitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePartitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteResourcePolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourcePolicyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteResourcePolicyCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteResourcePolicyResponse(data, context);
  const response: DeleteResourcePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteResourcePolicyResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteResourcePolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourcePolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConditionCheckFailureException":
    case "com.amazonaws.glue.common.exceptions#ConditionCheckFailureException":
      response = {
        ...(await deserializeAws_json1_1ConditionCheckFailureExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteTableCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTableResponse(data, context);
  const response: DeleteTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTableResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteTableCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteTableVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableVersionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTableVersionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTableVersionResponse(data, context);
  const response: DeleteTableVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTableVersionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteTableVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTableVersionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteUserDefinedFunctionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserDefinedFunctionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteUserDefinedFunctionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteUserDefinedFunctionResponse(
    data,
    context
  );
  const response: DeleteUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteUserDefinedFunctionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteUserDefinedFunctionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserDefinedFunctionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCatalogImportStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCatalogImportStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCatalogImportStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCatalogImportStatusResponse(
    data,
    context
  );
  const response: GetCatalogImportStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCatalogImportStatusResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCatalogImportStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCatalogImportStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetConnectionResponse(data, context);
  const response: GetConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetConnectionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetConnectionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetConnectionsResponse(data, context);
  const response: GetConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConnectionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetConnectionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataCatalogEncryptionSettingsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDataCatalogEncryptionSettingsResponse(
    data,
    context
  );
  const response: GetDataCatalogEncryptionSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDataCatalogEncryptionSettingsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataCatalogEncryptionSettingsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDatabaseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabaseCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDatabaseResponse(data, context);
  const response: GetDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDatabaseResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDatabaseCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabaseCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDatabasesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabasesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDatabasesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDatabasesResponse(data, context);
  const response: GetDatabasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDatabasesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDatabasesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDatabasesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetPartitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPartitionResponse(data, context);
  const response: GetPartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPartitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetPartitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetPartitionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPartitionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPartitionsResponse(data, context);
  const response: GetPartitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPartitionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetPartitionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPartitionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetResourcePolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcePolicyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetResourcePolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetResourcePolicyResponse(data, context);
  const response: GetResourcePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetResourcePolicyResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetResourcePolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourcePolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetTableCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTableResponse(data, context);
  const response: GetTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTableResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetTableCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetTableVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTableVersionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTableVersionResponse(data, context);
  const response: GetTableVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTableVersionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetTableVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetTableVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTableVersionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTableVersionsResponse(data, context);
  const response: GetTableVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTableVersionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetTableVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTableVersionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetTablesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTablesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTablesResponse(data, context);
  const response: GetTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTablesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetTablesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTablesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetUserDefinedFunctionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetUserDefinedFunctionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetUserDefinedFunctionResponse(
    data,
    context
  );
  const response: GetUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetUserDefinedFunctionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetUserDefinedFunctionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetUserDefinedFunctionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetUserDefinedFunctionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetUserDefinedFunctionsResponse(
    data,
    context
  );
  const response: GetUserDefinedFunctionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetUserDefinedFunctionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetUserDefinedFunctionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserDefinedFunctionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ImportCatalogToGlueCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCatalogToGlueCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ImportCatalogToGlueCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ImportCatalogToGlueResponse(data, context);
  const response: ImportCatalogToGlueCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportCatalogToGlueResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ImportCatalogToGlueCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCatalogToGlueCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutDataCatalogEncryptionSettingsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutDataCatalogEncryptionSettingsResponse(
    data,
    context
  );
  const response: PutDataCatalogEncryptionSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutDataCatalogEncryptionSettingsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutDataCatalogEncryptionSettingsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutResourcePolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutResourcePolicyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutResourcePolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutResourcePolicyResponse(data, context);
  const response: PutResourcePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutResourcePolicyResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutResourcePolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutResourcePolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConditionCheckFailureException":
    case "com.amazonaws.glue.common.exceptions#ConditionCheckFailureException":
      response = {
        ...(await deserializeAws_json1_1ConditionCheckFailureExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchTablesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTablesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchTablesResponse(data, context);
  const response: SearchTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchTablesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchTablesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchTablesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateConnectionResponse(data, context);
  const response: UpdateConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateDatabaseCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDatabaseCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDatabaseCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDatabaseResponse(data, context);
  const response: UpdateDatabaseCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDatabaseResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateDatabaseCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDatabaseCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdatePartitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePartitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdatePartitionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdatePartitionResponse(data, context);
  const response: UpdatePartitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePartitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdatePartitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePartitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateTableCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTableCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateTableCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateTableResponse(data, context);
  const response: UpdateTableCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTableResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateTableCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTableCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateUserDefinedFunctionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserDefinedFunctionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateUserDefinedFunctionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateUserDefinedFunctionResponse(
    data,
    context
  );
  const response: UpdateUserDefinedFunctionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateUserDefinedFunctionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateUserDefinedFunctionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserDefinedFunctionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlueEncryptionException":
    case "com.amazonaws.glue.common.exceptions#GlueEncryptionException":
      response = {
        ...(await deserializeAws_json1_1GlueEncryptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchGetDevEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetDevEndpointsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetDevEndpointsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetDevEndpointsResponse(data, context);
  const response: BatchGetDevEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetDevEndpointsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchGetDevEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetDevEndpointsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue.common.exceptions#AccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateDevEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDevEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDevEndpointResponse(data, context);
  const response: CreateDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDevEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDevEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDevEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue.common.exceptions#AccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue.common.exceptions#IdempotentParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.glue.common.exceptions#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateSecurityConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateSecurityConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateSecurityConfigurationResponse(
    data,
    context
  );
  const response: CreateSecurityConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSecurityConfigurationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateSecurityConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDevEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDevEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDevEndpointResponse(data, context);
  const response: DeleteDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDevEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDevEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDevEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteSecurityConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteSecurityConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteSecurityConfigurationResponse(
    data,
    context
  );
  const response: DeleteSecurityConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSecurityConfigurationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteSecurityConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDevEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDevEndpointResponse(data, context);
  const response: GetDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDevEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDevEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDevEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDevEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDevEndpointsResponse(data, context);
  const response: GetDevEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDevEndpointsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDevEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDevEndpointsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetJobBookmarkCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobBookmarkCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobBookmarkCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobBookmarkResponse(data, context);
  const response: GetJobBookmarkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobBookmarkResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetJobBookmarkCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobBookmarkCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.glue.common.exceptions#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetSecurityConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSecurityConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSecurityConfigurationResponse(
    data,
    context
  );
  const response: GetSecurityConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSecurityConfigurationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetSecurityConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetSecurityConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSecurityConfigurationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSecurityConfigurationsResponse(
    data,
    context
  );
  const response: GetSecurityConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSecurityConfigurationsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetSecurityConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSecurityConfigurationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListDevEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDevEndpointsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDevEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDevEndpointsResponse(data, context);
  const response: ListDevEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDevEndpointsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDevEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDevEndpointsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ResetJobBookmarkCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetJobBookmarkCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ResetJobBookmarkCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ResetJobBookmarkResponse(data, context);
  const response: ResetJobBookmarkCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResetJobBookmarkResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ResetJobBookmarkCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetJobBookmarkCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateDevEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDevEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDevEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDevEndpointResponse(data, context);
  const response: UpdateDevEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDevEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateDevEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDevEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.glue.common.exceptions#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CancelMLTaskRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelMLTaskRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CancelMLTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CancelMLTaskRunResponse(data, context);
  const response: CancelMLTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelMLTaskRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CancelMLTaskRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelMLTaskRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateMLTransformCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMLTransformCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateMLTransformResponse(data, context);
  const response: CreateMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMLTransformResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateMLTransformCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMLTransformCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue.common.exceptions#AccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue.common.exceptions#IdempotentParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteMLTransformCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMLTransformCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteMLTransformResponse(data, context);
  const response: DeleteMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteMLTransformResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteMLTransformCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMLTransformCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMLTaskRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMLTaskRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMLTaskRunResponse(data, context);
  const response: GetMLTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMLTaskRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMLTaskRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMLTaskRunsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMLTaskRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMLTaskRunsResponse(data, context);
  const response: GetMLTaskRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMLTaskRunsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMLTaskRunsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTaskRunsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMLTransformCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMLTransformResponse(data, context);
  const response: GetMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMLTransformResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMLTransformCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMLTransformsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMLTransformsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMLTransformsResponse(data, context);
  const response: GetMLTransformsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMLTransformsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMLTransformsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMLTransformsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartExportLabelsTaskRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartExportLabelsTaskRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartExportLabelsTaskRunCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartExportLabelsTaskRunResponse(
    data,
    context
  );
  const response: StartExportLabelsTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartExportLabelsTaskRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartExportLabelsTaskRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartExportLabelsTaskRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartImportLabelsTaskRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartImportLabelsTaskRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartImportLabelsTaskRunCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartImportLabelsTaskRunResponse(
    data,
    context
  );
  const response: StartImportLabelsTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartImportLabelsTaskRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartImportLabelsTaskRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartImportLabelsTaskRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartMLEvaluationTaskRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLEvaluationTaskRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartMLEvaluationTaskRunCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartMLEvaluationTaskRunResponse(
    data,
    context
  );
  const response: StartMLEvaluationTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartMLEvaluationTaskRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartMLEvaluationTaskRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLEvaluationTaskRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MLTransformNotReadyException":
    case "com.amazonaws.glue.ml.coral#MLTransformNotReadyException":
      response = {
        ...(await deserializeAws_json1_1MLTransformNotReadyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLLabelingSetGenerationTaskRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunResponse(
    data,
    context
  );
  const response: StartMLLabelingSetGenerationTaskRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartMLLabelingSetGenerationTaskRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMLLabelingSetGenerationTaskRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateMLTransformCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMLTransformCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateMLTransformCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateMLTransformResponse(data, context);
  const response: UpdateMLTransformCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateMLTransformResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateMLTransformCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMLTransformCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.glue.common.exceptions#AccessDeniedException":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchGetJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetJobsResponse(data, context);
  const response: BatchGetJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchGetJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchGetTriggersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetTriggersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetTriggersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetTriggersResponse(data, context);
  const response: BatchGetTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetTriggersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchGetTriggersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetTriggersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchGetWorkflowsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetWorkflowsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetWorkflowsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetWorkflowsResponse(data, context);
  const response: BatchGetWorkflowsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetWorkflowsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchGetWorkflowsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetWorkflowsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchStopJobRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchStopJobRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchStopJobRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchStopJobRunResponse(data, context);
  const response: BatchStopJobRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchStopJobRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchStopJobRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchStopJobRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateJobResponse(data, context);
  const response: CreateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue.common.exceptions#IdempotentParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateTriggerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTriggerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTriggerResponse(data, context);
  const response: CreateTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTriggerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateTriggerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTriggerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.glue.common.exceptions#IdempotentParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateWorkflowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWorkflowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateWorkflowResponse(data, context);
  const response: CreateWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateWorkflowResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateWorkflowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWorkflowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteJobResponse(data, context);
  const response: DeleteJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteTriggerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTriggerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTriggerResponse(data, context);
  const response: DeleteTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTriggerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteTriggerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTriggerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteWorkflowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWorkflowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteWorkflowResponse(data, context);
  const response: DeleteWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteWorkflowResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteWorkflowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWorkflowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobResponse(data, context);
  const response: GetJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetJobRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobRunResponse(data, context);
  const response: GetJobRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetJobRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetJobRunsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobRunsResponse(data, context);
  const response: GetJobRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobRunsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetJobRunsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobRunsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetJobsResponse(data, context);
  const response: GetJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetTriggerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTriggerResponse(data, context);
  const response: GetTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTriggerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetTriggerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetTriggersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetTriggersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetTriggersResponse(data, context);
  const response: GetTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTriggersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetTriggersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTriggersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetWorkflowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWorkflowResponse(data, context);
  const response: GetWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWorkflowResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetWorkflowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetWorkflowRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWorkflowRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWorkflowRunResponse(data, context);
  const response: GetWorkflowRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWorkflowRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetWorkflowRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetWorkflowRunPropertiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunPropertiesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWorkflowRunPropertiesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWorkflowRunPropertiesResponse(
    data,
    context
  );
  const response: GetWorkflowRunPropertiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWorkflowRunPropertiesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetWorkflowRunPropertiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunPropertiesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetWorkflowRunsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWorkflowRunsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWorkflowRunsResponse(data, context);
  const response: GetWorkflowRunsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWorkflowRunsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetWorkflowRunsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWorkflowRunsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListJobsResponse(data, context);
  const response: ListJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTriggersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTriggersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTriggersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTriggersResponse(data, context);
  const response: ListTriggersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTriggersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTriggersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTriggersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListWorkflowsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWorkflowsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListWorkflowsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListWorkflowsResponse(data, context);
  const response: ListWorkflowsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListWorkflowsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListWorkflowsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWorkflowsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutWorkflowRunPropertiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutWorkflowRunPropertiesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutWorkflowRunPropertiesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutWorkflowRunPropertiesResponse(
    data,
    context
  );
  const response: PutWorkflowRunPropertiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutWorkflowRunPropertiesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutWorkflowRunPropertiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutWorkflowRunPropertiesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartJobRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartJobRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartJobRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartJobRunResponse(data, context);
  const response: StartJobRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartJobRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartJobRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartJobRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartTriggerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTriggerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartTriggerResponse(data, context);
  const response: StartTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartTriggerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartTriggerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTriggerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartWorkflowRunCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartWorkflowRunCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartWorkflowRunCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartWorkflowRunResponse(data, context);
  const response: StartWorkflowRunCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartWorkflowRunResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartWorkflowRunCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartWorkflowRunCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentRunsExceededException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentRunsExceededException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopTriggerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTriggerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopTriggerResponse(data, context);
  const response: StopTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopTriggerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopTriggerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTriggerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateJobResponse(data, context);
  const response: UpdateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateTriggerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTriggerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateTriggerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateTriggerResponse(data, context);
  const response: UpdateTriggerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTriggerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateTriggerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTriggerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateWorkflowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkflowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateWorkflowCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateWorkflowResponse(data, context);
  const response: UpdateWorkflowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateWorkflowResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateWorkflowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkflowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.glue.common.exceptions#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchGetCrawlersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCrawlersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchGetCrawlersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchGetCrawlersResponse(data, context);
  const response: BatchGetCrawlersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchGetCrawlersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchGetCrawlersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchGetCrawlersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateClassifierResponse(data, context);
  const response: CreateClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateClassifierCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateCrawlerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCrawlerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateCrawlerResponse(data, context);
  const response: CreateCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCrawlerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateCrawlerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCrawlerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.glue.common.exceptions#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNumberLimitExceededException":
    case "com.amazonaws.glue.common.exceptions#ResourceNumberLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateScriptCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScriptCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateScriptCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateScriptResponse(data, context);
  const response: CreateScriptCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateScriptResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateScriptCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScriptCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteClassifierResponse(data, context);
  const response: DeleteClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteClassifierCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteCrawlerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCrawlerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteCrawlerResponse(data, context);
  const response: DeleteCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCrawlerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteCrawlerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCrawlerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CrawlerRunningException":
    case "com.amazonaws.gluedataplane.coral#CrawlerRunningException":
      response = {
        ...(await deserializeAws_json1_1CrawlerRunningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SchedulerTransitioningException":
    case "com.amazonaws.gluedataplane.coral#SchedulerTransitioningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetClassifierResponse(data, context);
  const response: GetClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifierCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetClassifiersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifiersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetClassifiersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetClassifiersResponse(data, context);
  const response: GetClassifiersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetClassifiersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetClassifiersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetClassifiersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCrawlerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCrawlerResponse(data, context);
  const response: GetCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCrawlerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCrawlerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCrawlerMetricsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerMetricsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCrawlerMetricsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCrawlerMetricsResponse(data, context);
  const response: GetCrawlerMetricsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCrawlerMetricsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCrawlerMetricsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlerMetricsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCrawlersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCrawlersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCrawlersResponse(data, context);
  const response: GetCrawlersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCrawlersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCrawlersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCrawlersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDataflowGraphCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataflowGraphCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDataflowGraphCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDataflowGraphResponse(data, context);
  const response: GetDataflowGraphCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDataflowGraphResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDataflowGraphCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDataflowGraphCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMappingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMappingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMappingCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMappingResponse(data, context);
  const response: GetMappingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMappingResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMappingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMappingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetPlanCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPlanCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPlanCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPlanResponse(data, context);
  const response: GetPlanCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPlanResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetPlanCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPlanCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.glue.common.exceptions#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListCrawlersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCrawlersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListCrawlersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListCrawlersResponse(data, context);
  const response: ListCrawlersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCrawlersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListCrawlersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCrawlersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartCrawlerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartCrawlerResponse(data, context);
  const response: StartCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartCrawlerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartCrawlerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CrawlerRunningException":
    case "com.amazonaws.gluedataplane.coral#CrawlerRunningException":
      response = {
        ...(await deserializeAws_json1_1CrawlerRunningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartCrawlerScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartCrawlerScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartCrawlerScheduleResponse(data, context);
  const response: StartCrawlerScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartCrawlerScheduleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartCrawlerScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartCrawlerScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoScheduleException":
    case "com.amazonaws.gluedataplane.coral#NoScheduleException":
      response = {
        ...(await deserializeAws_json1_1NoScheduleExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SchedulerRunningException":
    case "com.amazonaws.gluedataplane.coral#SchedulerRunningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerRunningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SchedulerTransitioningException":
    case "com.amazonaws.gluedataplane.coral#SchedulerTransitioningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopCrawlerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopCrawlerResponse(data, context);
  const response: StopCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopCrawlerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopCrawlerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CrawlerNotRunningException":
    case "com.amazonaws.gluedataplane.coral#CrawlerNotRunningException":
      response = {
        ...(await deserializeAws_json1_1CrawlerNotRunningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CrawlerStoppingException":
    case "com.amazonaws.gluedataplane.coral#CrawlerStoppingException":
      response = {
        ...(await deserializeAws_json1_1CrawlerStoppingExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopCrawlerScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopCrawlerScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopCrawlerScheduleResponse(data, context);
  const response: StopCrawlerScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopCrawlerScheduleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopCrawlerScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCrawlerScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SchedulerNotRunningException":
    case "com.amazonaws.gluedataplane.coral#SchedulerNotRunningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerNotRunningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SchedulerTransitioningException":
    case "com.amazonaws.gluedataplane.coral#SchedulerTransitioningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateClassifierCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateClassifierResponse(data, context);
  const response: UpdateClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateClassifierCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionMismatchException":
    case "com.amazonaws.glue.common.exceptions#VersionMismatchException":
      response = {
        ...(await deserializeAws_json1_1VersionMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateCrawlerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateCrawlerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateCrawlerResponse(data, context);
  const response: UpdateCrawlerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCrawlerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateCrawlerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionMismatchException":
    case "com.amazonaws.glue.common.exceptions#VersionMismatchException":
      response = {
        ...(await deserializeAws_json1_1VersionMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CrawlerRunningException":
    case "com.amazonaws.gluedataplane.coral#CrawlerRunningException":
      response = {
        ...(await deserializeAws_json1_1CrawlerRunningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateCrawlerScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateCrawlerScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateCrawlerScheduleResponse(data, context);
  const response: UpdateCrawlerScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCrawlerScheduleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateCrawlerScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCrawlerScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "EntityNotFoundException":
    case "com.amazonaws.glue.common.exceptions#EntityNotFoundException":
      response = {
        ...(await deserializeAws_json1_1EntityNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInputException":
    case "com.amazonaws.glue.common.exceptions#InvalidInputException":
      response = {
        ...(await deserializeAws_json1_1InvalidInputExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OperationTimeoutException":
    case "com.amazonaws.glue.common.exceptions#OperationTimeoutException":
      response = {
        ...(await deserializeAws_json1_1OperationTimeoutExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionMismatchException":
    case "com.amazonaws.glue.common.exceptions#VersionMismatchException":
      response = {
        ...(await deserializeAws_json1_1VersionMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SchedulerTransitioningException":
    case "com.amazonaws.gluedataplane.coral#SchedulerTransitioningException":
      response = {
        ...(await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1AccessDeniedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessDeniedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AccessDeniedException(
    body,
    context
  );
  const contents: AccessDeniedException = {
    name: "AccessDeniedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AlreadyExistsException(
    body,
    context
  );
  const contents: AlreadyExistsException = {
    name: "AlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ConcurrentModificationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentModificationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConcurrentModificationException(
    body,
    context
  );
  const contents: ConcurrentModificationException = {
    name: "ConcurrentModificationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentRunsExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConcurrentRunsExceededException(
    body,
    context
  );
  const contents: ConcurrentRunsExceededException = {
    name: "ConcurrentRunsExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ConditionCheckFailureExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConditionCheckFailureException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConditionCheckFailureException(
    body,
    context
  );
  const contents: ConditionCheckFailureException = {
    name: "ConditionCheckFailureException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1EntityNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EntityNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1EntityNotFoundException(
    body,
    context
  );
  const contents: EntityNotFoundException = {
    name: "EntityNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1GlueEncryptionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<GlueEncryptionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1GlueEncryptionException(
    body,
    context
  );
  const contents: GlueEncryptionException = {
    name: "GlueEncryptionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IdempotentParameterMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1IdempotentParameterMismatchException(
    body,
    context
  );
  const contents: IdempotentParameterMismatchException = {
    name: "IdempotentParameterMismatchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InternalServiceExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalServiceException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InternalServiceException(
    body,
    context
  );
  const contents: InternalServiceException = {
    name: "InternalServiceException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidInputExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInputException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidInputException(
    body,
    context
  );
  const contents: InvalidInputException = {
    name: "InvalidInputException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1OperationTimeoutExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OperationTimeoutException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1OperationTimeoutException(
    body,
    context
  );
  const contents: OperationTimeoutException = {
    name: "OperationTimeoutException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNumberLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceNumberLimitExceededException(
    body,
    context
  );
  const contents: ResourceNumberLimitExceededException = {
    name: "ResourceNumberLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ValidationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ValidationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ValidationException(
    body,
    context
  );
  const contents: ValidationException = {
    name: "ValidationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1VersionMismatchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<VersionMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1VersionMismatchException(
    body,
    context
  );
  const contents: VersionMismatchException = {
    name: "VersionMismatchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MLTransformNotReadyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MLTransformNotReadyException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MLTransformNotReadyException(
    body,
    context
  );
  const contents: MLTransformNotReadyException = {
    name: "MLTransformNotReadyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CrawlerNotRunningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CrawlerNotRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CrawlerNotRunningException(
    body,
    context
  );
  const contents: CrawlerNotRunningException = {
    name: "CrawlerNotRunningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CrawlerRunningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CrawlerRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CrawlerRunningException(
    body,
    context
  );
  const contents: CrawlerRunningException = {
    name: "CrawlerRunningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CrawlerStoppingExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CrawlerStoppingException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CrawlerStoppingException(
    body,
    context
  );
  const contents: CrawlerStoppingException = {
    name: "CrawlerStoppingException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1NoScheduleExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoScheduleException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NoScheduleException(
    body,
    context
  );
  const contents: NoScheduleException = {
    name: "NoScheduleException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SchedulerNotRunningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SchedulerNotRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SchedulerNotRunningException(
    body,
    context
  );
  const contents: SchedulerNotRunningException = {
    name: "SchedulerNotRunningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SchedulerRunningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SchedulerRunningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SchedulerRunningException(
    body,
    context
  );
  const contents: SchedulerRunningException = {
    name: "SchedulerRunningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SchedulerTransitioningExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SchedulerTransitioningException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SchedulerTransitioningException(
    body,
    context
  );
  const contents: SchedulerTransitioningException = {
    name: "SchedulerTransitioningException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1GetTagsRequest = (
  input: GetTagsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1TagResourceRequest = (
  input: TagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.TagsToAdd !== undefined) {
    bodyParams["TagsToAdd"] = serializeAws_json1_1TagsMap(
      input.TagsToAdd,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UntagResourceRequest = (
  input: UntagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.TagsToRemove !== undefined) {
    bodyParams["TagsToRemove"] = serializeAws_json1_1TagKeysList(
      input.TagsToRemove,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1NameStringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1TagKeysList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1TagsMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1BatchCreatePartitionRequest = (
  input: BatchCreatePartitionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.PartitionInputList !== undefined) {
    bodyParams["PartitionInputList"] = serializeAws_json1_1PartitionInputList(
      input.PartitionInputList,
      context
    );
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDeleteConnectionRequest = (
  input: BatchDeleteConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.ConnectionNameList !== undefined) {
    bodyParams[
      "ConnectionNameList"
    ] = serializeAws_json1_1DeleteConnectionNameList(
      input.ConnectionNameList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDeletePartitionRequest = (
  input: BatchDeletePartitionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.PartitionsToDelete !== undefined) {
    bodyParams[
      "PartitionsToDelete"
    ] = serializeAws_json1_1BatchDeletePartitionValueList(
      input.PartitionsToDelete,
      context
    );
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDeletePartitionValueList = (
  input: Array<PartitionValueList>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PartitionValueList(entry, context));
  }
  return contents;
};

const serializeAws_json1_1BatchDeleteTableNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1BatchDeleteTableRequest = (
  input: BatchDeleteTableRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.TablesToDelete !== undefined) {
    bodyParams["TablesToDelete"] = serializeAws_json1_1BatchDeleteTableNameList(
      input.TablesToDelete,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDeleteTableVersionList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1BatchDeleteTableVersionRequest = (
  input: BatchDeleteTableVersionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  if (input.VersionIds !== undefined) {
    bodyParams["VersionIds"] = serializeAws_json1_1BatchDeleteTableVersionList(
      input.VersionIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchGetPartitionRequest = (
  input: BatchGetPartitionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.PartitionsToGet !== undefined) {
    bodyParams[
      "PartitionsToGet"
    ] = serializeAws_json1_1BatchGetPartitionValueList(
      input.PartitionsToGet,
      context
    );
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1BatchGetPartitionValueList = (
  input: Array<PartitionValueList>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PartitionValueList(entry, context));
  }
  return contents;
};

const serializeAws_json1_1BoundedPartitionValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Column = (
  input: Column,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Comment !== undefined) {
    bodyParams["Comment"] = input.Comment;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1ParametersMap(
      input.Parameters,
      context
    );
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1ColumnList = (
  input: Array<Column>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Column(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ColumnValueStringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ConnectionInput = (
  input: ConnectionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConnectionProperties !== undefined) {
    bodyParams[
      "ConnectionProperties"
    ] = serializeAws_json1_1ConnectionProperties(
      input.ConnectionProperties,
      context
    );
  }
  if (input.ConnectionType !== undefined) {
    bodyParams["ConnectionType"] = input.ConnectionType;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.MatchCriteria !== undefined) {
    bodyParams["MatchCriteria"] = serializeAws_json1_1MatchCriteria(
      input.MatchCriteria,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.PhysicalConnectionRequirements !== undefined) {
    bodyParams[
      "PhysicalConnectionRequirements"
    ] = serializeAws_json1_1PhysicalConnectionRequirements(
      input.PhysicalConnectionRequirements,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ConnectionPasswordEncryption = (
  input: ConnectionPasswordEncryption,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AwsKmsKeyId !== undefined) {
    bodyParams["AwsKmsKeyId"] = input.AwsKmsKeyId;
  }
  if (input.ReturnConnectionPasswordEncrypted !== undefined) {
    bodyParams["ReturnConnectionPasswordEncrypted"] =
      input.ReturnConnectionPasswordEncrypted;
  }
  return bodyParams;
};

const serializeAws_json1_1ConnectionProperties = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1CreateConnectionRequest = (
  input: CreateConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.ConnectionInput !== undefined) {
    bodyParams["ConnectionInput"] = serializeAws_json1_1ConnectionInput(
      input.ConnectionInput,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDatabaseRequest = (
  input: CreateDatabaseRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseInput !== undefined) {
    bodyParams["DatabaseInput"] = serializeAws_json1_1DatabaseInput(
      input.DatabaseInput,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePartitionRequest = (
  input: CreatePartitionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.PartitionInput !== undefined) {
    bodyParams["PartitionInput"] = serializeAws_json1_1PartitionInput(
      input.PartitionInput,
      context
    );
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateTableRequest = (
  input: CreateTableRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.TableInput !== undefined) {
    bodyParams["TableInput"] = serializeAws_json1_1TableInput(
      input.TableInput,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateUserDefinedFunctionRequest = (
  input: CreateUserDefinedFunctionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.FunctionInput !== undefined) {
    bodyParams["FunctionInput"] = serializeAws_json1_1UserDefinedFunctionInput(
      input.FunctionInput,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DataCatalogEncryptionSettings = (
  input: DataCatalogEncryptionSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConnectionPasswordEncryption !== undefined) {
    bodyParams[
      "ConnectionPasswordEncryption"
    ] = serializeAws_json1_1ConnectionPasswordEncryption(
      input.ConnectionPasswordEncryption,
      context
    );
  }
  if (input.EncryptionAtRest !== undefined) {
    bodyParams["EncryptionAtRest"] = serializeAws_json1_1EncryptionAtRest(
      input.EncryptionAtRest,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DataLakePrincipal = (
  input: DataLakePrincipal,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DataLakePrincipalIdentifier !== undefined) {
    bodyParams["DataLakePrincipalIdentifier"] =
      input.DataLakePrincipalIdentifier;
  }
  return bodyParams;
};

const serializeAws_json1_1DatabaseInput = (
  input: DatabaseInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CreateTableDefaultPermissions !== undefined) {
    bodyParams[
      "CreateTableDefaultPermissions"
    ] = serializeAws_json1_1PrincipalPermissionsList(
      input.CreateTableDefaultPermissions,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.LocationUri !== undefined) {
    bodyParams["LocationUri"] = input.LocationUri;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1ParametersMap(
      input.Parameters,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteConnectionNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1DeleteConnectionRequest = (
  input: DeleteConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.ConnectionName !== undefined) {
    bodyParams["ConnectionName"] = input.ConnectionName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDatabaseRequest = (
  input: DeleteDatabaseRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeletePartitionRequest = (
  input: DeletePartitionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.PartitionValues !== undefined) {
    bodyParams["PartitionValues"] = serializeAws_json1_1ValueStringList(
      input.PartitionValues,
      context
    );
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteResourcePolicyRequest = (
  input: DeleteResourcePolicyRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.PolicyHashCondition !== undefined) {
    bodyParams["PolicyHashCondition"] = input.PolicyHashCondition;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteTableRequest = (
  input: DeleteTableRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteTableVersionRequest = (
  input: DeleteTableVersionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  if (input.VersionId !== undefined) {
    bodyParams["VersionId"] = input.VersionId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteUserDefinedFunctionRequest = (
  input: DeleteUserDefinedFunctionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.FunctionName !== undefined) {
    bodyParams["FunctionName"] = input.FunctionName;
  }
  return bodyParams;
};

const serializeAws_json1_1EncryptionAtRest = (
  input: EncryptionAtRest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogEncryptionMode !== undefined) {
    bodyParams["CatalogEncryptionMode"] = input.CatalogEncryptionMode;
  }
  if (input.SseAwsKmsKeyId !== undefined) {
    bodyParams["SseAwsKmsKeyId"] = input.SseAwsKmsKeyId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetCatalogImportStatusRequest = (
  input: GetCatalogImportStatusRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetConnectionRequest = (
  input: GetConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.HidePassword !== undefined) {
    bodyParams["HidePassword"] = input.HidePassword;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1GetConnectionsFilter = (
  input: GetConnectionsFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConnectionType !== undefined) {
    bodyParams["ConnectionType"] = input.ConnectionType;
  }
  if (input.MatchCriteria !== undefined) {
    bodyParams["MatchCriteria"] = serializeAws_json1_1MatchCriteria(
      input.MatchCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1GetConnectionsRequest = (
  input: GetConnectionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1GetConnectionsFilter(
      input.Filter,
      context
    );
  }
  if (input.HidePassword !== undefined) {
    bodyParams["HidePassword"] = input.HidePassword;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDataCatalogEncryptionSettingsRequest = (
  input: GetDataCatalogEncryptionSettingsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDatabaseRequest = (
  input: GetDatabaseRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDatabasesRequest = (
  input: GetDatabasesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetPartitionRequest = (
  input: GetPartitionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.PartitionValues !== undefined) {
    bodyParams["PartitionValues"] = serializeAws_json1_1ValueStringList(
      input.PartitionValues,
      context
    );
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetPartitionsRequest = (
  input: GetPartitionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.Expression !== undefined) {
    bodyParams["Expression"] = input.Expression;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Segment !== undefined) {
    bodyParams["Segment"] = serializeAws_json1_1Segment(input.Segment, context);
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetResourcePolicyRequest = (
  input: GetResourcePolicyRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  return bodyParams;
};

const serializeAws_json1_1GetTableRequest = (
  input: GetTableRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1GetTableVersionRequest = (
  input: GetTableVersionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  if (input.VersionId !== undefined) {
    bodyParams["VersionId"] = input.VersionId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetTableVersionsRequest = (
  input: GetTableVersionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetTablesRequest = (
  input: GetTablesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.Expression !== undefined) {
    bodyParams["Expression"] = input.Expression;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetUserDefinedFunctionRequest = (
  input: GetUserDefinedFunctionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.FunctionName !== undefined) {
    bodyParams["FunctionName"] = input.FunctionName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetUserDefinedFunctionsRequest = (
  input: GetUserDefinedFunctionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Pattern !== undefined) {
    bodyParams["Pattern"] = input.Pattern;
  }
  return bodyParams;
};

const serializeAws_json1_1ImportCatalogToGlueRequest = (
  input: ImportCatalogToGlueRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  return bodyParams;
};

const serializeAws_json1_1LocationMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1MatchCriteria = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Order = (
  input: Order,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Column !== undefined) {
    bodyParams["Column"] = input.Column;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1OrderList = (
  input: Array<Order>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Order(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ParametersMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1PartitionInput = (
  input: PartitionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LastAccessTime !== undefined) {
    bodyParams["LastAccessTime"] = Math.round(
      input.LastAccessTime.getTime() / 1000
    );
  }
  if (input.LastAnalyzedTime !== undefined) {
    bodyParams["LastAnalyzedTime"] = Math.round(
      input.LastAnalyzedTime.getTime() / 1000
    );
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1ParametersMap(
      input.Parameters,
      context
    );
  }
  if (input.StorageDescriptor !== undefined) {
    bodyParams["StorageDescriptor"] = serializeAws_json1_1StorageDescriptor(
      input.StorageDescriptor,
      context
    );
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1ValueStringList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PartitionInputList = (
  input: Array<PartitionInput>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PartitionInput(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PartitionValueList = (
  input: PartitionValueList,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1ValueStringList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PermissionList = (
  input: Array<Permission | string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1PhysicalConnectionRequirements = (
  input: PhysicalConnectionRequirements,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AvailabilityZone !== undefined) {
    bodyParams["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.SecurityGroupIdList !== undefined) {
    bodyParams["SecurityGroupIdList"] = serializeAws_json1_1SecurityGroupIdList(
      input.SecurityGroupIdList,
      context
    );
  }
  if (input.SubnetId !== undefined) {
    bodyParams["SubnetId"] = input.SubnetId;
  }
  return bodyParams;
};

const serializeAws_json1_1PrincipalPermissions = (
  input: PrincipalPermissions,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Permissions !== undefined) {
    bodyParams["Permissions"] = serializeAws_json1_1PermissionList(
      input.Permissions,
      context
    );
  }
  if (input.Principal !== undefined) {
    bodyParams["Principal"] = serializeAws_json1_1DataLakePrincipal(
      input.Principal,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PrincipalPermissionsList = (
  input: Array<PrincipalPermissions>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PrincipalPermissions(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PropertyPredicate = (
  input: PropertyPredicate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Comparator !== undefined) {
    bodyParams["Comparator"] = input.Comparator;
  }
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1PutDataCatalogEncryptionSettingsRequest = (
  input: PutDataCatalogEncryptionSettingsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DataCatalogEncryptionSettings !== undefined) {
    bodyParams[
      "DataCatalogEncryptionSettings"
    ] = serializeAws_json1_1DataCatalogEncryptionSettings(
      input.DataCatalogEncryptionSettings,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PutResourcePolicyRequest = (
  input: PutResourcePolicyRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.PolicyExistsCondition !== undefined) {
    bodyParams["PolicyExistsCondition"] = input.PolicyExistsCondition;
  }
  if (input.PolicyHashCondition !== undefined) {
    bodyParams["PolicyHashCondition"] = input.PolicyHashCondition;
  }
  if (input.PolicyInJson !== undefined) {
    bodyParams["PolicyInJson"] = input.PolicyInJson;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceUri = (
  input: ResourceUri,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceType !== undefined) {
    bodyParams["ResourceType"] = input.ResourceType;
  }
  if (input.Uri !== undefined) {
    bodyParams["Uri"] = input.Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceUriList = (
  input: Array<ResourceUri>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1ResourceUri(entry, context));
  }
  return contents;
};

const serializeAws_json1_1SearchPropertyPredicates = (
  input: Array<PropertyPredicate>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PropertyPredicate(entry, context));
  }
  return contents;
};

const serializeAws_json1_1SearchTablesRequest = (
  input: SearchTablesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1SearchPropertyPredicates(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SearchText !== undefined) {
    bodyParams["SearchText"] = input.SearchText;
  }
  if (input.SortCriteria !== undefined) {
    bodyParams["SortCriteria"] = serializeAws_json1_1SortCriteria(
      input.SortCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SecurityGroupIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Segment = (
  input: Segment,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SegmentNumber !== undefined) {
    bodyParams["SegmentNumber"] = input.SegmentNumber;
  }
  if (input.TotalSegments !== undefined) {
    bodyParams["TotalSegments"] = input.TotalSegments;
  }
  return bodyParams;
};

const serializeAws_json1_1SerDeInfo = (
  input: SerDeInfo,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1ParametersMap(
      input.Parameters,
      context
    );
  }
  if (input.SerializationLibrary !== undefined) {
    bodyParams["SerializationLibrary"] = input.SerializationLibrary;
  }
  return bodyParams;
};

const serializeAws_json1_1SkewedInfo = (
  input: SkewedInfo,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SkewedColumnNames !== undefined) {
    bodyParams["SkewedColumnNames"] = serializeAws_json1_1NameStringList(
      input.SkewedColumnNames,
      context
    );
  }
  if (input.SkewedColumnValueLocationMaps !== undefined) {
    bodyParams[
      "SkewedColumnValueLocationMaps"
    ] = serializeAws_json1_1LocationMap(
      input.SkewedColumnValueLocationMaps,
      context
    );
  }
  if (input.SkewedColumnValues !== undefined) {
    bodyParams[
      "SkewedColumnValues"
    ] = serializeAws_json1_1ColumnValueStringList(
      input.SkewedColumnValues,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SortCriteria = (
  input: Array<SortCriterion>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1SortCriterion(entry, context));
  }
  return contents;
};

const serializeAws_json1_1SortCriterion = (
  input: SortCriterion,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FieldName !== undefined) {
    bodyParams["FieldName"] = input.FieldName;
  }
  if (input.Sort !== undefined) {
    bodyParams["Sort"] = input.Sort;
  }
  return bodyParams;
};

const serializeAws_json1_1StorageDescriptor = (
  input: StorageDescriptor,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BucketColumns !== undefined) {
    bodyParams["BucketColumns"] = serializeAws_json1_1NameStringList(
      input.BucketColumns,
      context
    );
  }
  if (input.Columns !== undefined) {
    bodyParams["Columns"] = serializeAws_json1_1ColumnList(
      input.Columns,
      context
    );
  }
  if (input.Compressed !== undefined) {
    bodyParams["Compressed"] = input.Compressed;
  }
  if (input.InputFormat !== undefined) {
    bodyParams["InputFormat"] = input.InputFormat;
  }
  if (input.Location !== undefined) {
    bodyParams["Location"] = input.Location;
  }
  if (input.NumberOfBuckets !== undefined) {
    bodyParams["NumberOfBuckets"] = input.NumberOfBuckets;
  }
  if (input.OutputFormat !== undefined) {
    bodyParams["OutputFormat"] = input.OutputFormat;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1ParametersMap(
      input.Parameters,
      context
    );
  }
  if (input.SerdeInfo !== undefined) {
    bodyParams["SerdeInfo"] = serializeAws_json1_1SerDeInfo(
      input.SerdeInfo,
      context
    );
  }
  if (input.SkewedInfo !== undefined) {
    bodyParams["SkewedInfo"] = serializeAws_json1_1SkewedInfo(
      input.SkewedInfo,
      context
    );
  }
  if (input.SortColumns !== undefined) {
    bodyParams["SortColumns"] = serializeAws_json1_1OrderList(
      input.SortColumns,
      context
    );
  }
  if (input.StoredAsSubDirectories !== undefined) {
    bodyParams["StoredAsSubDirectories"] = input.StoredAsSubDirectories;
  }
  return bodyParams;
};

const serializeAws_json1_1TableInput = (
  input: TableInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.LastAccessTime !== undefined) {
    bodyParams["LastAccessTime"] = Math.round(
      input.LastAccessTime.getTime() / 1000
    );
  }
  if (input.LastAnalyzedTime !== undefined) {
    bodyParams["LastAnalyzedTime"] = Math.round(
      input.LastAnalyzedTime.getTime() / 1000
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Owner !== undefined) {
    bodyParams["Owner"] = input.Owner;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1ParametersMap(
      input.Parameters,
      context
    );
  }
  if (input.PartitionKeys !== undefined) {
    bodyParams["PartitionKeys"] = serializeAws_json1_1ColumnList(
      input.PartitionKeys,
      context
    );
  }
  if (input.Retention !== undefined) {
    bodyParams["Retention"] = input.Retention;
  }
  if (input.StorageDescriptor !== undefined) {
    bodyParams["StorageDescriptor"] = serializeAws_json1_1StorageDescriptor(
      input.StorageDescriptor,
      context
    );
  }
  if (input.TableType !== undefined) {
    bodyParams["TableType"] = input.TableType;
  }
  if (input.ViewExpandedText !== undefined) {
    bodyParams["ViewExpandedText"] = input.ViewExpandedText;
  }
  if (input.ViewOriginalText !== undefined) {
    bodyParams["ViewOriginalText"] = input.ViewOriginalText;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateConnectionRequest = (
  input: UpdateConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.ConnectionInput !== undefined) {
    bodyParams["ConnectionInput"] = serializeAws_json1_1ConnectionInput(
      input.ConnectionInput,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateDatabaseRequest = (
  input: UpdateDatabaseRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseInput !== undefined) {
    bodyParams["DatabaseInput"] = serializeAws_json1_1DatabaseInput(
      input.DatabaseInput,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdatePartitionRequest = (
  input: UpdatePartitionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.PartitionInput !== undefined) {
    bodyParams["PartitionInput"] = serializeAws_json1_1PartitionInput(
      input.PartitionInput,
      context
    );
  }
  if (input.PartitionValueList !== undefined) {
    bodyParams[
      "PartitionValueList"
    ] = serializeAws_json1_1BoundedPartitionValueList(
      input.PartitionValueList,
      context
    );
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateTableRequest = (
  input: UpdateTableRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.SkipArchive !== undefined) {
    bodyParams["SkipArchive"] = input.SkipArchive;
  }
  if (input.TableInput !== undefined) {
    bodyParams["TableInput"] = serializeAws_json1_1TableInput(
      input.TableInput,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateUserDefinedFunctionRequest = (
  input: UpdateUserDefinedFunctionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.FunctionInput !== undefined) {
    bodyParams["FunctionInput"] = serializeAws_json1_1UserDefinedFunctionInput(
      input.FunctionInput,
      context
    );
  }
  if (input.FunctionName !== undefined) {
    bodyParams["FunctionName"] = input.FunctionName;
  }
  return bodyParams;
};

const serializeAws_json1_1UserDefinedFunctionInput = (
  input: UserDefinedFunctionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClassName !== undefined) {
    bodyParams["ClassName"] = input.ClassName;
  }
  if (input.FunctionName !== undefined) {
    bodyParams["FunctionName"] = input.FunctionName;
  }
  if (input.OwnerName !== undefined) {
    bodyParams["OwnerName"] = input.OwnerName;
  }
  if (input.OwnerType !== undefined) {
    bodyParams["OwnerType"] = input.OwnerType;
  }
  if (input.ResourceUris !== undefined) {
    bodyParams["ResourceUris"] = serializeAws_json1_1ResourceUriList(
      input.ResourceUris,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ValueStringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1BatchGetDevEndpointsRequest = (
  input: BatchGetDevEndpointsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DevEndpointNames !== undefined) {
    bodyParams["DevEndpointNames"] = serializeAws_json1_1DevEndpointNames(
      input.DevEndpointNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CloudWatchEncryption = (
  input: CloudWatchEncryption,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CloudWatchEncryptionMode !== undefined) {
    bodyParams["CloudWatchEncryptionMode"] = input.CloudWatchEncryptionMode;
  }
  if (input.KmsKeyArn !== undefined) {
    bodyParams["KmsKeyArn"] = input.KmsKeyArn;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDevEndpointRequest = (
  input: CreateDevEndpointRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arguments !== undefined) {
    bodyParams["Arguments"] = serializeAws_json1_1MapValue(
      input.Arguments,
      context
    );
  }
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  if (input.ExtraJarsS3Path !== undefined) {
    bodyParams["ExtraJarsS3Path"] = input.ExtraJarsS3Path;
  }
  if (input.ExtraPythonLibsS3Path !== undefined) {
    bodyParams["ExtraPythonLibsS3Path"] = input.ExtraPythonLibsS3Path;
  }
  if (input.GlueVersion !== undefined) {
    bodyParams["GlueVersion"] = input.GlueVersion;
  }
  if (input.NumberOfNodes !== undefined) {
    bodyParams["NumberOfNodes"] = input.NumberOfNodes;
  }
  if (input.NumberOfWorkers !== undefined) {
    bodyParams["NumberOfWorkers"] = input.NumberOfWorkers;
  }
  if (input.PublicKey !== undefined) {
    bodyParams["PublicKey"] = input.PublicKey;
  }
  if (input.PublicKeys !== undefined) {
    bodyParams["PublicKeys"] = serializeAws_json1_1PublicKeysList(
      input.PublicKeys,
      context
    );
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.SecurityConfiguration !== undefined) {
    bodyParams["SecurityConfiguration"] = input.SecurityConfiguration;
  }
  if (input.SecurityGroupIds !== undefined) {
    bodyParams["SecurityGroupIds"] = serializeAws_json1_1StringList(
      input.SecurityGroupIds,
      context
    );
  }
  if (input.SubnetId !== undefined) {
    bodyParams["SubnetId"] = input.SubnetId;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagsMap(input.Tags, context);
  }
  if (input.WorkerType !== undefined) {
    bodyParams["WorkerType"] = input.WorkerType;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateSecurityConfigurationRequest = (
  input: CreateSecurityConfigurationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EncryptionConfiguration !== undefined) {
    bodyParams[
      "EncryptionConfiguration"
    ] = serializeAws_json1_1EncryptionConfiguration(
      input.EncryptionConfiguration,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDevEndpointRequest = (
  input: DeleteDevEndpointRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteSecurityConfigurationRequest = (
  input: DeleteSecurityConfigurationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DevEndpointCustomLibraries = (
  input: DevEndpointCustomLibraries,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ExtraJarsS3Path !== undefined) {
    bodyParams["ExtraJarsS3Path"] = input.ExtraJarsS3Path;
  }
  if (input.ExtraPythonLibsS3Path !== undefined) {
    bodyParams["ExtraPythonLibsS3Path"] = input.ExtraPythonLibsS3Path;
  }
  return bodyParams;
};

const serializeAws_json1_1DevEndpointNames = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1EncryptionConfiguration = (
  input: EncryptionConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CloudWatchEncryption !== undefined) {
    bodyParams[
      "CloudWatchEncryption"
    ] = serializeAws_json1_1CloudWatchEncryption(
      input.CloudWatchEncryption,
      context
    );
  }
  if (input.JobBookmarksEncryption !== undefined) {
    bodyParams[
      "JobBookmarksEncryption"
    ] = serializeAws_json1_1JobBookmarksEncryption(
      input.JobBookmarksEncryption,
      context
    );
  }
  if (input.S3Encryption !== undefined) {
    bodyParams["S3Encryption"] = serializeAws_json1_1S3EncryptionList(
      input.S3Encryption,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1GetDevEndpointRequest = (
  input: GetDevEndpointRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDevEndpointsRequest = (
  input: GetDevEndpointsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetJobBookmarkRequest = (
  input: GetJobBookmarkRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.RunId !== undefined) {
    bodyParams["RunId"] = input.RunId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetSecurityConfigurationRequest = (
  input: GetSecurityConfigurationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1GetSecurityConfigurationsRequest = (
  input: GetSecurityConfigurationsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1JobBookmarksEncryption = (
  input: JobBookmarksEncryption,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobBookmarksEncryptionMode !== undefined) {
    bodyParams["JobBookmarksEncryptionMode"] = input.JobBookmarksEncryptionMode;
  }
  if (input.KmsKeyArn !== undefined) {
    bodyParams["KmsKeyArn"] = input.KmsKeyArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ListDevEndpointsRequest = (
  input: ListDevEndpointsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagsMap(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1MapValue = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1PublicKeysList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ResetJobBookmarkRequest = (
  input: ResetJobBookmarkRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.RunId !== undefined) {
    bodyParams["RunId"] = input.RunId;
  }
  return bodyParams;
};

const serializeAws_json1_1S3Encryption = (
  input: S3Encryption,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.KmsKeyArn !== undefined) {
    bodyParams["KmsKeyArn"] = input.KmsKeyArn;
  }
  if (input.S3EncryptionMode !== undefined) {
    bodyParams["S3EncryptionMode"] = input.S3EncryptionMode;
  }
  return bodyParams;
};

const serializeAws_json1_1S3EncryptionList = (
  input: Array<S3Encryption>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1S3Encryption(entry, context));
  }
  return contents;
};

const serializeAws_json1_1StringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1UpdateDevEndpointRequest = (
  input: UpdateDevEndpointRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AddArguments !== undefined) {
    bodyParams["AddArguments"] = serializeAws_json1_1MapValue(
      input.AddArguments,
      context
    );
  }
  if (input.AddPublicKeys !== undefined) {
    bodyParams["AddPublicKeys"] = serializeAws_json1_1PublicKeysList(
      input.AddPublicKeys,
      context
    );
  }
  if (input.CustomLibraries !== undefined) {
    bodyParams[
      "CustomLibraries"
    ] = serializeAws_json1_1DevEndpointCustomLibraries(
      input.CustomLibraries,
      context
    );
  }
  if (input.DeleteArguments !== undefined) {
    bodyParams["DeleteArguments"] = serializeAws_json1_1StringList(
      input.DeleteArguments,
      context
    );
  }
  if (input.DeletePublicKeys !== undefined) {
    bodyParams["DeletePublicKeys"] = serializeAws_json1_1PublicKeysList(
      input.DeletePublicKeys,
      context
    );
  }
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  if (input.PublicKey !== undefined) {
    bodyParams["PublicKey"] = input.PublicKey;
  }
  if (input.UpdateEtlLibraries !== undefined) {
    bodyParams["UpdateEtlLibraries"] = input.UpdateEtlLibraries;
  }
  return bodyParams;
};

const serializeAws_json1_1CancelMLTaskRunRequest = (
  input: CancelMLTaskRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TaskRunId !== undefined) {
    bodyParams["TaskRunId"] = input.TaskRunId;
  }
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateMLTransformRequest = (
  input: CreateMLTransformRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.GlueVersion !== undefined) {
    bodyParams["GlueVersion"] = input.GlueVersion;
  }
  if (input.InputRecordTables !== undefined) {
    bodyParams["InputRecordTables"] = serializeAws_json1_1GlueTables(
      input.InputRecordTables,
      context
    );
  }
  if (input.MaxCapacity !== undefined) {
    bodyParams["MaxCapacity"] = input.MaxCapacity;
  }
  if (input.MaxRetries !== undefined) {
    bodyParams["MaxRetries"] = input.MaxRetries;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NumberOfWorkers !== undefined) {
    bodyParams["NumberOfWorkers"] = input.NumberOfWorkers;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1TransformParameters(
      input.Parameters,
      context
    );
  }
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  if (input.Timeout !== undefined) {
    bodyParams["Timeout"] = input.Timeout;
  }
  if (input.WorkerType !== undefined) {
    bodyParams["WorkerType"] = input.WorkerType;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteMLTransformRequest = (
  input: DeleteMLTransformRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  return bodyParams;
};

const serializeAws_json1_1FindMatchesParameters = (
  input: FindMatchesParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AccuracyCostTradeoff !== undefined) {
    bodyParams["AccuracyCostTradeoff"] = input.AccuracyCostTradeoff;
  }
  if (input.EnforceProvidedLabels !== undefined) {
    bodyParams["EnforceProvidedLabels"] = input.EnforceProvidedLabels;
  }
  if (input.PrecisionRecallTradeoff !== undefined) {
    bodyParams["PrecisionRecallTradeoff"] = input.PrecisionRecallTradeoff;
  }
  if (input.PrimaryKeyColumnName !== undefined) {
    bodyParams["PrimaryKeyColumnName"] = input.PrimaryKeyColumnName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMLTaskRunRequest = (
  input: GetMLTaskRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TaskRunId !== undefined) {
    bodyParams["TaskRunId"] = input.TaskRunId;
  }
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMLTaskRunsRequest = (
  input: GetMLTaskRunsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1TaskRunFilterCriteria(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Sort !== undefined) {
    bodyParams["Sort"] = serializeAws_json1_1TaskRunSortCriteria(
      input.Sort,
      context
    );
  }
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMLTransformRequest = (
  input: GetMLTransformRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMLTransformsRequest = (
  input: GetMLTransformsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1TransformFilterCriteria(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Sort !== undefined) {
    bodyParams["Sort"] = serializeAws_json1_1TransformSortCriteria(
      input.Sort,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1GlueTable = (
  input: GlueTable,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogId !== undefined) {
    bodyParams["CatalogId"] = input.CatalogId;
  }
  if (input.ConnectionName !== undefined) {
    bodyParams["ConnectionName"] = input.ConnectionName;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1GlueTables = (
  input: Array<GlueTable>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1GlueTable(entry, context));
  }
  return contents;
};

const serializeAws_json1_1SchemaColumn = (
  input: SchemaColumn,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DataType !== undefined) {
    bodyParams["DataType"] = input.DataType;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1StartExportLabelsTaskRunRequest = (
  input: StartExportLabelsTaskRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.OutputS3Path !== undefined) {
    bodyParams["OutputS3Path"] = input.OutputS3Path;
  }
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  return bodyParams;
};

const serializeAws_json1_1StartImportLabelsTaskRunRequest = (
  input: StartImportLabelsTaskRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InputS3Path !== undefined) {
    bodyParams["InputS3Path"] = input.InputS3Path;
  }
  if (input.ReplaceAllLabels !== undefined) {
    bodyParams["ReplaceAllLabels"] = input.ReplaceAllLabels;
  }
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  return bodyParams;
};

const serializeAws_json1_1StartMLEvaluationTaskRunRequest = (
  input: StartMLEvaluationTaskRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  return bodyParams;
};

const serializeAws_json1_1StartMLLabelingSetGenerationTaskRunRequest = (
  input: StartMLLabelingSetGenerationTaskRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.OutputS3Path !== undefined) {
    bodyParams["OutputS3Path"] = input.OutputS3Path;
  }
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  return bodyParams;
};

const serializeAws_json1_1TaskRunFilterCriteria = (
  input: TaskRunFilterCriteria,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.StartedAfter !== undefined) {
    bodyParams["StartedAfter"] = Math.round(
      input.StartedAfter.getTime() / 1000
    );
  }
  if (input.StartedBefore !== undefined) {
    bodyParams["StartedBefore"] = Math.round(
      input.StartedBefore.getTime() / 1000
    );
  }
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  if (input.TaskRunType !== undefined) {
    bodyParams["TaskRunType"] = input.TaskRunType;
  }
  return bodyParams;
};

const serializeAws_json1_1TaskRunSortCriteria = (
  input: TaskRunSortCriteria,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Column !== undefined) {
    bodyParams["Column"] = input.Column;
  }
  if (input.SortDirection !== undefined) {
    bodyParams["SortDirection"] = input.SortDirection;
  }
  return bodyParams;
};

const serializeAws_json1_1TransformFilterCriteria = (
  input: TransformFilterCriteria,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CreatedAfter !== undefined) {
    bodyParams["CreatedAfter"] = Math.round(
      input.CreatedAfter.getTime() / 1000
    );
  }
  if (input.CreatedBefore !== undefined) {
    bodyParams["CreatedBefore"] = Math.round(
      input.CreatedBefore.getTime() / 1000
    );
  }
  if (input.GlueVersion !== undefined) {
    bodyParams["GlueVersion"] = input.GlueVersion;
  }
  if (input.LastModifiedAfter !== undefined) {
    bodyParams["LastModifiedAfter"] = Math.round(
      input.LastModifiedAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedBefore !== undefined) {
    bodyParams["LastModifiedBefore"] = Math.round(
      input.LastModifiedBefore.getTime() / 1000
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Schema !== undefined) {
    bodyParams["Schema"] = serializeAws_json1_1TransformSchema(
      input.Schema,
      context
    );
  }
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  if (input.TransformType !== undefined) {
    bodyParams["TransformType"] = input.TransformType;
  }
  return bodyParams;
};

const serializeAws_json1_1TransformParameters = (
  input: TransformParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FindMatchesParameters !== undefined) {
    bodyParams[
      "FindMatchesParameters"
    ] = serializeAws_json1_1FindMatchesParameters(
      input.FindMatchesParameters,
      context
    );
  }
  if (input.TransformType !== undefined) {
    bodyParams["TransformType"] = input.TransformType;
  }
  return bodyParams;
};

const serializeAws_json1_1TransformSchema = (
  input: Array<SchemaColumn>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1SchemaColumn(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TransformSortCriteria = (
  input: TransformSortCriteria,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Column !== undefined) {
    bodyParams["Column"] = input.Column;
  }
  if (input.SortDirection !== undefined) {
    bodyParams["SortDirection"] = input.SortDirection;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateMLTransformRequest = (
  input: UpdateMLTransformRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.GlueVersion !== undefined) {
    bodyParams["GlueVersion"] = input.GlueVersion;
  }
  if (input.MaxCapacity !== undefined) {
    bodyParams["MaxCapacity"] = input.MaxCapacity;
  }
  if (input.MaxRetries !== undefined) {
    bodyParams["MaxRetries"] = input.MaxRetries;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NumberOfWorkers !== undefined) {
    bodyParams["NumberOfWorkers"] = input.NumberOfWorkers;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1TransformParameters(
      input.Parameters,
      context
    );
  }
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  if (input.Timeout !== undefined) {
    bodyParams["Timeout"] = input.Timeout;
  }
  if (input.TransformId !== undefined) {
    bodyParams["TransformId"] = input.TransformId;
  }
  if (input.WorkerType !== undefined) {
    bodyParams["WorkerType"] = input.WorkerType;
  }
  return bodyParams;
};

const serializeAws_json1_1Action = (
  input: Action,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arguments !== undefined) {
    bodyParams["Arguments"] = serializeAws_json1_1GenericMap(
      input.Arguments,
      context
    );
  }
  if (input.CrawlerName !== undefined) {
    bodyParams["CrawlerName"] = input.CrawlerName;
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.NotificationProperty !== undefined) {
    bodyParams[
      "NotificationProperty"
    ] = serializeAws_json1_1NotificationProperty(
      input.NotificationProperty,
      context
    );
  }
  if (input.SecurityConfiguration !== undefined) {
    bodyParams["SecurityConfiguration"] = input.SecurityConfiguration;
  }
  if (input.Timeout !== undefined) {
    bodyParams["Timeout"] = input.Timeout;
  }
  return bodyParams;
};

const serializeAws_json1_1ActionList = (
  input: Array<Action>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Action(entry, context));
  }
  return contents;
};

const serializeAws_json1_1BatchGetJobsRequest = (
  input: BatchGetJobsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobNames !== undefined) {
    bodyParams["JobNames"] = serializeAws_json1_1JobNameList(
      input.JobNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchGetTriggersRequest = (
  input: BatchGetTriggersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TriggerNames !== undefined) {
    bodyParams["TriggerNames"] = serializeAws_json1_1TriggerNameList(
      input.TriggerNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchGetWorkflowsRequest = (
  input: BatchGetWorkflowsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.IncludeGraph !== undefined) {
    bodyParams["IncludeGraph"] = input.IncludeGraph;
  }
  if (input.Names !== undefined) {
    bodyParams["Names"] = serializeAws_json1_1WorkflowNames(
      input.Names,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchStopJobRunJobRunIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1BatchStopJobRunRequest = (
  input: BatchStopJobRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobRunIds !== undefined) {
    bodyParams["JobRunIds"] = serializeAws_json1_1BatchStopJobRunJobRunIdList(
      input.JobRunIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1Condition = (
  input: Condition,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CrawlState !== undefined) {
    bodyParams["CrawlState"] = input.CrawlState;
  }
  if (input.CrawlerName !== undefined) {
    bodyParams["CrawlerName"] = input.CrawlerName;
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.LogicalOperator !== undefined) {
    bodyParams["LogicalOperator"] = input.LogicalOperator;
  }
  if (input.State !== undefined) {
    bodyParams["State"] = input.State;
  }
  return bodyParams;
};

const serializeAws_json1_1ConditionList = (
  input: Array<Condition>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Condition(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ConnectionsList = (
  input: ConnectionsList,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Connections !== undefined) {
    bodyParams["Connections"] = serializeAws_json1_1OrchestrationStringList(
      input.Connections,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateJobRequest = (
  input: CreateJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllocatedCapacity !== undefined) {
    bodyParams["AllocatedCapacity"] = input.AllocatedCapacity;
  }
  if (input.Command !== undefined) {
    bodyParams["Command"] = serializeAws_json1_1JobCommand(
      input.Command,
      context
    );
  }
  if (input.Connections !== undefined) {
    bodyParams["Connections"] = serializeAws_json1_1ConnectionsList(
      input.Connections,
      context
    );
  }
  if (input.DefaultArguments !== undefined) {
    bodyParams["DefaultArguments"] = serializeAws_json1_1GenericMap(
      input.DefaultArguments,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.ExecutionProperty !== undefined) {
    bodyParams["ExecutionProperty"] = serializeAws_json1_1ExecutionProperty(
      input.ExecutionProperty,
      context
    );
  }
  if (input.GlueVersion !== undefined) {
    bodyParams["GlueVersion"] = input.GlueVersion;
  }
  if (input.LogUri !== undefined) {
    bodyParams["LogUri"] = input.LogUri;
  }
  if (input.MaxCapacity !== undefined) {
    bodyParams["MaxCapacity"] = input.MaxCapacity;
  }
  if (input.MaxRetries !== undefined) {
    bodyParams["MaxRetries"] = input.MaxRetries;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NotificationProperty !== undefined) {
    bodyParams[
      "NotificationProperty"
    ] = serializeAws_json1_1NotificationProperty(
      input.NotificationProperty,
      context
    );
  }
  if (input.NumberOfWorkers !== undefined) {
    bodyParams["NumberOfWorkers"] = input.NumberOfWorkers;
  }
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  if (input.SecurityConfiguration !== undefined) {
    bodyParams["SecurityConfiguration"] = input.SecurityConfiguration;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagsMap(input.Tags, context);
  }
  if (input.Timeout !== undefined) {
    bodyParams["Timeout"] = input.Timeout;
  }
  if (input.WorkerType !== undefined) {
    bodyParams["WorkerType"] = input.WorkerType;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateTriggerRequest = (
  input: CreateTriggerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Actions !== undefined) {
    bodyParams["Actions"] = serializeAws_json1_1ActionList(
      input.Actions,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Predicate !== undefined) {
    bodyParams["Predicate"] = serializeAws_json1_1Predicate(
      input.Predicate,
      context
    );
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = input.Schedule;
  }
  if (input.StartOnCreation !== undefined) {
    bodyParams["StartOnCreation"] = input.StartOnCreation;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagsMap(input.Tags, context);
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.WorkflowName !== undefined) {
    bodyParams["WorkflowName"] = input.WorkflowName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateWorkflowRequest = (
  input: CreateWorkflowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DefaultRunProperties !== undefined) {
    bodyParams[
      "DefaultRunProperties"
    ] = serializeAws_json1_1WorkflowRunProperties(
      input.DefaultRunProperties,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagsMap(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteJobRequest = (
  input: DeleteJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteTriggerRequest = (
  input: DeleteTriggerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteWorkflowRequest = (
  input: DeleteWorkflowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1ExecutionProperty = (
  input: ExecutionProperty,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxConcurrentRuns !== undefined) {
    bodyParams["MaxConcurrentRuns"] = input.MaxConcurrentRuns;
  }
  return bodyParams;
};

const serializeAws_json1_1GenericMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1GetJobRequest = (
  input: GetJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetJobRunRequest = (
  input: GetJobRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.PredecessorsIncluded !== undefined) {
    bodyParams["PredecessorsIncluded"] = input.PredecessorsIncluded;
  }
  if (input.RunId !== undefined) {
    bodyParams["RunId"] = input.RunId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetJobRunsRequest = (
  input: GetJobRunsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetJobsRequest = (
  input: GetJobsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetTriggerRequest = (
  input: GetTriggerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1GetTriggersRequest = (
  input: GetTriggersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DependentJobName !== undefined) {
    bodyParams["DependentJobName"] = input.DependentJobName;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetWorkflowRequest = (
  input: GetWorkflowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.IncludeGraph !== undefined) {
    bodyParams["IncludeGraph"] = input.IncludeGraph;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1GetWorkflowRunPropertiesRequest = (
  input: GetWorkflowRunPropertiesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RunId !== undefined) {
    bodyParams["RunId"] = input.RunId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetWorkflowRunRequest = (
  input: GetWorkflowRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.IncludeGraph !== undefined) {
    bodyParams["IncludeGraph"] = input.IncludeGraph;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RunId !== undefined) {
    bodyParams["RunId"] = input.RunId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetWorkflowRunsRequest = (
  input: GetWorkflowRunsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.IncludeGraph !== undefined) {
    bodyParams["IncludeGraph"] = input.IncludeGraph;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1JobCommand = (
  input: JobCommand,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.PythonVersion !== undefined) {
    bodyParams["PythonVersion"] = input.PythonVersion;
  }
  if (input.ScriptLocation !== undefined) {
    bodyParams["ScriptLocation"] = input.ScriptLocation;
  }
  return bodyParams;
};

const serializeAws_json1_1JobNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1JobUpdate = (
  input: JobUpdate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllocatedCapacity !== undefined) {
    bodyParams["AllocatedCapacity"] = input.AllocatedCapacity;
  }
  if (input.Command !== undefined) {
    bodyParams["Command"] = serializeAws_json1_1JobCommand(
      input.Command,
      context
    );
  }
  if (input.Connections !== undefined) {
    bodyParams["Connections"] = serializeAws_json1_1ConnectionsList(
      input.Connections,
      context
    );
  }
  if (input.DefaultArguments !== undefined) {
    bodyParams["DefaultArguments"] = serializeAws_json1_1GenericMap(
      input.DefaultArguments,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.ExecutionProperty !== undefined) {
    bodyParams["ExecutionProperty"] = serializeAws_json1_1ExecutionProperty(
      input.ExecutionProperty,
      context
    );
  }
  if (input.GlueVersion !== undefined) {
    bodyParams["GlueVersion"] = input.GlueVersion;
  }
  if (input.LogUri !== undefined) {
    bodyParams["LogUri"] = input.LogUri;
  }
  if (input.MaxCapacity !== undefined) {
    bodyParams["MaxCapacity"] = input.MaxCapacity;
  }
  if (input.MaxRetries !== undefined) {
    bodyParams["MaxRetries"] = input.MaxRetries;
  }
  if (input.NotificationProperty !== undefined) {
    bodyParams[
      "NotificationProperty"
    ] = serializeAws_json1_1NotificationProperty(
      input.NotificationProperty,
      context
    );
  }
  if (input.NumberOfWorkers !== undefined) {
    bodyParams["NumberOfWorkers"] = input.NumberOfWorkers;
  }
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  if (input.SecurityConfiguration !== undefined) {
    bodyParams["SecurityConfiguration"] = input.SecurityConfiguration;
  }
  if (input.Timeout !== undefined) {
    bodyParams["Timeout"] = input.Timeout;
  }
  if (input.WorkerType !== undefined) {
    bodyParams["WorkerType"] = input.WorkerType;
  }
  return bodyParams;
};

const serializeAws_json1_1ListJobsRequest = (
  input: ListJobsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagsMap(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1ListTriggersRequest = (
  input: ListTriggersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DependentJobName !== undefined) {
    bodyParams["DependentJobName"] = input.DependentJobName;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagsMap(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1ListWorkflowsRequest = (
  input: ListWorkflowsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1NotificationProperty = (
  input: NotificationProperty,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.NotifyDelayAfter !== undefined) {
    bodyParams["NotifyDelayAfter"] = input.NotifyDelayAfter;
  }
  return bodyParams;
};

const serializeAws_json1_1OrchestrationStringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Predicate = (
  input: Predicate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Conditions !== undefined) {
    bodyParams["Conditions"] = serializeAws_json1_1ConditionList(
      input.Conditions,
      context
    );
  }
  if (input.Logical !== undefined) {
    bodyParams["Logical"] = input.Logical;
  }
  return bodyParams;
};

const serializeAws_json1_1PutWorkflowRunPropertiesRequest = (
  input: PutWorkflowRunPropertiesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RunId !== undefined) {
    bodyParams["RunId"] = input.RunId;
  }
  if (input.RunProperties !== undefined) {
    bodyParams["RunProperties"] = serializeAws_json1_1WorkflowRunProperties(
      input.RunProperties,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartJobRunRequest = (
  input: StartJobRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllocatedCapacity !== undefined) {
    bodyParams["AllocatedCapacity"] = input.AllocatedCapacity;
  }
  if (input.Arguments !== undefined) {
    bodyParams["Arguments"] = serializeAws_json1_1GenericMap(
      input.Arguments,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobRunId !== undefined) {
    bodyParams["JobRunId"] = input.JobRunId;
  }
  if (input.MaxCapacity !== undefined) {
    bodyParams["MaxCapacity"] = input.MaxCapacity;
  }
  if (input.NotificationProperty !== undefined) {
    bodyParams[
      "NotificationProperty"
    ] = serializeAws_json1_1NotificationProperty(
      input.NotificationProperty,
      context
    );
  }
  if (input.NumberOfWorkers !== undefined) {
    bodyParams["NumberOfWorkers"] = input.NumberOfWorkers;
  }
  if (input.SecurityConfiguration !== undefined) {
    bodyParams["SecurityConfiguration"] = input.SecurityConfiguration;
  }
  if (input.Timeout !== undefined) {
    bodyParams["Timeout"] = input.Timeout;
  }
  if (input.WorkerType !== undefined) {
    bodyParams["WorkerType"] = input.WorkerType;
  }
  return bodyParams;
};

const serializeAws_json1_1StartTriggerRequest = (
  input: StartTriggerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1StartWorkflowRunRequest = (
  input: StartWorkflowRunRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1StopTriggerRequest = (
  input: StopTriggerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1TriggerNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1TriggerUpdate = (
  input: TriggerUpdate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Actions !== undefined) {
    bodyParams["Actions"] = serializeAws_json1_1ActionList(
      input.Actions,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Predicate !== undefined) {
    bodyParams["Predicate"] = serializeAws_json1_1Predicate(
      input.Predicate,
      context
    );
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = input.Schedule;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateJobRequest = (
  input: UpdateJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobUpdate !== undefined) {
    bodyParams["JobUpdate"] = serializeAws_json1_1JobUpdate(
      input.JobUpdate,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateTriggerRequest = (
  input: UpdateTriggerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.TriggerUpdate !== undefined) {
    bodyParams["TriggerUpdate"] = serializeAws_json1_1TriggerUpdate(
      input.TriggerUpdate,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateWorkflowRequest = (
  input: UpdateWorkflowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DefaultRunProperties !== undefined) {
    bodyParams[
      "DefaultRunProperties"
    ] = serializeAws_json1_1WorkflowRunProperties(
      input.DefaultRunProperties,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1WorkflowNames = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1WorkflowRunProperties = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1BatchGetCrawlersRequest = (
  input: BatchGetCrawlersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CrawlerNames !== undefined) {
    bodyParams["CrawlerNames"] = serializeAws_json1_1CrawlerNameList(
      input.CrawlerNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CatalogEntries = (
  input: Array<CatalogEntry>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1CatalogEntry(entry, context));
  }
  return contents;
};

const serializeAws_json1_1CatalogEntry = (
  input: CatalogEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1CatalogTablesList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1CatalogTarget = (
  input: CatalogTarget,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.Tables !== undefined) {
    bodyParams["Tables"] = serializeAws_json1_1CatalogTablesList(
      input.Tables,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CatalogTargetList = (
  input: Array<CatalogTarget>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1CatalogTarget(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ClassifierNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1CodeGenEdge = (
  input: CodeGenEdge,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Source !== undefined) {
    bodyParams["Source"] = input.Source;
  }
  if (input.Target !== undefined) {
    bodyParams["Target"] = input.Target;
  }
  if (input.TargetParameter !== undefined) {
    bodyParams["TargetParameter"] = input.TargetParameter;
  }
  return bodyParams;
};

const serializeAws_json1_1CodeGenNode = (
  input: CodeGenNode,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Args !== undefined) {
    bodyParams["Args"] = serializeAws_json1_1CodeGenNodeArgs(
      input.Args,
      context
    );
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.LineNumber !== undefined) {
    bodyParams["LineNumber"] = input.LineNumber;
  }
  if (input.NodeType !== undefined) {
    bodyParams["NodeType"] = input.NodeType;
  }
  return bodyParams;
};

const serializeAws_json1_1CodeGenNodeArg = (
  input: CodeGenNodeArg,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Param !== undefined) {
    bodyParams["Param"] = input.Param;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1CodeGenNodeArgs = (
  input: Array<CodeGenNodeArg>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1CodeGenNodeArg(entry, context));
  }
  return contents;
};

const serializeAws_json1_1CrawlerNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1CrawlerTargets = (
  input: CrawlerTargets,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CatalogTargets !== undefined) {
    bodyParams["CatalogTargets"] = serializeAws_json1_1CatalogTargetList(
      input.CatalogTargets,
      context
    );
  }
  if (input.DynamoDBTargets !== undefined) {
    bodyParams["DynamoDBTargets"] = serializeAws_json1_1DynamoDBTargetList(
      input.DynamoDBTargets,
      context
    );
  }
  if (input.JdbcTargets !== undefined) {
    bodyParams["JdbcTargets"] = serializeAws_json1_1JdbcTargetList(
      input.JdbcTargets,
      context
    );
  }
  if (input.S3Targets !== undefined) {
    bodyParams["S3Targets"] = serializeAws_json1_1S3TargetList(
      input.S3Targets,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateClassifierRequest = (
  input: CreateClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CsvClassifier !== undefined) {
    bodyParams[
      "CsvClassifier"
    ] = serializeAws_json1_1CreateCsvClassifierRequest(
      input.CsvClassifier,
      context
    );
  }
  if (input.GrokClassifier !== undefined) {
    bodyParams[
      "GrokClassifier"
    ] = serializeAws_json1_1CreateGrokClassifierRequest(
      input.GrokClassifier,
      context
    );
  }
  if (input.JsonClassifier !== undefined) {
    bodyParams[
      "JsonClassifier"
    ] = serializeAws_json1_1CreateJsonClassifierRequest(
      input.JsonClassifier,
      context
    );
  }
  if (input.XMLClassifier !== undefined) {
    bodyParams[
      "XMLClassifier"
    ] = serializeAws_json1_1CreateXMLClassifierRequest(
      input.XMLClassifier,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateCrawlerRequest = (
  input: CreateCrawlerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Classifiers !== undefined) {
    bodyParams["Classifiers"] = serializeAws_json1_1ClassifierNameList(
      input.Classifiers,
      context
    );
  }
  if (input.Configuration !== undefined) {
    bodyParams["Configuration"] = input.Configuration;
  }
  if (input.CrawlerSecurityConfiguration !== undefined) {
    bodyParams["CrawlerSecurityConfiguration"] =
      input.CrawlerSecurityConfiguration;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = input.Schedule;
  }
  if (input.SchemaChangePolicy !== undefined) {
    bodyParams["SchemaChangePolicy"] = serializeAws_json1_1SchemaChangePolicy(
      input.SchemaChangePolicy,
      context
    );
  }
  if (input.TablePrefix !== undefined) {
    bodyParams["TablePrefix"] = input.TablePrefix;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagsMap(input.Tags, context);
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1CrawlerTargets(
      input.Targets,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateCsvClassifierRequest = (
  input: CreateCsvClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllowSingleColumn !== undefined) {
    bodyParams["AllowSingleColumn"] = input.AllowSingleColumn;
  }
  if (input.ContainsHeader !== undefined) {
    bodyParams["ContainsHeader"] = input.ContainsHeader;
  }
  if (input.Delimiter !== undefined) {
    bodyParams["Delimiter"] = input.Delimiter;
  }
  if (input.DisableValueTrimming !== undefined) {
    bodyParams["DisableValueTrimming"] = input.DisableValueTrimming;
  }
  if (input.Header !== undefined) {
    bodyParams["Header"] = serializeAws_json1_1CsvHeader(input.Header, context);
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.QuoteSymbol !== undefined) {
    bodyParams["QuoteSymbol"] = input.QuoteSymbol;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateGrokClassifierRequest = (
  input: CreateGrokClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Classification !== undefined) {
    bodyParams["Classification"] = input.Classification;
  }
  if (input.CustomPatterns !== undefined) {
    bodyParams["CustomPatterns"] = input.CustomPatterns;
  }
  if (input.GrokPattern !== undefined) {
    bodyParams["GrokPattern"] = input.GrokPattern;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateJsonClassifierRequest = (
  input: CreateJsonClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JsonPath !== undefined) {
    bodyParams["JsonPath"] = input.JsonPath;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateScriptRequest = (
  input: CreateScriptRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DagEdges !== undefined) {
    bodyParams["DagEdges"] = serializeAws_json1_1DagEdges(
      input.DagEdges,
      context
    );
  }
  if (input.DagNodes !== undefined) {
    bodyParams["DagNodes"] = serializeAws_json1_1DagNodes(
      input.DagNodes,
      context
    );
  }
  if (input.Language !== undefined) {
    bodyParams["Language"] = input.Language;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateXMLClassifierRequest = (
  input: CreateXMLClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Classification !== undefined) {
    bodyParams["Classification"] = input.Classification;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RowTag !== undefined) {
    bodyParams["RowTag"] = input.RowTag;
  }
  return bodyParams;
};

const serializeAws_json1_1CsvHeader = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1DagEdges = (
  input: Array<CodeGenEdge>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1CodeGenEdge(entry, context));
  }
  return contents;
};

const serializeAws_json1_1DagNodes = (
  input: Array<CodeGenNode>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1CodeGenNode(entry, context));
  }
  return contents;
};

const serializeAws_json1_1DeleteClassifierRequest = (
  input: DeleteClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteCrawlerRequest = (
  input: DeleteCrawlerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DynamoDBTarget = (
  input: DynamoDBTarget,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Path !== undefined) {
    bodyParams["Path"] = input.Path;
  }
  return bodyParams;
};

const serializeAws_json1_1DynamoDBTargetList = (
  input: Array<DynamoDBTarget>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1DynamoDBTarget(entry, context));
  }
  return contents;
};

const serializeAws_json1_1GetClassifierRequest = (
  input: GetClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1GetClassifiersRequest = (
  input: GetClassifiersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetCrawlerMetricsRequest = (
  input: GetCrawlerMetricsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CrawlerNameList !== undefined) {
    bodyParams["CrawlerNameList"] = serializeAws_json1_1CrawlerNameList(
      input.CrawlerNameList,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetCrawlerRequest = (
  input: GetCrawlerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1GetCrawlersRequest = (
  input: GetCrawlersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDataflowGraphRequest = (
  input: GetDataflowGraphRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.PythonScript !== undefined) {
    bodyParams["PythonScript"] = input.PythonScript;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMappingRequest = (
  input: GetMappingRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Location !== undefined) {
    bodyParams["Location"] = serializeAws_json1_1Location(
      input.Location,
      context
    );
  }
  if (input.Sinks !== undefined) {
    bodyParams["Sinks"] = serializeAws_json1_1CatalogEntries(
      input.Sinks,
      context
    );
  }
  if (input.Source !== undefined) {
    bodyParams["Source"] = serializeAws_json1_1CatalogEntry(
      input.Source,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1GetPlanRequest = (
  input: GetPlanRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Language !== undefined) {
    bodyParams["Language"] = input.Language;
  }
  if (input.Location !== undefined) {
    bodyParams["Location"] = serializeAws_json1_1Location(
      input.Location,
      context
    );
  }
  if (input.Mapping !== undefined) {
    bodyParams["Mapping"] = serializeAws_json1_1MappingList(
      input.Mapping,
      context
    );
  }
  if (input.Sinks !== undefined) {
    bodyParams["Sinks"] = serializeAws_json1_1CatalogEntries(
      input.Sinks,
      context
    );
  }
  if (input.Source !== undefined) {
    bodyParams["Source"] = serializeAws_json1_1CatalogEntry(
      input.Source,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1JdbcTarget = (
  input: JdbcTarget,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConnectionName !== undefined) {
    bodyParams["ConnectionName"] = input.ConnectionName;
  }
  if (input.Exclusions !== undefined) {
    bodyParams["Exclusions"] = serializeAws_json1_1PathList(
      input.Exclusions,
      context
    );
  }
  if (input.Path !== undefined) {
    bodyParams["Path"] = input.Path;
  }
  return bodyParams;
};

const serializeAws_json1_1JdbcTargetList = (
  input: Array<JdbcTarget>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1JdbcTarget(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ListCrawlersRequest = (
  input: ListCrawlersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagsMap(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1Location = (
  input: Location,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DynamoDB !== undefined) {
    bodyParams["DynamoDB"] = serializeAws_json1_1CodeGenNodeArgs(
      input.DynamoDB,
      context
    );
  }
  if (input.Jdbc !== undefined) {
    bodyParams["Jdbc"] = serializeAws_json1_1CodeGenNodeArgs(
      input.Jdbc,
      context
    );
  }
  if (input.S3 !== undefined) {
    bodyParams["S3"] = serializeAws_json1_1CodeGenNodeArgs(input.S3, context);
  }
  return bodyParams;
};

const serializeAws_json1_1MappingEntry = (
  input: MappingEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SourcePath !== undefined) {
    bodyParams["SourcePath"] = input.SourcePath;
  }
  if (input.SourceTable !== undefined) {
    bodyParams["SourceTable"] = input.SourceTable;
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  if (input.TargetPath !== undefined) {
    bodyParams["TargetPath"] = input.TargetPath;
  }
  if (input.TargetTable !== undefined) {
    bodyParams["TargetTable"] = input.TargetTable;
  }
  if (input.TargetType !== undefined) {
    bodyParams["TargetType"] = input.TargetType;
  }
  return bodyParams;
};

const serializeAws_json1_1MappingList = (
  input: Array<MappingEntry>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1MappingEntry(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PathList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1S3Target = (
  input: S3Target,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Exclusions !== undefined) {
    bodyParams["Exclusions"] = serializeAws_json1_1PathList(
      input.Exclusions,
      context
    );
  }
  if (input.Path !== undefined) {
    bodyParams["Path"] = input.Path;
  }
  return bodyParams;
};

const serializeAws_json1_1S3TargetList = (
  input: Array<S3Target>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1S3Target(entry, context));
  }
  return contents;
};

const serializeAws_json1_1SchemaChangePolicy = (
  input: SchemaChangePolicy,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeleteBehavior !== undefined) {
    bodyParams["DeleteBehavior"] = input.DeleteBehavior;
  }
  if (input.UpdateBehavior !== undefined) {
    bodyParams["UpdateBehavior"] = input.UpdateBehavior;
  }
  return bodyParams;
};

const serializeAws_json1_1StartCrawlerRequest = (
  input: StartCrawlerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1StartCrawlerScheduleRequest = (
  input: StartCrawlerScheduleRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CrawlerName !== undefined) {
    bodyParams["CrawlerName"] = input.CrawlerName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopCrawlerRequest = (
  input: StopCrawlerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1StopCrawlerScheduleRequest = (
  input: StopCrawlerScheduleRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CrawlerName !== undefined) {
    bodyParams["CrawlerName"] = input.CrawlerName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateClassifierRequest = (
  input: UpdateClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CsvClassifier !== undefined) {
    bodyParams[
      "CsvClassifier"
    ] = serializeAws_json1_1UpdateCsvClassifierRequest(
      input.CsvClassifier,
      context
    );
  }
  if (input.GrokClassifier !== undefined) {
    bodyParams[
      "GrokClassifier"
    ] = serializeAws_json1_1UpdateGrokClassifierRequest(
      input.GrokClassifier,
      context
    );
  }
  if (input.JsonClassifier !== undefined) {
    bodyParams[
      "JsonClassifier"
    ] = serializeAws_json1_1UpdateJsonClassifierRequest(
      input.JsonClassifier,
      context
    );
  }
  if (input.XMLClassifier !== undefined) {
    bodyParams[
      "XMLClassifier"
    ] = serializeAws_json1_1UpdateXMLClassifierRequest(
      input.XMLClassifier,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateCrawlerRequest = (
  input: UpdateCrawlerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Classifiers !== undefined) {
    bodyParams["Classifiers"] = serializeAws_json1_1ClassifierNameList(
      input.Classifiers,
      context
    );
  }
  if (input.Configuration !== undefined) {
    bodyParams["Configuration"] = input.Configuration;
  }
  if (input.CrawlerSecurityConfiguration !== undefined) {
    bodyParams["CrawlerSecurityConfiguration"] =
      input.CrawlerSecurityConfiguration;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = input.Schedule;
  }
  if (input.SchemaChangePolicy !== undefined) {
    bodyParams["SchemaChangePolicy"] = serializeAws_json1_1SchemaChangePolicy(
      input.SchemaChangePolicy,
      context
    );
  }
  if (input.TablePrefix !== undefined) {
    bodyParams["TablePrefix"] = input.TablePrefix;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1CrawlerTargets(
      input.Targets,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateCrawlerScheduleRequest = (
  input: UpdateCrawlerScheduleRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CrawlerName !== undefined) {
    bodyParams["CrawlerName"] = input.CrawlerName;
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = input.Schedule;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateCsvClassifierRequest = (
  input: UpdateCsvClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllowSingleColumn !== undefined) {
    bodyParams["AllowSingleColumn"] = input.AllowSingleColumn;
  }
  if (input.ContainsHeader !== undefined) {
    bodyParams["ContainsHeader"] = input.ContainsHeader;
  }
  if (input.Delimiter !== undefined) {
    bodyParams["Delimiter"] = input.Delimiter;
  }
  if (input.DisableValueTrimming !== undefined) {
    bodyParams["DisableValueTrimming"] = input.DisableValueTrimming;
  }
  if (input.Header !== undefined) {
    bodyParams["Header"] = serializeAws_json1_1CsvHeader(input.Header, context);
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.QuoteSymbol !== undefined) {
    bodyParams["QuoteSymbol"] = input.QuoteSymbol;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateGrokClassifierRequest = (
  input: UpdateGrokClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Classification !== undefined) {
    bodyParams["Classification"] = input.Classification;
  }
  if (input.CustomPatterns !== undefined) {
    bodyParams["CustomPatterns"] = input.CustomPatterns;
  }
  if (input.GrokPattern !== undefined) {
    bodyParams["GrokPattern"] = input.GrokPattern;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateJsonClassifierRequest = (
  input: UpdateJsonClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JsonPath !== undefined) {
    bodyParams["JsonPath"] = input.JsonPath;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateXMLClassifierRequest = (
  input: UpdateXMLClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Classification !== undefined) {
    bodyParams["Classification"] = input.Classification;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RowTag !== undefined) {
    bodyParams["RowTag"] = input.RowTag;
  }
  return bodyParams;
};

const deserializeAws_json1_1GetTagsResponse = (
  output: any,
  context: __SerdeContext
): GetTagsResponse => {
  let contents: any = {
    __type: "GetTagsResponse",
    Tags: undefined
  };
  if (output.Tags !== undefined && output.Tags !== null) {
    contents.Tags = deserializeAws_json1_1TagsMap(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1TagResourceResponse = (
  output: any,
  context: __SerdeContext
): TagResourceResponse => {
  let contents: any = {
    __type: "TagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1UntagResourceResponse = (
  output: any,
  context: __SerdeContext
): UntagResourceResponse => {
  let contents: any = {
    __type: "UntagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1NameStringList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1TagsMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1AccessDeniedException = (
  output: any,
  context: __SerdeContext
): AccessDeniedException => {
  let contents: any = {
    __type: "AccessDeniedException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1AlreadyExistsException = (
  output: any,
  context: __SerdeContext
): AlreadyExistsException => {
  let contents: any = {
    __type: "AlreadyExistsException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ConcurrentModificationException = (
  output: any,
  context: __SerdeContext
): ConcurrentModificationException => {
  let contents: any = {
    __type: "ConcurrentModificationException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ConcurrentRunsExceededException = (
  output: any,
  context: __SerdeContext
): ConcurrentRunsExceededException => {
  let contents: any = {
    __type: "ConcurrentRunsExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ConditionCheckFailureException = (
  output: any,
  context: __SerdeContext
): ConditionCheckFailureException => {
  let contents: any = {
    __type: "ConditionCheckFailureException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1EntityNotFoundException = (
  output: any,
  context: __SerdeContext
): EntityNotFoundException => {
  let contents: any = {
    __type: "EntityNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ErrorDetail = (
  output: any,
  context: __SerdeContext
): ErrorDetail => {
  let contents: any = {
    __type: "ErrorDetail",
    ErrorCode: undefined,
    ErrorMessage: undefined
  };
  if (output.ErrorCode !== undefined && output.ErrorCode !== null) {
    contents.ErrorCode = output.ErrorCode;
  }
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  return contents;
};

const deserializeAws_json1_1GlueEncryptionException = (
  output: any,
  context: __SerdeContext
): GlueEncryptionException => {
  let contents: any = {
    __type: "GlueEncryptionException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1IdempotentParameterMismatchException = (
  output: any,
  context: __SerdeContext
): IdempotentParameterMismatchException => {
  let contents: any = {
    __type: "IdempotentParameterMismatchException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InternalServiceException = (
  output: any,
  context: __SerdeContext
): InternalServiceException => {
  let contents: any = {
    __type: "InternalServiceException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidInputException = (
  output: any,
  context: __SerdeContext
): InvalidInputException => {
  let contents: any = {
    __type: "InvalidInputException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1OperationTimeoutException = (
  output: any,
  context: __SerdeContext
): OperationTimeoutException => {
  let contents: any = {
    __type: "OperationTimeoutException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceNumberLimitExceededException = (
  output: any,
  context: __SerdeContext
): ResourceNumberLimitExceededException => {
  let contents: any = {
    __type: "ResourceNumberLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ValidationException = (
  output: any,
  context: __SerdeContext
): ValidationException => {
  let contents: any = {
    __type: "ValidationException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1VersionMismatchException = (
  output: any,
  context: __SerdeContext
): VersionMismatchException => {
  let contents: any = {
    __type: "VersionMismatchException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1BatchCreatePartitionResponse = (
  output: any,
  context: __SerdeContext
): BatchCreatePartitionResponse => {
  let contents: any = {
    __type: "BatchCreatePartitionResponse",
    Errors: undefined
  };
  if (output.Errors !== undefined && output.Errors !== null) {
    contents.Errors = deserializeAws_json1_1PartitionErrors(
      output.Errors,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDeleteConnectionResponse = (
  output: any,
  context: __SerdeContext
): BatchDeleteConnectionResponse => {
  let contents: any = {
    __type: "BatchDeleteConnectionResponse",
    Errors: undefined,
    Succeeded: undefined
  };
  if (output.Errors !== undefined && output.Errors !== null) {
    contents.Errors = deserializeAws_json1_1ErrorByName(output.Errors, context);
  }
  if (output.Succeeded !== undefined && output.Succeeded !== null) {
    contents.Succeeded = deserializeAws_json1_1NameStringList(
      output.Succeeded,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDeletePartitionResponse = (
  output: any,
  context: __SerdeContext
): BatchDeletePartitionResponse => {
  let contents: any = {
    __type: "BatchDeletePartitionResponse",
    Errors: undefined
  };
  if (output.Errors !== undefined && output.Errors !== null) {
    contents.Errors = deserializeAws_json1_1PartitionErrors(
      output.Errors,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDeleteTableResponse = (
  output: any,
  context: __SerdeContext
): BatchDeleteTableResponse => {
  let contents: any = {
    __type: "BatchDeleteTableResponse",
    Errors: undefined
  };
  if (output.Errors !== undefined && output.Errors !== null) {
    contents.Errors = deserializeAws_json1_1TableErrors(output.Errors, context);
  }
  return contents;
};

const deserializeAws_json1_1BatchDeleteTableVersionResponse = (
  output: any,
  context: __SerdeContext
): BatchDeleteTableVersionResponse => {
  let contents: any = {
    __type: "BatchDeleteTableVersionResponse",
    Errors: undefined
  };
  if (output.Errors !== undefined && output.Errors !== null) {
    contents.Errors = deserializeAws_json1_1TableVersionErrors(
      output.Errors,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchGetPartitionResponse = (
  output: any,
  context: __SerdeContext
): BatchGetPartitionResponse => {
  let contents: any = {
    __type: "BatchGetPartitionResponse",
    Partitions: undefined,
    UnprocessedKeys: undefined
  };
  if (output.Partitions !== undefined && output.Partitions !== null) {
    contents.Partitions = deserializeAws_json1_1PartitionList(
      output.Partitions,
      context
    );
  }
  if (output.UnprocessedKeys !== undefined && output.UnprocessedKeys !== null) {
    contents.UnprocessedKeys = deserializeAws_json1_1BatchGetPartitionValueList(
      output.UnprocessedKeys,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchGetPartitionValueList = (
  output: any,
  context: __SerdeContext
): Array<PartitionValueList> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PartitionValueList(entry, context)
  );
};

const deserializeAws_json1_1CatalogImportStatus = (
  output: any,
  context: __SerdeContext
): CatalogImportStatus => {
  let contents: any = {
    __type: "CatalogImportStatus",
    ImportCompleted: undefined,
    ImportTime: undefined,
    ImportedBy: undefined
  };
  if (output.ImportCompleted !== undefined && output.ImportCompleted !== null) {
    contents.ImportCompleted = output.ImportCompleted;
  }
  if (output.ImportTime !== undefined && output.ImportTime !== null) {
    contents.ImportTime = new Date(Math.round(output.ImportTime * 1000));
  }
  if (output.ImportedBy !== undefined && output.ImportedBy !== null) {
    contents.ImportedBy = output.ImportedBy;
  }
  return contents;
};

const deserializeAws_json1_1Column = (
  output: any,
  context: __SerdeContext
): Column => {
  let contents: any = {
    __type: "Column",
    Comment: undefined,
    Name: undefined,
    Parameters: undefined,
    Type: undefined
  };
  if (output.Comment !== undefined && output.Comment !== null) {
    contents.Comment = output.Comment;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParametersMap(
      output.Parameters,
      context
    );
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1ColumnList = (
  output: any,
  context: __SerdeContext
): Array<Column> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Column(entry, context)
  );
};

const deserializeAws_json1_1ColumnValueStringList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Connection = (
  output: any,
  context: __SerdeContext
): Connection => {
  let contents: any = {
    __type: "Connection",
    ConnectionProperties: undefined,
    ConnectionType: undefined,
    CreationTime: undefined,
    Description: undefined,
    LastUpdatedBy: undefined,
    LastUpdatedTime: undefined,
    MatchCriteria: undefined,
    Name: undefined,
    PhysicalConnectionRequirements: undefined
  };
  if (
    output.ConnectionProperties !== undefined &&
    output.ConnectionProperties !== null
  ) {
    contents.ConnectionProperties = deserializeAws_json1_1ConnectionProperties(
      output.ConnectionProperties,
      context
    );
  }
  if (output.ConnectionType !== undefined && output.ConnectionType !== null) {
    contents.ConnectionType = output.ConnectionType;
  }
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.LastUpdatedBy !== undefined && output.LastUpdatedBy !== null) {
    contents.LastUpdatedBy = output.LastUpdatedBy;
  }
  if (output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null) {
    contents.LastUpdatedTime = new Date(
      Math.round(output.LastUpdatedTime * 1000)
    );
  }
  if (output.MatchCriteria !== undefined && output.MatchCriteria !== null) {
    contents.MatchCriteria = deserializeAws_json1_1MatchCriteria(
      output.MatchCriteria,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.PhysicalConnectionRequirements !== undefined &&
    output.PhysicalConnectionRequirements !== null
  ) {
    contents.PhysicalConnectionRequirements = deserializeAws_json1_1PhysicalConnectionRequirements(
      output.PhysicalConnectionRequirements,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ConnectionList = (
  output: any,
  context: __SerdeContext
): Array<Connection> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Connection(entry, context)
  );
};

const deserializeAws_json1_1ConnectionPasswordEncryption = (
  output: any,
  context: __SerdeContext
): ConnectionPasswordEncryption => {
  let contents: any = {
    __type: "ConnectionPasswordEncryption",
    AwsKmsKeyId: undefined,
    ReturnConnectionPasswordEncrypted: undefined
  };
  if (output.AwsKmsKeyId !== undefined && output.AwsKmsKeyId !== null) {
    contents.AwsKmsKeyId = output.AwsKmsKeyId;
  }
  if (
    output.ReturnConnectionPasswordEncrypted !== undefined &&
    output.ReturnConnectionPasswordEncrypted !== null
  ) {
    contents.ReturnConnectionPasswordEncrypted =
      output.ReturnConnectionPasswordEncrypted;
  }
  return contents;
};

const deserializeAws_json1_1ConnectionProperties = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1CreateConnectionResponse = (
  output: any,
  context: __SerdeContext
): CreateConnectionResponse => {
  let contents: any = {
    __type: "CreateConnectionResponse"
  };
  return contents;
};

const deserializeAws_json1_1CreateDatabaseResponse = (
  output: any,
  context: __SerdeContext
): CreateDatabaseResponse => {
  let contents: any = {
    __type: "CreateDatabaseResponse"
  };
  return contents;
};

const deserializeAws_json1_1CreatePartitionResponse = (
  output: any,
  context: __SerdeContext
): CreatePartitionResponse => {
  let contents: any = {
    __type: "CreatePartitionResponse"
  };
  return contents;
};

const deserializeAws_json1_1CreateTableResponse = (
  output: any,
  context: __SerdeContext
): CreateTableResponse => {
  let contents: any = {
    __type: "CreateTableResponse"
  };
  return contents;
};

const deserializeAws_json1_1CreateUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): CreateUserDefinedFunctionResponse => {
  let contents: any = {
    __type: "CreateUserDefinedFunctionResponse"
  };
  return contents;
};

const deserializeAws_json1_1DataCatalogEncryptionSettings = (
  output: any,
  context: __SerdeContext
): DataCatalogEncryptionSettings => {
  let contents: any = {
    __type: "DataCatalogEncryptionSettings",
    ConnectionPasswordEncryption: undefined,
    EncryptionAtRest: undefined
  };
  if (
    output.ConnectionPasswordEncryption !== undefined &&
    output.ConnectionPasswordEncryption !== null
  ) {
    contents.ConnectionPasswordEncryption = deserializeAws_json1_1ConnectionPasswordEncryption(
      output.ConnectionPasswordEncryption,
      context
    );
  }
  if (
    output.EncryptionAtRest !== undefined &&
    output.EncryptionAtRest !== null
  ) {
    contents.EncryptionAtRest = deserializeAws_json1_1EncryptionAtRest(
      output.EncryptionAtRest,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DataLakePrincipal = (
  output: any,
  context: __SerdeContext
): DataLakePrincipal => {
  let contents: any = {
    __type: "DataLakePrincipal",
    DataLakePrincipalIdentifier: undefined
  };
  if (
    output.DataLakePrincipalIdentifier !== undefined &&
    output.DataLakePrincipalIdentifier !== null
  ) {
    contents.DataLakePrincipalIdentifier = output.DataLakePrincipalIdentifier;
  }
  return contents;
};

const deserializeAws_json1_1Database = (
  output: any,
  context: __SerdeContext
): Database => {
  let contents: any = {
    __type: "Database",
    CreateTableDefaultPermissions: undefined,
    CreateTime: undefined,
    Description: undefined,
    LocationUri: undefined,
    Name: undefined,
    Parameters: undefined
  };
  if (
    output.CreateTableDefaultPermissions !== undefined &&
    output.CreateTableDefaultPermissions !== null
  ) {
    contents.CreateTableDefaultPermissions = deserializeAws_json1_1PrincipalPermissionsList(
      output.CreateTableDefaultPermissions,
      context
    );
  }
  if (output.CreateTime !== undefined && output.CreateTime !== null) {
    contents.CreateTime = new Date(Math.round(output.CreateTime * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.LocationUri !== undefined && output.LocationUri !== null) {
    contents.LocationUri = output.LocationUri;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParametersMap(
      output.Parameters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DatabaseList = (
  output: any,
  context: __SerdeContext
): Array<Database> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Database(entry, context)
  );
};

const deserializeAws_json1_1DeleteConnectionResponse = (
  output: any,
  context: __SerdeContext
): DeleteConnectionResponse => {
  let contents: any = {
    __type: "DeleteConnectionResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteDatabaseResponse = (
  output: any,
  context: __SerdeContext
): DeleteDatabaseResponse => {
  let contents: any = {
    __type: "DeleteDatabaseResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeletePartitionResponse = (
  output: any,
  context: __SerdeContext
): DeletePartitionResponse => {
  let contents: any = {
    __type: "DeletePartitionResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteResourcePolicyResponse = (
  output: any,
  context: __SerdeContext
): DeleteResourcePolicyResponse => {
  let contents: any = {
    __type: "DeleteResourcePolicyResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteTableResponse = (
  output: any,
  context: __SerdeContext
): DeleteTableResponse => {
  let contents: any = {
    __type: "DeleteTableResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteTableVersionResponse = (
  output: any,
  context: __SerdeContext
): DeleteTableVersionResponse => {
  let contents: any = {
    __type: "DeleteTableVersionResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): DeleteUserDefinedFunctionResponse => {
  let contents: any = {
    __type: "DeleteUserDefinedFunctionResponse"
  };
  return contents;
};

const deserializeAws_json1_1EncryptionAtRest = (
  output: any,
  context: __SerdeContext
): EncryptionAtRest => {
  let contents: any = {
    __type: "EncryptionAtRest",
    CatalogEncryptionMode: undefined,
    SseAwsKmsKeyId: undefined
  };
  if (
    output.CatalogEncryptionMode !== undefined &&
    output.CatalogEncryptionMode !== null
  ) {
    contents.CatalogEncryptionMode = output.CatalogEncryptionMode;
  }
  if (output.SseAwsKmsKeyId !== undefined && output.SseAwsKmsKeyId !== null) {
    contents.SseAwsKmsKeyId = output.SseAwsKmsKeyId;
  }
  return contents;
};

const deserializeAws_json1_1ErrorByName = (
  output: any,
  context: __SerdeContext
): { [key: string]: ErrorDetail } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1ErrorDetail(output[key], context);
  });
  return mapParams;
};

const deserializeAws_json1_1GetCatalogImportStatusResponse = (
  output: any,
  context: __SerdeContext
): GetCatalogImportStatusResponse => {
  let contents: any = {
    __type: "GetCatalogImportStatusResponse",
    ImportStatus: undefined
  };
  if (output.ImportStatus !== undefined && output.ImportStatus !== null) {
    contents.ImportStatus = deserializeAws_json1_1CatalogImportStatus(
      output.ImportStatus,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetConnectionResponse = (
  output: any,
  context: __SerdeContext
): GetConnectionResponse => {
  let contents: any = {
    __type: "GetConnectionResponse",
    Connection: undefined
  };
  if (output.Connection !== undefined && output.Connection !== null) {
    contents.Connection = deserializeAws_json1_1Connection(
      output.Connection,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetConnectionsResponse = (
  output: any,
  context: __SerdeContext
): GetConnectionsResponse => {
  let contents: any = {
    __type: "GetConnectionsResponse",
    ConnectionList: undefined,
    NextToken: undefined
  };
  if (output.ConnectionList !== undefined && output.ConnectionList !== null) {
    contents.ConnectionList = deserializeAws_json1_1ConnectionList(
      output.ConnectionList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetDataCatalogEncryptionSettingsResponse = (
  output: any,
  context: __SerdeContext
): GetDataCatalogEncryptionSettingsResponse => {
  let contents: any = {
    __type: "GetDataCatalogEncryptionSettingsResponse",
    DataCatalogEncryptionSettings: undefined
  };
  if (
    output.DataCatalogEncryptionSettings !== undefined &&
    output.DataCatalogEncryptionSettings !== null
  ) {
    contents.DataCatalogEncryptionSettings = deserializeAws_json1_1DataCatalogEncryptionSettings(
      output.DataCatalogEncryptionSettings,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetDatabaseResponse = (
  output: any,
  context: __SerdeContext
): GetDatabaseResponse => {
  let contents: any = {
    __type: "GetDatabaseResponse",
    Database: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = deserializeAws_json1_1Database(
      output.Database,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetDatabasesResponse = (
  output: any,
  context: __SerdeContext
): GetDatabasesResponse => {
  let contents: any = {
    __type: "GetDatabasesResponse",
    DatabaseList: undefined,
    NextToken: undefined
  };
  if (output.DatabaseList !== undefined && output.DatabaseList !== null) {
    contents.DatabaseList = deserializeAws_json1_1DatabaseList(
      output.DatabaseList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetPartitionResponse = (
  output: any,
  context: __SerdeContext
): GetPartitionResponse => {
  let contents: any = {
    __type: "GetPartitionResponse",
    Partition: undefined
  };
  if (output.Partition !== undefined && output.Partition !== null) {
    contents.Partition = deserializeAws_json1_1Partition(
      output.Partition,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetPartitionsResponse = (
  output: any,
  context: __SerdeContext
): GetPartitionsResponse => {
  let contents: any = {
    __type: "GetPartitionsResponse",
    NextToken: undefined,
    Partitions: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Partitions !== undefined && output.Partitions !== null) {
    contents.Partitions = deserializeAws_json1_1PartitionList(
      output.Partitions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetResourcePolicyResponse = (
  output: any,
  context: __SerdeContext
): GetResourcePolicyResponse => {
  let contents: any = {
    __type: "GetResourcePolicyResponse",
    CreateTime: undefined,
    PolicyHash: undefined,
    PolicyInJson: undefined,
    UpdateTime: undefined
  };
  if (output.CreateTime !== undefined && output.CreateTime !== null) {
    contents.CreateTime = new Date(Math.round(output.CreateTime * 1000));
  }
  if (output.PolicyHash !== undefined && output.PolicyHash !== null) {
    contents.PolicyHash = output.PolicyHash;
  }
  if (output.PolicyInJson !== undefined && output.PolicyInJson !== null) {
    contents.PolicyInJson = output.PolicyInJson;
  }
  if (output.UpdateTime !== undefined && output.UpdateTime !== null) {
    contents.UpdateTime = new Date(Math.round(output.UpdateTime * 1000));
  }
  return contents;
};

const deserializeAws_json1_1GetTableResponse = (
  output: any,
  context: __SerdeContext
): GetTableResponse => {
  let contents: any = {
    __type: "GetTableResponse",
    Table: undefined
  };
  if (output.Table !== undefined && output.Table !== null) {
    contents.Table = deserializeAws_json1_1Table(output.Table, context);
  }
  return contents;
};

const deserializeAws_json1_1GetTableVersionResponse = (
  output: any,
  context: __SerdeContext
): GetTableVersionResponse => {
  let contents: any = {
    __type: "GetTableVersionResponse",
    TableVersion: undefined
  };
  if (output.TableVersion !== undefined && output.TableVersion !== null) {
    contents.TableVersion = deserializeAws_json1_1TableVersion(
      output.TableVersion,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetTableVersionsList = (
  output: any,
  context: __SerdeContext
): Array<TableVersion> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TableVersion(entry, context)
  );
};

const deserializeAws_json1_1GetTableVersionsResponse = (
  output: any,
  context: __SerdeContext
): GetTableVersionsResponse => {
  let contents: any = {
    __type: "GetTableVersionsResponse",
    NextToken: undefined,
    TableVersions: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TableVersions !== undefined && output.TableVersions !== null) {
    contents.TableVersions = deserializeAws_json1_1GetTableVersionsList(
      output.TableVersions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetTablesResponse = (
  output: any,
  context: __SerdeContext
): GetTablesResponse => {
  let contents: any = {
    __type: "GetTablesResponse",
    NextToken: undefined,
    TableList: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TableList !== undefined && output.TableList !== null) {
    contents.TableList = deserializeAws_json1_1TableList(
      output.TableList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): GetUserDefinedFunctionResponse => {
  let contents: any = {
    __type: "GetUserDefinedFunctionResponse",
    UserDefinedFunction: undefined
  };
  if (
    output.UserDefinedFunction !== undefined &&
    output.UserDefinedFunction !== null
  ) {
    contents.UserDefinedFunction = deserializeAws_json1_1UserDefinedFunction(
      output.UserDefinedFunction,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetUserDefinedFunctionsResponse = (
  output: any,
  context: __SerdeContext
): GetUserDefinedFunctionsResponse => {
  let contents: any = {
    __type: "GetUserDefinedFunctionsResponse",
    NextToken: undefined,
    UserDefinedFunctions: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.UserDefinedFunctions !== undefined &&
    output.UserDefinedFunctions !== null
  ) {
    contents.UserDefinedFunctions = deserializeAws_json1_1UserDefinedFunctionList(
      output.UserDefinedFunctions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ImportCatalogToGlueResponse = (
  output: any,
  context: __SerdeContext
): ImportCatalogToGlueResponse => {
  let contents: any = {
    __type: "ImportCatalogToGlueResponse"
  };
  return contents;
};

const deserializeAws_json1_1LocationMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1MatchCriteria = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Order = (
  output: any,
  context: __SerdeContext
): Order => {
  let contents: any = {
    __type: "Order",
    Column: undefined,
    SortOrder: undefined
  };
  if (output.Column !== undefined && output.Column !== null) {
    contents.Column = output.Column;
  }
  if (output.SortOrder !== undefined && output.SortOrder !== null) {
    contents.SortOrder = output.SortOrder;
  }
  return contents;
};

const deserializeAws_json1_1OrderList = (
  output: any,
  context: __SerdeContext
): Array<Order> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Order(entry, context)
  );
};

const deserializeAws_json1_1ParametersMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1Partition = (
  output: any,
  context: __SerdeContext
): Partition => {
  let contents: any = {
    __type: "Partition",
    CreationTime: undefined,
    DatabaseName: undefined,
    LastAccessTime: undefined,
    LastAnalyzedTime: undefined,
    Parameters: undefined,
    StorageDescriptor: undefined,
    TableName: undefined,
    Values: undefined
  };
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DatabaseName !== undefined && output.DatabaseName !== null) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (output.LastAccessTime !== undefined && output.LastAccessTime !== null) {
    contents.LastAccessTime = new Date(
      Math.round(output.LastAccessTime * 1000)
    );
  }
  if (
    output.LastAnalyzedTime !== undefined &&
    output.LastAnalyzedTime !== null
  ) {
    contents.LastAnalyzedTime = new Date(
      Math.round(output.LastAnalyzedTime * 1000)
    );
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParametersMap(
      output.Parameters,
      context
    );
  }
  if (
    output.StorageDescriptor !== undefined &&
    output.StorageDescriptor !== null
  ) {
    contents.StorageDescriptor = deserializeAws_json1_1StorageDescriptor(
      output.StorageDescriptor,
      context
    );
  }
  if (output.TableName !== undefined && output.TableName !== null) {
    contents.TableName = output.TableName;
  }
  if (output.Values !== undefined && output.Values !== null) {
    contents.Values = deserializeAws_json1_1ValueStringList(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PartitionError = (
  output: any,
  context: __SerdeContext
): PartitionError => {
  let contents: any = {
    __type: "PartitionError",
    ErrorDetail: undefined,
    PartitionValues: undefined
  };
  if (output.ErrorDetail !== undefined && output.ErrorDetail !== null) {
    contents.ErrorDetail = deserializeAws_json1_1ErrorDetail(
      output.ErrorDetail,
      context
    );
  }
  if (output.PartitionValues !== undefined && output.PartitionValues !== null) {
    contents.PartitionValues = deserializeAws_json1_1ValueStringList(
      output.PartitionValues,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PartitionErrors = (
  output: any,
  context: __SerdeContext
): Array<PartitionError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PartitionError(entry, context)
  );
};

const deserializeAws_json1_1PartitionList = (
  output: any,
  context: __SerdeContext
): Array<Partition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Partition(entry, context)
  );
};

const deserializeAws_json1_1PartitionValueList = (
  output: any,
  context: __SerdeContext
): PartitionValueList => {
  let contents: any = {
    __type: "PartitionValueList",
    Values: undefined
  };
  if (output.Values !== undefined && output.Values !== null) {
    contents.Values = deserializeAws_json1_1ValueStringList(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PermissionList = (
  output: any,
  context: __SerdeContext
): Array<Permission | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PhysicalConnectionRequirements = (
  output: any,
  context: __SerdeContext
): PhysicalConnectionRequirements => {
  let contents: any = {
    __type: "PhysicalConnectionRequirements",
    AvailabilityZone: undefined,
    SecurityGroupIdList: undefined,
    SubnetId: undefined
  };
  if (
    output.AvailabilityZone !== undefined &&
    output.AvailabilityZone !== null
  ) {
    contents.AvailabilityZone = output.AvailabilityZone;
  }
  if (
    output.SecurityGroupIdList !== undefined &&
    output.SecurityGroupIdList !== null
  ) {
    contents.SecurityGroupIdList = deserializeAws_json1_1SecurityGroupIdList(
      output.SecurityGroupIdList,
      context
    );
  }
  if (output.SubnetId !== undefined && output.SubnetId !== null) {
    contents.SubnetId = output.SubnetId;
  }
  return contents;
};

const deserializeAws_json1_1PrincipalPermissions = (
  output: any,
  context: __SerdeContext
): PrincipalPermissions => {
  let contents: any = {
    __type: "PrincipalPermissions",
    Permissions: undefined,
    Principal: undefined
  };
  if (output.Permissions !== undefined && output.Permissions !== null) {
    contents.Permissions = deserializeAws_json1_1PermissionList(
      output.Permissions,
      context
    );
  }
  if (output.Principal !== undefined && output.Principal !== null) {
    contents.Principal = deserializeAws_json1_1DataLakePrincipal(
      output.Principal,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PrincipalPermissionsList = (
  output: any,
  context: __SerdeContext
): Array<PrincipalPermissions> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PrincipalPermissions(entry, context)
  );
};

const deserializeAws_json1_1PutDataCatalogEncryptionSettingsResponse = (
  output: any,
  context: __SerdeContext
): PutDataCatalogEncryptionSettingsResponse => {
  let contents: any = {
    __type: "PutDataCatalogEncryptionSettingsResponse"
  };
  return contents;
};

const deserializeAws_json1_1PutResourcePolicyResponse = (
  output: any,
  context: __SerdeContext
): PutResourcePolicyResponse => {
  let contents: any = {
    __type: "PutResourcePolicyResponse",
    PolicyHash: undefined
  };
  if (output.PolicyHash !== undefined && output.PolicyHash !== null) {
    contents.PolicyHash = output.PolicyHash;
  }
  return contents;
};

const deserializeAws_json1_1ResourceUri = (
  output: any,
  context: __SerdeContext
): ResourceUri => {
  let contents: any = {
    __type: "ResourceUri",
    ResourceType: undefined,
    Uri: undefined
  };
  if (output.ResourceType !== undefined && output.ResourceType !== null) {
    contents.ResourceType = output.ResourceType;
  }
  if (output.Uri !== undefined && output.Uri !== null) {
    contents.Uri = output.Uri;
  }
  return contents;
};

const deserializeAws_json1_1ResourceUriList = (
  output: any,
  context: __SerdeContext
): Array<ResourceUri> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ResourceUri(entry, context)
  );
};

const deserializeAws_json1_1SearchTablesResponse = (
  output: any,
  context: __SerdeContext
): SearchTablesResponse => {
  let contents: any = {
    __type: "SearchTablesResponse",
    NextToken: undefined,
    TableList: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TableList !== undefined && output.TableList !== null) {
    contents.TableList = deserializeAws_json1_1TableList(
      output.TableList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1SecurityGroupIdList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SerDeInfo = (
  output: any,
  context: __SerdeContext
): SerDeInfo => {
  let contents: any = {
    __type: "SerDeInfo",
    Name: undefined,
    Parameters: undefined,
    SerializationLibrary: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParametersMap(
      output.Parameters,
      context
    );
  }
  if (
    output.SerializationLibrary !== undefined &&
    output.SerializationLibrary !== null
  ) {
    contents.SerializationLibrary = output.SerializationLibrary;
  }
  return contents;
};

const deserializeAws_json1_1SkewedInfo = (
  output: any,
  context: __SerdeContext
): SkewedInfo => {
  let contents: any = {
    __type: "SkewedInfo",
    SkewedColumnNames: undefined,
    SkewedColumnValueLocationMaps: undefined,
    SkewedColumnValues: undefined
  };
  if (
    output.SkewedColumnNames !== undefined &&
    output.SkewedColumnNames !== null
  ) {
    contents.SkewedColumnNames = deserializeAws_json1_1NameStringList(
      output.SkewedColumnNames,
      context
    );
  }
  if (
    output.SkewedColumnValueLocationMaps !== undefined &&
    output.SkewedColumnValueLocationMaps !== null
  ) {
    contents.SkewedColumnValueLocationMaps = deserializeAws_json1_1LocationMap(
      output.SkewedColumnValueLocationMaps,
      context
    );
  }
  if (
    output.SkewedColumnValues !== undefined &&
    output.SkewedColumnValues !== null
  ) {
    contents.SkewedColumnValues = deserializeAws_json1_1ColumnValueStringList(
      output.SkewedColumnValues,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StorageDescriptor = (
  output: any,
  context: __SerdeContext
): StorageDescriptor => {
  let contents: any = {
    __type: "StorageDescriptor",
    BucketColumns: undefined,
    Columns: undefined,
    Compressed: undefined,
    InputFormat: undefined,
    Location: undefined,
    NumberOfBuckets: undefined,
    OutputFormat: undefined,
    Parameters: undefined,
    SerdeInfo: undefined,
    SkewedInfo: undefined,
    SortColumns: undefined,
    StoredAsSubDirectories: undefined
  };
  if (output.BucketColumns !== undefined && output.BucketColumns !== null) {
    contents.BucketColumns = deserializeAws_json1_1NameStringList(
      output.BucketColumns,
      context
    );
  }
  if (output.Columns !== undefined && output.Columns !== null) {
    contents.Columns = deserializeAws_json1_1ColumnList(
      output.Columns,
      context
    );
  }
  if (output.Compressed !== undefined && output.Compressed !== null) {
    contents.Compressed = output.Compressed;
  }
  if (output.InputFormat !== undefined && output.InputFormat !== null) {
    contents.InputFormat = output.InputFormat;
  }
  if (output.Location !== undefined && output.Location !== null) {
    contents.Location = output.Location;
  }
  if (output.NumberOfBuckets !== undefined && output.NumberOfBuckets !== null) {
    contents.NumberOfBuckets = output.NumberOfBuckets;
  }
  if (output.OutputFormat !== undefined && output.OutputFormat !== null) {
    contents.OutputFormat = output.OutputFormat;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParametersMap(
      output.Parameters,
      context
    );
  }
  if (output.SerdeInfo !== undefined && output.SerdeInfo !== null) {
    contents.SerdeInfo = deserializeAws_json1_1SerDeInfo(
      output.SerdeInfo,
      context
    );
  }
  if (output.SkewedInfo !== undefined && output.SkewedInfo !== null) {
    contents.SkewedInfo = deserializeAws_json1_1SkewedInfo(
      output.SkewedInfo,
      context
    );
  }
  if (output.SortColumns !== undefined && output.SortColumns !== null) {
    contents.SortColumns = deserializeAws_json1_1OrderList(
      output.SortColumns,
      context
    );
  }
  if (
    output.StoredAsSubDirectories !== undefined &&
    output.StoredAsSubDirectories !== null
  ) {
    contents.StoredAsSubDirectories = output.StoredAsSubDirectories;
  }
  return contents;
};

const deserializeAws_json1_1Table = (
  output: any,
  context: __SerdeContext
): Table => {
  let contents: any = {
    __type: "Table",
    CreateTime: undefined,
    CreatedBy: undefined,
    DatabaseName: undefined,
    Description: undefined,
    IsRegisteredWithLakeFormation: undefined,
    LastAccessTime: undefined,
    LastAnalyzedTime: undefined,
    Name: undefined,
    Owner: undefined,
    Parameters: undefined,
    PartitionKeys: undefined,
    Retention: undefined,
    StorageDescriptor: undefined,
    TableType: undefined,
    UpdateTime: undefined,
    ViewExpandedText: undefined,
    ViewOriginalText: undefined
  };
  if (output.CreateTime !== undefined && output.CreateTime !== null) {
    contents.CreateTime = new Date(Math.round(output.CreateTime * 1000));
  }
  if (output.CreatedBy !== undefined && output.CreatedBy !== null) {
    contents.CreatedBy = output.CreatedBy;
  }
  if (output.DatabaseName !== undefined && output.DatabaseName !== null) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (
    output.IsRegisteredWithLakeFormation !== undefined &&
    output.IsRegisteredWithLakeFormation !== null
  ) {
    contents.IsRegisteredWithLakeFormation =
      output.IsRegisteredWithLakeFormation;
  }
  if (output.LastAccessTime !== undefined && output.LastAccessTime !== null) {
    contents.LastAccessTime = new Date(
      Math.round(output.LastAccessTime * 1000)
    );
  }
  if (
    output.LastAnalyzedTime !== undefined &&
    output.LastAnalyzedTime !== null
  ) {
    contents.LastAnalyzedTime = new Date(
      Math.round(output.LastAnalyzedTime * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Owner !== undefined && output.Owner !== null) {
    contents.Owner = output.Owner;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParametersMap(
      output.Parameters,
      context
    );
  }
  if (output.PartitionKeys !== undefined && output.PartitionKeys !== null) {
    contents.PartitionKeys = deserializeAws_json1_1ColumnList(
      output.PartitionKeys,
      context
    );
  }
  if (output.Retention !== undefined && output.Retention !== null) {
    contents.Retention = output.Retention;
  }
  if (
    output.StorageDescriptor !== undefined &&
    output.StorageDescriptor !== null
  ) {
    contents.StorageDescriptor = deserializeAws_json1_1StorageDescriptor(
      output.StorageDescriptor,
      context
    );
  }
  if (output.TableType !== undefined && output.TableType !== null) {
    contents.TableType = output.TableType;
  }
  if (output.UpdateTime !== undefined && output.UpdateTime !== null) {
    contents.UpdateTime = new Date(Math.round(output.UpdateTime * 1000));
  }
  if (
    output.ViewExpandedText !== undefined &&
    output.ViewExpandedText !== null
  ) {
    contents.ViewExpandedText = output.ViewExpandedText;
  }
  if (
    output.ViewOriginalText !== undefined &&
    output.ViewOriginalText !== null
  ) {
    contents.ViewOriginalText = output.ViewOriginalText;
  }
  return contents;
};

const deserializeAws_json1_1TableError = (
  output: any,
  context: __SerdeContext
): TableError => {
  let contents: any = {
    __type: "TableError",
    ErrorDetail: undefined,
    TableName: undefined
  };
  if (output.ErrorDetail !== undefined && output.ErrorDetail !== null) {
    contents.ErrorDetail = deserializeAws_json1_1ErrorDetail(
      output.ErrorDetail,
      context
    );
  }
  if (output.TableName !== undefined && output.TableName !== null) {
    contents.TableName = output.TableName;
  }
  return contents;
};

const deserializeAws_json1_1TableErrors = (
  output: any,
  context: __SerdeContext
): Array<TableError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TableError(entry, context)
  );
};

const deserializeAws_json1_1TableList = (
  output: any,
  context: __SerdeContext
): Array<Table> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Table(entry, context)
  );
};

const deserializeAws_json1_1TableVersion = (
  output: any,
  context: __SerdeContext
): TableVersion => {
  let contents: any = {
    __type: "TableVersion",
    Table: undefined,
    VersionId: undefined
  };
  if (output.Table !== undefined && output.Table !== null) {
    contents.Table = deserializeAws_json1_1Table(output.Table, context);
  }
  if (output.VersionId !== undefined && output.VersionId !== null) {
    contents.VersionId = output.VersionId;
  }
  return contents;
};

const deserializeAws_json1_1TableVersionError = (
  output: any,
  context: __SerdeContext
): TableVersionError => {
  let contents: any = {
    __type: "TableVersionError",
    ErrorDetail: undefined,
    TableName: undefined,
    VersionId: undefined
  };
  if (output.ErrorDetail !== undefined && output.ErrorDetail !== null) {
    contents.ErrorDetail = deserializeAws_json1_1ErrorDetail(
      output.ErrorDetail,
      context
    );
  }
  if (output.TableName !== undefined && output.TableName !== null) {
    contents.TableName = output.TableName;
  }
  if (output.VersionId !== undefined && output.VersionId !== null) {
    contents.VersionId = output.VersionId;
  }
  return contents;
};

const deserializeAws_json1_1TableVersionErrors = (
  output: any,
  context: __SerdeContext
): Array<TableVersionError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TableVersionError(entry, context)
  );
};

const deserializeAws_json1_1UpdateConnectionResponse = (
  output: any,
  context: __SerdeContext
): UpdateConnectionResponse => {
  let contents: any = {
    __type: "UpdateConnectionResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateDatabaseResponse = (
  output: any,
  context: __SerdeContext
): UpdateDatabaseResponse => {
  let contents: any = {
    __type: "UpdateDatabaseResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdatePartitionResponse = (
  output: any,
  context: __SerdeContext
): UpdatePartitionResponse => {
  let contents: any = {
    __type: "UpdatePartitionResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateTableResponse = (
  output: any,
  context: __SerdeContext
): UpdateTableResponse => {
  let contents: any = {
    __type: "UpdateTableResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateUserDefinedFunctionResponse = (
  output: any,
  context: __SerdeContext
): UpdateUserDefinedFunctionResponse => {
  let contents: any = {
    __type: "UpdateUserDefinedFunctionResponse"
  };
  return contents;
};

const deserializeAws_json1_1UserDefinedFunction = (
  output: any,
  context: __SerdeContext
): UserDefinedFunction => {
  let contents: any = {
    __type: "UserDefinedFunction",
    ClassName: undefined,
    CreateTime: undefined,
    FunctionName: undefined,
    OwnerName: undefined,
    OwnerType: undefined,
    ResourceUris: undefined
  };
  if (output.ClassName !== undefined && output.ClassName !== null) {
    contents.ClassName = output.ClassName;
  }
  if (output.CreateTime !== undefined && output.CreateTime !== null) {
    contents.CreateTime = new Date(Math.round(output.CreateTime * 1000));
  }
  if (output.FunctionName !== undefined && output.FunctionName !== null) {
    contents.FunctionName = output.FunctionName;
  }
  if (output.OwnerName !== undefined && output.OwnerName !== null) {
    contents.OwnerName = output.OwnerName;
  }
  if (output.OwnerType !== undefined && output.OwnerType !== null) {
    contents.OwnerType = output.OwnerType;
  }
  if (output.ResourceUris !== undefined && output.ResourceUris !== null) {
    contents.ResourceUris = deserializeAws_json1_1ResourceUriList(
      output.ResourceUris,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UserDefinedFunctionList = (
  output: any,
  context: __SerdeContext
): Array<UserDefinedFunction> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1UserDefinedFunction(entry, context)
  );
};

const deserializeAws_json1_1ValueStringList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1BatchGetDevEndpointsResponse = (
  output: any,
  context: __SerdeContext
): BatchGetDevEndpointsResponse => {
  let contents: any = {
    __type: "BatchGetDevEndpointsResponse",
    DevEndpoints: undefined,
    DevEndpointsNotFound: undefined
  };
  if (output.DevEndpoints !== undefined && output.DevEndpoints !== null) {
    contents.DevEndpoints = deserializeAws_json1_1DevEndpointList(
      output.DevEndpoints,
      context
    );
  }
  if (
    output.DevEndpointsNotFound !== undefined &&
    output.DevEndpointsNotFound !== null
  ) {
    contents.DevEndpointsNotFound = deserializeAws_json1_1DevEndpointNames(
      output.DevEndpointsNotFound,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CloudWatchEncryption = (
  output: any,
  context: __SerdeContext
): CloudWatchEncryption => {
  let contents: any = {
    __type: "CloudWatchEncryption",
    CloudWatchEncryptionMode: undefined,
    KmsKeyArn: undefined
  };
  if (
    output.CloudWatchEncryptionMode !== undefined &&
    output.CloudWatchEncryptionMode !== null
  ) {
    contents.CloudWatchEncryptionMode = output.CloudWatchEncryptionMode;
  }
  if (output.KmsKeyArn !== undefined && output.KmsKeyArn !== null) {
    contents.KmsKeyArn = output.KmsKeyArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateDevEndpointResponse = (
  output: any,
  context: __SerdeContext
): CreateDevEndpointResponse => {
  let contents: any = {
    __type: "CreateDevEndpointResponse",
    Arguments: undefined,
    AvailabilityZone: undefined,
    CreatedTimestamp: undefined,
    EndpointName: undefined,
    ExtraJarsS3Path: undefined,
    ExtraPythonLibsS3Path: undefined,
    FailureReason: undefined,
    GlueVersion: undefined,
    NumberOfNodes: undefined,
    NumberOfWorkers: undefined,
    RoleArn: undefined,
    SecurityConfiguration: undefined,
    SecurityGroupIds: undefined,
    Status: undefined,
    SubnetId: undefined,
    VpcId: undefined,
    WorkerType: undefined,
    YarnEndpointAddress: undefined,
    ZeppelinRemoteSparkInterpreterPort: undefined
  };
  if (output.Arguments !== undefined && output.Arguments !== null) {
    contents.Arguments = deserializeAws_json1_1MapValue(
      output.Arguments,
      context
    );
  }
  if (
    output.AvailabilityZone !== undefined &&
    output.AvailabilityZone !== null
  ) {
    contents.AvailabilityZone = output.AvailabilityZone;
  }
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(
      Math.round(output.CreatedTimestamp * 1000)
    );
  }
  if (output.EndpointName !== undefined && output.EndpointName !== null) {
    contents.EndpointName = output.EndpointName;
  }
  if (output.ExtraJarsS3Path !== undefined && output.ExtraJarsS3Path !== null) {
    contents.ExtraJarsS3Path = output.ExtraJarsS3Path;
  }
  if (
    output.ExtraPythonLibsS3Path !== undefined &&
    output.ExtraPythonLibsS3Path !== null
  ) {
    contents.ExtraPythonLibsS3Path = output.ExtraPythonLibsS3Path;
  }
  if (output.FailureReason !== undefined && output.FailureReason !== null) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.GlueVersion !== undefined && output.GlueVersion !== null) {
    contents.GlueVersion = output.GlueVersion;
  }
  if (output.NumberOfNodes !== undefined && output.NumberOfNodes !== null) {
    contents.NumberOfNodes = output.NumberOfNodes;
  }
  if (output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null) {
    contents.NumberOfWorkers = output.NumberOfWorkers;
  }
  if (output.RoleArn !== undefined && output.RoleArn !== null) {
    contents.RoleArn = output.RoleArn;
  }
  if (
    output.SecurityConfiguration !== undefined &&
    output.SecurityConfiguration !== null
  ) {
    contents.SecurityConfiguration = output.SecurityConfiguration;
  }
  if (
    output.SecurityGroupIds !== undefined &&
    output.SecurityGroupIds !== null
  ) {
    contents.SecurityGroupIds = deserializeAws_json1_1StringList(
      output.SecurityGroupIds,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.SubnetId !== undefined && output.SubnetId !== null) {
    contents.SubnetId = output.SubnetId;
  }
  if (output.VpcId !== undefined && output.VpcId !== null) {
    contents.VpcId = output.VpcId;
  }
  if (output.WorkerType !== undefined && output.WorkerType !== null) {
    contents.WorkerType = output.WorkerType;
  }
  if (
    output.YarnEndpointAddress !== undefined &&
    output.YarnEndpointAddress !== null
  ) {
    contents.YarnEndpointAddress = output.YarnEndpointAddress;
  }
  if (
    output.ZeppelinRemoteSparkInterpreterPort !== undefined &&
    output.ZeppelinRemoteSparkInterpreterPort !== null
  ) {
    contents.ZeppelinRemoteSparkInterpreterPort =
      output.ZeppelinRemoteSparkInterpreterPort;
  }
  return contents;
};

const deserializeAws_json1_1CreateSecurityConfigurationResponse = (
  output: any,
  context: __SerdeContext
): CreateSecurityConfigurationResponse => {
  let contents: any = {
    __type: "CreateSecurityConfigurationResponse",
    CreatedTimestamp: undefined,
    Name: undefined
  };
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(
      Math.round(output.CreatedTimestamp * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1DeleteDevEndpointResponse = (
  output: any,
  context: __SerdeContext
): DeleteDevEndpointResponse => {
  let contents: any = {
    __type: "DeleteDevEndpointResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteSecurityConfigurationResponse = (
  output: any,
  context: __SerdeContext
): DeleteSecurityConfigurationResponse => {
  let contents: any = {
    __type: "DeleteSecurityConfigurationResponse"
  };
  return contents;
};

const deserializeAws_json1_1DevEndpoint = (
  output: any,
  context: __SerdeContext
): DevEndpoint => {
  let contents: any = {
    __type: "DevEndpoint",
    Arguments: undefined,
    AvailabilityZone: undefined,
    CreatedTimestamp: undefined,
    EndpointName: undefined,
    ExtraJarsS3Path: undefined,
    ExtraPythonLibsS3Path: undefined,
    FailureReason: undefined,
    GlueVersion: undefined,
    LastModifiedTimestamp: undefined,
    LastUpdateStatus: undefined,
    NumberOfNodes: undefined,
    NumberOfWorkers: undefined,
    PrivateAddress: undefined,
    PublicAddress: undefined,
    PublicKey: undefined,
    PublicKeys: undefined,
    RoleArn: undefined,
    SecurityConfiguration: undefined,
    SecurityGroupIds: undefined,
    Status: undefined,
    SubnetId: undefined,
    VpcId: undefined,
    WorkerType: undefined,
    YarnEndpointAddress: undefined,
    ZeppelinRemoteSparkInterpreterPort: undefined
  };
  if (output.Arguments !== undefined && output.Arguments !== null) {
    contents.Arguments = deserializeAws_json1_1MapValue(
      output.Arguments,
      context
    );
  }
  if (
    output.AvailabilityZone !== undefined &&
    output.AvailabilityZone !== null
  ) {
    contents.AvailabilityZone = output.AvailabilityZone;
  }
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(
      Math.round(output.CreatedTimestamp * 1000)
    );
  }
  if (output.EndpointName !== undefined && output.EndpointName !== null) {
    contents.EndpointName = output.EndpointName;
  }
  if (output.ExtraJarsS3Path !== undefined && output.ExtraJarsS3Path !== null) {
    contents.ExtraJarsS3Path = output.ExtraJarsS3Path;
  }
  if (
    output.ExtraPythonLibsS3Path !== undefined &&
    output.ExtraPythonLibsS3Path !== null
  ) {
    contents.ExtraPythonLibsS3Path = output.ExtraPythonLibsS3Path;
  }
  if (output.FailureReason !== undefined && output.FailureReason !== null) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.GlueVersion !== undefined && output.GlueVersion !== null) {
    contents.GlueVersion = output.GlueVersion;
  }
  if (
    output.LastModifiedTimestamp !== undefined &&
    output.LastModifiedTimestamp !== null
  ) {
    contents.LastModifiedTimestamp = new Date(
      Math.round(output.LastModifiedTimestamp * 1000)
    );
  }
  if (
    output.LastUpdateStatus !== undefined &&
    output.LastUpdateStatus !== null
  ) {
    contents.LastUpdateStatus = output.LastUpdateStatus;
  }
  if (output.NumberOfNodes !== undefined && output.NumberOfNodes !== null) {
    contents.NumberOfNodes = output.NumberOfNodes;
  }
  if (output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null) {
    contents.NumberOfWorkers = output.NumberOfWorkers;
  }
  if (output.PrivateAddress !== undefined && output.PrivateAddress !== null) {
    contents.PrivateAddress = output.PrivateAddress;
  }
  if (output.PublicAddress !== undefined && output.PublicAddress !== null) {
    contents.PublicAddress = output.PublicAddress;
  }
  if (output.PublicKey !== undefined && output.PublicKey !== null) {
    contents.PublicKey = output.PublicKey;
  }
  if (output.PublicKeys !== undefined && output.PublicKeys !== null) {
    contents.PublicKeys = deserializeAws_json1_1PublicKeysList(
      output.PublicKeys,
      context
    );
  }
  if (output.RoleArn !== undefined && output.RoleArn !== null) {
    contents.RoleArn = output.RoleArn;
  }
  if (
    output.SecurityConfiguration !== undefined &&
    output.SecurityConfiguration !== null
  ) {
    contents.SecurityConfiguration = output.SecurityConfiguration;
  }
  if (
    output.SecurityGroupIds !== undefined &&
    output.SecurityGroupIds !== null
  ) {
    contents.SecurityGroupIds = deserializeAws_json1_1StringList(
      output.SecurityGroupIds,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.SubnetId !== undefined && output.SubnetId !== null) {
    contents.SubnetId = output.SubnetId;
  }
  if (output.VpcId !== undefined && output.VpcId !== null) {
    contents.VpcId = output.VpcId;
  }
  if (output.WorkerType !== undefined && output.WorkerType !== null) {
    contents.WorkerType = output.WorkerType;
  }
  if (
    output.YarnEndpointAddress !== undefined &&
    output.YarnEndpointAddress !== null
  ) {
    contents.YarnEndpointAddress = output.YarnEndpointAddress;
  }
  if (
    output.ZeppelinRemoteSparkInterpreterPort !== undefined &&
    output.ZeppelinRemoteSparkInterpreterPort !== null
  ) {
    contents.ZeppelinRemoteSparkInterpreterPort =
      output.ZeppelinRemoteSparkInterpreterPort;
  }
  return contents;
};

const deserializeAws_json1_1DevEndpointList = (
  output: any,
  context: __SerdeContext
): Array<DevEndpoint> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DevEndpoint(entry, context)
  );
};

const deserializeAws_json1_1DevEndpointNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1DevEndpointNames = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1EncryptionConfiguration = (
  output: any,
  context: __SerdeContext
): EncryptionConfiguration => {
  let contents: any = {
    __type: "EncryptionConfiguration",
    CloudWatchEncryption: undefined,
    JobBookmarksEncryption: undefined,
    S3Encryption: undefined
  };
  if (
    output.CloudWatchEncryption !== undefined &&
    output.CloudWatchEncryption !== null
  ) {
    contents.CloudWatchEncryption = deserializeAws_json1_1CloudWatchEncryption(
      output.CloudWatchEncryption,
      context
    );
  }
  if (
    output.JobBookmarksEncryption !== undefined &&
    output.JobBookmarksEncryption !== null
  ) {
    contents.JobBookmarksEncryption = deserializeAws_json1_1JobBookmarksEncryption(
      output.JobBookmarksEncryption,
      context
    );
  }
  if (output.S3Encryption !== undefined && output.S3Encryption !== null) {
    contents.S3Encryption = deserializeAws_json1_1S3EncryptionList(
      output.S3Encryption,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetDevEndpointResponse = (
  output: any,
  context: __SerdeContext
): GetDevEndpointResponse => {
  let contents: any = {
    __type: "GetDevEndpointResponse",
    DevEndpoint: undefined
  };
  if (output.DevEndpoint !== undefined && output.DevEndpoint !== null) {
    contents.DevEndpoint = deserializeAws_json1_1DevEndpoint(
      output.DevEndpoint,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetDevEndpointsResponse = (
  output: any,
  context: __SerdeContext
): GetDevEndpointsResponse => {
  let contents: any = {
    __type: "GetDevEndpointsResponse",
    DevEndpoints: undefined,
    NextToken: undefined
  };
  if (output.DevEndpoints !== undefined && output.DevEndpoints !== null) {
    contents.DevEndpoints = deserializeAws_json1_1DevEndpointList(
      output.DevEndpoints,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetJobBookmarkResponse = (
  output: any,
  context: __SerdeContext
): GetJobBookmarkResponse => {
  let contents: any = {
    __type: "GetJobBookmarkResponse",
    JobBookmarkEntry: undefined
  };
  if (
    output.JobBookmarkEntry !== undefined &&
    output.JobBookmarkEntry !== null
  ) {
    contents.JobBookmarkEntry = deserializeAws_json1_1JobBookmarkEntry(
      output.JobBookmarkEntry,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetSecurityConfigurationResponse = (
  output: any,
  context: __SerdeContext
): GetSecurityConfigurationResponse => {
  let contents: any = {
    __type: "GetSecurityConfigurationResponse",
    SecurityConfiguration: undefined
  };
  if (
    output.SecurityConfiguration !== undefined &&
    output.SecurityConfiguration !== null
  ) {
    contents.SecurityConfiguration = deserializeAws_json1_1SecurityConfiguration(
      output.SecurityConfiguration,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetSecurityConfigurationsResponse = (
  output: any,
  context: __SerdeContext
): GetSecurityConfigurationsResponse => {
  let contents: any = {
    __type: "GetSecurityConfigurationsResponse",
    NextToken: undefined,
    SecurityConfigurations: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.SecurityConfigurations !== undefined &&
    output.SecurityConfigurations !== null
  ) {
    contents.SecurityConfigurations = deserializeAws_json1_1SecurityConfigurationList(
      output.SecurityConfigurations,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1JobBookmarkEntry = (
  output: any,
  context: __SerdeContext
): JobBookmarkEntry => {
  let contents: any = {
    __type: "JobBookmarkEntry",
    Attempt: undefined,
    JobBookmark: undefined,
    JobName: undefined,
    PreviousRunId: undefined,
    Run: undefined,
    RunId: undefined,
    Version: undefined
  };
  if (output.Attempt !== undefined && output.Attempt !== null) {
    contents.Attempt = output.Attempt;
  }
  if (output.JobBookmark !== undefined && output.JobBookmark !== null) {
    contents.JobBookmark = output.JobBookmark;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.PreviousRunId !== undefined && output.PreviousRunId !== null) {
    contents.PreviousRunId = output.PreviousRunId;
  }
  if (output.Run !== undefined && output.Run !== null) {
    contents.Run = output.Run;
  }
  if (output.RunId !== undefined && output.RunId !== null) {
    contents.RunId = output.RunId;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1JobBookmarksEncryption = (
  output: any,
  context: __SerdeContext
): JobBookmarksEncryption => {
  let contents: any = {
    __type: "JobBookmarksEncryption",
    JobBookmarksEncryptionMode: undefined,
    KmsKeyArn: undefined
  };
  if (
    output.JobBookmarksEncryptionMode !== undefined &&
    output.JobBookmarksEncryptionMode !== null
  ) {
    contents.JobBookmarksEncryptionMode = output.JobBookmarksEncryptionMode;
  }
  if (output.KmsKeyArn !== undefined && output.KmsKeyArn !== null) {
    contents.KmsKeyArn = output.KmsKeyArn;
  }
  return contents;
};

const deserializeAws_json1_1ListDevEndpointsResponse = (
  output: any,
  context: __SerdeContext
): ListDevEndpointsResponse => {
  let contents: any = {
    __type: "ListDevEndpointsResponse",
    DevEndpointNames: undefined,
    NextToken: undefined
  };
  if (
    output.DevEndpointNames !== undefined &&
    output.DevEndpointNames !== null
  ) {
    contents.DevEndpointNames = deserializeAws_json1_1DevEndpointNameList(
      output.DevEndpointNames,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1MapValue = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1PublicKeysList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ResetJobBookmarkResponse = (
  output: any,
  context: __SerdeContext
): ResetJobBookmarkResponse => {
  let contents: any = {
    __type: "ResetJobBookmarkResponse",
    JobBookmarkEntry: undefined
  };
  if (
    output.JobBookmarkEntry !== undefined &&
    output.JobBookmarkEntry !== null
  ) {
    contents.JobBookmarkEntry = deserializeAws_json1_1JobBookmarkEntry(
      output.JobBookmarkEntry,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1S3Encryption = (
  output: any,
  context: __SerdeContext
): S3Encryption => {
  let contents: any = {
    __type: "S3Encryption",
    KmsKeyArn: undefined,
    S3EncryptionMode: undefined
  };
  if (output.KmsKeyArn !== undefined && output.KmsKeyArn !== null) {
    contents.KmsKeyArn = output.KmsKeyArn;
  }
  if (
    output.S3EncryptionMode !== undefined &&
    output.S3EncryptionMode !== null
  ) {
    contents.S3EncryptionMode = output.S3EncryptionMode;
  }
  return contents;
};

const deserializeAws_json1_1S3EncryptionList = (
  output: any,
  context: __SerdeContext
): Array<S3Encryption> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1S3Encryption(entry, context)
  );
};

const deserializeAws_json1_1SecurityConfiguration = (
  output: any,
  context: __SerdeContext
): SecurityConfiguration => {
  let contents: any = {
    __type: "SecurityConfiguration",
    CreatedTimeStamp: undefined,
    EncryptionConfiguration: undefined,
    Name: undefined
  };
  if (
    output.CreatedTimeStamp !== undefined &&
    output.CreatedTimeStamp !== null
  ) {
    contents.CreatedTimeStamp = new Date(
      Math.round(output.CreatedTimeStamp * 1000)
    );
  }
  if (
    output.EncryptionConfiguration !== undefined &&
    output.EncryptionConfiguration !== null
  ) {
    contents.EncryptionConfiguration = deserializeAws_json1_1EncryptionConfiguration(
      output.EncryptionConfiguration,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1SecurityConfigurationList = (
  output: any,
  context: __SerdeContext
): Array<SecurityConfiguration> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SecurityConfiguration(entry, context)
  );
};

const deserializeAws_json1_1StringList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1UpdateDevEndpointResponse = (
  output: any,
  context: __SerdeContext
): UpdateDevEndpointResponse => {
  let contents: any = {
    __type: "UpdateDevEndpointResponse"
  };
  return contents;
};

const deserializeAws_json1_1CancelMLTaskRunResponse = (
  output: any,
  context: __SerdeContext
): CancelMLTaskRunResponse => {
  let contents: any = {
    __type: "CancelMLTaskRunResponse",
    Status: undefined,
    TaskRunId: undefined,
    TransformId: undefined
  };
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.TaskRunId !== undefined && output.TaskRunId !== null) {
    contents.TaskRunId = output.TaskRunId;
  }
  if (output.TransformId !== undefined && output.TransformId !== null) {
    contents.TransformId = output.TransformId;
  }
  return contents;
};

const deserializeAws_json1_1ConfusionMatrix = (
  output: any,
  context: __SerdeContext
): ConfusionMatrix => {
  let contents: any = {
    __type: "ConfusionMatrix",
    NumFalseNegatives: undefined,
    NumFalsePositives: undefined,
    NumTrueNegatives: undefined,
    NumTruePositives: undefined
  };
  if (
    output.NumFalseNegatives !== undefined &&
    output.NumFalseNegatives !== null
  ) {
    contents.NumFalseNegatives = output.NumFalseNegatives;
  }
  if (
    output.NumFalsePositives !== undefined &&
    output.NumFalsePositives !== null
  ) {
    contents.NumFalsePositives = output.NumFalsePositives;
  }
  if (
    output.NumTrueNegatives !== undefined &&
    output.NumTrueNegatives !== null
  ) {
    contents.NumTrueNegatives = output.NumTrueNegatives;
  }
  if (
    output.NumTruePositives !== undefined &&
    output.NumTruePositives !== null
  ) {
    contents.NumTruePositives = output.NumTruePositives;
  }
  return contents;
};

const deserializeAws_json1_1CreateMLTransformResponse = (
  output: any,
  context: __SerdeContext
): CreateMLTransformResponse => {
  let contents: any = {
    __type: "CreateMLTransformResponse",
    TransformId: undefined
  };
  if (output.TransformId !== undefined && output.TransformId !== null) {
    contents.TransformId = output.TransformId;
  }
  return contents;
};

const deserializeAws_json1_1DeleteMLTransformResponse = (
  output: any,
  context: __SerdeContext
): DeleteMLTransformResponse => {
  let contents: any = {
    __type: "DeleteMLTransformResponse",
    TransformId: undefined
  };
  if (output.TransformId !== undefined && output.TransformId !== null) {
    contents.TransformId = output.TransformId;
  }
  return contents;
};

const deserializeAws_json1_1EvaluationMetrics = (
  output: any,
  context: __SerdeContext
): EvaluationMetrics => {
  let contents: any = {
    __type: "EvaluationMetrics",
    FindMatchesMetrics: undefined,
    TransformType: undefined
  };
  if (
    output.FindMatchesMetrics !== undefined &&
    output.FindMatchesMetrics !== null
  ) {
    contents.FindMatchesMetrics = deserializeAws_json1_1FindMatchesMetrics(
      output.FindMatchesMetrics,
      context
    );
  }
  if (output.TransformType !== undefined && output.TransformType !== null) {
    contents.TransformType = output.TransformType;
  }
  return contents;
};

const deserializeAws_json1_1ExportLabelsTaskRunProperties = (
  output: any,
  context: __SerdeContext
): ExportLabelsTaskRunProperties => {
  let contents: any = {
    __type: "ExportLabelsTaskRunProperties",
    OutputS3Path: undefined
  };
  if (output.OutputS3Path !== undefined && output.OutputS3Path !== null) {
    contents.OutputS3Path = output.OutputS3Path;
  }
  return contents;
};

const deserializeAws_json1_1FindMatchesMetrics = (
  output: any,
  context: __SerdeContext
): FindMatchesMetrics => {
  let contents: any = {
    __type: "FindMatchesMetrics",
    AreaUnderPRCurve: undefined,
    ConfusionMatrix: undefined,
    F1: undefined,
    Precision: undefined,
    Recall: undefined
  };
  if (
    output.AreaUnderPRCurve !== undefined &&
    output.AreaUnderPRCurve !== null
  ) {
    contents.AreaUnderPRCurve = output.AreaUnderPRCurve;
  }
  if (output.ConfusionMatrix !== undefined && output.ConfusionMatrix !== null) {
    contents.ConfusionMatrix = deserializeAws_json1_1ConfusionMatrix(
      output.ConfusionMatrix,
      context
    );
  }
  if (output.F1 !== undefined && output.F1 !== null) {
    contents.F1 = output.F1;
  }
  if (output.Precision !== undefined && output.Precision !== null) {
    contents.Precision = output.Precision;
  }
  if (output.Recall !== undefined && output.Recall !== null) {
    contents.Recall = output.Recall;
  }
  return contents;
};

const deserializeAws_json1_1FindMatchesParameters = (
  output: any,
  context: __SerdeContext
): FindMatchesParameters => {
  let contents: any = {
    __type: "FindMatchesParameters",
    AccuracyCostTradeoff: undefined,
    EnforceProvidedLabels: undefined,
    PrecisionRecallTradeoff: undefined,
    PrimaryKeyColumnName: undefined
  };
  if (
    output.AccuracyCostTradeoff !== undefined &&
    output.AccuracyCostTradeoff !== null
  ) {
    contents.AccuracyCostTradeoff = output.AccuracyCostTradeoff;
  }
  if (
    output.EnforceProvidedLabels !== undefined &&
    output.EnforceProvidedLabels !== null
  ) {
    contents.EnforceProvidedLabels = output.EnforceProvidedLabels;
  }
  if (
    output.PrecisionRecallTradeoff !== undefined &&
    output.PrecisionRecallTradeoff !== null
  ) {
    contents.PrecisionRecallTradeoff = output.PrecisionRecallTradeoff;
  }
  if (
    output.PrimaryKeyColumnName !== undefined &&
    output.PrimaryKeyColumnName !== null
  ) {
    contents.PrimaryKeyColumnName = output.PrimaryKeyColumnName;
  }
  return contents;
};

const deserializeAws_json1_1FindMatchesTaskRunProperties = (
  output: any,
  context: __SerdeContext
): FindMatchesTaskRunProperties => {
  let contents: any = {
    __type: "FindMatchesTaskRunProperties",
    JobId: undefined,
    JobName: undefined,
    JobRunId: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobRunId !== undefined && output.JobRunId !== null) {
    contents.JobRunId = output.JobRunId;
  }
  return contents;
};

const deserializeAws_json1_1GetMLTaskRunResponse = (
  output: any,
  context: __SerdeContext
): GetMLTaskRunResponse => {
  let contents: any = {
    __type: "GetMLTaskRunResponse",
    CompletedOn: undefined,
    ErrorString: undefined,
    ExecutionTime: undefined,
    LastModifiedOn: undefined,
    LogGroupName: undefined,
    Properties: undefined,
    StartedOn: undefined,
    Status: undefined,
    TaskRunId: undefined,
    TransformId: undefined
  };
  if (output.CompletedOn !== undefined && output.CompletedOn !== null) {
    contents.CompletedOn = new Date(Math.round(output.CompletedOn * 1000));
  }
  if (output.ErrorString !== undefined && output.ErrorString !== null) {
    contents.ErrorString = output.ErrorString;
  }
  if (output.ExecutionTime !== undefined && output.ExecutionTime !== null) {
    contents.ExecutionTime = output.ExecutionTime;
  }
  if (output.LastModifiedOn !== undefined && output.LastModifiedOn !== null) {
    contents.LastModifiedOn = new Date(
      Math.round(output.LastModifiedOn * 1000)
    );
  }
  if (output.LogGroupName !== undefined && output.LogGroupName !== null) {
    contents.LogGroupName = output.LogGroupName;
  }
  if (output.Properties !== undefined && output.Properties !== null) {
    contents.Properties = deserializeAws_json1_1TaskRunProperties(
      output.Properties,
      context
    );
  }
  if (output.StartedOn !== undefined && output.StartedOn !== null) {
    contents.StartedOn = new Date(Math.round(output.StartedOn * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.TaskRunId !== undefined && output.TaskRunId !== null) {
    contents.TaskRunId = output.TaskRunId;
  }
  if (output.TransformId !== undefined && output.TransformId !== null) {
    contents.TransformId = output.TransformId;
  }
  return contents;
};

const deserializeAws_json1_1GetMLTaskRunsResponse = (
  output: any,
  context: __SerdeContext
): GetMLTaskRunsResponse => {
  let contents: any = {
    __type: "GetMLTaskRunsResponse",
    NextToken: undefined,
    TaskRuns: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TaskRuns !== undefined && output.TaskRuns !== null) {
    contents.TaskRuns = deserializeAws_json1_1TaskRunList(
      output.TaskRuns,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetMLTransformResponse = (
  output: any,
  context: __SerdeContext
): GetMLTransformResponse => {
  let contents: any = {
    __type: "GetMLTransformResponse",
    CreatedOn: undefined,
    Description: undefined,
    EvaluationMetrics: undefined,
    GlueVersion: undefined,
    InputRecordTables: undefined,
    LabelCount: undefined,
    LastModifiedOn: undefined,
    MaxCapacity: undefined,
    MaxRetries: undefined,
    Name: undefined,
    NumberOfWorkers: undefined,
    Parameters: undefined,
    Role: undefined,
    Schema: undefined,
    Status: undefined,
    Timeout: undefined,
    TransformId: undefined,
    WorkerType: undefined
  };
  if (output.CreatedOn !== undefined && output.CreatedOn !== null) {
    contents.CreatedOn = new Date(Math.round(output.CreatedOn * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (
    output.EvaluationMetrics !== undefined &&
    output.EvaluationMetrics !== null
  ) {
    contents.EvaluationMetrics = deserializeAws_json1_1EvaluationMetrics(
      output.EvaluationMetrics,
      context
    );
  }
  if (output.GlueVersion !== undefined && output.GlueVersion !== null) {
    contents.GlueVersion = output.GlueVersion;
  }
  if (
    output.InputRecordTables !== undefined &&
    output.InputRecordTables !== null
  ) {
    contents.InputRecordTables = deserializeAws_json1_1GlueTables(
      output.InputRecordTables,
      context
    );
  }
  if (output.LabelCount !== undefined && output.LabelCount !== null) {
    contents.LabelCount = output.LabelCount;
  }
  if (output.LastModifiedOn !== undefined && output.LastModifiedOn !== null) {
    contents.LastModifiedOn = new Date(
      Math.round(output.LastModifiedOn * 1000)
    );
  }
  if (output.MaxCapacity !== undefined && output.MaxCapacity !== null) {
    contents.MaxCapacity = output.MaxCapacity;
  }
  if (output.MaxRetries !== undefined && output.MaxRetries !== null) {
    contents.MaxRetries = output.MaxRetries;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null) {
    contents.NumberOfWorkers = output.NumberOfWorkers;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1TransformParameters(
      output.Parameters,
      context
    );
  }
  if (output.Role !== undefined && output.Role !== null) {
    contents.Role = output.Role;
  }
  if (output.Schema !== undefined && output.Schema !== null) {
    contents.Schema = deserializeAws_json1_1TransformSchema(
      output.Schema,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Timeout !== undefined && output.Timeout !== null) {
    contents.Timeout = output.Timeout;
  }
  if (output.TransformId !== undefined && output.TransformId !== null) {
    contents.TransformId = output.TransformId;
  }
  if (output.WorkerType !== undefined && output.WorkerType !== null) {
    contents.WorkerType = output.WorkerType;
  }
  return contents;
};

const deserializeAws_json1_1GetMLTransformsResponse = (
  output: any,
  context: __SerdeContext
): GetMLTransformsResponse => {
  let contents: any = {
    __type: "GetMLTransformsResponse",
    NextToken: undefined,
    Transforms: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Transforms !== undefined && output.Transforms !== null) {
    contents.Transforms = deserializeAws_json1_1TransformList(
      output.Transforms,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GlueTable = (
  output: any,
  context: __SerdeContext
): GlueTable => {
  let contents: any = {
    __type: "GlueTable",
    CatalogId: undefined,
    ConnectionName: undefined,
    DatabaseName: undefined,
    TableName: undefined
  };
  if (output.CatalogId !== undefined && output.CatalogId !== null) {
    contents.CatalogId = output.CatalogId;
  }
  if (output.ConnectionName !== undefined && output.ConnectionName !== null) {
    contents.ConnectionName = output.ConnectionName;
  }
  if (output.DatabaseName !== undefined && output.DatabaseName !== null) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (output.TableName !== undefined && output.TableName !== null) {
    contents.TableName = output.TableName;
  }
  return contents;
};

const deserializeAws_json1_1GlueTables = (
  output: any,
  context: __SerdeContext
): Array<GlueTable> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GlueTable(entry, context)
  );
};

const deserializeAws_json1_1ImportLabelsTaskRunProperties = (
  output: any,
  context: __SerdeContext
): ImportLabelsTaskRunProperties => {
  let contents: any = {
    __type: "ImportLabelsTaskRunProperties",
    InputS3Path: undefined,
    Replace: undefined
  };
  if (output.InputS3Path !== undefined && output.InputS3Path !== null) {
    contents.InputS3Path = output.InputS3Path;
  }
  if (output.Replace !== undefined && output.Replace !== null) {
    contents.Replace = output.Replace;
  }
  return contents;
};

const deserializeAws_json1_1LabelingSetGenerationTaskRunProperties = (
  output: any,
  context: __SerdeContext
): LabelingSetGenerationTaskRunProperties => {
  let contents: any = {
    __type: "LabelingSetGenerationTaskRunProperties",
    OutputS3Path: undefined
  };
  if (output.OutputS3Path !== undefined && output.OutputS3Path !== null) {
    contents.OutputS3Path = output.OutputS3Path;
  }
  return contents;
};

const deserializeAws_json1_1MLTransform = (
  output: any,
  context: __SerdeContext
): MLTransform => {
  let contents: any = {
    __type: "MLTransform",
    CreatedOn: undefined,
    Description: undefined,
    EvaluationMetrics: undefined,
    GlueVersion: undefined,
    InputRecordTables: undefined,
    LabelCount: undefined,
    LastModifiedOn: undefined,
    MaxCapacity: undefined,
    MaxRetries: undefined,
    Name: undefined,
    NumberOfWorkers: undefined,
    Parameters: undefined,
    Role: undefined,
    Schema: undefined,
    Status: undefined,
    Timeout: undefined,
    TransformId: undefined,
    WorkerType: undefined
  };
  if (output.CreatedOn !== undefined && output.CreatedOn !== null) {
    contents.CreatedOn = new Date(Math.round(output.CreatedOn * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (
    output.EvaluationMetrics !== undefined &&
    output.EvaluationMetrics !== null
  ) {
    contents.EvaluationMetrics = deserializeAws_json1_1EvaluationMetrics(
      output.EvaluationMetrics,
      context
    );
  }
  if (output.GlueVersion !== undefined && output.GlueVersion !== null) {
    contents.GlueVersion = output.GlueVersion;
  }
  if (
    output.InputRecordTables !== undefined &&
    output.InputRecordTables !== null
  ) {
    contents.InputRecordTables = deserializeAws_json1_1GlueTables(
      output.InputRecordTables,
      context
    );
  }
  if (output.LabelCount !== undefined && output.LabelCount !== null) {
    contents.LabelCount = output.LabelCount;
  }
  if (output.LastModifiedOn !== undefined && output.LastModifiedOn !== null) {
    contents.LastModifiedOn = new Date(
      Math.round(output.LastModifiedOn * 1000)
    );
  }
  if (output.MaxCapacity !== undefined && output.MaxCapacity !== null) {
    contents.MaxCapacity = output.MaxCapacity;
  }
  if (output.MaxRetries !== undefined && output.MaxRetries !== null) {
    contents.MaxRetries = output.MaxRetries;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null) {
    contents.NumberOfWorkers = output.NumberOfWorkers;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1TransformParameters(
      output.Parameters,
      context
    );
  }
  if (output.Role !== undefined && output.Role !== null) {
    contents.Role = output.Role;
  }
  if (output.Schema !== undefined && output.Schema !== null) {
    contents.Schema = deserializeAws_json1_1TransformSchema(
      output.Schema,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Timeout !== undefined && output.Timeout !== null) {
    contents.Timeout = output.Timeout;
  }
  if (output.TransformId !== undefined && output.TransformId !== null) {
    contents.TransformId = output.TransformId;
  }
  if (output.WorkerType !== undefined && output.WorkerType !== null) {
    contents.WorkerType = output.WorkerType;
  }
  return contents;
};

const deserializeAws_json1_1MLTransformNotReadyException = (
  output: any,
  context: __SerdeContext
): MLTransformNotReadyException => {
  let contents: any = {
    __type: "MLTransformNotReadyException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1SchemaColumn = (
  output: any,
  context: __SerdeContext
): SchemaColumn => {
  let contents: any = {
    __type: "SchemaColumn",
    DataType: undefined,
    Name: undefined
  };
  if (output.DataType !== undefined && output.DataType !== null) {
    contents.DataType = output.DataType;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1StartExportLabelsTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartExportLabelsTaskRunResponse => {
  let contents: any = {
    __type: "StartExportLabelsTaskRunResponse",
    TaskRunId: undefined
  };
  if (output.TaskRunId !== undefined && output.TaskRunId !== null) {
    contents.TaskRunId = output.TaskRunId;
  }
  return contents;
};

const deserializeAws_json1_1StartImportLabelsTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartImportLabelsTaskRunResponse => {
  let contents: any = {
    __type: "StartImportLabelsTaskRunResponse",
    TaskRunId: undefined
  };
  if (output.TaskRunId !== undefined && output.TaskRunId !== null) {
    contents.TaskRunId = output.TaskRunId;
  }
  return contents;
};

const deserializeAws_json1_1StartMLEvaluationTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartMLEvaluationTaskRunResponse => {
  let contents: any = {
    __type: "StartMLEvaluationTaskRunResponse",
    TaskRunId: undefined
  };
  if (output.TaskRunId !== undefined && output.TaskRunId !== null) {
    contents.TaskRunId = output.TaskRunId;
  }
  return contents;
};

const deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunResponse = (
  output: any,
  context: __SerdeContext
): StartMLLabelingSetGenerationTaskRunResponse => {
  let contents: any = {
    __type: "StartMLLabelingSetGenerationTaskRunResponse",
    TaskRunId: undefined
  };
  if (output.TaskRunId !== undefined && output.TaskRunId !== null) {
    contents.TaskRunId = output.TaskRunId;
  }
  return contents;
};

const deserializeAws_json1_1TaskRun = (
  output: any,
  context: __SerdeContext
): TaskRun => {
  let contents: any = {
    __type: "TaskRun",
    CompletedOn: undefined,
    ErrorString: undefined,
    ExecutionTime: undefined,
    LastModifiedOn: undefined,
    LogGroupName: undefined,
    Properties: undefined,
    StartedOn: undefined,
    Status: undefined,
    TaskRunId: undefined,
    TransformId: undefined
  };
  if (output.CompletedOn !== undefined && output.CompletedOn !== null) {
    contents.CompletedOn = new Date(Math.round(output.CompletedOn * 1000));
  }
  if (output.ErrorString !== undefined && output.ErrorString !== null) {
    contents.ErrorString = output.ErrorString;
  }
  if (output.ExecutionTime !== undefined && output.ExecutionTime !== null) {
    contents.ExecutionTime = output.ExecutionTime;
  }
  if (output.LastModifiedOn !== undefined && output.LastModifiedOn !== null) {
    contents.LastModifiedOn = new Date(
      Math.round(output.LastModifiedOn * 1000)
    );
  }
  if (output.LogGroupName !== undefined && output.LogGroupName !== null) {
    contents.LogGroupName = output.LogGroupName;
  }
  if (output.Properties !== undefined && output.Properties !== null) {
    contents.Properties = deserializeAws_json1_1TaskRunProperties(
      output.Properties,
      context
    );
  }
  if (output.StartedOn !== undefined && output.StartedOn !== null) {
    contents.StartedOn = new Date(Math.round(output.StartedOn * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.TaskRunId !== undefined && output.TaskRunId !== null) {
    contents.TaskRunId = output.TaskRunId;
  }
  if (output.TransformId !== undefined && output.TransformId !== null) {
    contents.TransformId = output.TransformId;
  }
  return contents;
};

const deserializeAws_json1_1TaskRunList = (
  output: any,
  context: __SerdeContext
): Array<TaskRun> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TaskRun(entry, context)
  );
};

const deserializeAws_json1_1TaskRunProperties = (
  output: any,
  context: __SerdeContext
): TaskRunProperties => {
  let contents: any = {
    __type: "TaskRunProperties",
    ExportLabelsTaskRunProperties: undefined,
    FindMatchesTaskRunProperties: undefined,
    ImportLabelsTaskRunProperties: undefined,
    LabelingSetGenerationTaskRunProperties: undefined,
    TaskType: undefined
  };
  if (
    output.ExportLabelsTaskRunProperties !== undefined &&
    output.ExportLabelsTaskRunProperties !== null
  ) {
    contents.ExportLabelsTaskRunProperties = deserializeAws_json1_1ExportLabelsTaskRunProperties(
      output.ExportLabelsTaskRunProperties,
      context
    );
  }
  if (
    output.FindMatchesTaskRunProperties !== undefined &&
    output.FindMatchesTaskRunProperties !== null
  ) {
    contents.FindMatchesTaskRunProperties = deserializeAws_json1_1FindMatchesTaskRunProperties(
      output.FindMatchesTaskRunProperties,
      context
    );
  }
  if (
    output.ImportLabelsTaskRunProperties !== undefined &&
    output.ImportLabelsTaskRunProperties !== null
  ) {
    contents.ImportLabelsTaskRunProperties = deserializeAws_json1_1ImportLabelsTaskRunProperties(
      output.ImportLabelsTaskRunProperties,
      context
    );
  }
  if (
    output.LabelingSetGenerationTaskRunProperties !== undefined &&
    output.LabelingSetGenerationTaskRunProperties !== null
  ) {
    contents.LabelingSetGenerationTaskRunProperties = deserializeAws_json1_1LabelingSetGenerationTaskRunProperties(
      output.LabelingSetGenerationTaskRunProperties,
      context
    );
  }
  if (output.TaskType !== undefined && output.TaskType !== null) {
    contents.TaskType = output.TaskType;
  }
  return contents;
};

const deserializeAws_json1_1TransformList = (
  output: any,
  context: __SerdeContext
): Array<MLTransform> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MLTransform(entry, context)
  );
};

const deserializeAws_json1_1TransformParameters = (
  output: any,
  context: __SerdeContext
): TransformParameters => {
  let contents: any = {
    __type: "TransformParameters",
    FindMatchesParameters: undefined,
    TransformType: undefined
  };
  if (
    output.FindMatchesParameters !== undefined &&
    output.FindMatchesParameters !== null
  ) {
    contents.FindMatchesParameters = deserializeAws_json1_1FindMatchesParameters(
      output.FindMatchesParameters,
      context
    );
  }
  if (output.TransformType !== undefined && output.TransformType !== null) {
    contents.TransformType = output.TransformType;
  }
  return contents;
};

const deserializeAws_json1_1TransformSchema = (
  output: any,
  context: __SerdeContext
): Array<SchemaColumn> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SchemaColumn(entry, context)
  );
};

const deserializeAws_json1_1UpdateMLTransformResponse = (
  output: any,
  context: __SerdeContext
): UpdateMLTransformResponse => {
  let contents: any = {
    __type: "UpdateMLTransformResponse",
    TransformId: undefined
  };
  if (output.TransformId !== undefined && output.TransformId !== null) {
    contents.TransformId = output.TransformId;
  }
  return contents;
};

const deserializeAws_json1_1Action = (
  output: any,
  context: __SerdeContext
): Action => {
  let contents: any = {
    __type: "Action",
    Arguments: undefined,
    CrawlerName: undefined,
    JobName: undefined,
    NotificationProperty: undefined,
    SecurityConfiguration: undefined,
    Timeout: undefined
  };
  if (output.Arguments !== undefined && output.Arguments !== null) {
    contents.Arguments = deserializeAws_json1_1GenericMap(
      output.Arguments,
      context
    );
  }
  if (output.CrawlerName !== undefined && output.CrawlerName !== null) {
    contents.CrawlerName = output.CrawlerName;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (
    output.NotificationProperty !== undefined &&
    output.NotificationProperty !== null
  ) {
    contents.NotificationProperty = deserializeAws_json1_1NotificationProperty(
      output.NotificationProperty,
      context
    );
  }
  if (
    output.SecurityConfiguration !== undefined &&
    output.SecurityConfiguration !== null
  ) {
    contents.SecurityConfiguration = output.SecurityConfiguration;
  }
  if (output.Timeout !== undefined && output.Timeout !== null) {
    contents.Timeout = output.Timeout;
  }
  return contents;
};

const deserializeAws_json1_1ActionList = (
  output: any,
  context: __SerdeContext
): Array<Action> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Action(entry, context)
  );
};

const deserializeAws_json1_1BatchGetJobsResponse = (
  output: any,
  context: __SerdeContext
): BatchGetJobsResponse => {
  let contents: any = {
    __type: "BatchGetJobsResponse",
    Jobs: undefined,
    JobsNotFound: undefined
  };
  if (output.Jobs !== undefined && output.Jobs !== null) {
    contents.Jobs = deserializeAws_json1_1JobList(output.Jobs, context);
  }
  if (output.JobsNotFound !== undefined && output.JobsNotFound !== null) {
    contents.JobsNotFound = deserializeAws_json1_1JobNameList(
      output.JobsNotFound,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchGetTriggersResponse = (
  output: any,
  context: __SerdeContext
): BatchGetTriggersResponse => {
  let contents: any = {
    __type: "BatchGetTriggersResponse",
    Triggers: undefined,
    TriggersNotFound: undefined
  };
  if (output.Triggers !== undefined && output.Triggers !== null) {
    contents.Triggers = deserializeAws_json1_1TriggerList(
      output.Triggers,
      context
    );
  }
  if (
    output.TriggersNotFound !== undefined &&
    output.TriggersNotFound !== null
  ) {
    contents.TriggersNotFound = deserializeAws_json1_1TriggerNameList(
      output.TriggersNotFound,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchGetWorkflowsResponse = (
  output: any,
  context: __SerdeContext
): BatchGetWorkflowsResponse => {
  let contents: any = {
    __type: "BatchGetWorkflowsResponse",
    MissingWorkflows: undefined,
    Workflows: undefined
  };
  if (
    output.MissingWorkflows !== undefined &&
    output.MissingWorkflows !== null
  ) {
    contents.MissingWorkflows = deserializeAws_json1_1WorkflowNames(
      output.MissingWorkflows,
      context
    );
  }
  if (output.Workflows !== undefined && output.Workflows !== null) {
    contents.Workflows = deserializeAws_json1_1Workflows(
      output.Workflows,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchStopJobRunError = (
  output: any,
  context: __SerdeContext
): BatchStopJobRunError => {
  let contents: any = {
    __type: "BatchStopJobRunError",
    ErrorDetail: undefined,
    JobName: undefined,
    JobRunId: undefined
  };
  if (output.ErrorDetail !== undefined && output.ErrorDetail !== null) {
    contents.ErrorDetail = deserializeAws_json1_1ErrorDetail(
      output.ErrorDetail,
      context
    );
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobRunId !== undefined && output.JobRunId !== null) {
    contents.JobRunId = output.JobRunId;
  }
  return contents;
};

const deserializeAws_json1_1BatchStopJobRunErrorList = (
  output: any,
  context: __SerdeContext
): Array<BatchStopJobRunError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchStopJobRunError(entry, context)
  );
};

const deserializeAws_json1_1BatchStopJobRunResponse = (
  output: any,
  context: __SerdeContext
): BatchStopJobRunResponse => {
  let contents: any = {
    __type: "BatchStopJobRunResponse",
    Errors: undefined,
    SuccessfulSubmissions: undefined
  };
  if (output.Errors !== undefined && output.Errors !== null) {
    contents.Errors = deserializeAws_json1_1BatchStopJobRunErrorList(
      output.Errors,
      context
    );
  }
  if (
    output.SuccessfulSubmissions !== undefined &&
    output.SuccessfulSubmissions !== null
  ) {
    contents.SuccessfulSubmissions = deserializeAws_json1_1BatchStopJobRunSuccessfulSubmissionList(
      output.SuccessfulSubmissions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchStopJobRunSuccessfulSubmission = (
  output: any,
  context: __SerdeContext
): BatchStopJobRunSuccessfulSubmission => {
  let contents: any = {
    __type: "BatchStopJobRunSuccessfulSubmission",
    JobName: undefined,
    JobRunId: undefined
  };
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobRunId !== undefined && output.JobRunId !== null) {
    contents.JobRunId = output.JobRunId;
  }
  return contents;
};

const deserializeAws_json1_1BatchStopJobRunSuccessfulSubmissionList = (
  output: any,
  context: __SerdeContext
): Array<BatchStopJobRunSuccessfulSubmission> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchStopJobRunSuccessfulSubmission(entry, context)
  );
};

const deserializeAws_json1_1Condition = (
  output: any,
  context: __SerdeContext
): Condition => {
  let contents: any = {
    __type: "Condition",
    CrawlState: undefined,
    CrawlerName: undefined,
    JobName: undefined,
    LogicalOperator: undefined,
    State: undefined
  };
  if (output.CrawlState !== undefined && output.CrawlState !== null) {
    contents.CrawlState = output.CrawlState;
  }
  if (output.CrawlerName !== undefined && output.CrawlerName !== null) {
    contents.CrawlerName = output.CrawlerName;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.LogicalOperator !== undefined && output.LogicalOperator !== null) {
    contents.LogicalOperator = output.LogicalOperator;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  return contents;
};

const deserializeAws_json1_1ConditionList = (
  output: any,
  context: __SerdeContext
): Array<Condition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Condition(entry, context)
  );
};

const deserializeAws_json1_1ConnectionsList = (
  output: any,
  context: __SerdeContext
): ConnectionsList => {
  let contents: any = {
    __type: "ConnectionsList",
    Connections: undefined
  };
  if (output.Connections !== undefined && output.Connections !== null) {
    contents.Connections = deserializeAws_json1_1OrchestrationStringList(
      output.Connections,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1Crawl = (
  output: any,
  context: __SerdeContext
): Crawl => {
  let contents: any = {
    __type: "Crawl",
    CompletedOn: undefined,
    ErrorMessage: undefined,
    LogGroup: undefined,
    LogStream: undefined,
    StartedOn: undefined,
    State: undefined
  };
  if (output.CompletedOn !== undefined && output.CompletedOn !== null) {
    contents.CompletedOn = new Date(Math.round(output.CompletedOn * 1000));
  }
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.LogGroup !== undefined && output.LogGroup !== null) {
    contents.LogGroup = output.LogGroup;
  }
  if (output.LogStream !== undefined && output.LogStream !== null) {
    contents.LogStream = output.LogStream;
  }
  if (output.StartedOn !== undefined && output.StartedOn !== null) {
    contents.StartedOn = new Date(Math.round(output.StartedOn * 1000));
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  return contents;
};

const deserializeAws_json1_1CrawlList = (
  output: any,
  context: __SerdeContext
): Array<Crawl> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Crawl(entry, context)
  );
};

const deserializeAws_json1_1CrawlerNodeDetails = (
  output: any,
  context: __SerdeContext
): CrawlerNodeDetails => {
  let contents: any = {
    __type: "CrawlerNodeDetails",
    Crawls: undefined
  };
  if (output.Crawls !== undefined && output.Crawls !== null) {
    contents.Crawls = deserializeAws_json1_1CrawlList(output.Crawls, context);
  }
  return contents;
};

const deserializeAws_json1_1CreateJobResponse = (
  output: any,
  context: __SerdeContext
): CreateJobResponse => {
  let contents: any = {
    __type: "CreateJobResponse",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1CreateTriggerResponse = (
  output: any,
  context: __SerdeContext
): CreateTriggerResponse => {
  let contents: any = {
    __type: "CreateTriggerResponse",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1CreateWorkflowResponse = (
  output: any,
  context: __SerdeContext
): CreateWorkflowResponse => {
  let contents: any = {
    __type: "CreateWorkflowResponse",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1DeleteJobResponse = (
  output: any,
  context: __SerdeContext
): DeleteJobResponse => {
  let contents: any = {
    __type: "DeleteJobResponse",
    JobName: undefined
  };
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  return contents;
};

const deserializeAws_json1_1DeleteTriggerResponse = (
  output: any,
  context: __SerdeContext
): DeleteTriggerResponse => {
  let contents: any = {
    __type: "DeleteTriggerResponse",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1DeleteWorkflowResponse = (
  output: any,
  context: __SerdeContext
): DeleteWorkflowResponse => {
  let contents: any = {
    __type: "DeleteWorkflowResponse",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1Edge = (
  output: any,
  context: __SerdeContext
): Edge => {
  let contents: any = {
    __type: "Edge",
    DestinationId: undefined,
    SourceId: undefined
  };
  if (output.DestinationId !== undefined && output.DestinationId !== null) {
    contents.DestinationId = output.DestinationId;
  }
  if (output.SourceId !== undefined && output.SourceId !== null) {
    contents.SourceId = output.SourceId;
  }
  return contents;
};

const deserializeAws_json1_1EdgeList = (
  output: any,
  context: __SerdeContext
): Array<Edge> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Edge(entry, context)
  );
};

const deserializeAws_json1_1ExecutionProperty = (
  output: any,
  context: __SerdeContext
): ExecutionProperty => {
  let contents: any = {
    __type: "ExecutionProperty",
    MaxConcurrentRuns: undefined
  };
  if (
    output.MaxConcurrentRuns !== undefined &&
    output.MaxConcurrentRuns !== null
  ) {
    contents.MaxConcurrentRuns = output.MaxConcurrentRuns;
  }
  return contents;
};

const deserializeAws_json1_1GenericMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1GetJobResponse = (
  output: any,
  context: __SerdeContext
): GetJobResponse => {
  let contents: any = {
    __type: "GetJobResponse",
    Job: undefined
  };
  if (output.Job !== undefined && output.Job !== null) {
    contents.Job = deserializeAws_json1_1Job(output.Job, context);
  }
  return contents;
};

const deserializeAws_json1_1GetJobRunResponse = (
  output: any,
  context: __SerdeContext
): GetJobRunResponse => {
  let contents: any = {
    __type: "GetJobRunResponse",
    JobRun: undefined
  };
  if (output.JobRun !== undefined && output.JobRun !== null) {
    contents.JobRun = deserializeAws_json1_1JobRun(output.JobRun, context);
  }
  return contents;
};

const deserializeAws_json1_1GetJobRunsResponse = (
  output: any,
  context: __SerdeContext
): GetJobRunsResponse => {
  let contents: any = {
    __type: "GetJobRunsResponse",
    JobRuns: undefined,
    NextToken: undefined
  };
  if (output.JobRuns !== undefined && output.JobRuns !== null) {
    contents.JobRuns = deserializeAws_json1_1JobRunList(
      output.JobRuns,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetJobsResponse = (
  output: any,
  context: __SerdeContext
): GetJobsResponse => {
  let contents: any = {
    __type: "GetJobsResponse",
    Jobs: undefined,
    NextToken: undefined
  };
  if (output.Jobs !== undefined && output.Jobs !== null) {
    contents.Jobs = deserializeAws_json1_1JobList(output.Jobs, context);
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetTriggerResponse = (
  output: any,
  context: __SerdeContext
): GetTriggerResponse => {
  let contents: any = {
    __type: "GetTriggerResponse",
    Trigger: undefined
  };
  if (output.Trigger !== undefined && output.Trigger !== null) {
    contents.Trigger = deserializeAws_json1_1Trigger(output.Trigger, context);
  }
  return contents;
};

const deserializeAws_json1_1GetTriggersResponse = (
  output: any,
  context: __SerdeContext
): GetTriggersResponse => {
  let contents: any = {
    __type: "GetTriggersResponse",
    NextToken: undefined,
    Triggers: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Triggers !== undefined && output.Triggers !== null) {
    contents.Triggers = deserializeAws_json1_1TriggerList(
      output.Triggers,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetWorkflowResponse = (
  output: any,
  context: __SerdeContext
): GetWorkflowResponse => {
  let contents: any = {
    __type: "GetWorkflowResponse",
    Workflow: undefined
  };
  if (output.Workflow !== undefined && output.Workflow !== null) {
    contents.Workflow = deserializeAws_json1_1Workflow(
      output.Workflow,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetWorkflowRunPropertiesResponse = (
  output: any,
  context: __SerdeContext
): GetWorkflowRunPropertiesResponse => {
  let contents: any = {
    __type: "GetWorkflowRunPropertiesResponse",
    RunProperties: undefined
  };
  if (output.RunProperties !== undefined && output.RunProperties !== null) {
    contents.RunProperties = deserializeAws_json1_1WorkflowRunProperties(
      output.RunProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetWorkflowRunResponse = (
  output: any,
  context: __SerdeContext
): GetWorkflowRunResponse => {
  let contents: any = {
    __type: "GetWorkflowRunResponse",
    Run: undefined
  };
  if (output.Run !== undefined && output.Run !== null) {
    contents.Run = deserializeAws_json1_1WorkflowRun(output.Run, context);
  }
  return contents;
};

const deserializeAws_json1_1GetWorkflowRunsResponse = (
  output: any,
  context: __SerdeContext
): GetWorkflowRunsResponse => {
  let contents: any = {
    __type: "GetWorkflowRunsResponse",
    NextToken: undefined,
    Runs: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Runs !== undefined && output.Runs !== null) {
    contents.Runs = deserializeAws_json1_1WorkflowRuns(output.Runs, context);
  }
  return contents;
};

const deserializeAws_json1_1Job = (
  output: any,
  context: __SerdeContext
): Job => {
  let contents: any = {
    __type: "Job",
    AllocatedCapacity: undefined,
    Command: undefined,
    Connections: undefined,
    CreatedOn: undefined,
    DefaultArguments: undefined,
    Description: undefined,
    ExecutionProperty: undefined,
    GlueVersion: undefined,
    LastModifiedOn: undefined,
    LogUri: undefined,
    MaxCapacity: undefined,
    MaxRetries: undefined,
    Name: undefined,
    NotificationProperty: undefined,
    NumberOfWorkers: undefined,
    Role: undefined,
    SecurityConfiguration: undefined,
    Timeout: undefined,
    WorkerType: undefined
  };
  if (
    output.AllocatedCapacity !== undefined &&
    output.AllocatedCapacity !== null
  ) {
    contents.AllocatedCapacity = output.AllocatedCapacity;
  }
  if (output.Command !== undefined && output.Command !== null) {
    contents.Command = deserializeAws_json1_1JobCommand(
      output.Command,
      context
    );
  }
  if (output.Connections !== undefined && output.Connections !== null) {
    contents.Connections = deserializeAws_json1_1ConnectionsList(
      output.Connections,
      context
    );
  }
  if (output.CreatedOn !== undefined && output.CreatedOn !== null) {
    contents.CreatedOn = new Date(Math.round(output.CreatedOn * 1000));
  }
  if (
    output.DefaultArguments !== undefined &&
    output.DefaultArguments !== null
  ) {
    contents.DefaultArguments = deserializeAws_json1_1GenericMap(
      output.DefaultArguments,
      context
    );
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (
    output.ExecutionProperty !== undefined &&
    output.ExecutionProperty !== null
  ) {
    contents.ExecutionProperty = deserializeAws_json1_1ExecutionProperty(
      output.ExecutionProperty,
      context
    );
  }
  if (output.GlueVersion !== undefined && output.GlueVersion !== null) {
    contents.GlueVersion = output.GlueVersion;
  }
  if (output.LastModifiedOn !== undefined && output.LastModifiedOn !== null) {
    contents.LastModifiedOn = new Date(
      Math.round(output.LastModifiedOn * 1000)
    );
  }
  if (output.LogUri !== undefined && output.LogUri !== null) {
    contents.LogUri = output.LogUri;
  }
  if (output.MaxCapacity !== undefined && output.MaxCapacity !== null) {
    contents.MaxCapacity = output.MaxCapacity;
  }
  if (output.MaxRetries !== undefined && output.MaxRetries !== null) {
    contents.MaxRetries = output.MaxRetries;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.NotificationProperty !== undefined &&
    output.NotificationProperty !== null
  ) {
    contents.NotificationProperty = deserializeAws_json1_1NotificationProperty(
      output.NotificationProperty,
      context
    );
  }
  if (output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null) {
    contents.NumberOfWorkers = output.NumberOfWorkers;
  }
  if (output.Role !== undefined && output.Role !== null) {
    contents.Role = output.Role;
  }
  if (
    output.SecurityConfiguration !== undefined &&
    output.SecurityConfiguration !== null
  ) {
    contents.SecurityConfiguration = output.SecurityConfiguration;
  }
  if (output.Timeout !== undefined && output.Timeout !== null) {
    contents.Timeout = output.Timeout;
  }
  if (output.WorkerType !== undefined && output.WorkerType !== null) {
    contents.WorkerType = output.WorkerType;
  }
  return contents;
};

const deserializeAws_json1_1JobCommand = (
  output: any,
  context: __SerdeContext
): JobCommand => {
  let contents: any = {
    __type: "JobCommand",
    Name: undefined,
    PythonVersion: undefined,
    ScriptLocation: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.PythonVersion !== undefined && output.PythonVersion !== null) {
    contents.PythonVersion = output.PythonVersion;
  }
  if (output.ScriptLocation !== undefined && output.ScriptLocation !== null) {
    contents.ScriptLocation = output.ScriptLocation;
  }
  return contents;
};

const deserializeAws_json1_1JobList = (
  output: any,
  context: __SerdeContext
): Array<Job> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Job(entry, context)
  );
};

const deserializeAws_json1_1JobNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1JobNodeDetails = (
  output: any,
  context: __SerdeContext
): JobNodeDetails => {
  let contents: any = {
    __type: "JobNodeDetails",
    JobRuns: undefined
  };
  if (output.JobRuns !== undefined && output.JobRuns !== null) {
    contents.JobRuns = deserializeAws_json1_1JobRunList(
      output.JobRuns,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1JobRun = (
  output: any,
  context: __SerdeContext
): JobRun => {
  let contents: any = {
    __type: "JobRun",
    AllocatedCapacity: undefined,
    Arguments: undefined,
    Attempt: undefined,
    CompletedOn: undefined,
    ErrorMessage: undefined,
    ExecutionTime: undefined,
    GlueVersion: undefined,
    Id: undefined,
    JobName: undefined,
    JobRunState: undefined,
    LastModifiedOn: undefined,
    LogGroupName: undefined,
    MaxCapacity: undefined,
    NotificationProperty: undefined,
    NumberOfWorkers: undefined,
    PredecessorRuns: undefined,
    PreviousRunId: undefined,
    SecurityConfiguration: undefined,
    StartedOn: undefined,
    Timeout: undefined,
    TriggerName: undefined,
    WorkerType: undefined
  };
  if (
    output.AllocatedCapacity !== undefined &&
    output.AllocatedCapacity !== null
  ) {
    contents.AllocatedCapacity = output.AllocatedCapacity;
  }
  if (output.Arguments !== undefined && output.Arguments !== null) {
    contents.Arguments = deserializeAws_json1_1GenericMap(
      output.Arguments,
      context
    );
  }
  if (output.Attempt !== undefined && output.Attempt !== null) {
    contents.Attempt = output.Attempt;
  }
  if (output.CompletedOn !== undefined && output.CompletedOn !== null) {
    contents.CompletedOn = new Date(Math.round(output.CompletedOn * 1000));
  }
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.ExecutionTime !== undefined && output.ExecutionTime !== null) {
    contents.ExecutionTime = output.ExecutionTime;
  }
  if (output.GlueVersion !== undefined && output.GlueVersion !== null) {
    contents.GlueVersion = output.GlueVersion;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobRunState !== undefined && output.JobRunState !== null) {
    contents.JobRunState = output.JobRunState;
  }
  if (output.LastModifiedOn !== undefined && output.LastModifiedOn !== null) {
    contents.LastModifiedOn = new Date(
      Math.round(output.LastModifiedOn * 1000)
    );
  }
  if (output.LogGroupName !== undefined && output.LogGroupName !== null) {
    contents.LogGroupName = output.LogGroupName;
  }
  if (output.MaxCapacity !== undefined && output.MaxCapacity !== null) {
    contents.MaxCapacity = output.MaxCapacity;
  }
  if (
    output.NotificationProperty !== undefined &&
    output.NotificationProperty !== null
  ) {
    contents.NotificationProperty = deserializeAws_json1_1NotificationProperty(
      output.NotificationProperty,
      context
    );
  }
  if (output.NumberOfWorkers !== undefined && output.NumberOfWorkers !== null) {
    contents.NumberOfWorkers = output.NumberOfWorkers;
  }
  if (output.PredecessorRuns !== undefined && output.PredecessorRuns !== null) {
    contents.PredecessorRuns = deserializeAws_json1_1PredecessorList(
      output.PredecessorRuns,
      context
    );
  }
  if (output.PreviousRunId !== undefined && output.PreviousRunId !== null) {
    contents.PreviousRunId = output.PreviousRunId;
  }
  if (
    output.SecurityConfiguration !== undefined &&
    output.SecurityConfiguration !== null
  ) {
    contents.SecurityConfiguration = output.SecurityConfiguration;
  }
  if (output.StartedOn !== undefined && output.StartedOn !== null) {
    contents.StartedOn = new Date(Math.round(output.StartedOn * 1000));
  }
  if (output.Timeout !== undefined && output.Timeout !== null) {
    contents.Timeout = output.Timeout;
  }
  if (output.TriggerName !== undefined && output.TriggerName !== null) {
    contents.TriggerName = output.TriggerName;
  }
  if (output.WorkerType !== undefined && output.WorkerType !== null) {
    contents.WorkerType = output.WorkerType;
  }
  return contents;
};

const deserializeAws_json1_1JobRunList = (
  output: any,
  context: __SerdeContext
): Array<JobRun> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1JobRun(entry, context)
  );
};

const deserializeAws_json1_1ListJobsResponse = (
  output: any,
  context: __SerdeContext
): ListJobsResponse => {
  let contents: any = {
    __type: "ListJobsResponse",
    JobNames: undefined,
    NextToken: undefined
  };
  if (output.JobNames !== undefined && output.JobNames !== null) {
    contents.JobNames = deserializeAws_json1_1JobNameList(
      output.JobNames,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListTriggersResponse = (
  output: any,
  context: __SerdeContext
): ListTriggersResponse => {
  let contents: any = {
    __type: "ListTriggersResponse",
    NextToken: undefined,
    TriggerNames: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.TriggerNames !== undefined && output.TriggerNames !== null) {
    contents.TriggerNames = deserializeAws_json1_1TriggerNameList(
      output.TriggerNames,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListWorkflowsResponse = (
  output: any,
  context: __SerdeContext
): ListWorkflowsResponse => {
  let contents: any = {
    __type: "ListWorkflowsResponse",
    NextToken: undefined,
    Workflows: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Workflows !== undefined && output.Workflows !== null) {
    contents.Workflows = deserializeAws_json1_1WorkflowNames(
      output.Workflows,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1Node = (
  output: any,
  context: __SerdeContext
): Node => {
  let contents: any = {
    __type: "Node",
    CrawlerDetails: undefined,
    JobDetails: undefined,
    Name: undefined,
    TriggerDetails: undefined,
    Type: undefined,
    UniqueId: undefined
  };
  if (output.CrawlerDetails !== undefined && output.CrawlerDetails !== null) {
    contents.CrawlerDetails = deserializeAws_json1_1CrawlerNodeDetails(
      output.CrawlerDetails,
      context
    );
  }
  if (output.JobDetails !== undefined && output.JobDetails !== null) {
    contents.JobDetails = deserializeAws_json1_1JobNodeDetails(
      output.JobDetails,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.TriggerDetails !== undefined && output.TriggerDetails !== null) {
    contents.TriggerDetails = deserializeAws_json1_1TriggerNodeDetails(
      output.TriggerDetails,
      context
    );
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.UniqueId !== undefined && output.UniqueId !== null) {
    contents.UniqueId = output.UniqueId;
  }
  return contents;
};

const deserializeAws_json1_1NodeList = (
  output: any,
  context: __SerdeContext
): Array<Node> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Node(entry, context)
  );
};

const deserializeAws_json1_1NotificationProperty = (
  output: any,
  context: __SerdeContext
): NotificationProperty => {
  let contents: any = {
    __type: "NotificationProperty",
    NotifyDelayAfter: undefined
  };
  if (
    output.NotifyDelayAfter !== undefined &&
    output.NotifyDelayAfter !== null
  ) {
    contents.NotifyDelayAfter = output.NotifyDelayAfter;
  }
  return contents;
};

const deserializeAws_json1_1OrchestrationStringList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Predecessor = (
  output: any,
  context: __SerdeContext
): Predecessor => {
  let contents: any = {
    __type: "Predecessor",
    JobName: undefined,
    RunId: undefined
  };
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.RunId !== undefined && output.RunId !== null) {
    contents.RunId = output.RunId;
  }
  return contents;
};

const deserializeAws_json1_1PredecessorList = (
  output: any,
  context: __SerdeContext
): Array<Predecessor> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Predecessor(entry, context)
  );
};

const deserializeAws_json1_1Predicate = (
  output: any,
  context: __SerdeContext
): Predicate => {
  let contents: any = {
    __type: "Predicate",
    Conditions: undefined,
    Logical: undefined
  };
  if (output.Conditions !== undefined && output.Conditions !== null) {
    contents.Conditions = deserializeAws_json1_1ConditionList(
      output.Conditions,
      context
    );
  }
  if (output.Logical !== undefined && output.Logical !== null) {
    contents.Logical = output.Logical;
  }
  return contents;
};

const deserializeAws_json1_1PutWorkflowRunPropertiesResponse = (
  output: any,
  context: __SerdeContext
): PutWorkflowRunPropertiesResponse => {
  let contents: any = {
    __type: "PutWorkflowRunPropertiesResponse"
  };
  return contents;
};

const deserializeAws_json1_1StartJobRunResponse = (
  output: any,
  context: __SerdeContext
): StartJobRunResponse => {
  let contents: any = {
    __type: "StartJobRunResponse",
    JobRunId: undefined
  };
  if (output.JobRunId !== undefined && output.JobRunId !== null) {
    contents.JobRunId = output.JobRunId;
  }
  return contents;
};

const deserializeAws_json1_1StartTriggerResponse = (
  output: any,
  context: __SerdeContext
): StartTriggerResponse => {
  let contents: any = {
    __type: "StartTriggerResponse",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1StartWorkflowRunResponse = (
  output: any,
  context: __SerdeContext
): StartWorkflowRunResponse => {
  let contents: any = {
    __type: "StartWorkflowRunResponse",
    RunId: undefined
  };
  if (output.RunId !== undefined && output.RunId !== null) {
    contents.RunId = output.RunId;
  }
  return contents;
};

const deserializeAws_json1_1StopTriggerResponse = (
  output: any,
  context: __SerdeContext
): StopTriggerResponse => {
  let contents: any = {
    __type: "StopTriggerResponse",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1Trigger = (
  output: any,
  context: __SerdeContext
): Trigger => {
  let contents: any = {
    __type: "Trigger",
    Actions: undefined,
    Description: undefined,
    Id: undefined,
    Name: undefined,
    Predicate: undefined,
    Schedule: undefined,
    State: undefined,
    Type: undefined,
    WorkflowName: undefined
  };
  if (output.Actions !== undefined && output.Actions !== null) {
    contents.Actions = deserializeAws_json1_1ActionList(
      output.Actions,
      context
    );
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Predicate !== undefined && output.Predicate !== null) {
    contents.Predicate = deserializeAws_json1_1Predicate(
      output.Predicate,
      context
    );
  }
  if (output.Schedule !== undefined && output.Schedule !== null) {
    contents.Schedule = output.Schedule;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.WorkflowName !== undefined && output.WorkflowName !== null) {
    contents.WorkflowName = output.WorkflowName;
  }
  return contents;
};

const deserializeAws_json1_1TriggerList = (
  output: any,
  context: __SerdeContext
): Array<Trigger> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Trigger(entry, context)
  );
};

const deserializeAws_json1_1TriggerNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1TriggerNodeDetails = (
  output: any,
  context: __SerdeContext
): TriggerNodeDetails => {
  let contents: any = {
    __type: "TriggerNodeDetails",
    Trigger: undefined
  };
  if (output.Trigger !== undefined && output.Trigger !== null) {
    contents.Trigger = deserializeAws_json1_1Trigger(output.Trigger, context);
  }
  return contents;
};

const deserializeAws_json1_1UpdateJobResponse = (
  output: any,
  context: __SerdeContext
): UpdateJobResponse => {
  let contents: any = {
    __type: "UpdateJobResponse",
    JobName: undefined
  };
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  return contents;
};

const deserializeAws_json1_1UpdateTriggerResponse = (
  output: any,
  context: __SerdeContext
): UpdateTriggerResponse => {
  let contents: any = {
    __type: "UpdateTriggerResponse",
    Trigger: undefined
  };
  if (output.Trigger !== undefined && output.Trigger !== null) {
    contents.Trigger = deserializeAws_json1_1Trigger(output.Trigger, context);
  }
  return contents;
};

const deserializeAws_json1_1UpdateWorkflowResponse = (
  output: any,
  context: __SerdeContext
): UpdateWorkflowResponse => {
  let contents: any = {
    __type: "UpdateWorkflowResponse",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1Workflow = (
  output: any,
  context: __SerdeContext
): Workflow => {
  let contents: any = {
    __type: "Workflow",
    CreatedOn: undefined,
    DefaultRunProperties: undefined,
    Description: undefined,
    Graph: undefined,
    LastModifiedOn: undefined,
    LastRun: undefined,
    Name: undefined
  };
  if (output.CreatedOn !== undefined && output.CreatedOn !== null) {
    contents.CreatedOn = new Date(Math.round(output.CreatedOn * 1000));
  }
  if (
    output.DefaultRunProperties !== undefined &&
    output.DefaultRunProperties !== null
  ) {
    contents.DefaultRunProperties = deserializeAws_json1_1WorkflowRunProperties(
      output.DefaultRunProperties,
      context
    );
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Graph !== undefined && output.Graph !== null) {
    contents.Graph = deserializeAws_json1_1WorkflowGraph(output.Graph, context);
  }
  if (output.LastModifiedOn !== undefined && output.LastModifiedOn !== null) {
    contents.LastModifiedOn = new Date(
      Math.round(output.LastModifiedOn * 1000)
    );
  }
  if (output.LastRun !== undefined && output.LastRun !== null) {
    contents.LastRun = deserializeAws_json1_1WorkflowRun(
      output.LastRun,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1WorkflowGraph = (
  output: any,
  context: __SerdeContext
): WorkflowGraph => {
  let contents: any = {
    __type: "WorkflowGraph",
    Edges: undefined,
    Nodes: undefined
  };
  if (output.Edges !== undefined && output.Edges !== null) {
    contents.Edges = deserializeAws_json1_1EdgeList(output.Edges, context);
  }
  if (output.Nodes !== undefined && output.Nodes !== null) {
    contents.Nodes = deserializeAws_json1_1NodeList(output.Nodes, context);
  }
  return contents;
};

const deserializeAws_json1_1WorkflowNames = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1WorkflowRun = (
  output: any,
  context: __SerdeContext
): WorkflowRun => {
  let contents: any = {
    __type: "WorkflowRun",
    CompletedOn: undefined,
    Graph: undefined,
    Name: undefined,
    StartedOn: undefined,
    Statistics: undefined,
    Status: undefined,
    WorkflowRunId: undefined,
    WorkflowRunProperties: undefined
  };
  if (output.CompletedOn !== undefined && output.CompletedOn !== null) {
    contents.CompletedOn = new Date(Math.round(output.CompletedOn * 1000));
  }
  if (output.Graph !== undefined && output.Graph !== null) {
    contents.Graph = deserializeAws_json1_1WorkflowGraph(output.Graph, context);
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.StartedOn !== undefined && output.StartedOn !== null) {
    contents.StartedOn = new Date(Math.round(output.StartedOn * 1000));
  }
  if (output.Statistics !== undefined && output.Statistics !== null) {
    contents.Statistics = deserializeAws_json1_1WorkflowRunStatistics(
      output.Statistics,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.WorkflowRunId !== undefined && output.WorkflowRunId !== null) {
    contents.WorkflowRunId = output.WorkflowRunId;
  }
  if (
    output.WorkflowRunProperties !== undefined &&
    output.WorkflowRunProperties !== null
  ) {
    contents.WorkflowRunProperties = deserializeAws_json1_1WorkflowRunProperties(
      output.WorkflowRunProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1WorkflowRunProperties = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1WorkflowRunStatistics = (
  output: any,
  context: __SerdeContext
): WorkflowRunStatistics => {
  let contents: any = {
    __type: "WorkflowRunStatistics",
    FailedActions: undefined,
    RunningActions: undefined,
    StoppedActions: undefined,
    SucceededActions: undefined,
    TimeoutActions: undefined,
    TotalActions: undefined
  };
  if (output.FailedActions !== undefined && output.FailedActions !== null) {
    contents.FailedActions = output.FailedActions;
  }
  if (output.RunningActions !== undefined && output.RunningActions !== null) {
    contents.RunningActions = output.RunningActions;
  }
  if (output.StoppedActions !== undefined && output.StoppedActions !== null) {
    contents.StoppedActions = output.StoppedActions;
  }
  if (
    output.SucceededActions !== undefined &&
    output.SucceededActions !== null
  ) {
    contents.SucceededActions = output.SucceededActions;
  }
  if (output.TimeoutActions !== undefined && output.TimeoutActions !== null) {
    contents.TimeoutActions = output.TimeoutActions;
  }
  if (output.TotalActions !== undefined && output.TotalActions !== null) {
    contents.TotalActions = output.TotalActions;
  }
  return contents;
};

const deserializeAws_json1_1WorkflowRuns = (
  output: any,
  context: __SerdeContext
): Array<WorkflowRun> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1WorkflowRun(entry, context)
  );
};

const deserializeAws_json1_1Workflows = (
  output: any,
  context: __SerdeContext
): Array<Workflow> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Workflow(entry, context)
  );
};

const deserializeAws_json1_1BatchGetCrawlersResponse = (
  output: any,
  context: __SerdeContext
): BatchGetCrawlersResponse => {
  let contents: any = {
    __type: "BatchGetCrawlersResponse",
    Crawlers: undefined,
    CrawlersNotFound: undefined
  };
  if (output.Crawlers !== undefined && output.Crawlers !== null) {
    contents.Crawlers = deserializeAws_json1_1CrawlerList(
      output.Crawlers,
      context
    );
  }
  if (
    output.CrawlersNotFound !== undefined &&
    output.CrawlersNotFound !== null
  ) {
    contents.CrawlersNotFound = deserializeAws_json1_1CrawlerNameList(
      output.CrawlersNotFound,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CatalogTablesList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1CatalogTarget = (
  output: any,
  context: __SerdeContext
): CatalogTarget => {
  let contents: any = {
    __type: "CatalogTarget",
    DatabaseName: undefined,
    Tables: undefined
  };
  if (output.DatabaseName !== undefined && output.DatabaseName !== null) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (output.Tables !== undefined && output.Tables !== null) {
    contents.Tables = deserializeAws_json1_1CatalogTablesList(
      output.Tables,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CatalogTargetList = (
  output: any,
  context: __SerdeContext
): Array<CatalogTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CatalogTarget(entry, context)
  );
};

const deserializeAws_json1_1Classifier = (
  output: any,
  context: __SerdeContext
): Classifier => {
  let contents: any = {
    __type: "Classifier",
    CsvClassifier: undefined,
    GrokClassifier: undefined,
    JsonClassifier: undefined,
    XMLClassifier: undefined
  };
  if (output.CsvClassifier !== undefined && output.CsvClassifier !== null) {
    contents.CsvClassifier = deserializeAws_json1_1CsvClassifier(
      output.CsvClassifier,
      context
    );
  }
  if (output.GrokClassifier !== undefined && output.GrokClassifier !== null) {
    contents.GrokClassifier = deserializeAws_json1_1GrokClassifier(
      output.GrokClassifier,
      context
    );
  }
  if (output.JsonClassifier !== undefined && output.JsonClassifier !== null) {
    contents.JsonClassifier = deserializeAws_json1_1JsonClassifier(
      output.JsonClassifier,
      context
    );
  }
  if (output.XMLClassifier !== undefined && output.XMLClassifier !== null) {
    contents.XMLClassifier = deserializeAws_json1_1XMLClassifier(
      output.XMLClassifier,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ClassifierList = (
  output: any,
  context: __SerdeContext
): Array<Classifier> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Classifier(entry, context)
  );
};

const deserializeAws_json1_1ClassifierNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1CodeGenEdge = (
  output: any,
  context: __SerdeContext
): CodeGenEdge => {
  let contents: any = {
    __type: "CodeGenEdge",
    Source: undefined,
    Target: undefined,
    TargetParameter: undefined
  };
  if (output.Source !== undefined && output.Source !== null) {
    contents.Source = output.Source;
  }
  if (output.Target !== undefined && output.Target !== null) {
    contents.Target = output.Target;
  }
  if (output.TargetParameter !== undefined && output.TargetParameter !== null) {
    contents.TargetParameter = output.TargetParameter;
  }
  return contents;
};

const deserializeAws_json1_1CodeGenNode = (
  output: any,
  context: __SerdeContext
): CodeGenNode => {
  let contents: any = {
    __type: "CodeGenNode",
    Args: undefined,
    Id: undefined,
    LineNumber: undefined,
    NodeType: undefined
  };
  if (output.Args !== undefined && output.Args !== null) {
    contents.Args = deserializeAws_json1_1CodeGenNodeArgs(output.Args, context);
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.LineNumber !== undefined && output.LineNumber !== null) {
    contents.LineNumber = output.LineNumber;
  }
  if (output.NodeType !== undefined && output.NodeType !== null) {
    contents.NodeType = output.NodeType;
  }
  return contents;
};

const deserializeAws_json1_1CodeGenNodeArg = (
  output: any,
  context: __SerdeContext
): CodeGenNodeArg => {
  let contents: any = {
    __type: "CodeGenNodeArg",
    Name: undefined,
    Param: undefined,
    Value: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Param !== undefined && output.Param !== null) {
    contents.Param = output.Param;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1CodeGenNodeArgs = (
  output: any,
  context: __SerdeContext
): Array<CodeGenNodeArg> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CodeGenNodeArg(entry, context)
  );
};

const deserializeAws_json1_1Crawler = (
  output: any,
  context: __SerdeContext
): Crawler => {
  let contents: any = {
    __type: "Crawler",
    Classifiers: undefined,
    Configuration: undefined,
    CrawlElapsedTime: undefined,
    CrawlerSecurityConfiguration: undefined,
    CreationTime: undefined,
    DatabaseName: undefined,
    Description: undefined,
    LastCrawl: undefined,
    LastUpdated: undefined,
    Name: undefined,
    Role: undefined,
    Schedule: undefined,
    SchemaChangePolicy: undefined,
    State: undefined,
    TablePrefix: undefined,
    Targets: undefined,
    Version: undefined
  };
  if (output.Classifiers !== undefined && output.Classifiers !== null) {
    contents.Classifiers = deserializeAws_json1_1ClassifierNameList(
      output.Classifiers,
      context
    );
  }
  if (output.Configuration !== undefined && output.Configuration !== null) {
    contents.Configuration = output.Configuration;
  }
  if (
    output.CrawlElapsedTime !== undefined &&
    output.CrawlElapsedTime !== null
  ) {
    contents.CrawlElapsedTime = output.CrawlElapsedTime;
  }
  if (
    output.CrawlerSecurityConfiguration !== undefined &&
    output.CrawlerSecurityConfiguration !== null
  ) {
    contents.CrawlerSecurityConfiguration = output.CrawlerSecurityConfiguration;
  }
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DatabaseName !== undefined && output.DatabaseName !== null) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.LastCrawl !== undefined && output.LastCrawl !== null) {
    contents.LastCrawl = deserializeAws_json1_1LastCrawlInfo(
      output.LastCrawl,
      context
    );
  }
  if (output.LastUpdated !== undefined && output.LastUpdated !== null) {
    contents.LastUpdated = new Date(Math.round(output.LastUpdated * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Role !== undefined && output.Role !== null) {
    contents.Role = output.Role;
  }
  if (output.Schedule !== undefined && output.Schedule !== null) {
    contents.Schedule = deserializeAws_json1_1Schedule(
      output.Schedule,
      context
    );
  }
  if (
    output.SchemaChangePolicy !== undefined &&
    output.SchemaChangePolicy !== null
  ) {
    contents.SchemaChangePolicy = deserializeAws_json1_1SchemaChangePolicy(
      output.SchemaChangePolicy,
      context
    );
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  if (output.TablePrefix !== undefined && output.TablePrefix !== null) {
    contents.TablePrefix = output.TablePrefix;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1CrawlerTargets(
      output.Targets,
      context
    );
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1CrawlerList = (
  output: any,
  context: __SerdeContext
): Array<Crawler> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Crawler(entry, context)
  );
};

const deserializeAws_json1_1CrawlerMetrics = (
  output: any,
  context: __SerdeContext
): CrawlerMetrics => {
  let contents: any = {
    __type: "CrawlerMetrics",
    CrawlerName: undefined,
    LastRuntimeSeconds: undefined,
    MedianRuntimeSeconds: undefined,
    StillEstimating: undefined,
    TablesCreated: undefined,
    TablesDeleted: undefined,
    TablesUpdated: undefined,
    TimeLeftSeconds: undefined
  };
  if (output.CrawlerName !== undefined && output.CrawlerName !== null) {
    contents.CrawlerName = output.CrawlerName;
  }
  if (
    output.LastRuntimeSeconds !== undefined &&
    output.LastRuntimeSeconds !== null
  ) {
    contents.LastRuntimeSeconds = output.LastRuntimeSeconds;
  }
  if (
    output.MedianRuntimeSeconds !== undefined &&
    output.MedianRuntimeSeconds !== null
  ) {
    contents.MedianRuntimeSeconds = output.MedianRuntimeSeconds;
  }
  if (output.StillEstimating !== undefined && output.StillEstimating !== null) {
    contents.StillEstimating = output.StillEstimating;
  }
  if (output.TablesCreated !== undefined && output.TablesCreated !== null) {
    contents.TablesCreated = output.TablesCreated;
  }
  if (output.TablesDeleted !== undefined && output.TablesDeleted !== null) {
    contents.TablesDeleted = output.TablesDeleted;
  }
  if (output.TablesUpdated !== undefined && output.TablesUpdated !== null) {
    contents.TablesUpdated = output.TablesUpdated;
  }
  if (output.TimeLeftSeconds !== undefined && output.TimeLeftSeconds !== null) {
    contents.TimeLeftSeconds = output.TimeLeftSeconds;
  }
  return contents;
};

const deserializeAws_json1_1CrawlerMetricsList = (
  output: any,
  context: __SerdeContext
): Array<CrawlerMetrics> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CrawlerMetrics(entry, context)
  );
};

const deserializeAws_json1_1CrawlerNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1CrawlerNotRunningException = (
  output: any,
  context: __SerdeContext
): CrawlerNotRunningException => {
  let contents: any = {
    __type: "CrawlerNotRunningException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1CrawlerRunningException = (
  output: any,
  context: __SerdeContext
): CrawlerRunningException => {
  let contents: any = {
    __type: "CrawlerRunningException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1CrawlerStoppingException = (
  output: any,
  context: __SerdeContext
): CrawlerStoppingException => {
  let contents: any = {
    __type: "CrawlerStoppingException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1CrawlerTargets = (
  output: any,
  context: __SerdeContext
): CrawlerTargets => {
  let contents: any = {
    __type: "CrawlerTargets",
    CatalogTargets: undefined,
    DynamoDBTargets: undefined,
    JdbcTargets: undefined,
    S3Targets: undefined
  };
  if (output.CatalogTargets !== undefined && output.CatalogTargets !== null) {
    contents.CatalogTargets = deserializeAws_json1_1CatalogTargetList(
      output.CatalogTargets,
      context
    );
  }
  if (output.DynamoDBTargets !== undefined && output.DynamoDBTargets !== null) {
    contents.DynamoDBTargets = deserializeAws_json1_1DynamoDBTargetList(
      output.DynamoDBTargets,
      context
    );
  }
  if (output.JdbcTargets !== undefined && output.JdbcTargets !== null) {
    contents.JdbcTargets = deserializeAws_json1_1JdbcTargetList(
      output.JdbcTargets,
      context
    );
  }
  if (output.S3Targets !== undefined && output.S3Targets !== null) {
    contents.S3Targets = deserializeAws_json1_1S3TargetList(
      output.S3Targets,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateClassifierResponse = (
  output: any,
  context: __SerdeContext
): CreateClassifierResponse => {
  let contents: any = {
    __type: "CreateClassifierResponse"
  };
  return contents;
};

const deserializeAws_json1_1CreateCrawlerResponse = (
  output: any,
  context: __SerdeContext
): CreateCrawlerResponse => {
  let contents: any = {
    __type: "CreateCrawlerResponse"
  };
  return contents;
};

const deserializeAws_json1_1CreateScriptResponse = (
  output: any,
  context: __SerdeContext
): CreateScriptResponse => {
  let contents: any = {
    __type: "CreateScriptResponse",
    PythonScript: undefined,
    ScalaCode: undefined
  };
  if (output.PythonScript !== undefined && output.PythonScript !== null) {
    contents.PythonScript = output.PythonScript;
  }
  if (output.ScalaCode !== undefined && output.ScalaCode !== null) {
    contents.ScalaCode = output.ScalaCode;
  }
  return contents;
};

const deserializeAws_json1_1CsvClassifier = (
  output: any,
  context: __SerdeContext
): CsvClassifier => {
  let contents: any = {
    __type: "CsvClassifier",
    AllowSingleColumn: undefined,
    ContainsHeader: undefined,
    CreationTime: undefined,
    Delimiter: undefined,
    DisableValueTrimming: undefined,
    Header: undefined,
    LastUpdated: undefined,
    Name: undefined,
    QuoteSymbol: undefined,
    Version: undefined
  };
  if (
    output.AllowSingleColumn !== undefined &&
    output.AllowSingleColumn !== null
  ) {
    contents.AllowSingleColumn = output.AllowSingleColumn;
  }
  if (output.ContainsHeader !== undefined && output.ContainsHeader !== null) {
    contents.ContainsHeader = output.ContainsHeader;
  }
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.Delimiter !== undefined && output.Delimiter !== null) {
    contents.Delimiter = output.Delimiter;
  }
  if (
    output.DisableValueTrimming !== undefined &&
    output.DisableValueTrimming !== null
  ) {
    contents.DisableValueTrimming = output.DisableValueTrimming;
  }
  if (output.Header !== undefined && output.Header !== null) {
    contents.Header = deserializeAws_json1_1CsvHeader(output.Header, context);
  }
  if (output.LastUpdated !== undefined && output.LastUpdated !== null) {
    contents.LastUpdated = new Date(Math.round(output.LastUpdated * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.QuoteSymbol !== undefined && output.QuoteSymbol !== null) {
    contents.QuoteSymbol = output.QuoteSymbol;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1CsvHeader = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1DagEdges = (
  output: any,
  context: __SerdeContext
): Array<CodeGenEdge> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CodeGenEdge(entry, context)
  );
};

const deserializeAws_json1_1DagNodes = (
  output: any,
  context: __SerdeContext
): Array<CodeGenNode> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CodeGenNode(entry, context)
  );
};

const deserializeAws_json1_1DeleteClassifierResponse = (
  output: any,
  context: __SerdeContext
): DeleteClassifierResponse => {
  let contents: any = {
    __type: "DeleteClassifierResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteCrawlerResponse = (
  output: any,
  context: __SerdeContext
): DeleteCrawlerResponse => {
  let contents: any = {
    __type: "DeleteCrawlerResponse"
  };
  return contents;
};

const deserializeAws_json1_1DynamoDBTarget = (
  output: any,
  context: __SerdeContext
): DynamoDBTarget => {
  let contents: any = {
    __type: "DynamoDBTarget",
    Path: undefined
  };
  if (output.Path !== undefined && output.Path !== null) {
    contents.Path = output.Path;
  }
  return contents;
};

const deserializeAws_json1_1DynamoDBTargetList = (
  output: any,
  context: __SerdeContext
): Array<DynamoDBTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DynamoDBTarget(entry, context)
  );
};

const deserializeAws_json1_1GetClassifierResponse = (
  output: any,
  context: __SerdeContext
): GetClassifierResponse => {
  let contents: any = {
    __type: "GetClassifierResponse",
    Classifier: undefined
  };
  if (output.Classifier !== undefined && output.Classifier !== null) {
    contents.Classifier = deserializeAws_json1_1Classifier(
      output.Classifier,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetClassifiersResponse = (
  output: any,
  context: __SerdeContext
): GetClassifiersResponse => {
  let contents: any = {
    __type: "GetClassifiersResponse",
    Classifiers: undefined,
    NextToken: undefined
  };
  if (output.Classifiers !== undefined && output.Classifiers !== null) {
    contents.Classifiers = deserializeAws_json1_1ClassifierList(
      output.Classifiers,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetCrawlerMetricsResponse = (
  output: any,
  context: __SerdeContext
): GetCrawlerMetricsResponse => {
  let contents: any = {
    __type: "GetCrawlerMetricsResponse",
    CrawlerMetricsList: undefined,
    NextToken: undefined
  };
  if (
    output.CrawlerMetricsList !== undefined &&
    output.CrawlerMetricsList !== null
  ) {
    contents.CrawlerMetricsList = deserializeAws_json1_1CrawlerMetricsList(
      output.CrawlerMetricsList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetCrawlerResponse = (
  output: any,
  context: __SerdeContext
): GetCrawlerResponse => {
  let contents: any = {
    __type: "GetCrawlerResponse",
    Crawler: undefined
  };
  if (output.Crawler !== undefined && output.Crawler !== null) {
    contents.Crawler = deserializeAws_json1_1Crawler(output.Crawler, context);
  }
  return contents;
};

const deserializeAws_json1_1GetCrawlersResponse = (
  output: any,
  context: __SerdeContext
): GetCrawlersResponse => {
  let contents: any = {
    __type: "GetCrawlersResponse",
    Crawlers: undefined,
    NextToken: undefined
  };
  if (output.Crawlers !== undefined && output.Crawlers !== null) {
    contents.Crawlers = deserializeAws_json1_1CrawlerList(
      output.Crawlers,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetDataflowGraphResponse = (
  output: any,
  context: __SerdeContext
): GetDataflowGraphResponse => {
  let contents: any = {
    __type: "GetDataflowGraphResponse",
    DagEdges: undefined,
    DagNodes: undefined
  };
  if (output.DagEdges !== undefined && output.DagEdges !== null) {
    contents.DagEdges = deserializeAws_json1_1DagEdges(
      output.DagEdges,
      context
    );
  }
  if (output.DagNodes !== undefined && output.DagNodes !== null) {
    contents.DagNodes = deserializeAws_json1_1DagNodes(
      output.DagNodes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetMappingResponse = (
  output: any,
  context: __SerdeContext
): GetMappingResponse => {
  let contents: any = {
    __type: "GetMappingResponse",
    Mapping: undefined
  };
  if (output.Mapping !== undefined && output.Mapping !== null) {
    contents.Mapping = deserializeAws_json1_1MappingList(
      output.Mapping,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetPlanResponse = (
  output: any,
  context: __SerdeContext
): GetPlanResponse => {
  let contents: any = {
    __type: "GetPlanResponse",
    PythonScript: undefined,
    ScalaCode: undefined
  };
  if (output.PythonScript !== undefined && output.PythonScript !== null) {
    contents.PythonScript = output.PythonScript;
  }
  if (output.ScalaCode !== undefined && output.ScalaCode !== null) {
    contents.ScalaCode = output.ScalaCode;
  }
  return contents;
};

const deserializeAws_json1_1GrokClassifier = (
  output: any,
  context: __SerdeContext
): GrokClassifier => {
  let contents: any = {
    __type: "GrokClassifier",
    Classification: undefined,
    CreationTime: undefined,
    CustomPatterns: undefined,
    GrokPattern: undefined,
    LastUpdated: undefined,
    Name: undefined,
    Version: undefined
  };
  if (output.Classification !== undefined && output.Classification !== null) {
    contents.Classification = output.Classification;
  }
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.CustomPatterns !== undefined && output.CustomPatterns !== null) {
    contents.CustomPatterns = output.CustomPatterns;
  }
  if (output.GrokPattern !== undefined && output.GrokPattern !== null) {
    contents.GrokPattern = output.GrokPattern;
  }
  if (output.LastUpdated !== undefined && output.LastUpdated !== null) {
    contents.LastUpdated = new Date(Math.round(output.LastUpdated * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1JdbcTarget = (
  output: any,
  context: __SerdeContext
): JdbcTarget => {
  let contents: any = {
    __type: "JdbcTarget",
    ConnectionName: undefined,
    Exclusions: undefined,
    Path: undefined
  };
  if (output.ConnectionName !== undefined && output.ConnectionName !== null) {
    contents.ConnectionName = output.ConnectionName;
  }
  if (output.Exclusions !== undefined && output.Exclusions !== null) {
    contents.Exclusions = deserializeAws_json1_1PathList(
      output.Exclusions,
      context
    );
  }
  if (output.Path !== undefined && output.Path !== null) {
    contents.Path = output.Path;
  }
  return contents;
};

const deserializeAws_json1_1JdbcTargetList = (
  output: any,
  context: __SerdeContext
): Array<JdbcTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1JdbcTarget(entry, context)
  );
};

const deserializeAws_json1_1JsonClassifier = (
  output: any,
  context: __SerdeContext
): JsonClassifier => {
  let contents: any = {
    __type: "JsonClassifier",
    CreationTime: undefined,
    JsonPath: undefined,
    LastUpdated: undefined,
    Name: undefined,
    Version: undefined
  };
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.JsonPath !== undefined && output.JsonPath !== null) {
    contents.JsonPath = output.JsonPath;
  }
  if (output.LastUpdated !== undefined && output.LastUpdated !== null) {
    contents.LastUpdated = new Date(Math.round(output.LastUpdated * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1LastCrawlInfo = (
  output: any,
  context: __SerdeContext
): LastCrawlInfo => {
  let contents: any = {
    __type: "LastCrawlInfo",
    ErrorMessage: undefined,
    LogGroup: undefined,
    LogStream: undefined,
    MessagePrefix: undefined,
    StartTime: undefined,
    Status: undefined
  };
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.LogGroup !== undefined && output.LogGroup !== null) {
    contents.LogGroup = output.LogGroup;
  }
  if (output.LogStream !== undefined && output.LogStream !== null) {
    contents.LogStream = output.LogStream;
  }
  if (output.MessagePrefix !== undefined && output.MessagePrefix !== null) {
    contents.MessagePrefix = output.MessagePrefix;
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1ListCrawlersResponse = (
  output: any,
  context: __SerdeContext
): ListCrawlersResponse => {
  let contents: any = {
    __type: "ListCrawlersResponse",
    CrawlerNames: undefined,
    NextToken: undefined
  };
  if (output.CrawlerNames !== undefined && output.CrawlerNames !== null) {
    contents.CrawlerNames = deserializeAws_json1_1CrawlerNameList(
      output.CrawlerNames,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1MappingEntry = (
  output: any,
  context: __SerdeContext
): MappingEntry => {
  let contents: any = {
    __type: "MappingEntry",
    SourcePath: undefined,
    SourceTable: undefined,
    SourceType: undefined,
    TargetPath: undefined,
    TargetTable: undefined,
    TargetType: undefined
  };
  if (output.SourcePath !== undefined && output.SourcePath !== null) {
    contents.SourcePath = output.SourcePath;
  }
  if (output.SourceTable !== undefined && output.SourceTable !== null) {
    contents.SourceTable = output.SourceTable;
  }
  if (output.SourceType !== undefined && output.SourceType !== null) {
    contents.SourceType = output.SourceType;
  }
  if (output.TargetPath !== undefined && output.TargetPath !== null) {
    contents.TargetPath = output.TargetPath;
  }
  if (output.TargetTable !== undefined && output.TargetTable !== null) {
    contents.TargetTable = output.TargetTable;
  }
  if (output.TargetType !== undefined && output.TargetType !== null) {
    contents.TargetType = output.TargetType;
  }
  return contents;
};

const deserializeAws_json1_1MappingList = (
  output: any,
  context: __SerdeContext
): Array<MappingEntry> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MappingEntry(entry, context)
  );
};

const deserializeAws_json1_1NoScheduleException = (
  output: any,
  context: __SerdeContext
): NoScheduleException => {
  let contents: any = {
    __type: "NoScheduleException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1PathList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1S3Target = (
  output: any,
  context: __SerdeContext
): S3Target => {
  let contents: any = {
    __type: "S3Target",
    Exclusions: undefined,
    Path: undefined
  };
  if (output.Exclusions !== undefined && output.Exclusions !== null) {
    contents.Exclusions = deserializeAws_json1_1PathList(
      output.Exclusions,
      context
    );
  }
  if (output.Path !== undefined && output.Path !== null) {
    contents.Path = output.Path;
  }
  return contents;
};

const deserializeAws_json1_1S3TargetList = (
  output: any,
  context: __SerdeContext
): Array<S3Target> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1S3Target(entry, context)
  );
};

const deserializeAws_json1_1Schedule = (
  output: any,
  context: __SerdeContext
): Schedule => {
  let contents: any = {
    __type: "Schedule",
    ScheduleExpression: undefined,
    State: undefined
  };
  if (
    output.ScheduleExpression !== undefined &&
    output.ScheduleExpression !== null
  ) {
    contents.ScheduleExpression = output.ScheduleExpression;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  return contents;
};

const deserializeAws_json1_1SchedulerNotRunningException = (
  output: any,
  context: __SerdeContext
): SchedulerNotRunningException => {
  let contents: any = {
    __type: "SchedulerNotRunningException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1SchedulerRunningException = (
  output: any,
  context: __SerdeContext
): SchedulerRunningException => {
  let contents: any = {
    __type: "SchedulerRunningException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1SchedulerTransitioningException = (
  output: any,
  context: __SerdeContext
): SchedulerTransitioningException => {
  let contents: any = {
    __type: "SchedulerTransitioningException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1SchemaChangePolicy = (
  output: any,
  context: __SerdeContext
): SchemaChangePolicy => {
  let contents: any = {
    __type: "SchemaChangePolicy",
    DeleteBehavior: undefined,
    UpdateBehavior: undefined
  };
  if (output.DeleteBehavior !== undefined && output.DeleteBehavior !== null) {
    contents.DeleteBehavior = output.DeleteBehavior;
  }
  if (output.UpdateBehavior !== undefined && output.UpdateBehavior !== null) {
    contents.UpdateBehavior = output.UpdateBehavior;
  }
  return contents;
};

const deserializeAws_json1_1StartCrawlerResponse = (
  output: any,
  context: __SerdeContext
): StartCrawlerResponse => {
  let contents: any = {
    __type: "StartCrawlerResponse"
  };
  return contents;
};

const deserializeAws_json1_1StartCrawlerScheduleResponse = (
  output: any,
  context: __SerdeContext
): StartCrawlerScheduleResponse => {
  let contents: any = {
    __type: "StartCrawlerScheduleResponse"
  };
  return contents;
};

const deserializeAws_json1_1StopCrawlerResponse = (
  output: any,
  context: __SerdeContext
): StopCrawlerResponse => {
  let contents: any = {
    __type: "StopCrawlerResponse"
  };
  return contents;
};

const deserializeAws_json1_1StopCrawlerScheduleResponse = (
  output: any,
  context: __SerdeContext
): StopCrawlerScheduleResponse => {
  let contents: any = {
    __type: "StopCrawlerScheduleResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateClassifierResponse = (
  output: any,
  context: __SerdeContext
): UpdateClassifierResponse => {
  let contents: any = {
    __type: "UpdateClassifierResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateCrawlerResponse = (
  output: any,
  context: __SerdeContext
): UpdateCrawlerResponse => {
  let contents: any = {
    __type: "UpdateCrawlerResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateCrawlerScheduleResponse = (
  output: any,
  context: __SerdeContext
): UpdateCrawlerScheduleResponse => {
  let contents: any = {
    __type: "UpdateCrawlerScheduleResponse"
  };
  return contents;
};

const deserializeAws_json1_1XMLClassifier = (
  output: any,
  context: __SerdeContext
): XMLClassifier => {
  let contents: any = {
    __type: "XMLClassifier",
    Classification: undefined,
    CreationTime: undefined,
    LastUpdated: undefined,
    Name: undefined,
    RowTag: undefined,
    Version: undefined
  };
  if (output.Classification !== undefined && output.Classification !== null) {
    contents.Classification = output.Classification;
  }
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.LastUpdated !== undefined && output.LastUpdated !== null) {
    contents.LastUpdated = new Date(Math.round(output.LastUpdated * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.RowTag !== undefined && output.RowTag !== null) {
    contents.RowTag = output.RowTag;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
