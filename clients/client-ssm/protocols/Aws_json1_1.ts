import {
  AddTagsToResourceCommandInput,
  AddTagsToResourceCommandOutput
} from "../commands/AddTagsToResourceCommand";
import {
  CancelCommandCommandInput,
  CancelCommandCommandOutput
} from "../commands/CancelCommandCommand";
import {
  CancelMaintenanceWindowExecutionCommandInput,
  CancelMaintenanceWindowExecutionCommandOutput
} from "../commands/CancelMaintenanceWindowExecutionCommand";
import {
  CreateActivationCommandInput,
  CreateActivationCommandOutput
} from "../commands/CreateActivationCommand";
import {
  CreateAssociationBatchCommandInput,
  CreateAssociationBatchCommandOutput
} from "../commands/CreateAssociationBatchCommand";
import {
  CreateAssociationCommandInput,
  CreateAssociationCommandOutput
} from "../commands/CreateAssociationCommand";
import {
  CreateDocumentCommandInput,
  CreateDocumentCommandOutput
} from "../commands/CreateDocumentCommand";
import {
  CreateMaintenanceWindowCommandInput,
  CreateMaintenanceWindowCommandOutput
} from "../commands/CreateMaintenanceWindowCommand";
import {
  CreateOpsItemCommandInput,
  CreateOpsItemCommandOutput
} from "../commands/CreateOpsItemCommand";
import {
  CreatePatchBaselineCommandInput,
  CreatePatchBaselineCommandOutput
} from "../commands/CreatePatchBaselineCommand";
import {
  CreateResourceDataSyncCommandInput,
  CreateResourceDataSyncCommandOutput
} from "../commands/CreateResourceDataSyncCommand";
import {
  DeleteActivationCommandInput,
  DeleteActivationCommandOutput
} from "../commands/DeleteActivationCommand";
import {
  DeleteAssociationCommandInput,
  DeleteAssociationCommandOutput
} from "../commands/DeleteAssociationCommand";
import {
  DeleteDocumentCommandInput,
  DeleteDocumentCommandOutput
} from "../commands/DeleteDocumentCommand";
import {
  DeleteInventoryCommandInput,
  DeleteInventoryCommandOutput
} from "../commands/DeleteInventoryCommand";
import {
  DeleteMaintenanceWindowCommandInput,
  DeleteMaintenanceWindowCommandOutput
} from "../commands/DeleteMaintenanceWindowCommand";
import {
  DeleteParameterCommandInput,
  DeleteParameterCommandOutput
} from "../commands/DeleteParameterCommand";
import {
  DeleteParametersCommandInput,
  DeleteParametersCommandOutput
} from "../commands/DeleteParametersCommand";
import {
  DeletePatchBaselineCommandInput,
  DeletePatchBaselineCommandOutput
} from "../commands/DeletePatchBaselineCommand";
import {
  DeleteResourceDataSyncCommandInput,
  DeleteResourceDataSyncCommandOutput
} from "../commands/DeleteResourceDataSyncCommand";
import {
  DeregisterManagedInstanceCommandInput,
  DeregisterManagedInstanceCommandOutput
} from "../commands/DeregisterManagedInstanceCommand";
import {
  DeregisterPatchBaselineForPatchGroupCommandInput,
  DeregisterPatchBaselineForPatchGroupCommandOutput
} from "../commands/DeregisterPatchBaselineForPatchGroupCommand";
import {
  DeregisterTargetFromMaintenanceWindowCommandInput,
  DeregisterTargetFromMaintenanceWindowCommandOutput
} from "../commands/DeregisterTargetFromMaintenanceWindowCommand";
import {
  DeregisterTaskFromMaintenanceWindowCommandInput,
  DeregisterTaskFromMaintenanceWindowCommandOutput
} from "../commands/DeregisterTaskFromMaintenanceWindowCommand";
import {
  DescribeActivationsCommandInput,
  DescribeActivationsCommandOutput
} from "../commands/DescribeActivationsCommand";
import {
  DescribeAssociationCommandInput,
  DescribeAssociationCommandOutput
} from "../commands/DescribeAssociationCommand";
import {
  DescribeAssociationExecutionTargetsCommandInput,
  DescribeAssociationExecutionTargetsCommandOutput
} from "../commands/DescribeAssociationExecutionTargetsCommand";
import {
  DescribeAssociationExecutionsCommandInput,
  DescribeAssociationExecutionsCommandOutput
} from "../commands/DescribeAssociationExecutionsCommand";
import {
  DescribeAutomationExecutionsCommandInput,
  DescribeAutomationExecutionsCommandOutput
} from "../commands/DescribeAutomationExecutionsCommand";
import {
  DescribeAutomationStepExecutionsCommandInput,
  DescribeAutomationStepExecutionsCommandOutput
} from "../commands/DescribeAutomationStepExecutionsCommand";
import {
  DescribeAvailablePatchesCommandInput,
  DescribeAvailablePatchesCommandOutput
} from "../commands/DescribeAvailablePatchesCommand";
import {
  DescribeDocumentCommandInput,
  DescribeDocumentCommandOutput
} from "../commands/DescribeDocumentCommand";
import {
  DescribeDocumentPermissionCommandInput,
  DescribeDocumentPermissionCommandOutput
} from "../commands/DescribeDocumentPermissionCommand";
import {
  DescribeEffectiveInstanceAssociationsCommandInput,
  DescribeEffectiveInstanceAssociationsCommandOutput
} from "../commands/DescribeEffectiveInstanceAssociationsCommand";
import {
  DescribeEffectivePatchesForPatchBaselineCommandInput,
  DescribeEffectivePatchesForPatchBaselineCommandOutput
} from "../commands/DescribeEffectivePatchesForPatchBaselineCommand";
import {
  DescribeInstanceAssociationsStatusCommandInput,
  DescribeInstanceAssociationsStatusCommandOutput
} from "../commands/DescribeInstanceAssociationsStatusCommand";
import {
  DescribeInstanceInformationCommandInput,
  DescribeInstanceInformationCommandOutput
} from "../commands/DescribeInstanceInformationCommand";
import {
  DescribeInstancePatchStatesCommandInput,
  DescribeInstancePatchStatesCommandOutput
} from "../commands/DescribeInstancePatchStatesCommand";
import {
  DescribeInstancePatchStatesForPatchGroupCommandInput,
  DescribeInstancePatchStatesForPatchGroupCommandOutput
} from "../commands/DescribeInstancePatchStatesForPatchGroupCommand";
import {
  DescribeInstancePatchesCommandInput,
  DescribeInstancePatchesCommandOutput
} from "../commands/DescribeInstancePatchesCommand";
import {
  DescribeInventoryDeletionsCommandInput,
  DescribeInventoryDeletionsCommandOutput
} from "../commands/DescribeInventoryDeletionsCommand";
import {
  DescribeMaintenanceWindowExecutionTaskInvocationsCommandInput,
  DescribeMaintenanceWindowExecutionTaskInvocationsCommandOutput
} from "../commands/DescribeMaintenanceWindowExecutionTaskInvocationsCommand";
import {
  DescribeMaintenanceWindowExecutionTasksCommandInput,
  DescribeMaintenanceWindowExecutionTasksCommandOutput
} from "../commands/DescribeMaintenanceWindowExecutionTasksCommand";
import {
  DescribeMaintenanceWindowExecutionsCommandInput,
  DescribeMaintenanceWindowExecutionsCommandOutput
} from "../commands/DescribeMaintenanceWindowExecutionsCommand";
import {
  DescribeMaintenanceWindowScheduleCommandInput,
  DescribeMaintenanceWindowScheduleCommandOutput
} from "../commands/DescribeMaintenanceWindowScheduleCommand";
import {
  DescribeMaintenanceWindowTargetsCommandInput,
  DescribeMaintenanceWindowTargetsCommandOutput
} from "../commands/DescribeMaintenanceWindowTargetsCommand";
import {
  DescribeMaintenanceWindowTasksCommandInput,
  DescribeMaintenanceWindowTasksCommandOutput
} from "../commands/DescribeMaintenanceWindowTasksCommand";
import {
  DescribeMaintenanceWindowsCommandInput,
  DescribeMaintenanceWindowsCommandOutput
} from "../commands/DescribeMaintenanceWindowsCommand";
import {
  DescribeMaintenanceWindowsForTargetCommandInput,
  DescribeMaintenanceWindowsForTargetCommandOutput
} from "../commands/DescribeMaintenanceWindowsForTargetCommand";
import {
  DescribeOpsItemsCommandInput,
  DescribeOpsItemsCommandOutput
} from "../commands/DescribeOpsItemsCommand";
import {
  DescribeParametersCommandInput,
  DescribeParametersCommandOutput
} from "../commands/DescribeParametersCommand";
import {
  DescribePatchBaselinesCommandInput,
  DescribePatchBaselinesCommandOutput
} from "../commands/DescribePatchBaselinesCommand";
import {
  DescribePatchGroupStateCommandInput,
  DescribePatchGroupStateCommandOutput
} from "../commands/DescribePatchGroupStateCommand";
import {
  DescribePatchGroupsCommandInput,
  DescribePatchGroupsCommandOutput
} from "../commands/DescribePatchGroupsCommand";
import {
  DescribePatchPropertiesCommandInput,
  DescribePatchPropertiesCommandOutput
} from "../commands/DescribePatchPropertiesCommand";
import {
  DescribeSessionsCommandInput,
  DescribeSessionsCommandOutput
} from "../commands/DescribeSessionsCommand";
import {
  GetAutomationExecutionCommandInput,
  GetAutomationExecutionCommandOutput
} from "../commands/GetAutomationExecutionCommand";
import {
  GetCalendarStateCommandInput,
  GetCalendarStateCommandOutput
} from "../commands/GetCalendarStateCommand";
import {
  GetCommandInvocationCommandInput,
  GetCommandInvocationCommandOutput
} from "../commands/GetCommandInvocationCommand";
import {
  GetConnectionStatusCommandInput,
  GetConnectionStatusCommandOutput
} from "../commands/GetConnectionStatusCommand";
import {
  GetDefaultPatchBaselineCommandInput,
  GetDefaultPatchBaselineCommandOutput
} from "../commands/GetDefaultPatchBaselineCommand";
import {
  GetDeployablePatchSnapshotForInstanceCommandInput,
  GetDeployablePatchSnapshotForInstanceCommandOutput
} from "../commands/GetDeployablePatchSnapshotForInstanceCommand";
import {
  GetDocumentCommandInput,
  GetDocumentCommandOutput
} from "../commands/GetDocumentCommand";
import {
  GetInventoryCommandInput,
  GetInventoryCommandOutput
} from "../commands/GetInventoryCommand";
import {
  GetInventorySchemaCommandInput,
  GetInventorySchemaCommandOutput
} from "../commands/GetInventorySchemaCommand";
import {
  GetMaintenanceWindowCommandInput,
  GetMaintenanceWindowCommandOutput
} from "../commands/GetMaintenanceWindowCommand";
import {
  GetMaintenanceWindowExecutionCommandInput,
  GetMaintenanceWindowExecutionCommandOutput
} from "../commands/GetMaintenanceWindowExecutionCommand";
import {
  GetMaintenanceWindowExecutionTaskCommandInput,
  GetMaintenanceWindowExecutionTaskCommandOutput
} from "../commands/GetMaintenanceWindowExecutionTaskCommand";
import {
  GetMaintenanceWindowExecutionTaskInvocationCommandInput,
  GetMaintenanceWindowExecutionTaskInvocationCommandOutput
} from "../commands/GetMaintenanceWindowExecutionTaskInvocationCommand";
import {
  GetMaintenanceWindowTaskCommandInput,
  GetMaintenanceWindowTaskCommandOutput
} from "../commands/GetMaintenanceWindowTaskCommand";
import {
  GetOpsItemCommandInput,
  GetOpsItemCommandOutput
} from "../commands/GetOpsItemCommand";
import {
  GetOpsSummaryCommandInput,
  GetOpsSummaryCommandOutput
} from "../commands/GetOpsSummaryCommand";
import {
  GetParameterCommandInput,
  GetParameterCommandOutput
} from "../commands/GetParameterCommand";
import {
  GetParameterHistoryCommandInput,
  GetParameterHistoryCommandOutput
} from "../commands/GetParameterHistoryCommand";
import {
  GetParametersByPathCommandInput,
  GetParametersByPathCommandOutput
} from "../commands/GetParametersByPathCommand";
import {
  GetParametersCommandInput,
  GetParametersCommandOutput
} from "../commands/GetParametersCommand";
import {
  GetPatchBaselineCommandInput,
  GetPatchBaselineCommandOutput
} from "../commands/GetPatchBaselineCommand";
import {
  GetPatchBaselineForPatchGroupCommandInput,
  GetPatchBaselineForPatchGroupCommandOutput
} from "../commands/GetPatchBaselineForPatchGroupCommand";
import {
  GetServiceSettingCommandInput,
  GetServiceSettingCommandOutput
} from "../commands/GetServiceSettingCommand";
import {
  LabelParameterVersionCommandInput,
  LabelParameterVersionCommandOutput
} from "../commands/LabelParameterVersionCommand";
import {
  ListAssociationVersionsCommandInput,
  ListAssociationVersionsCommandOutput
} from "../commands/ListAssociationVersionsCommand";
import {
  ListAssociationsCommandInput,
  ListAssociationsCommandOutput
} from "../commands/ListAssociationsCommand";
import {
  ListCommandInvocationsCommandInput,
  ListCommandInvocationsCommandOutput
} from "../commands/ListCommandInvocationsCommand";
import {
  ListCommandsCommandInput,
  ListCommandsCommandOutput
} from "../commands/ListCommandsCommand";
import {
  ListComplianceItemsCommandInput,
  ListComplianceItemsCommandOutput
} from "../commands/ListComplianceItemsCommand";
import {
  ListComplianceSummariesCommandInput,
  ListComplianceSummariesCommandOutput
} from "../commands/ListComplianceSummariesCommand";
import {
  ListDocumentVersionsCommandInput,
  ListDocumentVersionsCommandOutput
} from "../commands/ListDocumentVersionsCommand";
import {
  ListDocumentsCommandInput,
  ListDocumentsCommandOutput
} from "../commands/ListDocumentsCommand";
import {
  ListInventoryEntriesCommandInput,
  ListInventoryEntriesCommandOutput
} from "../commands/ListInventoryEntriesCommand";
import {
  ListResourceComplianceSummariesCommandInput,
  ListResourceComplianceSummariesCommandOutput
} from "../commands/ListResourceComplianceSummariesCommand";
import {
  ListResourceDataSyncCommandInput,
  ListResourceDataSyncCommandOutput
} from "../commands/ListResourceDataSyncCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ModifyDocumentPermissionCommandInput,
  ModifyDocumentPermissionCommandOutput
} from "../commands/ModifyDocumentPermissionCommand";
import {
  PutComplianceItemsCommandInput,
  PutComplianceItemsCommandOutput
} from "../commands/PutComplianceItemsCommand";
import {
  PutInventoryCommandInput,
  PutInventoryCommandOutput
} from "../commands/PutInventoryCommand";
import {
  PutParameterCommandInput,
  PutParameterCommandOutput
} from "../commands/PutParameterCommand";
import {
  RegisterDefaultPatchBaselineCommandInput,
  RegisterDefaultPatchBaselineCommandOutput
} from "../commands/RegisterDefaultPatchBaselineCommand";
import {
  RegisterPatchBaselineForPatchGroupCommandInput,
  RegisterPatchBaselineForPatchGroupCommandOutput
} from "../commands/RegisterPatchBaselineForPatchGroupCommand";
import {
  RegisterTargetWithMaintenanceWindowCommandInput,
  RegisterTargetWithMaintenanceWindowCommandOutput
} from "../commands/RegisterTargetWithMaintenanceWindowCommand";
import {
  RegisterTaskWithMaintenanceWindowCommandInput,
  RegisterTaskWithMaintenanceWindowCommandOutput
} from "../commands/RegisterTaskWithMaintenanceWindowCommand";
import {
  RemoveTagsFromResourceCommandInput,
  RemoveTagsFromResourceCommandOutput
} from "../commands/RemoveTagsFromResourceCommand";
import {
  ResetServiceSettingCommandInput,
  ResetServiceSettingCommandOutput
} from "../commands/ResetServiceSettingCommand";
import {
  ResumeSessionCommandInput,
  ResumeSessionCommandOutput
} from "../commands/ResumeSessionCommand";
import {
  SendAutomationSignalCommandInput,
  SendAutomationSignalCommandOutput
} from "../commands/SendAutomationSignalCommand";
import {
  SendCommandCommandInput,
  SendCommandCommandOutput
} from "../commands/SendCommandCommand";
import {
  StartAssociationsOnceCommandInput,
  StartAssociationsOnceCommandOutput
} from "../commands/StartAssociationsOnceCommand";
import {
  StartAutomationExecutionCommandInput,
  StartAutomationExecutionCommandOutput
} from "../commands/StartAutomationExecutionCommand";
import {
  StartSessionCommandInput,
  StartSessionCommandOutput
} from "../commands/StartSessionCommand";
import {
  StopAutomationExecutionCommandInput,
  StopAutomationExecutionCommandOutput
} from "../commands/StopAutomationExecutionCommand";
import {
  TerminateSessionCommandInput,
  TerminateSessionCommandOutput
} from "../commands/TerminateSessionCommand";
import {
  UpdateAssociationCommandInput,
  UpdateAssociationCommandOutput
} from "../commands/UpdateAssociationCommand";
import {
  UpdateAssociationStatusCommandInput,
  UpdateAssociationStatusCommandOutput
} from "../commands/UpdateAssociationStatusCommand";
import {
  UpdateDocumentCommandInput,
  UpdateDocumentCommandOutput
} from "../commands/UpdateDocumentCommand";
import {
  UpdateDocumentDefaultVersionCommandInput,
  UpdateDocumentDefaultVersionCommandOutput
} from "../commands/UpdateDocumentDefaultVersionCommand";
import {
  UpdateMaintenanceWindowCommandInput,
  UpdateMaintenanceWindowCommandOutput
} from "../commands/UpdateMaintenanceWindowCommand";
import {
  UpdateMaintenanceWindowTargetCommandInput,
  UpdateMaintenanceWindowTargetCommandOutput
} from "../commands/UpdateMaintenanceWindowTargetCommand";
import {
  UpdateMaintenanceWindowTaskCommandInput,
  UpdateMaintenanceWindowTaskCommandOutput
} from "../commands/UpdateMaintenanceWindowTaskCommand";
import {
  UpdateManagedInstanceRoleCommandInput,
  UpdateManagedInstanceRoleCommandOutput
} from "../commands/UpdateManagedInstanceRoleCommand";
import {
  UpdateOpsItemCommandInput,
  UpdateOpsItemCommandOutput
} from "../commands/UpdateOpsItemCommand";
import {
  UpdatePatchBaselineCommandInput,
  UpdatePatchBaselineCommandOutput
} from "../commands/UpdatePatchBaselineCommand";
import {
  UpdateResourceDataSyncCommandInput,
  UpdateResourceDataSyncCommandOutput
} from "../commands/UpdateResourceDataSyncCommand";
import {
  UpdateServiceSettingCommandInput,
  UpdateServiceSettingCommandOutput
} from "../commands/UpdateServiceSettingCommand";
import {
  AccountSharingInfo,
  Activation,
  AddTagsToResourceRequest,
  AddTagsToResourceResult,
  AlreadyExistsException,
  AssociatedInstances,
  Association,
  AssociationAlreadyExists,
  AssociationDescription,
  AssociationDoesNotExist,
  AssociationExecution,
  AssociationExecutionDoesNotExist,
  AssociationExecutionFilter,
  AssociationExecutionTarget,
  AssociationExecutionTargetsFilter,
  AssociationFilter,
  AssociationLimitExceeded,
  AssociationOverview,
  AssociationStatus,
  AssociationVersionInfo,
  AssociationVersionLimitExceeded,
  AttachmentContent,
  AttachmentInformation,
  AttachmentsSource,
  AutomationDefinitionNotFoundException,
  AutomationDefinitionVersionNotFoundException,
  AutomationExecution,
  AutomationExecutionFilter,
  AutomationExecutionLimitExceededException,
  AutomationExecutionMetadata,
  AutomationExecutionNotFoundException,
  AutomationStepNotFoundException,
  CancelCommandRequest,
  CancelCommandResult,
  CancelMaintenanceWindowExecutionRequest,
  CancelMaintenanceWindowExecutionResult,
  CloudWatchOutputConfig,
  Command,
  CommandFilter,
  CommandInvocation,
  CommandPlugin,
  ComplianceExecutionSummary,
  ComplianceItem,
  ComplianceItemEntry,
  ComplianceStringFilter,
  ComplianceSummaryItem,
  ComplianceTypeCountLimitExceededException,
  CompliantSummary,
  CreateActivationRequest,
  CreateActivationResult,
  CreateAssociationBatchRequest,
  CreateAssociationBatchRequestEntry,
  CreateAssociationBatchResult,
  CreateAssociationRequest,
  CreateAssociationResult,
  CreateDocumentRequest,
  CreateDocumentResult,
  CreateMaintenanceWindowRequest,
  CreateMaintenanceWindowResult,
  CreateOpsItemRequest,
  CreateOpsItemResponse,
  CreatePatchBaselineRequest,
  CreatePatchBaselineResult,
  CreateResourceDataSyncRequest,
  CreateResourceDataSyncResult,
  CustomSchemaCountLimitExceededException,
  DeleteActivationRequest,
  DeleteActivationResult,
  DeleteAssociationRequest,
  DeleteAssociationResult,
  DeleteDocumentRequest,
  DeleteDocumentResult,
  DeleteInventoryRequest,
  DeleteInventoryResult,
  DeleteMaintenanceWindowRequest,
  DeleteMaintenanceWindowResult,
  DeleteParameterRequest,
  DeleteParameterResult,
  DeleteParametersRequest,
  DeleteParametersResult,
  DeletePatchBaselineRequest,
  DeletePatchBaselineResult,
  DeleteResourceDataSyncRequest,
  DeleteResourceDataSyncResult,
  DeregisterManagedInstanceRequest,
  DeregisterManagedInstanceResult,
  DeregisterPatchBaselineForPatchGroupRequest,
  DeregisterPatchBaselineForPatchGroupResult,
  DeregisterTargetFromMaintenanceWindowRequest,
  DeregisterTargetFromMaintenanceWindowResult,
  DeregisterTaskFromMaintenanceWindowRequest,
  DeregisterTaskFromMaintenanceWindowResult,
  DescribeActivationsFilter,
  DescribeActivationsRequest,
  DescribeActivationsResult,
  DescribeAssociationExecutionTargetsRequest,
  DescribeAssociationExecutionTargetsResult,
  DescribeAssociationExecutionsRequest,
  DescribeAssociationExecutionsResult,
  DescribeAssociationRequest,
  DescribeAssociationResult,
  DescribeAutomationExecutionsRequest,
  DescribeAutomationExecutionsResult,
  DescribeAutomationStepExecutionsRequest,
  DescribeAutomationStepExecutionsResult,
  DescribeAvailablePatchesRequest,
  DescribeAvailablePatchesResult,
  DescribeDocumentPermissionRequest,
  DescribeDocumentPermissionResponse,
  DescribeDocumentRequest,
  DescribeDocumentResult,
  DescribeEffectiveInstanceAssociationsRequest,
  DescribeEffectiveInstanceAssociationsResult,
  DescribeEffectivePatchesForPatchBaselineRequest,
  DescribeEffectivePatchesForPatchBaselineResult,
  DescribeInstanceAssociationsStatusRequest,
  DescribeInstanceAssociationsStatusResult,
  DescribeInstanceInformationRequest,
  DescribeInstanceInformationResult,
  DescribeInstancePatchStatesForPatchGroupRequest,
  DescribeInstancePatchStatesForPatchGroupResult,
  DescribeInstancePatchStatesRequest,
  DescribeInstancePatchStatesResult,
  DescribeInstancePatchesRequest,
  DescribeInstancePatchesResult,
  DescribeInventoryDeletionsRequest,
  DescribeInventoryDeletionsResult,
  DescribeMaintenanceWindowExecutionTaskInvocationsRequest,
  DescribeMaintenanceWindowExecutionTaskInvocationsResult,
  DescribeMaintenanceWindowExecutionTasksRequest,
  DescribeMaintenanceWindowExecutionTasksResult,
  DescribeMaintenanceWindowExecutionsRequest,
  DescribeMaintenanceWindowExecutionsResult,
  DescribeMaintenanceWindowScheduleRequest,
  DescribeMaintenanceWindowScheduleResult,
  DescribeMaintenanceWindowTargetsRequest,
  DescribeMaintenanceWindowTargetsResult,
  DescribeMaintenanceWindowTasksRequest,
  DescribeMaintenanceWindowTasksResult,
  DescribeMaintenanceWindowsForTargetRequest,
  DescribeMaintenanceWindowsForTargetResult,
  DescribeMaintenanceWindowsRequest,
  DescribeMaintenanceWindowsResult,
  DescribeOpsItemsRequest,
  DescribeOpsItemsResponse,
  DescribeParametersRequest,
  DescribeParametersResult,
  DescribePatchBaselinesRequest,
  DescribePatchBaselinesResult,
  DescribePatchGroupStateRequest,
  DescribePatchGroupStateResult,
  DescribePatchGroupsRequest,
  DescribePatchGroupsResult,
  DescribePatchPropertiesRequest,
  DescribePatchPropertiesResult,
  DescribeSessionsRequest,
  DescribeSessionsResponse,
  DocumentAlreadyExists,
  DocumentDefaultVersionDescription,
  DocumentDescription,
  DocumentFilter,
  DocumentIdentifier,
  DocumentKeyValuesFilter,
  DocumentLimitExceeded,
  DocumentParameter,
  DocumentPermissionLimit,
  DocumentRequires,
  DocumentVersionInfo,
  DocumentVersionLimitExceeded,
  DoesNotExistException,
  DuplicateDocumentContent,
  DuplicateDocumentVersionName,
  DuplicateInstanceId,
  EffectivePatch,
  FailedCreateAssociation,
  FailureDetails,
  FeatureNotAvailableException,
  GetAutomationExecutionRequest,
  GetAutomationExecutionResult,
  GetCalendarStateRequest,
  GetCalendarStateResponse,
  GetCommandInvocationRequest,
  GetCommandInvocationResult,
  GetConnectionStatusRequest,
  GetConnectionStatusResponse,
  GetDefaultPatchBaselineRequest,
  GetDefaultPatchBaselineResult,
  GetDeployablePatchSnapshotForInstanceRequest,
  GetDeployablePatchSnapshotForInstanceResult,
  GetDocumentRequest,
  GetDocumentResult,
  GetInventoryRequest,
  GetInventoryResult,
  GetInventorySchemaRequest,
  GetInventorySchemaResult,
  GetMaintenanceWindowExecutionRequest,
  GetMaintenanceWindowExecutionResult,
  GetMaintenanceWindowExecutionTaskInvocationRequest,
  GetMaintenanceWindowExecutionTaskInvocationResult,
  GetMaintenanceWindowExecutionTaskRequest,
  GetMaintenanceWindowExecutionTaskResult,
  GetMaintenanceWindowRequest,
  GetMaintenanceWindowResult,
  GetMaintenanceWindowTaskRequest,
  GetMaintenanceWindowTaskResult,
  GetOpsItemRequest,
  GetOpsItemResponse,
  GetOpsSummaryRequest,
  GetOpsSummaryResult,
  GetParameterHistoryRequest,
  GetParameterHistoryResult,
  GetParameterRequest,
  GetParameterResult,
  GetParametersByPathRequest,
  GetParametersByPathResult,
  GetParametersRequest,
  GetParametersResult,
  GetPatchBaselineForPatchGroupRequest,
  GetPatchBaselineForPatchGroupResult,
  GetPatchBaselineRequest,
  GetPatchBaselineResult,
  GetServiceSettingRequest,
  GetServiceSettingResult,
  HierarchyLevelLimitExceededException,
  HierarchyTypeMismatchException,
  IdempotentParameterMismatch,
  IncompatiblePolicyException,
  InstanceAggregatedAssociationOverview,
  InstanceAssociation,
  InstanceAssociationOutputLocation,
  InstanceAssociationOutputUrl,
  InstanceAssociationStatusInfo,
  InstanceInformation,
  InstanceInformationFilter,
  InstanceInformationStringFilter,
  InstancePatchState,
  InstancePatchStateFilter,
  InternalServerError,
  InvalidActivation,
  InvalidActivationId,
  InvalidAggregatorException,
  InvalidAllowedPatternException,
  InvalidAssociation,
  InvalidAssociationVersion,
  InvalidAutomationExecutionParametersException,
  InvalidAutomationSignalException,
  InvalidAutomationStatusUpdateException,
  InvalidCommandId,
  InvalidDeleteInventoryParametersException,
  InvalidDeletionIdException,
  InvalidDocument,
  InvalidDocumentContent,
  InvalidDocumentOperation,
  InvalidDocumentSchemaVersion,
  InvalidDocumentType,
  InvalidDocumentVersion,
  InvalidFilter,
  InvalidFilterKey,
  InvalidFilterOption,
  InvalidFilterValue,
  InvalidInstanceId,
  InvalidInstanceInformationFilterValue,
  InvalidInventoryGroupException,
  InvalidInventoryItemContextException,
  InvalidInventoryRequestException,
  InvalidItemContentException,
  InvalidKeyId,
  InvalidNextToken,
  InvalidNotificationConfig,
  InvalidOptionException,
  InvalidOutputFolder,
  InvalidOutputLocation,
  InvalidParameters,
  InvalidPermissionType,
  InvalidPluginName,
  InvalidPolicyAttributeException,
  InvalidPolicyTypeException,
  InvalidResourceId,
  InvalidResourceType,
  InvalidResultAttributeException,
  InvalidRole,
  InvalidSchedule,
  InvalidTarget,
  InvalidTypeNameException,
  InvalidUpdate,
  InventoryAggregator,
  InventoryDeletionStatusItem,
  InventoryDeletionSummary,
  InventoryDeletionSummaryItem,
  InventoryFilter,
  InventoryGroup,
  InventoryItem,
  InventoryItemAttribute,
  InventoryItemSchema,
  InventoryResultEntity,
  InventoryResultItem,
  InvocationDoesNotExist,
  ItemContentMismatchException,
  ItemSizeLimitExceededException,
  LabelParameterVersionRequest,
  LabelParameterVersionResult,
  ListAssociationVersionsRequest,
  ListAssociationVersionsResult,
  ListAssociationsRequest,
  ListAssociationsResult,
  ListCommandInvocationsRequest,
  ListCommandInvocationsResult,
  ListCommandsRequest,
  ListCommandsResult,
  ListComplianceItemsRequest,
  ListComplianceItemsResult,
  ListComplianceSummariesRequest,
  ListComplianceSummariesResult,
  ListDocumentVersionsRequest,
  ListDocumentVersionsResult,
  ListDocumentsRequest,
  ListDocumentsResult,
  ListInventoryEntriesRequest,
  ListInventoryEntriesResult,
  ListResourceComplianceSummariesRequest,
  ListResourceComplianceSummariesResult,
  ListResourceDataSyncRequest,
  ListResourceDataSyncResult,
  ListTagsForResourceRequest,
  ListTagsForResourceResult,
  LoggingInfo,
  MaintenanceWindowAutomationParameters,
  MaintenanceWindowExecution,
  MaintenanceWindowExecutionTaskIdentity,
  MaintenanceWindowExecutionTaskInvocationIdentity,
  MaintenanceWindowFilter,
  MaintenanceWindowIdentity,
  MaintenanceWindowIdentityForTarget,
  MaintenanceWindowLambdaParameters,
  MaintenanceWindowRunCommandParameters,
  MaintenanceWindowStepFunctionsParameters,
  MaintenanceWindowTarget,
  MaintenanceWindowTask,
  MaintenanceWindowTaskInvocationParameters,
  MaintenanceWindowTaskParameterValueExpression,
  MaxDocumentSizeExceeded,
  ModifyDocumentPermissionRequest,
  ModifyDocumentPermissionResponse,
  NonCompliantSummary,
  NotificationConfig,
  NotificationEvent,
  OpsAggregator,
  OpsEntity,
  OpsEntityItem,
  OpsFilter,
  OpsItem,
  OpsItemAlreadyExistsException,
  OpsItemDataValue,
  OpsItemFilter,
  OpsItemInvalidParameterException,
  OpsItemLimitExceededException,
  OpsItemNotFoundException,
  OpsItemNotification,
  OpsItemSummary,
  OpsResultAttribute,
  OutputSource,
  Parameter,
  ParameterAlreadyExists,
  ParameterHistory,
  ParameterInlinePolicy,
  ParameterLimitExceeded,
  ParameterMaxVersionLimitExceeded,
  ParameterMetadata,
  ParameterNotFound,
  ParameterPatternMismatchException,
  ParameterStringFilter,
  ParameterVersionLabelLimitExceeded,
  ParameterVersionNotFound,
  ParametersFilter,
  Patch,
  PatchBaselineIdentity,
  PatchComplianceData,
  PatchFilter,
  PatchFilterGroup,
  PatchGroupPatchBaselineMapping,
  PatchOrchestratorFilter,
  PatchRule,
  PatchRuleGroup,
  PatchSource,
  PatchStatus,
  PlatformType,
  PoliciesLimitExceededException,
  ProgressCounters,
  PutComplianceItemsRequest,
  PutComplianceItemsResult,
  PutInventoryRequest,
  PutInventoryResult,
  PutParameterRequest,
  PutParameterResult,
  RegisterDefaultPatchBaselineRequest,
  RegisterDefaultPatchBaselineResult,
  RegisterPatchBaselineForPatchGroupRequest,
  RegisterPatchBaselineForPatchGroupResult,
  RegisterTargetWithMaintenanceWindowRequest,
  RegisterTargetWithMaintenanceWindowResult,
  RegisterTaskWithMaintenanceWindowRequest,
  RegisterTaskWithMaintenanceWindowResult,
  RelatedOpsItem,
  RemoveTagsFromResourceRequest,
  RemoveTagsFromResourceResult,
  ResetServiceSettingRequest,
  ResetServiceSettingResult,
  ResolvedTargets,
  ResourceComplianceSummaryItem,
  ResourceDataSyncAlreadyExistsException,
  ResourceDataSyncAwsOrganizationsSource,
  ResourceDataSyncConflictException,
  ResourceDataSyncCountExceededException,
  ResourceDataSyncInvalidConfigurationException,
  ResourceDataSyncItem,
  ResourceDataSyncNotFoundException,
  ResourceDataSyncOrganizationalUnit,
  ResourceDataSyncS3Destination,
  ResourceDataSyncSource,
  ResourceDataSyncSourceWithState,
  ResourceInUseException,
  ResourceLimitExceededException,
  ResultAttribute,
  ResumeSessionRequest,
  ResumeSessionResponse,
  S3OutputLocation,
  S3OutputUrl,
  ScheduledWindowExecution,
  SendAutomationSignalRequest,
  SendAutomationSignalResult,
  SendCommandRequest,
  SendCommandResult,
  ServiceSetting,
  ServiceSettingNotFound,
  Session,
  SessionFilter,
  SessionManagerOutputUrl,
  SeveritySummary,
  StartAssociationsOnceRequest,
  StartAssociationsOnceResult,
  StartAutomationExecutionRequest,
  StartAutomationExecutionResult,
  StartSessionRequest,
  StartSessionResponse,
  StatusUnchanged,
  StepExecution,
  StepExecutionFilter,
  StopAutomationExecutionRequest,
  StopAutomationExecutionResult,
  SubTypeCountLimitExceededException,
  Tag,
  Target,
  TargetInUseException,
  TargetLocation,
  TargetNotConnected,
  TerminateSessionRequest,
  TerminateSessionResponse,
  TooManyTagsError,
  TooManyUpdates,
  TotalSizeLimitExceededException,
  UnsupportedCalendarException,
  UnsupportedFeatureRequiredException,
  UnsupportedInventoryItemContextException,
  UnsupportedInventorySchemaVersionException,
  UnsupportedOperatingSystem,
  UnsupportedParameterType,
  UnsupportedPlatformType,
  UpdateAssociationRequest,
  UpdateAssociationResult,
  UpdateAssociationStatusRequest,
  UpdateAssociationStatusResult,
  UpdateDocumentDefaultVersionRequest,
  UpdateDocumentDefaultVersionResult,
  UpdateDocumentRequest,
  UpdateDocumentResult,
  UpdateMaintenanceWindowRequest,
  UpdateMaintenanceWindowResult,
  UpdateMaintenanceWindowTargetRequest,
  UpdateMaintenanceWindowTargetResult,
  UpdateMaintenanceWindowTaskRequest,
  UpdateMaintenanceWindowTaskResult,
  UpdateManagedInstanceRoleRequest,
  UpdateManagedInstanceRoleResult,
  UpdateOpsItemRequest,
  UpdateOpsItemResponse,
  UpdatePatchBaselineRequest,
  UpdatePatchBaselineResult,
  UpdateResourceDataSyncRequest,
  UpdateResourceDataSyncResult,
  UpdateServiceSettingRequest,
  UpdateServiceSettingResult
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import { v4 as generateIdempotencyToken } from "uuid";

export async function serializeAws_json1_1AddTagsToResourceCommand(
  input: AddTagsToResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.AddTagsToResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AddTagsToResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CancelCommandCommand(
  input: CancelCommandCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CancelCommand";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CancelCommandRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CancelMaintenanceWindowExecutionCommand(
  input: CancelMaintenanceWindowExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CancelMaintenanceWindowExecution";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CancelMaintenanceWindowExecutionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateActivationCommand(
  input: CreateActivationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CreateActivation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateActivationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateAssociationCommand(
  input: CreateAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CreateAssociation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateAssociationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateAssociationBatchCommand(
  input: CreateAssociationBatchCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CreateAssociationBatch";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateAssociationBatchRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateDocumentCommand(
  input: CreateDocumentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CreateDocument";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateDocumentRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateMaintenanceWindowCommand(
  input: CreateMaintenanceWindowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CreateMaintenanceWindow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateMaintenanceWindowRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateOpsItemCommand(
  input: CreateOpsItemCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CreateOpsItem";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateOpsItemRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreatePatchBaselineCommand(
  input: CreatePatchBaselineCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CreatePatchBaseline";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreatePatchBaselineRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateResourceDataSyncCommand(
  input: CreateResourceDataSyncCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.CreateResourceDataSync";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateResourceDataSyncRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteActivationCommand(
  input: DeleteActivationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeleteActivation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteActivationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteAssociationCommand(
  input: DeleteAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeleteAssociation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteAssociationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDocumentCommand(
  input: DeleteDocumentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeleteDocument";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDocumentRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteInventoryCommand(
  input: DeleteInventoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeleteInventory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteInventoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteMaintenanceWindowCommand(
  input: DeleteMaintenanceWindowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeleteMaintenanceWindow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteMaintenanceWindowRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteParameterCommand(
  input: DeleteParameterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeleteParameter";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteParameterRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteParametersCommand(
  input: DeleteParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeleteParameters";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteParametersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeletePatchBaselineCommand(
  input: DeletePatchBaselineCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeletePatchBaseline";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeletePatchBaselineRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteResourceDataSyncCommand(
  input: DeleteResourceDataSyncCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeleteResourceDataSync";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteResourceDataSyncRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeregisterManagedInstanceCommand(
  input: DeregisterManagedInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeregisterManagedInstance";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterManagedInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeregisterPatchBaselineForPatchGroupCommand(
  input: DeregisterPatchBaselineForPatchGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeregisterPatchBaselineForPatchGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterPatchBaselineForPatchGroupRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeregisterTargetFromMaintenanceWindowCommand(
  input: DeregisterTargetFromMaintenanceWindowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeregisterTargetFromMaintenanceWindow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterTargetFromMaintenanceWindowRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeregisterTaskFromMaintenanceWindowCommand(
  input: DeregisterTaskFromMaintenanceWindowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DeregisterTaskFromMaintenanceWindow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterTaskFromMaintenanceWindowRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeActivationsCommand(
  input: DescribeActivationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeActivations";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeActivationsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeAssociationCommand(
  input: DescribeAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeAssociation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAssociationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeAssociationExecutionTargetsCommand(
  input: DescribeAssociationExecutionTargetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeAssociationExecutionTargets";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAssociationExecutionTargetsRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeAssociationExecutionsCommand(
  input: DescribeAssociationExecutionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeAssociationExecutions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAssociationExecutionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeAutomationExecutionsCommand(
  input: DescribeAutomationExecutionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeAutomationExecutions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAutomationExecutionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeAutomationStepExecutionsCommand(
  input: DescribeAutomationStepExecutionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeAutomationStepExecutions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAutomationStepExecutionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeAvailablePatchesCommand(
  input: DescribeAvailablePatchesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeAvailablePatches";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAvailablePatchesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDocumentCommand(
  input: DescribeDocumentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeDocument";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDocumentRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDocumentPermissionCommand(
  input: DescribeDocumentPermissionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeDocumentPermission";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDocumentPermissionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEffectiveInstanceAssociationsCommand(
  input: DescribeEffectiveInstanceAssociationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeEffectiveInstanceAssociations";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEffectiveInstanceAssociationsRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEffectivePatchesForPatchBaselineCommand(
  input: DescribeEffectivePatchesForPatchBaselineCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonSSM.DescribeEffectivePatchesForPatchBaseline";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEffectivePatchesForPatchBaselineRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeInstanceAssociationsStatusCommand(
  input: DescribeInstanceAssociationsStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeInstanceAssociationsStatus";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInstanceAssociationsStatusRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeInstanceInformationCommand(
  input: DescribeInstanceInformationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeInstanceInformation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInstanceInformationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeInstancePatchStatesCommand(
  input: DescribeInstancePatchStatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeInstancePatchStates";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInstancePatchStatesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeInstancePatchStatesForPatchGroupCommand(
  input: DescribeInstancePatchStatesForPatchGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonSSM.DescribeInstancePatchStatesForPatchGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInstancePatchStatesForPatchGroupRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeInstancePatchesCommand(
  input: DescribeInstancePatchesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeInstancePatches";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInstancePatchesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeInventoryDeletionsCommand(
  input: DescribeInventoryDeletionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeInventoryDeletions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInventoryDeletionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMaintenanceWindowExecutionTaskInvocationsCommand(
  input: DescribeMaintenanceWindowExecutionTaskInvocationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonSSM.DescribeMaintenanceWindowExecutionTaskInvocations";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMaintenanceWindowExecutionTaskInvocationsRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMaintenanceWindowExecutionTasksCommand(
  input: DescribeMaintenanceWindowExecutionTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeMaintenanceWindowExecutionTasks";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMaintenanceWindowExecutionTasksRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMaintenanceWindowExecutionsCommand(
  input: DescribeMaintenanceWindowExecutionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeMaintenanceWindowExecutions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMaintenanceWindowExecutionsRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMaintenanceWindowScheduleCommand(
  input: DescribeMaintenanceWindowScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeMaintenanceWindowSchedule";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMaintenanceWindowScheduleRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMaintenanceWindowTargetsCommand(
  input: DescribeMaintenanceWindowTargetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeMaintenanceWindowTargets";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMaintenanceWindowTargetsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMaintenanceWindowTasksCommand(
  input: DescribeMaintenanceWindowTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeMaintenanceWindowTasks";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMaintenanceWindowTasksRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMaintenanceWindowsCommand(
  input: DescribeMaintenanceWindowsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeMaintenanceWindows";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMaintenanceWindowsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMaintenanceWindowsForTargetCommand(
  input: DescribeMaintenanceWindowsForTargetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeMaintenanceWindowsForTarget";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMaintenanceWindowsForTargetRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeOpsItemsCommand(
  input: DescribeOpsItemsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeOpsItems";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeOpsItemsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeParametersCommand(
  input: DescribeParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeParameters";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeParametersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribePatchBaselinesCommand(
  input: DescribePatchBaselinesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribePatchBaselines";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribePatchBaselinesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribePatchGroupStateCommand(
  input: DescribePatchGroupStateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribePatchGroupState";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribePatchGroupStateRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribePatchGroupsCommand(
  input: DescribePatchGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribePatchGroups";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribePatchGroupsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribePatchPropertiesCommand(
  input: DescribePatchPropertiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribePatchProperties";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribePatchPropertiesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeSessionsCommand(
  input: DescribeSessionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.DescribeSessions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeSessionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetAutomationExecutionCommand(
  input: GetAutomationExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetAutomationExecution";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetAutomationExecutionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCalendarStateCommand(
  input: GetCalendarStateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetCalendarState";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetCalendarStateRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetCommandInvocationCommand(
  input: GetCommandInvocationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetCommandInvocation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetCommandInvocationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetConnectionStatusCommand(
  input: GetConnectionStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetConnectionStatus";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetConnectionStatusRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDefaultPatchBaselineCommand(
  input: GetDefaultPatchBaselineCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetDefaultPatchBaseline";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetDefaultPatchBaselineRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDeployablePatchSnapshotForInstanceCommand(
  input: GetDeployablePatchSnapshotForInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetDeployablePatchSnapshotForInstance";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetDeployablePatchSnapshotForInstanceRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetDocumentCommand(
  input: GetDocumentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetDocument";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetDocumentRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetInventoryCommand(
  input: GetInventoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetInventory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetInventoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetInventorySchemaCommand(
  input: GetInventorySchemaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetInventorySchema";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetInventorySchemaRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMaintenanceWindowCommand(
  input: GetMaintenanceWindowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetMaintenanceWindow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMaintenanceWindowRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMaintenanceWindowExecutionCommand(
  input: GetMaintenanceWindowExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetMaintenanceWindowExecution";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMaintenanceWindowExecutionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMaintenanceWindowExecutionTaskCommand(
  input: GetMaintenanceWindowExecutionTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetMaintenanceWindowExecutionTask";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMaintenanceWindowExecutionTaskRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMaintenanceWindowExecutionTaskInvocationCommand(
  input: GetMaintenanceWindowExecutionTaskInvocationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonSSM.GetMaintenanceWindowExecutionTaskInvocation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMaintenanceWindowExecutionTaskInvocationRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetMaintenanceWindowTaskCommand(
  input: GetMaintenanceWindowTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetMaintenanceWindowTask";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetMaintenanceWindowTaskRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetOpsItemCommand(
  input: GetOpsItemCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetOpsItem";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetOpsItemRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetOpsSummaryCommand(
  input: GetOpsSummaryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetOpsSummary";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetOpsSummaryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetParameterCommand(
  input: GetParameterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetParameter";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetParameterRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetParameterHistoryCommand(
  input: GetParameterHistoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetParameterHistory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetParameterHistoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetParametersCommand(
  input: GetParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetParameters";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetParametersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetParametersByPathCommand(
  input: GetParametersByPathCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetParametersByPath";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetParametersByPathRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetPatchBaselineCommand(
  input: GetPatchBaselineCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetPatchBaseline";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetPatchBaselineRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetPatchBaselineForPatchGroupCommand(
  input: GetPatchBaselineForPatchGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetPatchBaselineForPatchGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetPatchBaselineForPatchGroupRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetServiceSettingCommand(
  input: GetServiceSettingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.GetServiceSetting";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetServiceSettingRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1LabelParameterVersionCommand(
  input: LabelParameterVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.LabelParameterVersion";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1LabelParameterVersionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListAssociationVersionsCommand(
  input: ListAssociationVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListAssociationVersions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListAssociationVersionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListAssociationsCommand(
  input: ListAssociationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListAssociations";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListAssociationsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListCommandInvocationsCommand(
  input: ListCommandInvocationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListCommandInvocations";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListCommandInvocationsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListCommandsCommand(
  input: ListCommandsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListCommands";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListCommandsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListComplianceItemsCommand(
  input: ListComplianceItemsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListComplianceItems";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListComplianceItemsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListComplianceSummariesCommand(
  input: ListComplianceSummariesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListComplianceSummaries";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListComplianceSummariesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListDocumentVersionsCommand(
  input: ListDocumentVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListDocumentVersions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListDocumentVersionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListDocumentsCommand(
  input: ListDocumentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListDocuments";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListDocumentsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListInventoryEntriesCommand(
  input: ListInventoryEntriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListInventoryEntries";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListInventoryEntriesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListResourceComplianceSummariesCommand(
  input: ListResourceComplianceSummariesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListResourceComplianceSummaries";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListResourceComplianceSummariesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListResourceDataSyncCommand(
  input: ListResourceDataSyncCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListResourceDataSync";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListResourceDataSyncRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ListTagsForResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListTagsForResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ModifyDocumentPermissionCommand(
  input: ModifyDocumentPermissionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ModifyDocumentPermission";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyDocumentPermissionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutComplianceItemsCommand(
  input: PutComplianceItemsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.PutComplianceItems";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutComplianceItemsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutInventoryCommand(
  input: PutInventoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.PutInventory";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutInventoryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutParameterCommand(
  input: PutParameterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.PutParameter";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutParameterRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RegisterDefaultPatchBaselineCommand(
  input: RegisterDefaultPatchBaselineCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.RegisterDefaultPatchBaseline";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterDefaultPatchBaselineRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RegisterPatchBaselineForPatchGroupCommand(
  input: RegisterPatchBaselineForPatchGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.RegisterPatchBaselineForPatchGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterPatchBaselineForPatchGroupRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RegisterTargetWithMaintenanceWindowCommand(
  input: RegisterTargetWithMaintenanceWindowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.RegisterTargetWithMaintenanceWindow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterTargetWithMaintenanceWindowRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RegisterTaskWithMaintenanceWindowCommand(
  input: RegisterTaskWithMaintenanceWindowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.RegisterTaskWithMaintenanceWindow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterTaskWithMaintenanceWindowRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RemoveTagsFromResourceCommand(
  input: RemoveTagsFromResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.RemoveTagsFromResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RemoveTagsFromResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ResetServiceSettingCommand(
  input: ResetServiceSettingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ResetServiceSetting";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ResetServiceSettingRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ResumeSessionCommand(
  input: ResumeSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.ResumeSession";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ResumeSessionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SendAutomationSignalCommand(
  input: SendAutomationSignalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.SendAutomationSignal";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SendAutomationSignalRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SendCommandCommand(
  input: SendCommandCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.SendCommand";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1SendCommandRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartAssociationsOnceCommand(
  input: StartAssociationsOnceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.StartAssociationsOnce";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartAssociationsOnceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartAutomationExecutionCommand(
  input: StartAutomationExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.StartAutomationExecution";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartAutomationExecutionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartSessionCommand(
  input: StartSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.StartSession";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartSessionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopAutomationExecutionCommand(
  input: StopAutomationExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.StopAutomationExecution";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopAutomationExecutionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1TerminateSessionCommand(
  input: TerminateSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.TerminateSession";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1TerminateSessionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateAssociationCommand(
  input: UpdateAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateAssociation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateAssociationRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateAssociationStatusCommand(
  input: UpdateAssociationStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateAssociationStatus";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateAssociationStatusRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateDocumentCommand(
  input: UpdateDocumentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateDocument";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateDocumentRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateDocumentDefaultVersionCommand(
  input: UpdateDocumentDefaultVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateDocumentDefaultVersion";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateDocumentDefaultVersionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateMaintenanceWindowCommand(
  input: UpdateMaintenanceWindowCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateMaintenanceWindow";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateMaintenanceWindowRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateMaintenanceWindowTargetCommand(
  input: UpdateMaintenanceWindowTargetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateMaintenanceWindowTarget";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateMaintenanceWindowTargetRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateMaintenanceWindowTaskCommand(
  input: UpdateMaintenanceWindowTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateMaintenanceWindowTask";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateMaintenanceWindowTaskRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateManagedInstanceRoleCommand(
  input: UpdateManagedInstanceRoleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateManagedInstanceRole";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateManagedInstanceRoleRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateOpsItemCommand(
  input: UpdateOpsItemCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateOpsItem";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateOpsItemRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdatePatchBaselineCommand(
  input: UpdatePatchBaselineCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdatePatchBaseline";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdatePatchBaselineRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateResourceDataSyncCommand(
  input: UpdateResourceDataSyncCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateResourceDataSync";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateResourceDataSyncRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateServiceSettingCommand(
  input: UpdateServiceSettingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonSSM.UpdateServiceSetting";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateServiceSettingRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_json1_1AddTagsToResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AddTagsToResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AddTagsToResourceResult(data, context);
  const response: AddTagsToResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddTagsToResourceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AddTagsToResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceType":
    case "com.amazonaws.services.ssm#InvalidResourceType":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsError":
    case "com.amazonaws.services.ssm#TooManyTagsError":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CancelCommandCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelCommandCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CancelCommandCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CancelCommandResult(data, context);
  const response: CancelCommandCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelCommandResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CancelCommandCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelCommandCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DuplicateInstanceId":
    case "com.amazonaws.services.ssm#DuplicateInstanceId":
      response = {
        ...(await deserializeAws_json1_1DuplicateInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommandId":
    case "com.amazonaws.services.ssm#InvalidCommandId":
      response = {
        ...(await deserializeAws_json1_1InvalidCommandIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CancelMaintenanceWindowExecutionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelMaintenanceWindowExecutionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CancelMaintenanceWindowExecutionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CancelMaintenanceWindowExecutionResult(
    data,
    context
  );
  const response: CancelMaintenanceWindowExecutionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelMaintenanceWindowExecutionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CancelMaintenanceWindowExecutionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelMaintenanceWindowExecutionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateActivationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateActivationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateActivationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateActivationResult(data, context);
  const response: CreateActivationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateActivationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateActivationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateActivationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateAssociationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAssociationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateAssociationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateAssociationResult(data, context);
  const response: CreateAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateAssociationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAssociationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationAlreadyExists":
    case "com.amazonaws.services.ssm#AssociationAlreadyExists":
      response = {
        ...(await deserializeAws_json1_1AssociationAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AssociationLimitExceeded":
    case "com.amazonaws.services.ssm#AssociationLimitExceeded":
      response = {
        ...(await deserializeAws_json1_1AssociationLimitExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOutputLocation":
    case "com.amazonaws.services.ssm#InvalidOutputLocation":
      response = {
        ...(await deserializeAws_json1_1InvalidOutputLocationResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameters":
    case "com.amazonaws.services.ssm#InvalidParameters":
      response = {
        ...(await deserializeAws_json1_1InvalidParametersResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSchedule":
    case "com.amazonaws.services.ssm#InvalidSchedule":
      response = {
        ...(await deserializeAws_json1_1InvalidScheduleResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTarget":
    case "com.amazonaws.services.ssm#InvalidTarget":
      response = {
        ...(await deserializeAws_json1_1InvalidTargetResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedPlatformType":
    case "com.amazonaws.services.ssm#UnsupportedPlatformType":
      response = {
        ...(await deserializeAws_json1_1UnsupportedPlatformTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateAssociationBatchCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAssociationBatchCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateAssociationBatchCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateAssociationBatchResult(data, context);
  const response: CreateAssociationBatchCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAssociationBatchResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateAssociationBatchCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAssociationBatchCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationLimitExceeded":
    case "com.amazonaws.services.ssm#AssociationLimitExceeded":
      response = {
        ...(await deserializeAws_json1_1AssociationLimitExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateInstanceId":
    case "com.amazonaws.services.ssm#DuplicateInstanceId":
      response = {
        ...(await deserializeAws_json1_1DuplicateInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOutputLocation":
    case "com.amazonaws.services.ssm#InvalidOutputLocation":
      response = {
        ...(await deserializeAws_json1_1InvalidOutputLocationResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameters":
    case "com.amazonaws.services.ssm#InvalidParameters":
      response = {
        ...(await deserializeAws_json1_1InvalidParametersResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSchedule":
    case "com.amazonaws.services.ssm#InvalidSchedule":
      response = {
        ...(await deserializeAws_json1_1InvalidScheduleResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTarget":
    case "com.amazonaws.services.ssm#InvalidTarget":
      response = {
        ...(await deserializeAws_json1_1InvalidTargetResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedPlatformType":
    case "com.amazonaws.services.ssm#UnsupportedPlatformType":
      response = {
        ...(await deserializeAws_json1_1UnsupportedPlatformTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateDocumentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDocumentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDocumentResult(data, context);
  const response: CreateDocumentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDocumentResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDocumentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DocumentAlreadyExists":
    case "com.amazonaws.services.ssm#DocumentAlreadyExists":
      response = {
        ...(await deserializeAws_json1_1DocumentAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DocumentLimitExceeded":
    case "com.amazonaws.services.ssm#DocumentLimitExceeded":
      response = {
        ...(await deserializeAws_json1_1DocumentLimitExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentContent":
    case "com.amazonaws.services.ssm#InvalidDocumentContent":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentContentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentSchemaVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentSchemaVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentSchemaVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaxDocumentSizeExceeded":
    case "com.amazonaws.services.ssm#MaxDocumentSizeExceeded":
      response = {
        ...(await deserializeAws_json1_1MaxDocumentSizeExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateMaintenanceWindowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMaintenanceWindowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateMaintenanceWindowCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateMaintenanceWindowResult(data, context);
  const response: CreateMaintenanceWindowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMaintenanceWindowResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateMaintenanceWindowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMaintenanceWindowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "IdempotentParameterMismatch":
    case "com.amazonaws.services.ssm#IdempotentParameterMismatch":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.services.ssm#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateOpsItemCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateOpsItemCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateOpsItemCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateOpsItemResponse(data, context);
  const response: CreateOpsItemCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateOpsItemResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateOpsItemCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateOpsItemCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OpsItemAlreadyExistsException":
    case "com.amazonaws.services.ssm#OpsItemAlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1OpsItemAlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OpsItemInvalidParameterException":
    case "com.amazonaws.services.ssm#OpsItemInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1OpsItemInvalidParameterExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OpsItemLimitExceededException":
    case "com.amazonaws.services.ssm#OpsItemLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1OpsItemLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePatchBaselineCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePatchBaselineCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePatchBaselineCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreatePatchBaselineResult(data, context);
  const response: CreatePatchBaselineCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePatchBaselineResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePatchBaselineCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePatchBaselineCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "IdempotentParameterMismatch":
    case "com.amazonaws.services.ssm#IdempotentParameterMismatch":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.services.ssm#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateResourceDataSyncCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateResourceDataSyncCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateResourceDataSyncCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateResourceDataSyncResult(data, context);
  const response: CreateResourceDataSyncCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateResourceDataSyncResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateResourceDataSyncCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateResourceDataSyncCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncAlreadyExistsException":
    case "com.amazonaws.services.ssm#ResourceDataSyncAlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncAlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncCountExceededException":
    case "com.amazonaws.services.ssm#ResourceDataSyncCountExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncCountExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncInvalidConfigurationException":
    case "com.amazonaws.services.ssm#ResourceDataSyncInvalidConfigurationException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncInvalidConfigurationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteActivationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteActivationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteActivationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteActivationResult(data, context);
  const response: DeleteActivationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteActivationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteActivationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteActivationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidActivation":
    case "com.amazonaws.services.ssm#InvalidActivation":
      response = {
        ...(await deserializeAws_json1_1InvalidActivationResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidActivationId":
    case "com.amazonaws.services.ssm#InvalidActivationId":
      response = {
        ...(await deserializeAws_json1_1InvalidActivationIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteAssociationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAssociationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteAssociationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteAssociationResult(data, context);
  const response: DeleteAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteAssociationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAssociationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationDoesNotExist":
    case "com.amazonaws.services.ssm#AssociationDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1AssociationDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDocumentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDocumentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDocumentResult(data, context);
  const response: DeleteDocumentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDocumentResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDocumentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociatedInstances":
    case "com.amazonaws.services.ssm#AssociatedInstances":
      response = {
        ...(await deserializeAws_json1_1AssociatedInstancesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentOperation":
    case "com.amazonaws.services.ssm#InvalidDocumentOperation":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentOperationResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteInventoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInventoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteInventoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteInventoryResult(data, context);
  const response: DeleteInventoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteInventoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteInventoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInventoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDeleteInventoryParametersException":
    case "com.amazonaws.services.ssm#InvalidDeleteInventoryParametersException":
      response = {
        ...(await deserializeAws_json1_1InvalidDeleteInventoryParametersExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInventoryRequestException":
    case "com.amazonaws.services.ssm#InvalidInventoryRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidInventoryRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOptionException":
    case "com.amazonaws.services.ssm#InvalidOptionException":
      response = {
        ...(await deserializeAws_json1_1InvalidOptionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTypeNameException":
    case "com.amazonaws.services.ssm#InvalidTypeNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidTypeNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteMaintenanceWindowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMaintenanceWindowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteMaintenanceWindowCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteMaintenanceWindowResult(data, context);
  const response: DeleteMaintenanceWindowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteMaintenanceWindowResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteMaintenanceWindowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMaintenanceWindowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteParameterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteParameterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteParameterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteParameterResult(data, context);
  const response: DeleteParameterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteParameterResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteParameterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteParameterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterNotFound":
    case "com.amazonaws.services.ssm#ParameterNotFound":
      response = {
        ...(await deserializeAws_json1_1ParameterNotFoundResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteParametersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteParametersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteParametersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteParametersResult(data, context);
  const response: DeleteParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteParametersResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteParametersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteParametersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeletePatchBaselineCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePatchBaselineCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeletePatchBaselineCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeletePatchBaselineResult(data, context);
  const response: DeletePatchBaselineCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeletePatchBaselineResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeletePatchBaselineCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePatchBaselineCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.services.ssm#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteResourceDataSyncCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourceDataSyncCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteResourceDataSyncCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteResourceDataSyncResult(data, context);
  const response: DeleteResourceDataSyncCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteResourceDataSyncResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteResourceDataSyncCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourceDataSyncCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncInvalidConfigurationException":
    case "com.amazonaws.services.ssm#ResourceDataSyncInvalidConfigurationException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncInvalidConfigurationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncNotFoundException":
    case "com.amazonaws.services.ssm#ResourceDataSyncNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeregisterManagedInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterManagedInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterManagedInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeregisterManagedInstanceResult(
    data,
    context
  );
  const response: DeregisterManagedInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeregisterManagedInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeregisterManagedInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterManagedInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeregisterPatchBaselineForPatchGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterPatchBaselineForPatchGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterPatchBaselineForPatchGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeregisterPatchBaselineForPatchGroupResult(
    data,
    context
  );
  const response: DeregisterPatchBaselineForPatchGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeregisterPatchBaselineForPatchGroupResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeregisterPatchBaselineForPatchGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterPatchBaselineForPatchGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeregisterTargetFromMaintenanceWindowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterTargetFromMaintenanceWindowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterTargetFromMaintenanceWindowCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeregisterTargetFromMaintenanceWindowResult(
    data,
    context
  );
  const response: DeregisterTargetFromMaintenanceWindowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeregisterTargetFromMaintenanceWindowResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeregisterTargetFromMaintenanceWindowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterTargetFromMaintenanceWindowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TargetInUseException":
    case "com.amazonaws.services.ssm#TargetInUseException":
      response = {
        ...(await deserializeAws_json1_1TargetInUseExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeregisterTaskFromMaintenanceWindowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterTaskFromMaintenanceWindowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterTaskFromMaintenanceWindowCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeregisterTaskFromMaintenanceWindowResult(
    data,
    context
  );
  const response: DeregisterTaskFromMaintenanceWindowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeregisterTaskFromMaintenanceWindowResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeregisterTaskFromMaintenanceWindowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterTaskFromMaintenanceWindowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeActivationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeActivationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeActivationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeActivationsResult(data, context);
  const response: DescribeActivationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeActivationsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeActivationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeActivationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilter":
    case "com.amazonaws.services.ssm#InvalidFilter":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAssociationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAssociationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAssociationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAssociationResult(data, context);
  const response: DescribeAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAssociationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAssociationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationDoesNotExist":
    case "com.amazonaws.services.ssm#AssociationDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1AssociationDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAssociationVersion":
    case "com.amazonaws.services.ssm#InvalidAssociationVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidAssociationVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAssociationExecutionTargetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAssociationExecutionTargetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAssociationExecutionTargetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAssociationExecutionTargetsResult(
    data,
    context
  );
  const response: DescribeAssociationExecutionTargetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAssociationExecutionTargetsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAssociationExecutionTargetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAssociationExecutionTargetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationDoesNotExist":
    case "com.amazonaws.services.ssm#AssociationDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1AssociationDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AssociationExecutionDoesNotExist":
    case "com.amazonaws.services.ssm#AssociationExecutionDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1AssociationExecutionDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAssociationExecutionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAssociationExecutionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAssociationExecutionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAssociationExecutionsResult(
    data,
    context
  );
  const response: DescribeAssociationExecutionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAssociationExecutionsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAssociationExecutionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAssociationExecutionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationDoesNotExist":
    case "com.amazonaws.services.ssm#AssociationDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1AssociationDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAutomationExecutionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAutomationExecutionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAutomationExecutionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAutomationExecutionsResult(
    data,
    context
  );
  const response: DescribeAutomationExecutionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAutomationExecutionsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAutomationExecutionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAutomationExecutionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterKey":
    case "com.amazonaws.services.ssm#InvalidFilterKey":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterKeyResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterValue":
    case "com.amazonaws.services.ssm#InvalidFilterValue":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterValueResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAutomationStepExecutionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAutomationStepExecutionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAutomationStepExecutionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAutomationStepExecutionsResult(
    data,
    context
  );
  const response: DescribeAutomationStepExecutionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAutomationStepExecutionsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAutomationStepExecutionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAutomationStepExecutionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AutomationExecutionNotFoundException":
    case "com.amazonaws.services.ssm#AutomationExecutionNotFoundException":
      response = {
        ...(await deserializeAws_json1_1AutomationExecutionNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterKey":
    case "com.amazonaws.services.ssm#InvalidFilterKey":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterKeyResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterValue":
    case "com.amazonaws.services.ssm#InvalidFilterValue":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterValueResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAvailablePatchesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAvailablePatchesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAvailablePatchesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAvailablePatchesResult(
    data,
    context
  );
  const response: DescribeAvailablePatchesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAvailablePatchesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAvailablePatchesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAvailablePatchesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDocumentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDocumentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDocumentResult(data, context);
  const response: DescribeDocumentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDocumentResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDocumentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDocumentPermissionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentPermissionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDocumentPermissionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDocumentPermissionResponse(
    data,
    context
  );
  const response: DescribeDocumentPermissionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDocumentPermissionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDocumentPermissionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentPermissionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPermissionType":
    case "com.amazonaws.services.ssm#InvalidPermissionType":
      response = {
        ...(await deserializeAws_json1_1InvalidPermissionTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEffectiveInstanceAssociationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEffectiveInstanceAssociationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEffectiveInstanceAssociationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEffectiveInstanceAssociationsResult(
    data,
    context
  );
  const response: DescribeEffectiveInstanceAssociationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEffectiveInstanceAssociationsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEffectiveInstanceAssociationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEffectiveInstanceAssociationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEffectivePatchesForPatchBaselineCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEffectivePatchesForPatchBaselineCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEffectivePatchesForPatchBaselineCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEffectivePatchesForPatchBaselineResult(
    data,
    context
  );
  const response: DescribeEffectivePatchesForPatchBaselineCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEffectivePatchesForPatchBaselineResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEffectivePatchesForPatchBaselineCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEffectivePatchesForPatchBaselineCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedOperatingSystem":
    case "com.amazonaws.services.ssm#UnsupportedOperatingSystem":
      response = {
        ...(await deserializeAws_json1_1UnsupportedOperatingSystemResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeInstanceAssociationsStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceAssociationsStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInstanceAssociationsStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInstanceAssociationsStatusResult(
    data,
    context
  );
  const response: DescribeInstanceAssociationsStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstanceAssociationsStatusResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeInstanceAssociationsStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceAssociationsStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeInstanceInformationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceInformationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInstanceInformationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInstanceInformationResult(
    data,
    context
  );
  const response: DescribeInstanceInformationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstanceInformationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeInstanceInformationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstanceInformationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterKey":
    case "com.amazonaws.services.ssm#InvalidFilterKey":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterKeyResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceInformationFilterValue":
    case "com.amazonaws.services.ssm#InvalidInstanceInformationFilterValue":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceInformationFilterValueResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeInstancePatchStatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancePatchStatesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInstancePatchStatesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInstancePatchStatesResult(
    data,
    context
  );
  const response: DescribeInstancePatchStatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstancePatchStatesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeInstancePatchStatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancePatchStatesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeInstancePatchStatesForPatchGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancePatchStatesForPatchGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInstancePatchStatesForPatchGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInstancePatchStatesForPatchGroupResult(
    data,
    context
  );
  const response: DescribeInstancePatchStatesForPatchGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstancePatchStatesForPatchGroupResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeInstancePatchStatesForPatchGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancePatchStatesForPatchGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilter":
    case "com.amazonaws.services.ssm#InvalidFilter":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeInstancePatchesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancePatchesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInstancePatchesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInstancePatchesResult(data, context);
  const response: DescribeInstancePatchesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstancePatchesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeInstancePatchesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancePatchesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilter":
    case "com.amazonaws.services.ssm#InvalidFilter":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeInventoryDeletionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInventoryDeletionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInventoryDeletionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInventoryDeletionsResult(
    data,
    context
  );
  const response: DescribeInventoryDeletionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInventoryDeletionsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeInventoryDeletionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInventoryDeletionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDeletionIdException":
    case "com.amazonaws.services.ssm#InvalidDeletionIdException":
      response = {
        ...(await deserializeAws_json1_1InvalidDeletionIdExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMaintenanceWindowExecutionTaskInvocationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowExecutionTaskInvocationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMaintenanceWindowExecutionTaskInvocationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMaintenanceWindowExecutionTaskInvocationsResult(
    data,
    context
  );
  const response: DescribeMaintenanceWindowExecutionTaskInvocationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMaintenanceWindowExecutionTaskInvocationsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMaintenanceWindowExecutionTaskInvocationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowExecutionTaskInvocationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMaintenanceWindowExecutionTasksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowExecutionTasksCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMaintenanceWindowExecutionTasksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMaintenanceWindowExecutionTasksResult(
    data,
    context
  );
  const response: DescribeMaintenanceWindowExecutionTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMaintenanceWindowExecutionTasksResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMaintenanceWindowExecutionTasksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowExecutionTasksCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMaintenanceWindowExecutionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowExecutionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMaintenanceWindowExecutionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMaintenanceWindowExecutionsResult(
    data,
    context
  );
  const response: DescribeMaintenanceWindowExecutionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMaintenanceWindowExecutionsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMaintenanceWindowExecutionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowExecutionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMaintenanceWindowScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMaintenanceWindowScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMaintenanceWindowScheduleResult(
    data,
    context
  );
  const response: DescribeMaintenanceWindowScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMaintenanceWindowScheduleResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMaintenanceWindowScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMaintenanceWindowTargetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowTargetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMaintenanceWindowTargetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMaintenanceWindowTargetsResult(
    data,
    context
  );
  const response: DescribeMaintenanceWindowTargetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMaintenanceWindowTargetsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMaintenanceWindowTargetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowTargetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMaintenanceWindowTasksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowTasksCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMaintenanceWindowTasksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMaintenanceWindowTasksResult(
    data,
    context
  );
  const response: DescribeMaintenanceWindowTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMaintenanceWindowTasksResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMaintenanceWindowTasksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowTasksCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMaintenanceWindowsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMaintenanceWindowsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMaintenanceWindowsResult(
    data,
    context
  );
  const response: DescribeMaintenanceWindowsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMaintenanceWindowsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMaintenanceWindowsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMaintenanceWindowsForTargetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowsForTargetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMaintenanceWindowsForTargetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMaintenanceWindowsForTargetResult(
    data,
    context
  );
  const response: DescribeMaintenanceWindowsForTargetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMaintenanceWindowsForTargetResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMaintenanceWindowsForTargetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMaintenanceWindowsForTargetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeOpsItemsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOpsItemsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeOpsItemsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeOpsItemsResponse(data, context);
  const response: DescribeOpsItemsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeOpsItemsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeOpsItemsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOpsItemsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeParametersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeParametersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeParametersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeParametersResult(data, context);
  const response: DescribeParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeParametersResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeParametersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeParametersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterKey":
    case "com.amazonaws.services.ssm#InvalidFilterKey":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterKeyResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterOption":
    case "com.amazonaws.services.ssm#InvalidFilterOption":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterOptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterValue":
    case "com.amazonaws.services.ssm#InvalidFilterValue":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterValueResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribePatchBaselinesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePatchBaselinesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePatchBaselinesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePatchBaselinesResult(data, context);
  const response: DescribePatchBaselinesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePatchBaselinesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribePatchBaselinesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePatchBaselinesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribePatchGroupStateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePatchGroupStateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePatchGroupStateCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePatchGroupStateResult(data, context);
  const response: DescribePatchGroupStateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePatchGroupStateResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribePatchGroupStateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePatchGroupStateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribePatchGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePatchGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePatchGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePatchGroupsResult(data, context);
  const response: DescribePatchGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePatchGroupsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribePatchGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePatchGroupsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribePatchPropertiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePatchPropertiesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePatchPropertiesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePatchPropertiesResult(data, context);
  const response: DescribePatchPropertiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePatchPropertiesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribePatchPropertiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePatchPropertiesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeSessionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSessionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeSessionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeSessionsResponse(data, context);
  const response: DescribeSessionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSessionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeSessionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSessionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterKey":
    case "com.amazonaws.services.ssm#InvalidFilterKey":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterKeyResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetAutomationExecutionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAutomationExecutionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetAutomationExecutionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetAutomationExecutionResult(data, context);
  const response: GetAutomationExecutionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAutomationExecutionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetAutomationExecutionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAutomationExecutionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AutomationExecutionNotFoundException":
    case "com.amazonaws.services.ssm#AutomationExecutionNotFoundException":
      response = {
        ...(await deserializeAws_json1_1AutomationExecutionNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCalendarStateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCalendarStateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCalendarStateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCalendarStateResponse(data, context);
  const response: GetCalendarStateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCalendarStateResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCalendarStateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCalendarStateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentType":
    case "com.amazonaws.services.ssm#InvalidDocumentType":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedCalendarException":
    case "com.amazonaws.services.ssm#UnsupportedCalendarException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedCalendarExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetCommandInvocationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommandInvocationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetCommandInvocationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetCommandInvocationResult(data, context);
  const response: GetCommandInvocationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCommandInvocationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetCommandInvocationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCommandInvocationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommandId":
    case "com.amazonaws.services.ssm#InvalidCommandId":
      response = {
        ...(await deserializeAws_json1_1InvalidCommandIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPluginName":
    case "com.amazonaws.services.ssm#InvalidPluginName":
      response = {
        ...(await deserializeAws_json1_1InvalidPluginNameResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvocationDoesNotExist":
    case "com.amazonaws.services.ssm#InvocationDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1InvocationDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetConnectionStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetConnectionStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetConnectionStatusResponse(data, context);
  const response: GetConnectionStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConnectionStatusResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetConnectionStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectionStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDefaultPatchBaselineCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDefaultPatchBaselineCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDefaultPatchBaselineCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDefaultPatchBaselineResult(data, context);
  const response: GetDefaultPatchBaselineCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDefaultPatchBaselineResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDefaultPatchBaselineCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDefaultPatchBaselineCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDeployablePatchSnapshotForInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeployablePatchSnapshotForInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDeployablePatchSnapshotForInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDeployablePatchSnapshotForInstanceResult(
    data,
    context
  );
  const response: GetDeployablePatchSnapshotForInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDeployablePatchSnapshotForInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDeployablePatchSnapshotForInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeployablePatchSnapshotForInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedFeatureRequiredException":
    case "com.amazonaws.services.ssm#UnsupportedFeatureRequiredException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedFeatureRequiredExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedOperatingSystem":
    case "com.amazonaws.services.ssm#UnsupportedOperatingSystem":
      response = {
        ...(await deserializeAws_json1_1UnsupportedOperatingSystemResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetDocumentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetDocumentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetDocumentResult(data, context);
  const response: GetDocumentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDocumentResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetDocumentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDocumentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetInventoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInventoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetInventoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetInventoryResult(data, context);
  const response: GetInventoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetInventoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetInventoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInventoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAggregatorException":
    case "com.amazonaws.services.ssm#InvalidAggregatorException":
      response = {
        ...(await deserializeAws_json1_1InvalidAggregatorExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilter":
    case "com.amazonaws.services.ssm#InvalidFilter":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInventoryGroupException":
    case "com.amazonaws.services.ssm#InvalidInventoryGroupException":
      response = {
        ...(await deserializeAws_json1_1InvalidInventoryGroupExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResultAttributeException":
    case "com.amazonaws.services.ssm#InvalidResultAttributeException":
      response = {
        ...(await deserializeAws_json1_1InvalidResultAttributeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTypeNameException":
    case "com.amazonaws.services.ssm#InvalidTypeNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidTypeNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetInventorySchemaCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInventorySchemaCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetInventorySchemaCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetInventorySchemaResult(data, context);
  const response: GetInventorySchemaCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetInventorySchemaResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetInventorySchemaCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInventorySchemaCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTypeNameException":
    case "com.amazonaws.services.ssm#InvalidTypeNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidTypeNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMaintenanceWindowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMaintenanceWindowCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMaintenanceWindowResult(data, context);
  const response: GetMaintenanceWindowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMaintenanceWindowResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMaintenanceWindowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMaintenanceWindowExecutionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowExecutionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMaintenanceWindowExecutionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMaintenanceWindowExecutionResult(
    data,
    context
  );
  const response: GetMaintenanceWindowExecutionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMaintenanceWindowExecutionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMaintenanceWindowExecutionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowExecutionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMaintenanceWindowExecutionTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowExecutionTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMaintenanceWindowExecutionTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMaintenanceWindowExecutionTaskResult(
    data,
    context
  );
  const response: GetMaintenanceWindowExecutionTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMaintenanceWindowExecutionTaskResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMaintenanceWindowExecutionTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowExecutionTaskCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMaintenanceWindowExecutionTaskInvocationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowExecutionTaskInvocationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMaintenanceWindowExecutionTaskInvocationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMaintenanceWindowExecutionTaskInvocationResult(
    data,
    context
  );
  const response: GetMaintenanceWindowExecutionTaskInvocationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMaintenanceWindowExecutionTaskInvocationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMaintenanceWindowExecutionTaskInvocationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowExecutionTaskInvocationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetMaintenanceWindowTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetMaintenanceWindowTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetMaintenanceWindowTaskResult(
    data,
    context
  );
  const response: GetMaintenanceWindowTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMaintenanceWindowTaskResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetMaintenanceWindowTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMaintenanceWindowTaskCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetOpsItemCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetOpsItemCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetOpsItemCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetOpsItemResponse(data, context);
  const response: GetOpsItemCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetOpsItemResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetOpsItemCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetOpsItemCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OpsItemNotFoundException":
    case "com.amazonaws.services.ssm#OpsItemNotFoundException":
      response = {
        ...(await deserializeAws_json1_1OpsItemNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetOpsSummaryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetOpsSummaryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetOpsSummaryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetOpsSummaryResult(data, context);
  const response: GetOpsSummaryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetOpsSummaryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetOpsSummaryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetOpsSummaryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAggregatorException":
    case "com.amazonaws.services.ssm#InvalidAggregatorException":
      response = {
        ...(await deserializeAws_json1_1InvalidAggregatorExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilter":
    case "com.amazonaws.services.ssm#InvalidFilter":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTypeNameException":
    case "com.amazonaws.services.ssm#InvalidTypeNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidTypeNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncNotFoundException":
    case "com.amazonaws.services.ssm#ResourceDataSyncNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetParameterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetParameterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetParameterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetParameterResult(data, context);
  const response: GetParameterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetParameterResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetParameterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetParameterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidKeyId":
    case "com.amazonaws.services.ssm#InvalidKeyId":
      response = {
        ...(await deserializeAws_json1_1InvalidKeyIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterNotFound":
    case "com.amazonaws.services.ssm#ParameterNotFound":
      response = {
        ...(await deserializeAws_json1_1ParameterNotFoundResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterVersionNotFound":
    case "com.amazonaws.services.ssm#ParameterVersionNotFound":
      response = {
        ...(await deserializeAws_json1_1ParameterVersionNotFoundResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetParameterHistoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetParameterHistoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetParameterHistoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetParameterHistoryResult(data, context);
  const response: GetParameterHistoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetParameterHistoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetParameterHistoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetParameterHistoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidKeyId":
    case "com.amazonaws.services.ssm#InvalidKeyId":
      response = {
        ...(await deserializeAws_json1_1InvalidKeyIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterNotFound":
    case "com.amazonaws.services.ssm#ParameterNotFound":
      response = {
        ...(await deserializeAws_json1_1ParameterNotFoundResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetParametersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetParametersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetParametersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetParametersResult(data, context);
  const response: GetParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetParametersResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetParametersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetParametersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidKeyId":
    case "com.amazonaws.services.ssm#InvalidKeyId":
      response = {
        ...(await deserializeAws_json1_1InvalidKeyIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetParametersByPathCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetParametersByPathCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetParametersByPathCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetParametersByPathResult(data, context);
  const response: GetParametersByPathCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetParametersByPathResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetParametersByPathCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetParametersByPathCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterKey":
    case "com.amazonaws.services.ssm#InvalidFilterKey":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterKeyResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterOption":
    case "com.amazonaws.services.ssm#InvalidFilterOption":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterOptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterValue":
    case "com.amazonaws.services.ssm#InvalidFilterValue":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterValueResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidKeyId":
    case "com.amazonaws.services.ssm#InvalidKeyId":
      response = {
        ...(await deserializeAws_json1_1InvalidKeyIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetPatchBaselineCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPatchBaselineCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPatchBaselineCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPatchBaselineResult(data, context);
  const response: GetPatchBaselineCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPatchBaselineResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetPatchBaselineCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPatchBaselineCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetPatchBaselineForPatchGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPatchBaselineForPatchGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPatchBaselineForPatchGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPatchBaselineForPatchGroupResult(
    data,
    context
  );
  const response: GetPatchBaselineForPatchGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPatchBaselineForPatchGroupResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetPatchBaselineForPatchGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPatchBaselineForPatchGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetServiceSettingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetServiceSettingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetServiceSettingCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetServiceSettingResult(data, context);
  const response: GetServiceSettingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetServiceSettingResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetServiceSettingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetServiceSettingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceSettingNotFound":
    case "com.amazonaws.services.ssm#ServiceSettingNotFound":
      response = {
        ...(await deserializeAws_json1_1ServiceSettingNotFoundResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1LabelParameterVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<LabelParameterVersionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1LabelParameterVersionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1LabelParameterVersionResult(data, context);
  const response: LabelParameterVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "LabelParameterVersionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1LabelParameterVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<LabelParameterVersionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterNotFound":
    case "com.amazonaws.services.ssm#ParameterNotFound":
      response = {
        ...(await deserializeAws_json1_1ParameterNotFoundResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterVersionLabelLimitExceeded":
    case "com.amazonaws.services.ssm#ParameterVersionLabelLimitExceeded":
      response = {
        ...(await deserializeAws_json1_1ParameterVersionLabelLimitExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterVersionNotFound":
    case "com.amazonaws.services.ssm#ParameterVersionNotFound":
      response = {
        ...(await deserializeAws_json1_1ParameterVersionNotFoundResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListAssociationVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAssociationVersionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListAssociationVersionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListAssociationVersionsResult(data, context);
  const response: ListAssociationVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAssociationVersionsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListAssociationVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAssociationVersionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationDoesNotExist":
    case "com.amazonaws.services.ssm#AssociationDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1AssociationDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListAssociationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAssociationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListAssociationsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListAssociationsResult(data, context);
  const response: ListAssociationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAssociationsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListAssociationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAssociationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListCommandInvocationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCommandInvocationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListCommandInvocationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListCommandInvocationsResult(data, context);
  const response: ListCommandInvocationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCommandInvocationsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListCommandInvocationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCommandInvocationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommandId":
    case "com.amazonaws.services.ssm#InvalidCommandId":
      response = {
        ...(await deserializeAws_json1_1InvalidCommandIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterKey":
    case "com.amazonaws.services.ssm#InvalidFilterKey":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterKeyResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListCommandsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCommandsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListCommandsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListCommandsResult(data, context);
  const response: ListCommandsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCommandsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListCommandsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCommandsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidCommandId":
    case "com.amazonaws.services.ssm#InvalidCommandId":
      response = {
        ...(await deserializeAws_json1_1InvalidCommandIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterKey":
    case "com.amazonaws.services.ssm#InvalidFilterKey":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterKeyResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListComplianceItemsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListComplianceItemsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListComplianceItemsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListComplianceItemsResult(data, context);
  const response: ListComplianceItemsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListComplianceItemsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListComplianceItemsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListComplianceItemsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilter":
    case "com.amazonaws.services.ssm#InvalidFilter":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceType":
    case "com.amazonaws.services.ssm#InvalidResourceType":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListComplianceSummariesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListComplianceSummariesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListComplianceSummariesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListComplianceSummariesResult(data, context);
  const response: ListComplianceSummariesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListComplianceSummariesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListComplianceSummariesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListComplianceSummariesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilter":
    case "com.amazonaws.services.ssm#InvalidFilter":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListDocumentVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentVersionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDocumentVersionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDocumentVersionsResult(data, context);
  const response: ListDocumentVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDocumentVersionsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDocumentVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentVersionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListDocumentsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDocumentsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDocumentsResult(data, context);
  const response: ListDocumentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDocumentsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDocumentsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterKey":
    case "com.amazonaws.services.ssm#InvalidFilterKey":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterKeyResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListInventoryEntriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListInventoryEntriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListInventoryEntriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListInventoryEntriesResult(data, context);
  const response: ListInventoryEntriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListInventoryEntriesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListInventoryEntriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListInventoryEntriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilter":
    case "com.amazonaws.services.ssm#InvalidFilter":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTypeNameException":
    case "com.amazonaws.services.ssm#InvalidTypeNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidTypeNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListResourceComplianceSummariesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceComplianceSummariesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListResourceComplianceSummariesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListResourceComplianceSummariesResult(
    data,
    context
  );
  const response: ListResourceComplianceSummariesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListResourceComplianceSummariesResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListResourceComplianceSummariesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceComplianceSummariesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilter":
    case "com.amazonaws.services.ssm#InvalidFilter":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListResourceDataSyncCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceDataSyncCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListResourceDataSyncCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListResourceDataSyncResult(data, context);
  const response: ListResourceDataSyncCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListResourceDataSyncResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListResourceDataSyncCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceDataSyncCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextToken":
    case "com.amazonaws.services.ssm#InvalidNextToken":
      response = {
        ...(await deserializeAws_json1_1InvalidNextTokenResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncInvalidConfigurationException":
    case "com.amazonaws.services.ssm#ResourceDataSyncInvalidConfigurationException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncInvalidConfigurationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResult(data, context);
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceType":
    case "com.amazonaws.services.ssm#InvalidResourceType":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ModifyDocumentPermissionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDocumentPermissionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyDocumentPermissionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyDocumentPermissionResponse(
    data,
    context
  );
  const response: ModifyDocumentPermissionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDocumentPermissionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyDocumentPermissionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDocumentPermissionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DocumentLimitExceeded":
    case "com.amazonaws.services.ssm#DocumentLimitExceeded":
      response = {
        ...(await deserializeAws_json1_1DocumentLimitExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DocumentPermissionLimit":
    case "com.amazonaws.services.ssm#DocumentPermissionLimit":
      response = {
        ...(await deserializeAws_json1_1DocumentPermissionLimitResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPermissionType":
    case "com.amazonaws.services.ssm#InvalidPermissionType":
      response = {
        ...(await deserializeAws_json1_1InvalidPermissionTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutComplianceItemsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutComplianceItemsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutComplianceItemsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutComplianceItemsResult(data, context);
  const response: PutComplianceItemsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutComplianceItemsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutComplianceItemsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutComplianceItemsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ComplianceTypeCountLimitExceededException":
    case "com.amazonaws.services.ssm#ComplianceTypeCountLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ComplianceTypeCountLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidItemContentException":
    case "com.amazonaws.services.ssm#InvalidItemContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidItemContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceType":
    case "com.amazonaws.services.ssm#InvalidResourceType":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ItemSizeLimitExceededException":
    case "com.amazonaws.services.ssm#ItemSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ItemSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TotalSizeLimitExceededException":
    case "com.amazonaws.services.ssm#TotalSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TotalSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutInventoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutInventoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutInventoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutInventoryResult(data, context);
  const response: PutInventoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutInventoryResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutInventoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutInventoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "CustomSchemaCountLimitExceededException":
    case "com.amazonaws.services.ssm#CustomSchemaCountLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1CustomSchemaCountLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInventoryItemContextException":
    case "com.amazonaws.services.ssm#InvalidInventoryItemContextException":
      response = {
        ...(await deserializeAws_json1_1InvalidInventoryItemContextExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidItemContentException":
    case "com.amazonaws.services.ssm#InvalidItemContentException":
      response = {
        ...(await deserializeAws_json1_1InvalidItemContentExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTypeNameException":
    case "com.amazonaws.services.ssm#InvalidTypeNameException":
      response = {
        ...(await deserializeAws_json1_1InvalidTypeNameExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ItemContentMismatchException":
    case "com.amazonaws.services.ssm#ItemContentMismatchException":
      response = {
        ...(await deserializeAws_json1_1ItemContentMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ItemSizeLimitExceededException":
    case "com.amazonaws.services.ssm#ItemSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ItemSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubTypeCountLimitExceededException":
    case "com.amazonaws.services.ssm#SubTypeCountLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1SubTypeCountLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TotalSizeLimitExceededException":
    case "com.amazonaws.services.ssm#TotalSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TotalSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedInventoryItemContextException":
    case "com.amazonaws.services.ssm#UnsupportedInventoryItemContextException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedInventoryItemContextExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedInventorySchemaVersionException":
    case "com.amazonaws.services.ssm#UnsupportedInventorySchemaVersionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedInventorySchemaVersionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutParameterCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutParameterCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutParameterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutParameterResult(data, context);
  const response: PutParameterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutParameterResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutParameterCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutParameterCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "HierarchyLevelLimitExceededException":
    case "com.amazonaws.services.ssm#HierarchyLevelLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1HierarchyLevelLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "HierarchyTypeMismatchException":
    case "com.amazonaws.services.ssm#HierarchyTypeMismatchException":
      response = {
        ...(await deserializeAws_json1_1HierarchyTypeMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IncompatiblePolicyException":
    case "com.amazonaws.services.ssm#IncompatiblePolicyException":
      response = {
        ...(await deserializeAws_json1_1IncompatiblePolicyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAllowedPatternException":
    case "com.amazonaws.services.ssm#InvalidAllowedPatternException":
      response = {
        ...(await deserializeAws_json1_1InvalidAllowedPatternExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidKeyId":
    case "com.amazonaws.services.ssm#InvalidKeyId":
      response = {
        ...(await deserializeAws_json1_1InvalidKeyIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPolicyAttributeException":
    case "com.amazonaws.services.ssm#InvalidPolicyAttributeException":
      response = {
        ...(await deserializeAws_json1_1InvalidPolicyAttributeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPolicyTypeException":
    case "com.amazonaws.services.ssm#InvalidPolicyTypeException":
      response = {
        ...(await deserializeAws_json1_1InvalidPolicyTypeExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterAlreadyExists":
    case "com.amazonaws.services.ssm#ParameterAlreadyExists":
      response = {
        ...(await deserializeAws_json1_1ParameterAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterLimitExceeded":
    case "com.amazonaws.services.ssm#ParameterLimitExceeded":
      response = {
        ...(await deserializeAws_json1_1ParameterLimitExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterMaxVersionLimitExceeded":
    case "com.amazonaws.services.ssm#ParameterMaxVersionLimitExceeded":
      response = {
        ...(await deserializeAws_json1_1ParameterMaxVersionLimitExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ParameterPatternMismatchException":
    case "com.amazonaws.services.ssm#ParameterPatternMismatchException":
      response = {
        ...(await deserializeAws_json1_1ParameterPatternMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PoliciesLimitExceededException":
    case "com.amazonaws.services.ssm#PoliciesLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1PoliciesLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedParameterType":
    case "com.amazonaws.services.ssm#UnsupportedParameterType":
      response = {
        ...(await deserializeAws_json1_1UnsupportedParameterTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RegisterDefaultPatchBaselineCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterDefaultPatchBaselineCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterDefaultPatchBaselineCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterDefaultPatchBaselineResult(
    data,
    context
  );
  const response: RegisterDefaultPatchBaselineCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterDefaultPatchBaselineResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RegisterDefaultPatchBaselineCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterDefaultPatchBaselineCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RegisterPatchBaselineForPatchGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterPatchBaselineForPatchGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterPatchBaselineForPatchGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterPatchBaselineForPatchGroupResult(
    data,
    context
  );
  const response: RegisterPatchBaselineForPatchGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterPatchBaselineForPatchGroupResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RegisterPatchBaselineForPatchGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterPatchBaselineForPatchGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AlreadyExistsException":
    case "com.amazonaws.services.ssm#AlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1AlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.services.ssm#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RegisterTargetWithMaintenanceWindowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterTargetWithMaintenanceWindowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterTargetWithMaintenanceWindowCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterTargetWithMaintenanceWindowResult(
    data,
    context
  );
  const response: RegisterTargetWithMaintenanceWindowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterTargetWithMaintenanceWindowResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RegisterTargetWithMaintenanceWindowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterTargetWithMaintenanceWindowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotentParameterMismatch":
    case "com.amazonaws.services.ssm#IdempotentParameterMismatch":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.services.ssm#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RegisterTaskWithMaintenanceWindowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterTaskWithMaintenanceWindowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterTaskWithMaintenanceWindowCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterTaskWithMaintenanceWindowResult(
    data,
    context
  );
  const response: RegisterTaskWithMaintenanceWindowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterTaskWithMaintenanceWindowResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RegisterTaskWithMaintenanceWindowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterTaskWithMaintenanceWindowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FeatureNotAvailableException":
    case "com.amazonaws.services.ssm#FeatureNotAvailableException":
      response = {
        ...(await deserializeAws_json1_1FeatureNotAvailableExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotentParameterMismatch":
    case "com.amazonaws.services.ssm#IdempotentParameterMismatch":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.services.ssm#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RemoveTagsFromResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RemoveTagsFromResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RemoveTagsFromResourceResult(data, context);
  const response: RemoveTagsFromResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveTagsFromResourceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RemoveTagsFromResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceId":
    case "com.amazonaws.services.ssm#InvalidResourceId":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceType":
    case "com.amazonaws.services.ssm#InvalidResourceType":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ResetServiceSettingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetServiceSettingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ResetServiceSettingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ResetServiceSettingResult(data, context);
  const response: ResetServiceSettingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResetServiceSettingResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ResetServiceSettingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetServiceSettingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceSettingNotFound":
    case "com.amazonaws.services.ssm#ServiceSettingNotFound":
      response = {
        ...(await deserializeAws_json1_1ServiceSettingNotFoundResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ResumeSessionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResumeSessionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ResumeSessionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ResumeSessionResponse(data, context);
  const response: ResumeSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResumeSessionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ResumeSessionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResumeSessionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SendAutomationSignalCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendAutomationSignalCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SendAutomationSignalCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SendAutomationSignalResult(data, context);
  const response: SendAutomationSignalCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SendAutomationSignalResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SendAutomationSignalCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendAutomationSignalCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AutomationExecutionNotFoundException":
    case "com.amazonaws.services.ssm#AutomationExecutionNotFoundException":
      response = {
        ...(await deserializeAws_json1_1AutomationExecutionNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AutomationStepNotFoundException":
    case "com.amazonaws.services.ssm#AutomationStepNotFoundException":
      response = {
        ...(await deserializeAws_json1_1AutomationStepNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAutomationSignalException":
    case "com.amazonaws.services.ssm#InvalidAutomationSignalException":
      response = {
        ...(await deserializeAws_json1_1InvalidAutomationSignalExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SendCommandCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendCommandCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SendCommandCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SendCommandResult(data, context);
  const response: SendCommandCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SendCommandResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SendCommandCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendCommandCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DuplicateInstanceId":
    case "com.amazonaws.services.ssm#DuplicateInstanceId":
      response = {
        ...(await deserializeAws_json1_1DuplicateInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNotificationConfig":
    case "com.amazonaws.services.ssm#InvalidNotificationConfig":
      response = {
        ...(await deserializeAws_json1_1InvalidNotificationConfigResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOutputFolder":
    case "com.amazonaws.services.ssm#InvalidOutputFolder":
      response = {
        ...(await deserializeAws_json1_1InvalidOutputFolderResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameters":
    case "com.amazonaws.services.ssm#InvalidParameters":
      response = {
        ...(await deserializeAws_json1_1InvalidParametersResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRole":
    case "com.amazonaws.services.ssm#InvalidRole":
      response = {
        ...(await deserializeAws_json1_1InvalidRoleResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaxDocumentSizeExceeded":
    case "com.amazonaws.services.ssm#MaxDocumentSizeExceeded":
      response = {
        ...(await deserializeAws_json1_1MaxDocumentSizeExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedPlatformType":
    case "com.amazonaws.services.ssm#UnsupportedPlatformType":
      response = {
        ...(await deserializeAws_json1_1UnsupportedPlatformTypeResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartAssociationsOnceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartAssociationsOnceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartAssociationsOnceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartAssociationsOnceResult(data, context);
  const response: StartAssociationsOnceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartAssociationsOnceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartAssociationsOnceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartAssociationsOnceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationDoesNotExist":
    case "com.amazonaws.services.ssm#AssociationDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1AssociationDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAssociation":
    case "com.amazonaws.services.ssm#InvalidAssociation":
      response = {
        ...(await deserializeAws_json1_1InvalidAssociationResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartAutomationExecutionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartAutomationExecutionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartAutomationExecutionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartAutomationExecutionResult(
    data,
    context
  );
  const response: StartAutomationExecutionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartAutomationExecutionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartAutomationExecutionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartAutomationExecutionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AutomationDefinitionNotFoundException":
    case "com.amazonaws.services.ssm#AutomationDefinitionNotFoundException":
      response = {
        ...(await deserializeAws_json1_1AutomationDefinitionNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AutomationDefinitionVersionNotFoundException":
    case "com.amazonaws.services.ssm#AutomationDefinitionVersionNotFoundException":
      response = {
        ...(await deserializeAws_json1_1AutomationDefinitionVersionNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AutomationExecutionLimitExceededException":
    case "com.amazonaws.services.ssm#AutomationExecutionLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1AutomationExecutionLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotentParameterMismatch":
    case "com.amazonaws.services.ssm#IdempotentParameterMismatch":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAutomationExecutionParametersException":
    case "com.amazonaws.services.ssm#InvalidAutomationExecutionParametersException":
      response = {
        ...(await deserializeAws_json1_1InvalidAutomationExecutionParametersExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTarget":
    case "com.amazonaws.services.ssm#InvalidTarget":
      response = {
        ...(await deserializeAws_json1_1InvalidTargetResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartSessionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSessionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartSessionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartSessionResponse(data, context);
  const response: StartSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartSessionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartSessionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSessionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TargetNotConnected":
    case "com.amazonaws.services.ssm#TargetNotConnected":
      response = {
        ...(await deserializeAws_json1_1TargetNotConnectedResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopAutomationExecutionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopAutomationExecutionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopAutomationExecutionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopAutomationExecutionResult(data, context);
  const response: StopAutomationExecutionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopAutomationExecutionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopAutomationExecutionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopAutomationExecutionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AutomationExecutionNotFoundException":
    case "com.amazonaws.services.ssm#AutomationExecutionNotFoundException":
      response = {
        ...(await deserializeAws_json1_1AutomationExecutionNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAutomationStatusUpdateException":
    case "com.amazonaws.services.ssm#InvalidAutomationStatusUpdateException":
      response = {
        ...(await deserializeAws_json1_1InvalidAutomationStatusUpdateExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TerminateSessionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TerminateSessionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TerminateSessionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TerminateSessionResponse(data, context);
  const response: TerminateSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TerminateSessionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TerminateSessionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TerminateSessionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateAssociationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAssociationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateAssociationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateAssociationResult(data, context);
  const response: UpdateAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateAssociationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAssociationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationDoesNotExist":
    case "com.amazonaws.services.ssm#AssociationDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1AssociationDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AssociationVersionLimitExceeded":
    case "com.amazonaws.services.ssm#AssociationVersionLimitExceeded":
      response = {
        ...(await deserializeAws_json1_1AssociationVersionLimitExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAssociationVersion":
    case "com.amazonaws.services.ssm#InvalidAssociationVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidAssociationVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidOutputLocation":
    case "com.amazonaws.services.ssm#InvalidOutputLocation":
      response = {
        ...(await deserializeAws_json1_1InvalidOutputLocationResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameters":
    case "com.amazonaws.services.ssm#InvalidParameters":
      response = {
        ...(await deserializeAws_json1_1InvalidParametersResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSchedule":
    case "com.amazonaws.services.ssm#InvalidSchedule":
      response = {
        ...(await deserializeAws_json1_1InvalidScheduleResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTarget":
    case "com.amazonaws.services.ssm#InvalidTarget":
      response = {
        ...(await deserializeAws_json1_1InvalidTargetResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidUpdate":
    case "com.amazonaws.services.ssm#InvalidUpdate":
      response = {
        ...(await deserializeAws_json1_1InvalidUpdateResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateAssociationStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAssociationStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateAssociationStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateAssociationStatusResult(data, context);
  const response: UpdateAssociationStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateAssociationStatusResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateAssociationStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAssociationStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AssociationDoesNotExist":
    case "com.amazonaws.services.ssm#AssociationDoesNotExist":
      response = {
        ...(await deserializeAws_json1_1AssociationDoesNotExistResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StatusUnchanged":
    case "com.amazonaws.services.ssm#StatusUnchanged":
      response = {
        ...(await deserializeAws_json1_1StatusUnchangedResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateDocumentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDocumentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDocumentResult(data, context);
  const response: UpdateDocumentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDocumentResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateDocumentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DocumentVersionLimitExceeded":
    case "com.amazonaws.services.ssm#DocumentVersionLimitExceeded":
      response = {
        ...(await deserializeAws_json1_1DocumentVersionLimitExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateDocumentContent":
    case "com.amazonaws.services.ssm#DuplicateDocumentContent":
      response = {
        ...(await deserializeAws_json1_1DuplicateDocumentContentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateDocumentVersionName":
    case "com.amazonaws.services.ssm#DuplicateDocumentVersionName":
      response = {
        ...(await deserializeAws_json1_1DuplicateDocumentVersionNameResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentContent":
    case "com.amazonaws.services.ssm#InvalidDocumentContent":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentContentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentOperation":
    case "com.amazonaws.services.ssm#InvalidDocumentOperation":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentOperationResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentSchemaVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentSchemaVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentSchemaVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MaxDocumentSizeExceeded":
    case "com.amazonaws.services.ssm#MaxDocumentSizeExceeded":
      response = {
        ...(await deserializeAws_json1_1MaxDocumentSizeExceededResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateDocumentDefaultVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentDefaultVersionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDocumentDefaultVersionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDocumentDefaultVersionResult(
    data,
    context
  );
  const response: UpdateDocumentDefaultVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDocumentDefaultVersionResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateDocumentDefaultVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDocumentDefaultVersionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocument":
    case "com.amazonaws.services.ssm#InvalidDocument":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentSchemaVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentSchemaVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentSchemaVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDocumentVersion":
    case "com.amazonaws.services.ssm#InvalidDocumentVersion":
      response = {
        ...(await deserializeAws_json1_1InvalidDocumentVersionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateMaintenanceWindowCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMaintenanceWindowCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateMaintenanceWindowCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateMaintenanceWindowResult(data, context);
  const response: UpdateMaintenanceWindowCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateMaintenanceWindowResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateMaintenanceWindowCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMaintenanceWindowCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateMaintenanceWindowTargetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMaintenanceWindowTargetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateMaintenanceWindowTargetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateMaintenanceWindowTargetResult(
    data,
    context
  );
  const response: UpdateMaintenanceWindowTargetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateMaintenanceWindowTargetResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateMaintenanceWindowTargetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMaintenanceWindowTargetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateMaintenanceWindowTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMaintenanceWindowTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateMaintenanceWindowTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateMaintenanceWindowTaskResult(
    data,
    context
  );
  const response: UpdateMaintenanceWindowTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateMaintenanceWindowTaskResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateMaintenanceWindowTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMaintenanceWindowTaskCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateManagedInstanceRoleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateManagedInstanceRoleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateManagedInstanceRoleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateManagedInstanceRoleResult(
    data,
    context
  );
  const response: UpdateManagedInstanceRoleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateManagedInstanceRoleResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateManagedInstanceRoleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateManagedInstanceRoleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInstanceId":
    case "com.amazonaws.services.ssm#InvalidInstanceId":
      response = {
        ...(await deserializeAws_json1_1InvalidInstanceIdResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateOpsItemCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateOpsItemCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateOpsItemCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateOpsItemResponse(data, context);
  const response: UpdateOpsItemCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateOpsItemResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateOpsItemCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateOpsItemCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OpsItemAlreadyExistsException":
    case "com.amazonaws.services.ssm#OpsItemAlreadyExistsException":
      response = {
        ...(await deserializeAws_json1_1OpsItemAlreadyExistsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OpsItemInvalidParameterException":
    case "com.amazonaws.services.ssm#OpsItemInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1OpsItemInvalidParameterExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OpsItemLimitExceededException":
    case "com.amazonaws.services.ssm#OpsItemLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1OpsItemLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OpsItemNotFoundException":
    case "com.amazonaws.services.ssm#OpsItemNotFoundException":
      response = {
        ...(await deserializeAws_json1_1OpsItemNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdatePatchBaselineCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePatchBaselineCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdatePatchBaselineCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdatePatchBaselineResult(data, context);
  const response: UpdatePatchBaselineCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePatchBaselineResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdatePatchBaselineCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePatchBaselineCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DoesNotExistException":
    case "com.amazonaws.services.ssm#DoesNotExistException":
      response = {
        ...(await deserializeAws_json1_1DoesNotExistExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateResourceDataSyncCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateResourceDataSyncCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateResourceDataSyncCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateResourceDataSyncResult(data, context);
  const response: UpdateResourceDataSyncCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateResourceDataSyncResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateResourceDataSyncCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateResourceDataSyncCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncConflictException":
    case "com.amazonaws.services.ssm#ResourceDataSyncConflictException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncInvalidConfigurationException":
    case "com.amazonaws.services.ssm#ResourceDataSyncInvalidConfigurationException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncInvalidConfigurationExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceDataSyncNotFoundException":
    case "com.amazonaws.services.ssm#ResourceDataSyncNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceDataSyncNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateServiceSettingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateServiceSettingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateServiceSettingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateServiceSettingResult(data, context);
  const response: UpdateServiceSettingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateServiceSettingResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateServiceSettingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateServiceSettingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.services.ssm#InternalServerError":
      response = {
        ...(await deserializeAws_json1_1InternalServerErrorResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceSettingNotFound":
    case "com.amazonaws.services.ssm#ServiceSettingNotFound":
      response = {
        ...(await deserializeAws_json1_1ServiceSettingNotFoundResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyUpdates":
    case "com.amazonaws.services.ssm#TooManyUpdates":
      response = {
        ...(await deserializeAws_json1_1TooManyUpdatesResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1AlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AlreadyExistsException(
    body,
    context
  );
  const contents: AlreadyExistsException = {
    name: "AlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AssociatedInstancesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AssociatedInstances> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AssociatedInstances(
    body,
    context
  );
  const contents: AssociatedInstances = {
    name: "AssociatedInstances",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AssociationAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AssociationAlreadyExists> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AssociationAlreadyExists(
    body,
    context
  );
  const contents: AssociationAlreadyExists = {
    name: "AssociationAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AssociationDoesNotExistResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AssociationDoesNotExist> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AssociationDoesNotExist(
    body,
    context
  );
  const contents: AssociationDoesNotExist = {
    name: "AssociationDoesNotExist",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AssociationExecutionDoesNotExistResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AssociationExecutionDoesNotExist> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AssociationExecutionDoesNotExist(
    body,
    context
  );
  const contents: AssociationExecutionDoesNotExist = {
    name: "AssociationExecutionDoesNotExist",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AssociationLimitExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AssociationLimitExceeded> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AssociationLimitExceeded(
    body,
    context
  );
  const contents: AssociationLimitExceeded = {
    name: "AssociationLimitExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AssociationVersionLimitExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AssociationVersionLimitExceeded> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AssociationVersionLimitExceeded(
    body,
    context
  );
  const contents: AssociationVersionLimitExceeded = {
    name: "AssociationVersionLimitExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AutomationDefinitionNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AutomationDefinitionNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AutomationDefinitionNotFoundException(
    body,
    context
  );
  const contents: AutomationDefinitionNotFoundException = {
    name: "AutomationDefinitionNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AutomationDefinitionVersionNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AutomationDefinitionVersionNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AutomationDefinitionVersionNotFoundException(
    body,
    context
  );
  const contents: AutomationDefinitionVersionNotFoundException = {
    name: "AutomationDefinitionVersionNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AutomationExecutionLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AutomationExecutionLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AutomationExecutionLimitExceededException(
    body,
    context
  );
  const contents: AutomationExecutionLimitExceededException = {
    name: "AutomationExecutionLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AutomationExecutionNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AutomationExecutionNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AutomationExecutionNotFoundException(
    body,
    context
  );
  const contents: AutomationExecutionNotFoundException = {
    name: "AutomationExecutionNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1AutomationStepNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AutomationStepNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AutomationStepNotFoundException(
    body,
    context
  );
  const contents: AutomationStepNotFoundException = {
    name: "AutomationStepNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ComplianceTypeCountLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ComplianceTypeCountLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ComplianceTypeCountLimitExceededException(
    body,
    context
  );
  const contents: ComplianceTypeCountLimitExceededException = {
    name: "ComplianceTypeCountLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1CustomSchemaCountLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CustomSchemaCountLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1CustomSchemaCountLimitExceededException(
    body,
    context
  );
  const contents: CustomSchemaCountLimitExceededException = {
    name: "CustomSchemaCountLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DocumentAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DocumentAlreadyExists> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DocumentAlreadyExists(
    body,
    context
  );
  const contents: DocumentAlreadyExists = {
    name: "DocumentAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DocumentLimitExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DocumentLimitExceeded> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DocumentLimitExceeded(
    body,
    context
  );
  const contents: DocumentLimitExceeded = {
    name: "DocumentLimitExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DocumentPermissionLimitResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DocumentPermissionLimit> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DocumentPermissionLimit(
    body,
    context
  );
  const contents: DocumentPermissionLimit = {
    name: "DocumentPermissionLimit",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DocumentVersionLimitExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DocumentVersionLimitExceeded> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DocumentVersionLimitExceeded(
    body,
    context
  );
  const contents: DocumentVersionLimitExceeded = {
    name: "DocumentVersionLimitExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DoesNotExistExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DoesNotExistException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DoesNotExistException(
    body,
    context
  );
  const contents: DoesNotExistException = {
    name: "DoesNotExistException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DuplicateDocumentContentResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DuplicateDocumentContent> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DuplicateDocumentContent(
    body,
    context
  );
  const contents: DuplicateDocumentContent = {
    name: "DuplicateDocumentContent",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DuplicateDocumentVersionNameResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DuplicateDocumentVersionName> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DuplicateDocumentVersionName(
    body,
    context
  );
  const contents: DuplicateDocumentVersionName = {
    name: "DuplicateDocumentVersionName",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DuplicateInstanceIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DuplicateInstanceId> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DuplicateInstanceId(
    body,
    context
  );
  const contents: DuplicateInstanceId = {
    name: "DuplicateInstanceId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FeatureNotAvailableExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FeatureNotAvailableException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FeatureNotAvailableException(
    body,
    context
  );
  const contents: FeatureNotAvailableException = {
    name: "FeatureNotAvailableException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1HierarchyLevelLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HierarchyLevelLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1HierarchyLevelLimitExceededException(
    body,
    context
  );
  const contents: HierarchyLevelLimitExceededException = {
    name: "HierarchyLevelLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1HierarchyTypeMismatchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HierarchyTypeMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1HierarchyTypeMismatchException(
    body,
    context
  );
  const contents: HierarchyTypeMismatchException = {
    name: "HierarchyTypeMismatchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1IdempotentParameterMismatchResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IdempotentParameterMismatch> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1IdempotentParameterMismatch(
    body,
    context
  );
  const contents: IdempotentParameterMismatch = {
    name: "IdempotentParameterMismatch",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1IncompatiblePolicyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IncompatiblePolicyException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1IncompatiblePolicyException(
    body,
    context
  );
  const contents: IncompatiblePolicyException = {
    name: "IncompatiblePolicyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InternalServerErrorResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalServerError> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InternalServerError(
    body,
    context
  );
  const contents: InternalServerError = {
    name: "InternalServerError",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidActivationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidActivation> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidActivation(
    body,
    context
  );
  const contents: InvalidActivation = {
    name: "InvalidActivation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidActivationIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidActivationId> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidActivationId(
    body,
    context
  );
  const contents: InvalidActivationId = {
    name: "InvalidActivationId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidAggregatorExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidAggregatorException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidAggregatorException(
    body,
    context
  );
  const contents: InvalidAggregatorException = {
    name: "InvalidAggregatorException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidAllowedPatternExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidAllowedPatternException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidAllowedPatternException(
    body,
    context
  );
  const contents: InvalidAllowedPatternException = {
    name: "InvalidAllowedPatternException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidAssociationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidAssociation> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidAssociation(
    body,
    context
  );
  const contents: InvalidAssociation = {
    name: "InvalidAssociation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidAssociationVersionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidAssociationVersion> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidAssociationVersion(
    body,
    context
  );
  const contents: InvalidAssociationVersion = {
    name: "InvalidAssociationVersion",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidAutomationExecutionParametersExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidAutomationExecutionParametersException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidAutomationExecutionParametersException(
    body,
    context
  );
  const contents: InvalidAutomationExecutionParametersException = {
    name: "InvalidAutomationExecutionParametersException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidAutomationSignalExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidAutomationSignalException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidAutomationSignalException(
    body,
    context
  );
  const contents: InvalidAutomationSignalException = {
    name: "InvalidAutomationSignalException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidAutomationStatusUpdateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidAutomationStatusUpdateException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidAutomationStatusUpdateException(
    body,
    context
  );
  const contents: InvalidAutomationStatusUpdateException = {
    name: "InvalidAutomationStatusUpdateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidCommandIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidCommandId> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidCommandId(
    body,
    context
  );
  const contents: InvalidCommandId = {
    name: "InvalidCommandId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDeleteInventoryParametersExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDeleteInventoryParametersException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDeleteInventoryParametersException(
    body,
    context
  );
  const contents: InvalidDeleteInventoryParametersException = {
    name: "InvalidDeleteInventoryParametersException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDeletionIdExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDeletionIdException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDeletionIdException(
    body,
    context
  );
  const contents: InvalidDeletionIdException = {
    name: "InvalidDeletionIdException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDocumentResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDocument> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDocument(
    body,
    context
  );
  const contents: InvalidDocument = {
    name: "InvalidDocument",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDocumentContentResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDocumentContent> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDocumentContent(
    body,
    context
  );
  const contents: InvalidDocumentContent = {
    name: "InvalidDocumentContent",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDocumentOperationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDocumentOperation> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDocumentOperation(
    body,
    context
  );
  const contents: InvalidDocumentOperation = {
    name: "InvalidDocumentOperation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDocumentSchemaVersionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDocumentSchemaVersion> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDocumentSchemaVersion(
    body,
    context
  );
  const contents: InvalidDocumentSchemaVersion = {
    name: "InvalidDocumentSchemaVersion",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDocumentTypeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDocumentType> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDocumentType(
    body,
    context
  );
  const contents: InvalidDocumentType = {
    name: "InvalidDocumentType",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidDocumentVersionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDocumentVersion> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidDocumentVersion(
    body,
    context
  );
  const contents: InvalidDocumentVersion = {
    name: "InvalidDocumentVersion",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFilterResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidFilter> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidFilter(body, context);
  const contents: InvalidFilter = {
    name: "InvalidFilter",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFilterKeyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidFilterKey> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidFilterKey(
    body,
    context
  );
  const contents: InvalidFilterKey = {
    name: "InvalidFilterKey",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFilterOptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidFilterOption> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidFilterOption(
    body,
    context
  );
  const contents: InvalidFilterOption = {
    name: "InvalidFilterOption",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFilterValueResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidFilterValue> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidFilterValue(
    body,
    context
  );
  const contents: InvalidFilterValue = {
    name: "InvalidFilterValue",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidInstanceIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInstanceId> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidInstanceId(
    body,
    context
  );
  const contents: InvalidInstanceId = {
    name: "InvalidInstanceId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidInstanceInformationFilterValueResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInstanceInformationFilterValue> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidInstanceInformationFilterValue(
    body,
    context
  );
  const contents: InvalidInstanceInformationFilterValue = {
    name: "InvalidInstanceInformationFilterValue",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidInventoryGroupExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInventoryGroupException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidInventoryGroupException(
    body,
    context
  );
  const contents: InvalidInventoryGroupException = {
    name: "InvalidInventoryGroupException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidInventoryItemContextExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInventoryItemContextException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidInventoryItemContextException(
    body,
    context
  );
  const contents: InvalidInventoryItemContextException = {
    name: "InvalidInventoryItemContextException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidInventoryRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInventoryRequestException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidInventoryRequestException(
    body,
    context
  );
  const contents: InvalidInventoryRequestException = {
    name: "InvalidInventoryRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidItemContentExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidItemContentException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidItemContentException(
    body,
    context
  );
  const contents: InvalidItemContentException = {
    name: "InvalidItemContentException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidKeyIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidKeyId> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidKeyId(body, context);
  const contents: InvalidKeyId = {
    name: "InvalidKeyId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidNextTokenResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidNextToken> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidNextToken(
    body,
    context
  );
  const contents: InvalidNextToken = {
    name: "InvalidNextToken",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidNotificationConfigResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidNotificationConfig> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidNotificationConfig(
    body,
    context
  );
  const contents: InvalidNotificationConfig = {
    name: "InvalidNotificationConfig",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidOptionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOptionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidOptionException(
    body,
    context
  );
  const contents: InvalidOptionException = {
    name: "InvalidOptionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidOutputFolderResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOutputFolder> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidOutputFolder(
    body,
    context
  );
  const contents: InvalidOutputFolder = {
    name: "InvalidOutputFolder",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidOutputLocationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOutputLocation> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidOutputLocation(
    body,
    context
  );
  const contents: InvalidOutputLocation = {
    name: "InvalidOutputLocation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidParametersResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidParameters> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidParameters(
    body,
    context
  );
  const contents: InvalidParameters = {
    name: "InvalidParameters",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPermissionTypeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPermissionType> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPermissionType(
    body,
    context
  );
  const contents: InvalidPermissionType = {
    name: "InvalidPermissionType",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPluginNameResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPluginName> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPluginName(
    body,
    context
  );
  const contents: InvalidPluginName = {
    name: "InvalidPluginName",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPolicyAttributeExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPolicyAttributeException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPolicyAttributeException(
    body,
    context
  );
  const contents: InvalidPolicyAttributeException = {
    name: "InvalidPolicyAttributeException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidPolicyTypeExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPolicyTypeException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidPolicyTypeException(
    body,
    context
  );
  const contents: InvalidPolicyTypeException = {
    name: "InvalidPolicyTypeException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidResourceIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidResourceId> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidResourceId(
    body,
    context
  );
  const contents: InvalidResourceId = {
    name: "InvalidResourceId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidResourceTypeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidResourceType> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidResourceType(
    body,
    context
  );
  const contents: InvalidResourceType = {
    name: "InvalidResourceType",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidResultAttributeExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidResultAttributeException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidResultAttributeException(
    body,
    context
  );
  const contents: InvalidResultAttributeException = {
    name: "InvalidResultAttributeException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRoleResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRole> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRole(body, context);
  const contents: InvalidRole = {
    name: "InvalidRole",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidScheduleResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSchedule> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidSchedule(
    body,
    context
  );
  const contents: InvalidSchedule = {
    name: "InvalidSchedule",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidTargetResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTarget> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidTarget(body, context);
  const contents: InvalidTarget = {
    name: "InvalidTarget",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidTypeNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTypeNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidTypeNameException(
    body,
    context
  );
  const contents: InvalidTypeNameException = {
    name: "InvalidTypeNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidUpdateResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidUpdate> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidUpdate(body, context);
  const contents: InvalidUpdate = {
    name: "InvalidUpdate",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvocationDoesNotExistResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvocationDoesNotExist> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvocationDoesNotExist(
    body,
    context
  );
  const contents: InvocationDoesNotExist = {
    name: "InvocationDoesNotExist",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ItemContentMismatchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ItemContentMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ItemContentMismatchException(
    body,
    context
  );
  const contents: ItemContentMismatchException = {
    name: "ItemContentMismatchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ItemSizeLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ItemSizeLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ItemSizeLimitExceededException(
    body,
    context
  );
  const contents: ItemSizeLimitExceededException = {
    name: "ItemSizeLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1MaxDocumentSizeExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MaxDocumentSizeExceeded> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1MaxDocumentSizeExceeded(
    body,
    context
  );
  const contents: MaxDocumentSizeExceeded = {
    name: "MaxDocumentSizeExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1OpsItemAlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OpsItemAlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1OpsItemAlreadyExistsException(
    body,
    context
  );
  const contents: OpsItemAlreadyExistsException = {
    name: "OpsItemAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1OpsItemInvalidParameterExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OpsItemInvalidParameterException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1OpsItemInvalidParameterException(
    body,
    context
  );
  const contents: OpsItemInvalidParameterException = {
    name: "OpsItemInvalidParameterException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1OpsItemLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OpsItemLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1OpsItemLimitExceededException(
    body,
    context
  );
  const contents: OpsItemLimitExceededException = {
    name: "OpsItemLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1OpsItemNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OpsItemNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1OpsItemNotFoundException(
    body,
    context
  );
  const contents: OpsItemNotFoundException = {
    name: "OpsItemNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParameterAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParameterAlreadyExists> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParameterAlreadyExists(
    body,
    context
  );
  const contents: ParameterAlreadyExists = {
    name: "ParameterAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParameterLimitExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParameterLimitExceeded> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParameterLimitExceeded(
    body,
    context
  );
  const contents: ParameterLimitExceeded = {
    name: "ParameterLimitExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParameterMaxVersionLimitExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParameterMaxVersionLimitExceeded> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParameterMaxVersionLimitExceeded(
    body,
    context
  );
  const contents: ParameterMaxVersionLimitExceeded = {
    name: "ParameterMaxVersionLimitExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParameterNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParameterNotFound> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParameterNotFound(
    body,
    context
  );
  const contents: ParameterNotFound = {
    name: "ParameterNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParameterPatternMismatchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParameterPatternMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParameterPatternMismatchException(
    body,
    context
  );
  const contents: ParameterPatternMismatchException = {
    name: "ParameterPatternMismatchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParameterVersionLabelLimitExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParameterVersionLabelLimitExceeded> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParameterVersionLabelLimitExceeded(
    body,
    context
  );
  const contents: ParameterVersionLabelLimitExceeded = {
    name: "ParameterVersionLabelLimitExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ParameterVersionNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ParameterVersionNotFound> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ParameterVersionNotFound(
    body,
    context
  );
  const contents: ParameterVersionNotFound = {
    name: "ParameterVersionNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1PoliciesLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PoliciesLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1PoliciesLimitExceededException(
    body,
    context
  );
  const contents: PoliciesLimitExceededException = {
    name: "PoliciesLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncAlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceDataSyncAlreadyExistsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceDataSyncAlreadyExistsException(
    body,
    context
  );
  const contents: ResourceDataSyncAlreadyExistsException = {
    name: "ResourceDataSyncAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceDataSyncConflictException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceDataSyncConflictException(
    body,
    context
  );
  const contents: ResourceDataSyncConflictException = {
    name: "ResourceDataSyncConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncCountExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceDataSyncCountExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceDataSyncCountExceededException(
    body,
    context
  );
  const contents: ResourceDataSyncCountExceededException = {
    name: "ResourceDataSyncCountExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncInvalidConfigurationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceDataSyncInvalidConfigurationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceDataSyncInvalidConfigurationException(
    body,
    context
  );
  const contents: ResourceDataSyncInvalidConfigurationException = {
    name: "ResourceDataSyncInvalidConfigurationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceDataSyncNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceDataSyncNotFoundException(
    body,
    context
  );
  const contents: ResourceDataSyncNotFoundException = {
    name: "ResourceDataSyncNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceInUseExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceInUseException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceInUseException(
    body,
    context
  );
  const contents: ResourceInUseException = {
    name: "ResourceInUseException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceLimitExceededException(
    body,
    context
  );
  const contents: ResourceLimitExceededException = {
    name: "ResourceLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ServiceSettingNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ServiceSettingNotFound> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ServiceSettingNotFound(
    body,
    context
  );
  const contents: ServiceSettingNotFound = {
    name: "ServiceSettingNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1StatusUnchangedResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<StatusUnchanged> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1StatusUnchanged(
    body,
    context
  );
  const contents: StatusUnchanged = {
    name: "StatusUnchanged",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SubTypeCountLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubTypeCountLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SubTypeCountLimitExceededException(
    body,
    context
  );
  const contents: SubTypeCountLimitExceededException = {
    name: "SubTypeCountLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TargetInUseExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TargetInUseException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TargetInUseException(
    body,
    context
  );
  const contents: TargetInUseException = {
    name: "TargetInUseException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TargetNotConnectedResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TargetNotConnected> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TargetNotConnected(
    body,
    context
  );
  const contents: TargetNotConnected = {
    name: "TargetNotConnected",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyTagsErrorResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTagsError> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TooManyTagsError(
    body,
    context
  );
  const contents: TooManyTagsError = {
    name: "TooManyTagsError",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyUpdatesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyUpdates> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TooManyUpdates(body, context);
  const contents: TooManyUpdates = {
    name: "TooManyUpdates",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TotalSizeLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TotalSizeLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TotalSizeLimitExceededException(
    body,
    context
  );
  const contents: TotalSizeLimitExceededException = {
    name: "TotalSizeLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedCalendarExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedCalendarException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedCalendarException(
    body,
    context
  );
  const contents: UnsupportedCalendarException = {
    name: "UnsupportedCalendarException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedFeatureRequiredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedFeatureRequiredException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedFeatureRequiredException(
    body,
    context
  );
  const contents: UnsupportedFeatureRequiredException = {
    name: "UnsupportedFeatureRequiredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedInventoryItemContextExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedInventoryItemContextException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedInventoryItemContextException(
    body,
    context
  );
  const contents: UnsupportedInventoryItemContextException = {
    name: "UnsupportedInventoryItemContextException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedInventorySchemaVersionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedInventorySchemaVersionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedInventorySchemaVersionException(
    body,
    context
  );
  const contents: UnsupportedInventorySchemaVersionException = {
    name: "UnsupportedInventorySchemaVersionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedOperatingSystemResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedOperatingSystem> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedOperatingSystem(
    body,
    context
  );
  const contents: UnsupportedOperatingSystem = {
    name: "UnsupportedOperatingSystem",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedParameterTypeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedParameterType> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedParameterType(
    body,
    context
  );
  const contents: UnsupportedParameterType = {
    name: "UnsupportedParameterType",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedPlatformTypeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedPlatformType> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedPlatformType(
    body,
    context
  );
  const contents: UnsupportedPlatformType = {
    name: "UnsupportedPlatformType",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AccountIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Accounts = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1AddTagsToResourceRequest = (
  input: AddTagsToResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceId !== undefined) {
    bodyParams["ResourceId"] = input.ResourceId;
  }
  if (input.ResourceType !== undefined) {
    bodyParams["ResourceType"] = input.ResourceType;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1AssociationExecutionFilter = (
  input: AssociationExecutionFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociationExecutionFilterList = (
  input: Array<AssociationExecutionFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_json1_1AssociationExecutionFilter(entry, context)
    );
  }
  return contents;
};

const serializeAws_json1_1AssociationExecutionTargetsFilter = (
  input: AssociationExecutionTargetsFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociationExecutionTargetsFilterList = (
  input: Array<AssociationExecutionTargetsFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_json1_1AssociationExecutionTargetsFilter(entry, context)
    );
  }
  return contents;
};

const serializeAws_json1_1AssociationFilter = (
  input: AssociationFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.key !== undefined) {
    bodyParams["key"] = input.key;
  }
  if (input.value !== undefined) {
    bodyParams["value"] = input.value;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociationFilterList = (
  input: Array<AssociationFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1AssociationFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1AssociationIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1AssociationStatus = (
  input: AssociationStatus,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AdditionalInfo !== undefined) {
    bodyParams["AdditionalInfo"] = input.AdditionalInfo;
  }
  if (input.Date !== undefined) {
    bodyParams["Date"] = Math.round(input.Date.getTime() / 1000);
  }
  if (input.Message !== undefined) {
    bodyParams["Message"] = input.Message;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1AttachmentsSource = (
  input: AttachmentsSource,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1AttachmentsSourceValues(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1AttachmentsSourceList = (
  input: Array<AttachmentsSource>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1AttachmentsSource(entry, context));
  }
  return contents;
};

const serializeAws_json1_1AttachmentsSourceValues = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1AutomationExecutionFilter = (
  input: AutomationExecutionFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams[
      "Values"
    ] = serializeAws_json1_1AutomationExecutionFilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1AutomationExecutionFilterList = (
  input: Array<AutomationExecutionFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_json1_1AutomationExecutionFilter(entry, context)
    );
  }
  return contents;
};

const serializeAws_json1_1AutomationExecutionFilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1AutomationParameterMap = (
  input: { [key: string]: Array<string> },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_json1_1AutomationParameterValueList(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_json1_1AutomationParameterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1CalendarNameOrARNList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1CancelCommandRequest = (
  input: CancelCommandRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CommandId !== undefined) {
    bodyParams["CommandId"] = input.CommandId;
  }
  if (input.InstanceIds !== undefined) {
    bodyParams["InstanceIds"] = serializeAws_json1_1InstanceIdList(
      input.InstanceIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CancelMaintenanceWindowExecutionRequest = (
  input: CancelMaintenanceWindowExecutionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.WindowExecutionId !== undefined) {
    bodyParams["WindowExecutionId"] = input.WindowExecutionId;
  }
  return bodyParams;
};

const serializeAws_json1_1CloudWatchOutputConfig = (
  input: CloudWatchOutputConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CloudWatchLogGroupName !== undefined) {
    bodyParams["CloudWatchLogGroupName"] = input.CloudWatchLogGroupName;
  }
  if (input.CloudWatchOutputEnabled !== undefined) {
    bodyParams["CloudWatchOutputEnabled"] = input.CloudWatchOutputEnabled;
  }
  return bodyParams;
};

const serializeAws_json1_1CommandFilter = (
  input: CommandFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.key !== undefined) {
    bodyParams["key"] = input.key;
  }
  if (input.value !== undefined) {
    bodyParams["value"] = input.value;
  }
  return bodyParams;
};

const serializeAws_json1_1CommandFilterList = (
  input: Array<CommandFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1CommandFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ComplianceExecutionSummary = (
  input: ComplianceExecutionSummary,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ExecutionId !== undefined) {
    bodyParams["ExecutionId"] = input.ExecutionId;
  }
  if (input.ExecutionTime !== undefined) {
    bodyParams["ExecutionTime"] = Math.round(
      input.ExecutionTime.getTime() / 1000
    );
  }
  if (input.ExecutionType !== undefined) {
    bodyParams["ExecutionType"] = input.ExecutionType;
  }
  return bodyParams;
};

const serializeAws_json1_1ComplianceItemDetails = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1ComplianceItemEntry = (
  input: ComplianceItemEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Details !== undefined) {
    bodyParams["Details"] = serializeAws_json1_1ComplianceItemDetails(
      input.Details,
      context
    );
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Severity !== undefined) {
    bodyParams["Severity"] = input.Severity;
  }
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  return bodyParams;
};

const serializeAws_json1_1ComplianceItemEntryList = (
  input: Array<ComplianceItemEntry>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1ComplianceItemEntry(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ComplianceResourceIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ComplianceResourceTypeList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ComplianceStringFilter = (
  input: ComplianceStringFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1ComplianceStringFilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ComplianceStringFilterList = (
  input: Array<ComplianceStringFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1ComplianceStringFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ComplianceStringFilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1CreateActivationRequest = (
  input: CreateActivationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DefaultInstanceName !== undefined) {
    bodyParams["DefaultInstanceName"] = input.DefaultInstanceName;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.ExpirationDate !== undefined) {
    bodyParams["ExpirationDate"] = Math.round(
      input.ExpirationDate.getTime() / 1000
    );
  }
  if (input.IamRole !== undefined) {
    bodyParams["IamRole"] = input.IamRole;
  }
  if (input.RegistrationLimit !== undefined) {
    bodyParams["RegistrationLimit"] = input.RegistrationLimit;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateAssociationBatchRequest = (
  input: CreateAssociationBatchRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Entries !== undefined) {
    bodyParams[
      "Entries"
    ] = serializeAws_json1_1CreateAssociationBatchRequestEntries(
      input.Entries,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateAssociationBatchRequestEntries = (
  input: Array<CreateAssociationBatchRequestEntry>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_json1_1CreateAssociationBatchRequestEntry(entry, context)
    );
  }
  return contents;
};

const serializeAws_json1_1CreateAssociationBatchRequestEntry = (
  input: CreateAssociationBatchRequestEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationName !== undefined) {
    bodyParams["AssociationName"] = input.AssociationName;
  }
  if (input.AutomationTargetParameterName !== undefined) {
    bodyParams["AutomationTargetParameterName"] =
      input.AutomationTargetParameterName;
  }
  if (input.ComplianceSeverity !== undefined) {
    bodyParams["ComplianceSeverity"] = input.ComplianceSeverity;
  }
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.MaxConcurrency !== undefined) {
    bodyParams["MaxConcurrency"] = input.MaxConcurrency;
  }
  if (input.MaxErrors !== undefined) {
    bodyParams["MaxErrors"] = input.MaxErrors;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.OutputLocation !== undefined) {
    bodyParams[
      "OutputLocation"
    ] = serializeAws_json1_1InstanceAssociationOutputLocation(
      input.OutputLocation,
      context
    );
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1Parameters(
      input.Parameters,
      context
    );
  }
  if (input.ScheduleExpression !== undefined) {
    bodyParams["ScheduleExpression"] = input.ScheduleExpression;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateAssociationRequest = (
  input: CreateAssociationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationName !== undefined) {
    bodyParams["AssociationName"] = input.AssociationName;
  }
  if (input.AutomationTargetParameterName !== undefined) {
    bodyParams["AutomationTargetParameterName"] =
      input.AutomationTargetParameterName;
  }
  if (input.ComplianceSeverity !== undefined) {
    bodyParams["ComplianceSeverity"] = input.ComplianceSeverity;
  }
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.MaxConcurrency !== undefined) {
    bodyParams["MaxConcurrency"] = input.MaxConcurrency;
  }
  if (input.MaxErrors !== undefined) {
    bodyParams["MaxErrors"] = input.MaxErrors;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.OutputLocation !== undefined) {
    bodyParams[
      "OutputLocation"
    ] = serializeAws_json1_1InstanceAssociationOutputLocation(
      input.OutputLocation,
      context
    );
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1Parameters(
      input.Parameters,
      context
    );
  }
  if (input.ScheduleExpression !== undefined) {
    bodyParams["ScheduleExpression"] = input.ScheduleExpression;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDocumentRequest = (
  input: CreateDocumentRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Attachments !== undefined) {
    bodyParams["Attachments"] = serializeAws_json1_1AttachmentsSourceList(
      input.Attachments,
      context
    );
  }
  if (input.Content !== undefined) {
    bodyParams["Content"] = input.Content;
  }
  if (input.DocumentFormat !== undefined) {
    bodyParams["DocumentFormat"] = input.DocumentFormat;
  }
  if (input.DocumentType !== undefined) {
    bodyParams["DocumentType"] = input.DocumentType;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Requires !== undefined) {
    bodyParams["Requires"] = serializeAws_json1_1DocumentRequiresList(
      input.Requires,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TargetType !== undefined) {
    bodyParams["TargetType"] = input.TargetType;
  }
  if (input.VersionName !== undefined) {
    bodyParams["VersionName"] = input.VersionName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateMaintenanceWindowRequest = (
  input: CreateMaintenanceWindowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllowUnassociatedTargets !== undefined) {
    bodyParams["AllowUnassociatedTargets"] = input.AllowUnassociatedTargets;
  }
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    bodyParams["ClientToken"] = input.ClientToken;
  }
  if (input.Cutoff !== undefined) {
    bodyParams["Cutoff"] = input.Cutoff;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Duration !== undefined) {
    bodyParams["Duration"] = input.Duration;
  }
  if (input.EndDate !== undefined) {
    bodyParams["EndDate"] = input.EndDate;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = input.Schedule;
  }
  if (input.ScheduleTimezone !== undefined) {
    bodyParams["ScheduleTimezone"] = input.ScheduleTimezone;
  }
  if (input.StartDate !== undefined) {
    bodyParams["StartDate"] = input.StartDate;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateOpsItemRequest = (
  input: CreateOpsItemRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Category !== undefined) {
    bodyParams["Category"] = input.Category;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Notifications !== undefined) {
    bodyParams["Notifications"] = serializeAws_json1_1OpsItemNotifications(
      input.Notifications,
      context
    );
  }
  if (input.OperationalData !== undefined) {
    bodyParams["OperationalData"] = serializeAws_json1_1OpsItemOperationalData(
      input.OperationalData,
      context
    );
  }
  if (input.Priority !== undefined) {
    bodyParams["Priority"] = input.Priority;
  }
  if (input.RelatedOpsItems !== undefined) {
    bodyParams["RelatedOpsItems"] = serializeAws_json1_1RelatedOpsItems(
      input.RelatedOpsItems,
      context
    );
  }
  if (input.Severity !== undefined) {
    bodyParams["Severity"] = input.Severity;
  }
  if (input.Source !== undefined) {
    bodyParams["Source"] = input.Source;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePatchBaselineRequest = (
  input: CreatePatchBaselineRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ApprovalRules !== undefined) {
    bodyParams["ApprovalRules"] = serializeAws_json1_1PatchRuleGroup(
      input.ApprovalRules,
      context
    );
  }
  if (input.ApprovedPatches !== undefined) {
    bodyParams["ApprovedPatches"] = serializeAws_json1_1PatchIdList(
      input.ApprovedPatches,
      context
    );
  }
  if (input.ApprovedPatchesComplianceLevel !== undefined) {
    bodyParams["ApprovedPatchesComplianceLevel"] =
      input.ApprovedPatchesComplianceLevel;
  }
  if (input.ApprovedPatchesEnableNonSecurity !== undefined) {
    bodyParams["ApprovedPatchesEnableNonSecurity"] =
      input.ApprovedPatchesEnableNonSecurity;
  }
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    bodyParams["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.GlobalFilters !== undefined) {
    bodyParams["GlobalFilters"] = serializeAws_json1_1PatchFilterGroup(
      input.GlobalFilters,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.OperatingSystem !== undefined) {
    bodyParams["OperatingSystem"] = input.OperatingSystem;
  }
  if (input.RejectedPatches !== undefined) {
    bodyParams["RejectedPatches"] = serializeAws_json1_1PatchIdList(
      input.RejectedPatches,
      context
    );
  }
  if (input.RejectedPatchesAction !== undefined) {
    bodyParams["RejectedPatchesAction"] = input.RejectedPatchesAction;
  }
  if (input.Sources !== undefined) {
    bodyParams["Sources"] = serializeAws_json1_1PatchSourceList(
      input.Sources,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateResourceDataSyncRequest = (
  input: CreateResourceDataSyncRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.S3Destination !== undefined) {
    bodyParams[
      "S3Destination"
    ] = serializeAws_json1_1ResourceDataSyncS3Destination(
      input.S3Destination,
      context
    );
  }
  if (input.SyncName !== undefined) {
    bodyParams["SyncName"] = input.SyncName;
  }
  if (input.SyncSource !== undefined) {
    bodyParams["SyncSource"] = serializeAws_json1_1ResourceDataSyncSource(
      input.SyncSource,
      context
    );
  }
  if (input.SyncType !== undefined) {
    bodyParams["SyncType"] = input.SyncType;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteActivationRequest = (
  input: DeleteActivationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ActivationId !== undefined) {
    bodyParams["ActivationId"] = input.ActivationId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteAssociationRequest = (
  input: DeleteAssociationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationId !== undefined) {
    bodyParams["AssociationId"] = input.AssociationId;
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDocumentRequest = (
  input: DeleteDocumentRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.Force !== undefined) {
    bodyParams["Force"] = input.Force;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.VersionName !== undefined) {
    bodyParams["VersionName"] = input.VersionName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteInventoryRequest = (
  input: DeleteInventoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    bodyParams["ClientToken"] = input.ClientToken;
  }
  if (input.DryRun !== undefined) {
    bodyParams["DryRun"] = input.DryRun;
  }
  if (input.SchemaDeleteOption !== undefined) {
    bodyParams["SchemaDeleteOption"] = input.SchemaDeleteOption;
  }
  if (input.TypeName !== undefined) {
    bodyParams["TypeName"] = input.TypeName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteMaintenanceWindowRequest = (
  input: DeleteMaintenanceWindowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteParameterRequest = (
  input: DeleteParameterRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteParametersRequest = (
  input: DeleteParametersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Names !== undefined) {
    bodyParams["Names"] = serializeAws_json1_1ParameterNameList(
      input.Names,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DeletePatchBaselineRequest = (
  input: DeletePatchBaselineRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BaselineId !== undefined) {
    bodyParams["BaselineId"] = input.BaselineId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteResourceDataSyncRequest = (
  input: DeleteResourceDataSyncRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SyncName !== undefined) {
    bodyParams["SyncName"] = input.SyncName;
  }
  if (input.SyncType !== undefined) {
    bodyParams["SyncType"] = input.SyncType;
  }
  return bodyParams;
};

const serializeAws_json1_1DeregisterManagedInstanceRequest = (
  input: DeregisterManagedInstanceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeregisterPatchBaselineForPatchGroupRequest = (
  input: DeregisterPatchBaselineForPatchGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BaselineId !== undefined) {
    bodyParams["BaselineId"] = input.BaselineId;
  }
  if (input.PatchGroup !== undefined) {
    bodyParams["PatchGroup"] = input.PatchGroup;
  }
  return bodyParams;
};

const serializeAws_json1_1DeregisterTargetFromMaintenanceWindowRequest = (
  input: DeregisterTargetFromMaintenanceWindowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Safe !== undefined) {
    bodyParams["Safe"] = input.Safe;
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  if (input.WindowTargetId !== undefined) {
    bodyParams["WindowTargetId"] = input.WindowTargetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeregisterTaskFromMaintenanceWindowRequest = (
  input: DeregisterTaskFromMaintenanceWindowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  if (input.WindowTaskId !== undefined) {
    bodyParams["WindowTaskId"] = input.WindowTaskId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeActivationsFilter = (
  input: DescribeActivationsFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FilterKey !== undefined) {
    bodyParams["FilterKey"] = input.FilterKey;
  }
  if (input.FilterValues !== undefined) {
    bodyParams["FilterValues"] = serializeAws_json1_1StringList(
      input.FilterValues,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeActivationsFilterList = (
  input: Array<DescribeActivationsFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_json1_1DescribeActivationsFilter(entry, context)
    );
  }
  return contents;
};

const serializeAws_json1_1DescribeActivationsRequest = (
  input: DescribeActivationsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1DescribeActivationsFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAssociationExecutionTargetsRequest = (
  input: DescribeAssociationExecutionTargetsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationId !== undefined) {
    bodyParams["AssociationId"] = input.AssociationId;
  }
  if (input.ExecutionId !== undefined) {
    bodyParams["ExecutionId"] = input.ExecutionId;
  }
  if (input.Filters !== undefined) {
    bodyParams[
      "Filters"
    ] = serializeAws_json1_1AssociationExecutionTargetsFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAssociationExecutionsRequest = (
  input: DescribeAssociationExecutionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationId !== undefined) {
    bodyParams["AssociationId"] = input.AssociationId;
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1AssociationExecutionFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAssociationRequest = (
  input: DescribeAssociationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationId !== undefined) {
    bodyParams["AssociationId"] = input.AssociationId;
  }
  if (input.AssociationVersion !== undefined) {
    bodyParams["AssociationVersion"] = input.AssociationVersion;
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAutomationExecutionsRequest = (
  input: DescribeAutomationExecutionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1AutomationExecutionFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAutomationStepExecutionsRequest = (
  input: DescribeAutomationStepExecutionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AutomationExecutionId !== undefined) {
    bodyParams["AutomationExecutionId"] = input.AutomationExecutionId;
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1StepExecutionFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ReverseOrder !== undefined) {
    bodyParams["ReverseOrder"] = input.ReverseOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAvailablePatchesRequest = (
  input: DescribeAvailablePatchesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1PatchOrchestratorFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDocumentPermissionRequest = (
  input: DescribeDocumentPermissionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.PermissionType !== undefined) {
    bodyParams["PermissionType"] = input.PermissionType;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDocumentRequest = (
  input: DescribeDocumentRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.VersionName !== undefined) {
    bodyParams["VersionName"] = input.VersionName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEffectiveInstanceAssociationsRequest = (
  input: DescribeEffectiveInstanceAssociationsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEffectivePatchesForPatchBaselineRequest = (
  input: DescribeEffectivePatchesForPatchBaselineRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BaselineId !== undefined) {
    bodyParams["BaselineId"] = input.BaselineId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeInstanceAssociationsStatusRequest = (
  input: DescribeInstanceAssociationsStatusRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeInstanceInformationRequest = (
  input: DescribeInstanceInformationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams[
      "Filters"
    ] = serializeAws_json1_1InstanceInformationStringFilterList(
      input.Filters,
      context
    );
  }
  if (input.InstanceInformationFilterList !== undefined) {
    bodyParams[
      "InstanceInformationFilterList"
    ] = serializeAws_json1_1InstanceInformationFilterList(
      input.InstanceInformationFilterList,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeInstancePatchStatesForPatchGroupRequest = (
  input: DescribeInstancePatchStatesForPatchGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1InstancePatchStateFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.PatchGroup !== undefined) {
    bodyParams["PatchGroup"] = input.PatchGroup;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeInstancePatchStatesRequest = (
  input: DescribeInstancePatchStatesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InstanceIds !== undefined) {
    bodyParams["InstanceIds"] = serializeAws_json1_1InstanceIdList(
      input.InstanceIds,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeInstancePatchesRequest = (
  input: DescribeInstancePatchesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1PatchOrchestratorFilterList(
      input.Filters,
      context
    );
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeInventoryDeletionsRequest = (
  input: DescribeInventoryDeletionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DeletionId !== undefined) {
    bodyParams["DeletionId"] = input.DeletionId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMaintenanceWindowExecutionTaskInvocationsRequest = (
  input: DescribeMaintenanceWindowExecutionTaskInvocationsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1MaintenanceWindowFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.TaskId !== undefined) {
    bodyParams["TaskId"] = input.TaskId;
  }
  if (input.WindowExecutionId !== undefined) {
    bodyParams["WindowExecutionId"] = input.WindowExecutionId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMaintenanceWindowExecutionTasksRequest = (
  input: DescribeMaintenanceWindowExecutionTasksRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1MaintenanceWindowFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.WindowExecutionId !== undefined) {
    bodyParams["WindowExecutionId"] = input.WindowExecutionId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMaintenanceWindowExecutionsRequest = (
  input: DescribeMaintenanceWindowExecutionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1MaintenanceWindowFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMaintenanceWindowScheduleRequest = (
  input: DescribeMaintenanceWindowScheduleRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1PatchOrchestratorFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ResourceType !== undefined) {
    bodyParams["ResourceType"] = input.ResourceType;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMaintenanceWindowTargetsRequest = (
  input: DescribeMaintenanceWindowTargetsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1MaintenanceWindowFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMaintenanceWindowTasksRequest = (
  input: DescribeMaintenanceWindowTasksRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1MaintenanceWindowFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMaintenanceWindowsForTargetRequest = (
  input: DescribeMaintenanceWindowsForTargetRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ResourceType !== undefined) {
    bodyParams["ResourceType"] = input.ResourceType;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMaintenanceWindowsRequest = (
  input: DescribeMaintenanceWindowsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1MaintenanceWindowFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeOpsItemsRequest = (
  input: DescribeOpsItemsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.OpsItemFilters !== undefined) {
    bodyParams["OpsItemFilters"] = serializeAws_json1_1OpsItemFilters(
      input.OpsItemFilters,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeParametersRequest = (
  input: DescribeParametersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1ParametersFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ParameterFilters !== undefined) {
    bodyParams[
      "ParameterFilters"
    ] = serializeAws_json1_1ParameterStringFilterList(
      input.ParameterFilters,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DescribePatchBaselinesRequest = (
  input: DescribePatchBaselinesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1PatchOrchestratorFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribePatchGroupStateRequest = (
  input: DescribePatchGroupStateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.PatchGroup !== undefined) {
    bodyParams["PatchGroup"] = input.PatchGroup;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribePatchGroupsRequest = (
  input: DescribePatchGroupsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1PatchOrchestratorFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribePatchPropertiesRequest = (
  input: DescribePatchPropertiesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.OperatingSystem !== undefined) {
    bodyParams["OperatingSystem"] = input.OperatingSystem;
  }
  if (input.PatchSet !== undefined) {
    bodyParams["PatchSet"] = input.PatchSet;
  }
  if (input.Property !== undefined) {
    bodyParams["Property"] = input.Property;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeSessionsRequest = (
  input: DescribeSessionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1SessionFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.State !== undefined) {
    bodyParams["State"] = input.State;
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentFilter = (
  input: DocumentFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.key !== undefined) {
    bodyParams["key"] = input.key;
  }
  if (input.value !== undefined) {
    bodyParams["value"] = input.value;
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentFilterList = (
  input: Array<DocumentFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1DocumentFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1DocumentKeyValuesFilter = (
  input: DocumentKeyValuesFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1DocumentKeyValuesFilterValues(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentKeyValuesFilterList = (
  input: Array<DocumentKeyValuesFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1DocumentKeyValuesFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1DocumentKeyValuesFilterValues = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1DocumentRequires = (
  input: DocumentRequires,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Version !== undefined) {
    bodyParams["Version"] = input.Version;
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentRequiresList = (
  input: Array<DocumentRequires>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1DocumentRequires(entry, context));
  }
  return contents;
};

const serializeAws_json1_1GetAutomationExecutionRequest = (
  input: GetAutomationExecutionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AutomationExecutionId !== undefined) {
    bodyParams["AutomationExecutionId"] = input.AutomationExecutionId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetCalendarStateRequest = (
  input: GetCalendarStateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AtTime !== undefined) {
    bodyParams["AtTime"] = input.AtTime;
  }
  if (input.CalendarNames !== undefined) {
    bodyParams["CalendarNames"] = serializeAws_json1_1CalendarNameOrARNList(
      input.CalendarNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1GetCommandInvocationRequest = (
  input: GetCommandInvocationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CommandId !== undefined) {
    bodyParams["CommandId"] = input.CommandId;
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.PluginName !== undefined) {
    bodyParams["PluginName"] = input.PluginName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetConnectionStatusRequest = (
  input: GetConnectionStatusRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Target !== undefined) {
    bodyParams["Target"] = input.Target;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDefaultPatchBaselineRequest = (
  input: GetDefaultPatchBaselineRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.OperatingSystem !== undefined) {
    bodyParams["OperatingSystem"] = input.OperatingSystem;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDeployablePatchSnapshotForInstanceRequest = (
  input: GetDeployablePatchSnapshotForInstanceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.SnapshotId !== undefined) {
    bodyParams["SnapshotId"] = input.SnapshotId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetDocumentRequest = (
  input: GetDocumentRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentFormat !== undefined) {
    bodyParams["DocumentFormat"] = input.DocumentFormat;
  }
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.VersionName !== undefined) {
    bodyParams["VersionName"] = input.VersionName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetInventoryRequest = (
  input: GetInventoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Aggregators !== undefined) {
    bodyParams["Aggregators"] = serializeAws_json1_1InventoryAggregatorList(
      input.Aggregators,
      context
    );
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1InventoryFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ResultAttributes !== undefined) {
    bodyParams["ResultAttributes"] = serializeAws_json1_1ResultAttributeList(
      input.ResultAttributes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1GetInventorySchemaRequest = (
  input: GetInventorySchemaRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Aggregator !== undefined) {
    bodyParams["Aggregator"] = input.Aggregator;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SubType !== undefined) {
    bodyParams["SubType"] = input.SubType;
  }
  if (input.TypeName !== undefined) {
    bodyParams["TypeName"] = input.TypeName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMaintenanceWindowExecutionRequest = (
  input: GetMaintenanceWindowExecutionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.WindowExecutionId !== undefined) {
    bodyParams["WindowExecutionId"] = input.WindowExecutionId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMaintenanceWindowExecutionTaskInvocationRequest = (
  input: GetMaintenanceWindowExecutionTaskInvocationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InvocationId !== undefined) {
    bodyParams["InvocationId"] = input.InvocationId;
  }
  if (input.TaskId !== undefined) {
    bodyParams["TaskId"] = input.TaskId;
  }
  if (input.WindowExecutionId !== undefined) {
    bodyParams["WindowExecutionId"] = input.WindowExecutionId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMaintenanceWindowExecutionTaskRequest = (
  input: GetMaintenanceWindowExecutionTaskRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TaskId !== undefined) {
    bodyParams["TaskId"] = input.TaskId;
  }
  if (input.WindowExecutionId !== undefined) {
    bodyParams["WindowExecutionId"] = input.WindowExecutionId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMaintenanceWindowRequest = (
  input: GetMaintenanceWindowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetMaintenanceWindowTaskRequest = (
  input: GetMaintenanceWindowTaskRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  if (input.WindowTaskId !== undefined) {
    bodyParams["WindowTaskId"] = input.WindowTaskId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetOpsItemRequest = (
  input: GetOpsItemRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.OpsItemId !== undefined) {
    bodyParams["OpsItemId"] = input.OpsItemId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetOpsSummaryRequest = (
  input: GetOpsSummaryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Aggregators !== undefined) {
    bodyParams["Aggregators"] = serializeAws_json1_1OpsAggregatorList(
      input.Aggregators,
      context
    );
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1OpsFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ResultAttributes !== undefined) {
    bodyParams["ResultAttributes"] = serializeAws_json1_1OpsResultAttributeList(
      input.ResultAttributes,
      context
    );
  }
  if (input.SyncName !== undefined) {
    bodyParams["SyncName"] = input.SyncName;
  }
  return bodyParams;
};

const serializeAws_json1_1GetParameterHistoryRequest = (
  input: GetParameterHistoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.WithDecryption !== undefined) {
    bodyParams["WithDecryption"] = input.WithDecryption;
  }
  return bodyParams;
};

const serializeAws_json1_1GetParameterRequest = (
  input: GetParameterRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.WithDecryption !== undefined) {
    bodyParams["WithDecryption"] = input.WithDecryption;
  }
  return bodyParams;
};

const serializeAws_json1_1GetParametersByPathRequest = (
  input: GetParametersByPathRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ParameterFilters !== undefined) {
    bodyParams[
      "ParameterFilters"
    ] = serializeAws_json1_1ParameterStringFilterList(
      input.ParameterFilters,
      context
    );
  }
  if (input.Path !== undefined) {
    bodyParams["Path"] = input.Path;
  }
  if (input.Recursive !== undefined) {
    bodyParams["Recursive"] = input.Recursive;
  }
  if (input.WithDecryption !== undefined) {
    bodyParams["WithDecryption"] = input.WithDecryption;
  }
  return bodyParams;
};

const serializeAws_json1_1GetParametersRequest = (
  input: GetParametersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Names !== undefined) {
    bodyParams["Names"] = serializeAws_json1_1ParameterNameList(
      input.Names,
      context
    );
  }
  if (input.WithDecryption !== undefined) {
    bodyParams["WithDecryption"] = input.WithDecryption;
  }
  return bodyParams;
};

const serializeAws_json1_1GetPatchBaselineForPatchGroupRequest = (
  input: GetPatchBaselineForPatchGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.OperatingSystem !== undefined) {
    bodyParams["OperatingSystem"] = input.OperatingSystem;
  }
  if (input.PatchGroup !== undefined) {
    bodyParams["PatchGroup"] = input.PatchGroup;
  }
  return bodyParams;
};

const serializeAws_json1_1GetPatchBaselineRequest = (
  input: GetPatchBaselineRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BaselineId !== undefined) {
    bodyParams["BaselineId"] = input.BaselineId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetServiceSettingRequest = (
  input: GetServiceSettingRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SettingId !== undefined) {
    bodyParams["SettingId"] = input.SettingId;
  }
  return bodyParams;
};

const serializeAws_json1_1InstanceAssociationOutputLocation = (
  input: InstanceAssociationOutputLocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.S3Location !== undefined) {
    bodyParams["S3Location"] = serializeAws_json1_1S3OutputLocation(
      input.S3Location,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1InstanceIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1InstanceInformationFilter = (
  input: InstanceInformationFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.key !== undefined) {
    bodyParams["key"] = input.key;
  }
  if (input.valueSet !== undefined) {
    bodyParams[
      "valueSet"
    ] = serializeAws_json1_1InstanceInformationFilterValueSet(
      input.valueSet,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1InstanceInformationFilterList = (
  input: Array<InstanceInformationFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_json1_1InstanceInformationFilter(entry, context)
    );
  }
  return contents;
};

const serializeAws_json1_1InstanceInformationFilterValueSet = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1InstanceInformationStringFilter = (
  input: InstanceInformationStringFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams[
      "Values"
    ] = serializeAws_json1_1InstanceInformationFilterValueSet(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1InstanceInformationStringFilterList = (
  input: Array<InstanceInformationStringFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_json1_1InstanceInformationStringFilter(entry, context)
    );
  }
  return contents;
};

const serializeAws_json1_1InstancePatchStateFilter = (
  input: InstancePatchStateFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1InstancePatchStateFilterValues(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1InstancePatchStateFilterList = (
  input: Array<InstancePatchStateFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1InstancePatchStateFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1InstancePatchStateFilterValues = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1InventoryAggregator = (
  input: InventoryAggregator,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Aggregators !== undefined) {
    bodyParams["Aggregators"] = serializeAws_json1_1InventoryAggregatorList(
      input.Aggregators,
      context
    );
  }
  if (input.Expression !== undefined) {
    bodyParams["Expression"] = input.Expression;
  }
  if (input.Groups !== undefined) {
    bodyParams["Groups"] = serializeAws_json1_1InventoryGroupList(
      input.Groups,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1InventoryAggregatorList = (
  input: Array<InventoryAggregator>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1InventoryAggregator(entry, context));
  }
  return contents;
};

const serializeAws_json1_1InventoryFilter = (
  input: InventoryFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1InventoryFilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1InventoryFilterList = (
  input: Array<InventoryFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1InventoryFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1InventoryFilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1InventoryGroup = (
  input: InventoryGroup,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1InventoryFilterList(
      input.Filters,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1InventoryGroupList = (
  input: Array<InventoryGroup>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1InventoryGroup(entry, context));
  }
  return contents;
};

const serializeAws_json1_1InventoryItem = (
  input: InventoryItem,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CaptureTime !== undefined) {
    bodyParams["CaptureTime"] = input.CaptureTime;
  }
  if (input.Content !== undefined) {
    bodyParams["Content"] = serializeAws_json1_1InventoryItemEntryList(
      input.Content,
      context
    );
  }
  if (input.ContentHash !== undefined) {
    bodyParams["ContentHash"] = input.ContentHash;
  }
  if (input.Context !== undefined) {
    bodyParams["Context"] = serializeAws_json1_1InventoryItemContentContext(
      input.Context,
      context
    );
  }
  if (input.SchemaVersion !== undefined) {
    bodyParams["SchemaVersion"] = input.SchemaVersion;
  }
  if (input.TypeName !== undefined) {
    bodyParams["TypeName"] = input.TypeName;
  }
  return bodyParams;
};

const serializeAws_json1_1InventoryItemContentContext = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1InventoryItemEntry = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1InventoryItemEntryList = (
  input: Array<{ [key: string]: string }>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1InventoryItemEntry(entry, context));
  }
  return contents;
};

const serializeAws_json1_1InventoryItemList = (
  input: Array<InventoryItem>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1InventoryItem(entry, context));
  }
  return contents;
};

const serializeAws_json1_1KeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1LabelParameterVersionRequest = (
  input: LabelParameterVersionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Labels !== undefined) {
    bodyParams["Labels"] = serializeAws_json1_1ParameterLabelList(
      input.Labels,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.ParameterVersion !== undefined) {
    bodyParams["ParameterVersion"] = input.ParameterVersion;
  }
  return bodyParams;
};

const serializeAws_json1_1ListAssociationVersionsRequest = (
  input: ListAssociationVersionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationId !== undefined) {
    bodyParams["AssociationId"] = input.AssociationId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListAssociationsRequest = (
  input: ListAssociationsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationFilterList !== undefined) {
    bodyParams[
      "AssociationFilterList"
    ] = serializeAws_json1_1AssociationFilterList(
      input.AssociationFilterList,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListCommandInvocationsRequest = (
  input: ListCommandInvocationsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CommandId !== undefined) {
    bodyParams["CommandId"] = input.CommandId;
  }
  if (input.Details !== undefined) {
    bodyParams["Details"] = input.Details;
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1CommandFilterList(
      input.Filters,
      context
    );
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListCommandsRequest = (
  input: ListCommandsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CommandId !== undefined) {
    bodyParams["CommandId"] = input.CommandId;
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1CommandFilterList(
      input.Filters,
      context
    );
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListComplianceItemsRequest = (
  input: ListComplianceItemsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1ComplianceStringFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ResourceIds !== undefined) {
    bodyParams["ResourceIds"] = serializeAws_json1_1ComplianceResourceIdList(
      input.ResourceIds,
      context
    );
  }
  if (input.ResourceTypes !== undefined) {
    bodyParams[
      "ResourceTypes"
    ] = serializeAws_json1_1ComplianceResourceTypeList(
      input.ResourceTypes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ListComplianceSummariesRequest = (
  input: ListComplianceSummariesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1ComplianceStringFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListDocumentVersionsRequest = (
  input: ListDocumentVersionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListDocumentsRequest = (
  input: ListDocumentsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentFilterList !== undefined) {
    bodyParams["DocumentFilterList"] = serializeAws_json1_1DocumentFilterList(
      input.DocumentFilterList,
      context
    );
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1DocumentKeyValuesFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListInventoryEntriesRequest = (
  input: ListInventoryEntriesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1InventoryFilterList(
      input.Filters,
      context
    );
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.TypeName !== undefined) {
    bodyParams["TypeName"] = input.TypeName;
  }
  return bodyParams;
};

const serializeAws_json1_1ListResourceComplianceSummariesRequest = (
  input: ListResourceComplianceSummariesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1ComplianceStringFilterList(
      input.Filters,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListResourceDataSyncRequest = (
  input: ListResourceDataSyncRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SyncType !== undefined) {
    bodyParams["SyncType"] = input.SyncType;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsForResourceRequest = (
  input: ListTagsForResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceId !== undefined) {
    bodyParams["ResourceId"] = input.ResourceId;
  }
  if (input.ResourceType !== undefined) {
    bodyParams["ResourceType"] = input.ResourceType;
  }
  return bodyParams;
};

const serializeAws_json1_1LoggingInfo = (
  input: LoggingInfo,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.S3BucketName !== undefined) {
    bodyParams["S3BucketName"] = input.S3BucketName;
  }
  if (input.S3KeyPrefix !== undefined) {
    bodyParams["S3KeyPrefix"] = input.S3KeyPrefix;
  }
  if (input.S3Region !== undefined) {
    bodyParams["S3Region"] = input.S3Region;
  }
  return bodyParams;
};

const serializeAws_json1_1MaintenanceWindowAutomationParameters = (
  input: MaintenanceWindowAutomationParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1AutomationParameterMap(
      input.Parameters,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MaintenanceWindowFilter = (
  input: MaintenanceWindowFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1MaintenanceWindowFilterValues(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MaintenanceWindowFilterList = (
  input: Array<MaintenanceWindowFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1MaintenanceWindowFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1MaintenanceWindowFilterValues = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1MaintenanceWindowLambdaParameters = (
  input: MaintenanceWindowLambdaParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientContext !== undefined) {
    bodyParams["ClientContext"] = input.ClientContext;
  }
  if (input.Payload !== undefined) {
    bodyParams["Payload"] = context.base64Encoder(input.Payload);
  }
  if (input.Qualifier !== undefined) {
    bodyParams["Qualifier"] = input.Qualifier;
  }
  return bodyParams;
};

const serializeAws_json1_1MaintenanceWindowRunCommandParameters = (
  input: MaintenanceWindowRunCommandParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CloudWatchOutputConfig !== undefined) {
    bodyParams[
      "CloudWatchOutputConfig"
    ] = serializeAws_json1_1CloudWatchOutputConfig(
      input.CloudWatchOutputConfig,
      context
    );
  }
  if (input.Comment !== undefined) {
    bodyParams["Comment"] = input.Comment;
  }
  if (input.DocumentHash !== undefined) {
    bodyParams["DocumentHash"] = input.DocumentHash;
  }
  if (input.DocumentHashType !== undefined) {
    bodyParams["DocumentHashType"] = input.DocumentHashType;
  }
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.NotificationConfig !== undefined) {
    bodyParams["NotificationConfig"] = serializeAws_json1_1NotificationConfig(
      input.NotificationConfig,
      context
    );
  }
  if (input.OutputS3BucketName !== undefined) {
    bodyParams["OutputS3BucketName"] = input.OutputS3BucketName;
  }
  if (input.OutputS3KeyPrefix !== undefined) {
    bodyParams["OutputS3KeyPrefix"] = input.OutputS3KeyPrefix;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1Parameters(
      input.Parameters,
      context
    );
  }
  if (input.ServiceRoleArn !== undefined) {
    bodyParams["ServiceRoleArn"] = input.ServiceRoleArn;
  }
  if (input.TimeoutSeconds !== undefined) {
    bodyParams["TimeoutSeconds"] = input.TimeoutSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1MaintenanceWindowStepFunctionsParameters = (
  input: MaintenanceWindowStepFunctionsParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Input !== undefined) {
    bodyParams["Input"] = input.Input;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1MaintenanceWindowTaskInvocationParameters = (
  input: MaintenanceWindowTaskInvocationParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Automation !== undefined) {
    bodyParams[
      "Automation"
    ] = serializeAws_json1_1MaintenanceWindowAutomationParameters(
      input.Automation,
      context
    );
  }
  if (input.Lambda !== undefined) {
    bodyParams[
      "Lambda"
    ] = serializeAws_json1_1MaintenanceWindowLambdaParameters(
      input.Lambda,
      context
    );
  }
  if (input.RunCommand !== undefined) {
    bodyParams[
      "RunCommand"
    ] = serializeAws_json1_1MaintenanceWindowRunCommandParameters(
      input.RunCommand,
      context
    );
  }
  if (input.StepFunctions !== undefined) {
    bodyParams[
      "StepFunctions"
    ] = serializeAws_json1_1MaintenanceWindowStepFunctionsParameters(
      input.StepFunctions,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MaintenanceWindowTaskParameterValueExpression = (
  input: MaintenanceWindowTaskParameterValueExpression,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Values !== undefined) {
    bodyParams[
      "Values"
    ] = serializeAws_json1_1MaintenanceWindowTaskParameterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MaintenanceWindowTaskParameterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1MaintenanceWindowTaskParameters = (
  input: { [key: string]: MaintenanceWindowTaskParameterValueExpression },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[
      key
    ] = serializeAws_json1_1MaintenanceWindowTaskParameterValueExpression(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_json1_1ModifyDocumentPermissionRequest = (
  input: ModifyDocumentPermissionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AccountIdsToAdd !== undefined) {
    bodyParams["AccountIdsToAdd"] = serializeAws_json1_1AccountIdList(
      input.AccountIdsToAdd,
      context
    );
  }
  if (input.AccountIdsToRemove !== undefined) {
    bodyParams["AccountIdsToRemove"] = serializeAws_json1_1AccountIdList(
      input.AccountIdsToRemove,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.PermissionType !== undefined) {
    bodyParams["PermissionType"] = input.PermissionType;
  }
  if (input.SharedDocumentVersion !== undefined) {
    bodyParams["SharedDocumentVersion"] = input.SharedDocumentVersion;
  }
  return bodyParams;
};

const serializeAws_json1_1NotificationConfig = (
  input: NotificationConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.NotificationArn !== undefined) {
    bodyParams["NotificationArn"] = input.NotificationArn;
  }
  if (input.NotificationEvents !== undefined) {
    bodyParams[
      "NotificationEvents"
    ] = serializeAws_json1_1NotificationEventList(
      input.NotificationEvents,
      context
    );
  }
  if (input.NotificationType !== undefined) {
    bodyParams["NotificationType"] = input.NotificationType;
  }
  return bodyParams;
};

const serializeAws_json1_1NotificationEventList = (
  input: Array<NotificationEvent | string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1OpsAggregator = (
  input: OpsAggregator,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AggregatorType !== undefined) {
    bodyParams["AggregatorType"] = input.AggregatorType;
  }
  if (input.Aggregators !== undefined) {
    bodyParams["Aggregators"] = serializeAws_json1_1OpsAggregatorList(
      input.Aggregators,
      context
    );
  }
  if (input.AttributeName !== undefined) {
    bodyParams["AttributeName"] = input.AttributeName;
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1OpsFilterList(
      input.Filters,
      context
    );
  }
  if (input.TypeName !== undefined) {
    bodyParams["TypeName"] = input.TypeName;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1OpsAggregatorValueMap(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1OpsAggregatorList = (
  input: Array<OpsAggregator>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1OpsAggregator(entry, context));
  }
  return contents;
};

const serializeAws_json1_1OpsAggregatorValueMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1OpsFilter = (
  input: OpsFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1OpsFilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1OpsFilterList = (
  input: Array<OpsFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1OpsFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1OpsFilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1OpsItemDataValue = (
  input: OpsItemDataValue,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1OpsItemFilter = (
  input: OpsItemFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Operator !== undefined) {
    bodyParams["Operator"] = input.Operator;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1OpsItemFilterValues(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1OpsItemFilterValues = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1OpsItemFilters = (
  input: Array<OpsItemFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1OpsItemFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1OpsItemNotification = (
  input: OpsItemNotification,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arn !== undefined) {
    bodyParams["Arn"] = input.Arn;
  }
  return bodyParams;
};

const serializeAws_json1_1OpsItemNotifications = (
  input: Array<OpsItemNotification>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1OpsItemNotification(entry, context));
  }
  return contents;
};

const serializeAws_json1_1OpsItemOperationalData = (
  input: { [key: string]: OpsItemDataValue },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_json1_1OpsItemDataValue(input[key], context);
  });
  return mapParams;
};

const serializeAws_json1_1OpsItemOpsDataKeysList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1OpsResultAttribute = (
  input: OpsResultAttribute,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TypeName !== undefined) {
    bodyParams["TypeName"] = input.TypeName;
  }
  return bodyParams;
};

const serializeAws_json1_1OpsResultAttributeList = (
  input: Array<OpsResultAttribute>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1OpsResultAttribute(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ParameterLabelList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ParameterNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ParameterStringFilter = (
  input: ParameterStringFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Option !== undefined) {
    bodyParams["Option"] = input.Option;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1ParameterStringFilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ParameterStringFilterList = (
  input: Array<ParameterStringFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1ParameterStringFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ParameterStringFilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ParameterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Parameters = (
  input: { [key: string]: Array<string> },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_json1_1ParameterValueList(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_json1_1ParametersFilter = (
  input: ParametersFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1ParametersFilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ParametersFilterList = (
  input: Array<ParametersFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1ParametersFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ParametersFilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1PatchFilter = (
  input: PatchFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1PatchFilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PatchFilterGroup = (
  input: PatchFilterGroup,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.PatchFilters !== undefined) {
    bodyParams["PatchFilters"] = serializeAws_json1_1PatchFilterList(
      input.PatchFilters,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PatchFilterList = (
  input: Array<PatchFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PatchFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PatchFilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1PatchIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1PatchOrchestratorFilter = (
  input: PatchOrchestratorFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1PatchOrchestratorFilterValues(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PatchOrchestratorFilterList = (
  input: Array<PatchOrchestratorFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PatchOrchestratorFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PatchOrchestratorFilterValues = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1PatchRule = (
  input: PatchRule,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ApproveAfterDays !== undefined) {
    bodyParams["ApproveAfterDays"] = input.ApproveAfterDays;
  }
  if (input.ComplianceLevel !== undefined) {
    bodyParams["ComplianceLevel"] = input.ComplianceLevel;
  }
  if (input.EnableNonSecurity !== undefined) {
    bodyParams["EnableNonSecurity"] = input.EnableNonSecurity;
  }
  if (input.PatchFilterGroup !== undefined) {
    bodyParams["PatchFilterGroup"] = serializeAws_json1_1PatchFilterGroup(
      input.PatchFilterGroup,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PatchRuleGroup = (
  input: PatchRuleGroup,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.PatchRules !== undefined) {
    bodyParams["PatchRules"] = serializeAws_json1_1PatchRuleList(
      input.PatchRules,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PatchRuleList = (
  input: Array<PatchRule>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PatchRule(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PatchSource = (
  input: PatchSource,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Configuration !== undefined) {
    bodyParams["Configuration"] = input.Configuration;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Products !== undefined) {
    bodyParams["Products"] = serializeAws_json1_1PatchSourceProductList(
      input.Products,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PatchSourceList = (
  input: Array<PatchSource>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PatchSource(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PatchSourceProductList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1PutComplianceItemsRequest = (
  input: PutComplianceItemsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ComplianceType !== undefined) {
    bodyParams["ComplianceType"] = input.ComplianceType;
  }
  if (input.ExecutionSummary !== undefined) {
    bodyParams[
      "ExecutionSummary"
    ] = serializeAws_json1_1ComplianceExecutionSummary(
      input.ExecutionSummary,
      context
    );
  }
  if (input.ItemContentHash !== undefined) {
    bodyParams["ItemContentHash"] = input.ItemContentHash;
  }
  if (input.Items !== undefined) {
    bodyParams["Items"] = serializeAws_json1_1ComplianceItemEntryList(
      input.Items,
      context
    );
  }
  if (input.ResourceId !== undefined) {
    bodyParams["ResourceId"] = input.ResourceId;
  }
  if (input.ResourceType !== undefined) {
    bodyParams["ResourceType"] = input.ResourceType;
  }
  return bodyParams;
};

const serializeAws_json1_1PutInventoryRequest = (
  input: PutInventoryRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.Items !== undefined) {
    bodyParams["Items"] = serializeAws_json1_1InventoryItemList(
      input.Items,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PutParameterRequest = (
  input: PutParameterRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllowedPattern !== undefined) {
    bodyParams["AllowedPattern"] = input.AllowedPattern;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.KeyId !== undefined) {
    bodyParams["KeyId"] = input.KeyId;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Overwrite !== undefined) {
    bodyParams["Overwrite"] = input.Overwrite;
  }
  if (input.Policies !== undefined) {
    bodyParams["Policies"] = input.Policies;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.Tier !== undefined) {
    bodyParams["Tier"] = input.Tier;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1Regions = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1RegisterDefaultPatchBaselineRequest = (
  input: RegisterDefaultPatchBaselineRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BaselineId !== undefined) {
    bodyParams["BaselineId"] = input.BaselineId;
  }
  return bodyParams;
};

const serializeAws_json1_1RegisterPatchBaselineForPatchGroupRequest = (
  input: RegisterPatchBaselineForPatchGroupRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BaselineId !== undefined) {
    bodyParams["BaselineId"] = input.BaselineId;
  }
  if (input.PatchGroup !== undefined) {
    bodyParams["PatchGroup"] = input.PatchGroup;
  }
  return bodyParams;
};

const serializeAws_json1_1RegisterTargetWithMaintenanceWindowRequest = (
  input: RegisterTargetWithMaintenanceWindowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    bodyParams["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.OwnerInformation !== undefined) {
    bodyParams["OwnerInformation"] = input.OwnerInformation;
  }
  if (input.ResourceType !== undefined) {
    bodyParams["ResourceType"] = input.ResourceType;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  return bodyParams;
};

const serializeAws_json1_1RegisterTaskWithMaintenanceWindowRequest = (
  input: RegisterTaskWithMaintenanceWindowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientToken === undefined) {
    input.ClientToken = generateIdempotencyToken();
  }
  if (input.ClientToken !== undefined) {
    bodyParams["ClientToken"] = input.ClientToken;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.LoggingInfo !== undefined) {
    bodyParams["LoggingInfo"] = serializeAws_json1_1LoggingInfo(
      input.LoggingInfo,
      context
    );
  }
  if (input.MaxConcurrency !== undefined) {
    bodyParams["MaxConcurrency"] = input.MaxConcurrency;
  }
  if (input.MaxErrors !== undefined) {
    bodyParams["MaxErrors"] = input.MaxErrors;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Priority !== undefined) {
    bodyParams["Priority"] = input.Priority;
  }
  if (input.ServiceRoleArn !== undefined) {
    bodyParams["ServiceRoleArn"] = input.ServiceRoleArn;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  if (input.TaskArn !== undefined) {
    bodyParams["TaskArn"] = input.TaskArn;
  }
  if (input.TaskInvocationParameters !== undefined) {
    bodyParams[
      "TaskInvocationParameters"
    ] = serializeAws_json1_1MaintenanceWindowTaskInvocationParameters(
      input.TaskInvocationParameters,
      context
    );
  }
  if (input.TaskParameters !== undefined) {
    bodyParams[
      "TaskParameters"
    ] = serializeAws_json1_1MaintenanceWindowTaskParameters(
      input.TaskParameters,
      context
    );
  }
  if (input.TaskType !== undefined) {
    bodyParams["TaskType"] = input.TaskType;
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  return bodyParams;
};

const serializeAws_json1_1RelatedOpsItem = (
  input: RelatedOpsItem,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.OpsItemId !== undefined) {
    bodyParams["OpsItemId"] = input.OpsItemId;
  }
  return bodyParams;
};

const serializeAws_json1_1RelatedOpsItems = (
  input: Array<RelatedOpsItem>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1RelatedOpsItem(entry, context));
  }
  return contents;
};

const serializeAws_json1_1RemoveTagsFromResourceRequest = (
  input: RemoveTagsFromResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceId !== undefined) {
    bodyParams["ResourceId"] = input.ResourceId;
  }
  if (input.ResourceType !== undefined) {
    bodyParams["ResourceType"] = input.ResourceType;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1KeyList(input.TagKeys, context);
  }
  return bodyParams;
};

const serializeAws_json1_1ResetServiceSettingRequest = (
  input: ResetServiceSettingRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SettingId !== undefined) {
    bodyParams["SettingId"] = input.SettingId;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceDataSyncAwsOrganizationsSource = (
  input: ResourceDataSyncAwsOrganizationsSource,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.OrganizationSourceType !== undefined) {
    bodyParams["OrganizationSourceType"] = input.OrganizationSourceType;
  }
  if (input.OrganizationalUnits !== undefined) {
    bodyParams[
      "OrganizationalUnits"
    ] = serializeAws_json1_1ResourceDataSyncOrganizationalUnitList(
      input.OrganizationalUnits,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceDataSyncOrganizationalUnit = (
  input: ResourceDataSyncOrganizationalUnit,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.OrganizationalUnitId !== undefined) {
    bodyParams["OrganizationalUnitId"] = input.OrganizationalUnitId;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceDataSyncOrganizationalUnitList = (
  input: Array<ResourceDataSyncOrganizationalUnit>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_json1_1ResourceDataSyncOrganizationalUnit(entry, context)
    );
  }
  return contents;
};

const serializeAws_json1_1ResourceDataSyncS3Destination = (
  input: ResourceDataSyncS3Destination,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AWSKMSKeyARN !== undefined) {
    bodyParams["AWSKMSKeyARN"] = input.AWSKMSKeyARN;
  }
  if (input.BucketName !== undefined) {
    bodyParams["BucketName"] = input.BucketName;
  }
  if (input.Prefix !== undefined) {
    bodyParams["Prefix"] = input.Prefix;
  }
  if (input.Region !== undefined) {
    bodyParams["Region"] = input.Region;
  }
  if (input.SyncFormat !== undefined) {
    bodyParams["SyncFormat"] = input.SyncFormat;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceDataSyncSource = (
  input: ResourceDataSyncSource,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AwsOrganizationsSource !== undefined) {
    bodyParams[
      "AwsOrganizationsSource"
    ] = serializeAws_json1_1ResourceDataSyncAwsOrganizationsSource(
      input.AwsOrganizationsSource,
      context
    );
  }
  if (input.IncludeFutureRegions !== undefined) {
    bodyParams["IncludeFutureRegions"] = input.IncludeFutureRegions;
  }
  if (input.SourceRegions !== undefined) {
    bodyParams[
      "SourceRegions"
    ] = serializeAws_json1_1ResourceDataSyncSourceRegionList(
      input.SourceRegions,
      context
    );
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceDataSyncSourceRegionList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ResultAttribute = (
  input: ResultAttribute,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TypeName !== undefined) {
    bodyParams["TypeName"] = input.TypeName;
  }
  return bodyParams;
};

const serializeAws_json1_1ResultAttributeList = (
  input: Array<ResultAttribute>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1ResultAttribute(entry, context));
  }
  return contents;
};

const serializeAws_json1_1ResumeSessionRequest = (
  input: ResumeSessionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SessionId !== undefined) {
    bodyParams["SessionId"] = input.SessionId;
  }
  return bodyParams;
};

const serializeAws_json1_1S3OutputLocation = (
  input: S3OutputLocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.OutputS3BucketName !== undefined) {
    bodyParams["OutputS3BucketName"] = input.OutputS3BucketName;
  }
  if (input.OutputS3KeyPrefix !== undefined) {
    bodyParams["OutputS3KeyPrefix"] = input.OutputS3KeyPrefix;
  }
  if (input.OutputS3Region !== undefined) {
    bodyParams["OutputS3Region"] = input.OutputS3Region;
  }
  return bodyParams;
};

const serializeAws_json1_1SendAutomationSignalRequest = (
  input: SendAutomationSignalRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AutomationExecutionId !== undefined) {
    bodyParams["AutomationExecutionId"] = input.AutomationExecutionId;
  }
  if (input.Payload !== undefined) {
    bodyParams["Payload"] = serializeAws_json1_1AutomationParameterMap(
      input.Payload,
      context
    );
  }
  if (input.SignalType !== undefined) {
    bodyParams["SignalType"] = input.SignalType;
  }
  return bodyParams;
};

const serializeAws_json1_1SendCommandRequest = (
  input: SendCommandRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CloudWatchOutputConfig !== undefined) {
    bodyParams[
      "CloudWatchOutputConfig"
    ] = serializeAws_json1_1CloudWatchOutputConfig(
      input.CloudWatchOutputConfig,
      context
    );
  }
  if (input.Comment !== undefined) {
    bodyParams["Comment"] = input.Comment;
  }
  if (input.DocumentHash !== undefined) {
    bodyParams["DocumentHash"] = input.DocumentHash;
  }
  if (input.DocumentHashType !== undefined) {
    bodyParams["DocumentHashType"] = input.DocumentHashType;
  }
  if (input.DocumentName !== undefined) {
    bodyParams["DocumentName"] = input.DocumentName;
  }
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.InstanceIds !== undefined) {
    bodyParams["InstanceIds"] = serializeAws_json1_1InstanceIdList(
      input.InstanceIds,
      context
    );
  }
  if (input.MaxConcurrency !== undefined) {
    bodyParams["MaxConcurrency"] = input.MaxConcurrency;
  }
  if (input.MaxErrors !== undefined) {
    bodyParams["MaxErrors"] = input.MaxErrors;
  }
  if (input.NotificationConfig !== undefined) {
    bodyParams["NotificationConfig"] = serializeAws_json1_1NotificationConfig(
      input.NotificationConfig,
      context
    );
  }
  if (input.OutputS3BucketName !== undefined) {
    bodyParams["OutputS3BucketName"] = input.OutputS3BucketName;
  }
  if (input.OutputS3KeyPrefix !== undefined) {
    bodyParams["OutputS3KeyPrefix"] = input.OutputS3KeyPrefix;
  }
  if (input.OutputS3Region !== undefined) {
    bodyParams["OutputS3Region"] = input.OutputS3Region;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1Parameters(
      input.Parameters,
      context
    );
  }
  if (input.ServiceRoleArn !== undefined) {
    bodyParams["ServiceRoleArn"] = input.ServiceRoleArn;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  if (input.TimeoutSeconds !== undefined) {
    bodyParams["TimeoutSeconds"] = input.TimeoutSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1SessionFilter = (
  input: SessionFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.key !== undefined) {
    bodyParams["key"] = input.key;
  }
  if (input.value !== undefined) {
    bodyParams["value"] = input.value;
  }
  return bodyParams;
};

const serializeAws_json1_1SessionFilterList = (
  input: Array<SessionFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1SessionFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1SessionManagerParameterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1SessionManagerParameters = (
  input: { [key: string]: Array<string> },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_json1_1SessionManagerParameterValueList(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_json1_1StartAssociationsOnceRequest = (
  input: StartAssociationsOnceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationIds !== undefined) {
    bodyParams["AssociationIds"] = serializeAws_json1_1AssociationIdList(
      input.AssociationIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartAutomationExecutionRequest = (
  input: StartAutomationExecutionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientToken !== undefined) {
    bodyParams["ClientToken"] = input.ClientToken;
  }
  if (input.DocumentName !== undefined) {
    bodyParams["DocumentName"] = input.DocumentName;
  }
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.MaxConcurrency !== undefined) {
    bodyParams["MaxConcurrency"] = input.MaxConcurrency;
  }
  if (input.MaxErrors !== undefined) {
    bodyParams["MaxErrors"] = input.MaxErrors;
  }
  if (input.Mode !== undefined) {
    bodyParams["Mode"] = input.Mode;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1AutomationParameterMap(
      input.Parameters,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TargetLocations !== undefined) {
    bodyParams["TargetLocations"] = serializeAws_json1_1TargetLocations(
      input.TargetLocations,
      context
    );
  }
  if (input.TargetMaps !== undefined) {
    bodyParams["TargetMaps"] = serializeAws_json1_1TargetMaps(
      input.TargetMaps,
      context
    );
  }
  if (input.TargetParameterName !== undefined) {
    bodyParams["TargetParameterName"] = input.TargetParameterName;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  return bodyParams;
};

const serializeAws_json1_1StartSessionRequest = (
  input: StartSessionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentName !== undefined) {
    bodyParams["DocumentName"] = input.DocumentName;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1SessionManagerParameters(
      input.Parameters,
      context
    );
  }
  if (input.Target !== undefined) {
    bodyParams["Target"] = input.Target;
  }
  return bodyParams;
};

const serializeAws_json1_1StepExecutionFilter = (
  input: StepExecutionFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1StepExecutionFilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StepExecutionFilterList = (
  input: Array<StepExecutionFilter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1StepExecutionFilter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1StepExecutionFilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1StopAutomationExecutionRequest = (
  input: StopAutomationExecutionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AutomationExecutionId !== undefined) {
    bodyParams["AutomationExecutionId"] = input.AutomationExecutionId;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1StringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Tag(entry, context));
  }
  return contents;
};

const serializeAws_json1_1Target = (
  input: Target,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1TargetValues(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1TargetLocation = (
  input: TargetLocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Accounts !== undefined) {
    bodyParams["Accounts"] = serializeAws_json1_1Accounts(
      input.Accounts,
      context
    );
  }
  if (input.ExecutionRoleName !== undefined) {
    bodyParams["ExecutionRoleName"] = input.ExecutionRoleName;
  }
  if (input.Regions !== undefined) {
    bodyParams["Regions"] = serializeAws_json1_1Regions(input.Regions, context);
  }
  if (input.TargetLocationMaxConcurrency !== undefined) {
    bodyParams["TargetLocationMaxConcurrency"] =
      input.TargetLocationMaxConcurrency;
  }
  if (input.TargetLocationMaxErrors !== undefined) {
    bodyParams["TargetLocationMaxErrors"] = input.TargetLocationMaxErrors;
  }
  return bodyParams;
};

const serializeAws_json1_1TargetLocations = (
  input: Array<TargetLocation>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1TargetLocation(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TargetMap = (
  input: { [key: string]: Array<string> },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_json1_1TargetMapValueList(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_json1_1TargetMapValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1TargetMaps = (
  input: Array<{ [key: string]: Array<string> }>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1TargetMap(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TargetValues = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Targets = (
  input: Array<Target>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Target(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TerminateSessionRequest = (
  input: TerminateSessionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SessionId !== undefined) {
    bodyParams["SessionId"] = input.SessionId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateAssociationRequest = (
  input: UpdateAssociationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationId !== undefined) {
    bodyParams["AssociationId"] = input.AssociationId;
  }
  if (input.AssociationName !== undefined) {
    bodyParams["AssociationName"] = input.AssociationName;
  }
  if (input.AssociationVersion !== undefined) {
    bodyParams["AssociationVersion"] = input.AssociationVersion;
  }
  if (input.AutomationTargetParameterName !== undefined) {
    bodyParams["AutomationTargetParameterName"] =
      input.AutomationTargetParameterName;
  }
  if (input.ComplianceSeverity !== undefined) {
    bodyParams["ComplianceSeverity"] = input.ComplianceSeverity;
  }
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.MaxConcurrency !== undefined) {
    bodyParams["MaxConcurrency"] = input.MaxConcurrency;
  }
  if (input.MaxErrors !== undefined) {
    bodyParams["MaxErrors"] = input.MaxErrors;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.OutputLocation !== undefined) {
    bodyParams[
      "OutputLocation"
    ] = serializeAws_json1_1InstanceAssociationOutputLocation(
      input.OutputLocation,
      context
    );
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1Parameters(
      input.Parameters,
      context
    );
  }
  if (input.ScheduleExpression !== undefined) {
    bodyParams["ScheduleExpression"] = input.ScheduleExpression;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateAssociationStatusRequest = (
  input: UpdateAssociationStatusRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AssociationStatus !== undefined) {
    bodyParams["AssociationStatus"] = serializeAws_json1_1AssociationStatus(
      input.AssociationStatus,
      context
    );
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateDocumentDefaultVersionRequest = (
  input: UpdateDocumentDefaultVersionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateDocumentRequest = (
  input: UpdateDocumentRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Attachments !== undefined) {
    bodyParams["Attachments"] = serializeAws_json1_1AttachmentsSourceList(
      input.Attachments,
      context
    );
  }
  if (input.Content !== undefined) {
    bodyParams["Content"] = input.Content;
  }
  if (input.DocumentFormat !== undefined) {
    bodyParams["DocumentFormat"] = input.DocumentFormat;
  }
  if (input.DocumentVersion !== undefined) {
    bodyParams["DocumentVersion"] = input.DocumentVersion;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.TargetType !== undefined) {
    bodyParams["TargetType"] = input.TargetType;
  }
  if (input.VersionName !== undefined) {
    bodyParams["VersionName"] = input.VersionName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateMaintenanceWindowRequest = (
  input: UpdateMaintenanceWindowRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllowUnassociatedTargets !== undefined) {
    bodyParams["AllowUnassociatedTargets"] = input.AllowUnassociatedTargets;
  }
  if (input.Cutoff !== undefined) {
    bodyParams["Cutoff"] = input.Cutoff;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Duration !== undefined) {
    bodyParams["Duration"] = input.Duration;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.EndDate !== undefined) {
    bodyParams["EndDate"] = input.EndDate;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Replace !== undefined) {
    bodyParams["Replace"] = input.Replace;
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = input.Schedule;
  }
  if (input.ScheduleTimezone !== undefined) {
    bodyParams["ScheduleTimezone"] = input.ScheduleTimezone;
  }
  if (input.StartDate !== undefined) {
    bodyParams["StartDate"] = input.StartDate;
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateMaintenanceWindowTargetRequest = (
  input: UpdateMaintenanceWindowTargetRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.OwnerInformation !== undefined) {
    bodyParams["OwnerInformation"] = input.OwnerInformation;
  }
  if (input.Replace !== undefined) {
    bodyParams["Replace"] = input.Replace;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  if (input.WindowTargetId !== undefined) {
    bodyParams["WindowTargetId"] = input.WindowTargetId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateMaintenanceWindowTaskRequest = (
  input: UpdateMaintenanceWindowTaskRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.LoggingInfo !== undefined) {
    bodyParams["LoggingInfo"] = serializeAws_json1_1LoggingInfo(
      input.LoggingInfo,
      context
    );
  }
  if (input.MaxConcurrency !== undefined) {
    bodyParams["MaxConcurrency"] = input.MaxConcurrency;
  }
  if (input.MaxErrors !== undefined) {
    bodyParams["MaxErrors"] = input.MaxErrors;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Priority !== undefined) {
    bodyParams["Priority"] = input.Priority;
  }
  if (input.Replace !== undefined) {
    bodyParams["Replace"] = input.Replace;
  }
  if (input.ServiceRoleArn !== undefined) {
    bodyParams["ServiceRoleArn"] = input.ServiceRoleArn;
  }
  if (input.Targets !== undefined) {
    bodyParams["Targets"] = serializeAws_json1_1Targets(input.Targets, context);
  }
  if (input.TaskArn !== undefined) {
    bodyParams["TaskArn"] = input.TaskArn;
  }
  if (input.TaskInvocationParameters !== undefined) {
    bodyParams[
      "TaskInvocationParameters"
    ] = serializeAws_json1_1MaintenanceWindowTaskInvocationParameters(
      input.TaskInvocationParameters,
      context
    );
  }
  if (input.TaskParameters !== undefined) {
    bodyParams[
      "TaskParameters"
    ] = serializeAws_json1_1MaintenanceWindowTaskParameters(
      input.TaskParameters,
      context
    );
  }
  if (input.WindowId !== undefined) {
    bodyParams["WindowId"] = input.WindowId;
  }
  if (input.WindowTaskId !== undefined) {
    bodyParams["WindowTaskId"] = input.WindowTaskId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateManagedInstanceRoleRequest = (
  input: UpdateManagedInstanceRoleRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.IamRole !== undefined) {
    bodyParams["IamRole"] = input.IamRole;
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateOpsItemRequest = (
  input: UpdateOpsItemRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Category !== undefined) {
    bodyParams["Category"] = input.Category;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Notifications !== undefined) {
    bodyParams["Notifications"] = serializeAws_json1_1OpsItemNotifications(
      input.Notifications,
      context
    );
  }
  if (input.OperationalData !== undefined) {
    bodyParams["OperationalData"] = serializeAws_json1_1OpsItemOperationalData(
      input.OperationalData,
      context
    );
  }
  if (input.OperationalDataToDelete !== undefined) {
    bodyParams[
      "OperationalDataToDelete"
    ] = serializeAws_json1_1OpsItemOpsDataKeysList(
      input.OperationalDataToDelete,
      context
    );
  }
  if (input.OpsItemId !== undefined) {
    bodyParams["OpsItemId"] = input.OpsItemId;
  }
  if (input.Priority !== undefined) {
    bodyParams["Priority"] = input.Priority;
  }
  if (input.RelatedOpsItems !== undefined) {
    bodyParams["RelatedOpsItems"] = serializeAws_json1_1RelatedOpsItems(
      input.RelatedOpsItems,
      context
    );
  }
  if (input.Severity !== undefined) {
    bodyParams["Severity"] = input.Severity;
  }
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdatePatchBaselineRequest = (
  input: UpdatePatchBaselineRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ApprovalRules !== undefined) {
    bodyParams["ApprovalRules"] = serializeAws_json1_1PatchRuleGroup(
      input.ApprovalRules,
      context
    );
  }
  if (input.ApprovedPatches !== undefined) {
    bodyParams["ApprovedPatches"] = serializeAws_json1_1PatchIdList(
      input.ApprovedPatches,
      context
    );
  }
  if (input.ApprovedPatchesComplianceLevel !== undefined) {
    bodyParams["ApprovedPatchesComplianceLevel"] =
      input.ApprovedPatchesComplianceLevel;
  }
  if (input.ApprovedPatchesEnableNonSecurity !== undefined) {
    bodyParams["ApprovedPatchesEnableNonSecurity"] =
      input.ApprovedPatchesEnableNonSecurity;
  }
  if (input.BaselineId !== undefined) {
    bodyParams["BaselineId"] = input.BaselineId;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.GlobalFilters !== undefined) {
    bodyParams["GlobalFilters"] = serializeAws_json1_1PatchFilterGroup(
      input.GlobalFilters,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RejectedPatches !== undefined) {
    bodyParams["RejectedPatches"] = serializeAws_json1_1PatchIdList(
      input.RejectedPatches,
      context
    );
  }
  if (input.RejectedPatchesAction !== undefined) {
    bodyParams["RejectedPatchesAction"] = input.RejectedPatchesAction;
  }
  if (input.Replace !== undefined) {
    bodyParams["Replace"] = input.Replace;
  }
  if (input.Sources !== undefined) {
    bodyParams["Sources"] = serializeAws_json1_1PatchSourceList(
      input.Sources,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateResourceDataSyncRequest = (
  input: UpdateResourceDataSyncRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SyncName !== undefined) {
    bodyParams["SyncName"] = input.SyncName;
  }
  if (input.SyncSource !== undefined) {
    bodyParams["SyncSource"] = serializeAws_json1_1ResourceDataSyncSource(
      input.SyncSource,
      context
    );
  }
  if (input.SyncType !== undefined) {
    bodyParams["SyncType"] = input.SyncType;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateServiceSettingRequest = (
  input: UpdateServiceSettingRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SettingId !== undefined) {
    bodyParams["SettingId"] = input.SettingId;
  }
  if (input.SettingValue !== undefined) {
    bodyParams["SettingValue"] = input.SettingValue;
  }
  return bodyParams;
};

const deserializeAws_json1_1AccountIdList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1AccountSharingInfo = (
  output: any,
  context: __SerdeContext
): AccountSharingInfo => {
  let contents: any = {
    __type: "AccountSharingInfo",
    AccountId: undefined,
    SharedDocumentVersion: undefined
  };
  if (output.AccountId !== undefined && output.AccountId !== null) {
    contents.AccountId = output.AccountId;
  }
  if (
    output.SharedDocumentVersion !== undefined &&
    output.SharedDocumentVersion !== null
  ) {
    contents.SharedDocumentVersion = output.SharedDocumentVersion;
  }
  return contents;
};

const deserializeAws_json1_1AccountSharingInfoList = (
  output: any,
  context: __SerdeContext
): Array<AccountSharingInfo> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AccountSharingInfo(entry, context)
  );
};

const deserializeAws_json1_1Accounts = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Activation = (
  output: any,
  context: __SerdeContext
): Activation => {
  let contents: any = {
    __type: "Activation",
    ActivationId: undefined,
    CreatedDate: undefined,
    DefaultInstanceName: undefined,
    Description: undefined,
    ExpirationDate: undefined,
    Expired: undefined,
    IamRole: undefined,
    RegistrationLimit: undefined,
    RegistrationsCount: undefined,
    Tags: undefined
  };
  if (output.ActivationId !== undefined && output.ActivationId !== null) {
    contents.ActivationId = output.ActivationId;
  }
  if (output.CreatedDate !== undefined && output.CreatedDate !== null) {
    contents.CreatedDate = new Date(Math.round(output.CreatedDate * 1000));
  }
  if (
    output.DefaultInstanceName !== undefined &&
    output.DefaultInstanceName !== null
  ) {
    contents.DefaultInstanceName = output.DefaultInstanceName;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.ExpirationDate !== undefined && output.ExpirationDate !== null) {
    contents.ExpirationDate = new Date(
      Math.round(output.ExpirationDate * 1000)
    );
  }
  if (output.Expired !== undefined && output.Expired !== null) {
    contents.Expired = output.Expired;
  }
  if (output.IamRole !== undefined && output.IamRole !== null) {
    contents.IamRole = output.IamRole;
  }
  if (
    output.RegistrationLimit !== undefined &&
    output.RegistrationLimit !== null
  ) {
    contents.RegistrationLimit = output.RegistrationLimit;
  }
  if (
    output.RegistrationsCount !== undefined &&
    output.RegistrationsCount !== null
  ) {
    contents.RegistrationsCount = output.RegistrationsCount;
  }
  if (output.Tags !== undefined && output.Tags !== null) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1ActivationList = (
  output: any,
  context: __SerdeContext
): Array<Activation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Activation(entry, context)
  );
};

const deserializeAws_json1_1AddTagsToResourceResult = (
  output: any,
  context: __SerdeContext
): AddTagsToResourceResult => {
  let contents: any = {
    __type: "AddTagsToResourceResult"
  };
  return contents;
};

const deserializeAws_json1_1AlreadyExistsException = (
  output: any,
  context: __SerdeContext
): AlreadyExistsException => {
  let contents: any = {
    __type: "AlreadyExistsException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1AssociatedInstances = (
  output: any,
  context: __SerdeContext
): AssociatedInstances => {
  let contents: any = {
    __type: "AssociatedInstances"
  };
  return contents;
};

const deserializeAws_json1_1Association = (
  output: any,
  context: __SerdeContext
): Association => {
  let contents: any = {
    __type: "Association",
    AssociationId: undefined,
    AssociationName: undefined,
    AssociationVersion: undefined,
    DocumentVersion: undefined,
    InstanceId: undefined,
    LastExecutionDate: undefined,
    Name: undefined,
    Overview: undefined,
    ScheduleExpression: undefined,
    Targets: undefined
  };
  if (output.AssociationId !== undefined && output.AssociationId !== null) {
    contents.AssociationId = output.AssociationId;
  }
  if (output.AssociationName !== undefined && output.AssociationName !== null) {
    contents.AssociationName = output.AssociationName;
  }
  if (
    output.AssociationVersion !== undefined &&
    output.AssociationVersion !== null
  ) {
    contents.AssociationVersion = output.AssociationVersion;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (
    output.LastExecutionDate !== undefined &&
    output.LastExecutionDate !== null
  ) {
    contents.LastExecutionDate = new Date(
      Math.round(output.LastExecutionDate * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Overview !== undefined && output.Overview !== null) {
    contents.Overview = deserializeAws_json1_1AssociationOverview(
      output.Overview,
      context
    );
  }
  if (
    output.ScheduleExpression !== undefined &&
    output.ScheduleExpression !== null
  ) {
    contents.ScheduleExpression = output.ScheduleExpression;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  return contents;
};

const deserializeAws_json1_1AssociationAlreadyExists = (
  output: any,
  context: __SerdeContext
): AssociationAlreadyExists => {
  let contents: any = {
    __type: "AssociationAlreadyExists"
  };
  return contents;
};

const deserializeAws_json1_1AssociationDescription = (
  output: any,
  context: __SerdeContext
): AssociationDescription => {
  let contents: any = {
    __type: "AssociationDescription",
    AssociationId: undefined,
    AssociationName: undefined,
    AssociationVersion: undefined,
    AutomationTargetParameterName: undefined,
    ComplianceSeverity: undefined,
    Date: undefined,
    DocumentVersion: undefined,
    InstanceId: undefined,
    LastExecutionDate: undefined,
    LastSuccessfulExecutionDate: undefined,
    LastUpdateAssociationDate: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    Name: undefined,
    OutputLocation: undefined,
    Overview: undefined,
    Parameters: undefined,
    ScheduleExpression: undefined,
    Status: undefined,
    Targets: undefined
  };
  if (output.AssociationId !== undefined && output.AssociationId !== null) {
    contents.AssociationId = output.AssociationId;
  }
  if (output.AssociationName !== undefined && output.AssociationName !== null) {
    contents.AssociationName = output.AssociationName;
  }
  if (
    output.AssociationVersion !== undefined &&
    output.AssociationVersion !== null
  ) {
    contents.AssociationVersion = output.AssociationVersion;
  }
  if (
    output.AutomationTargetParameterName !== undefined &&
    output.AutomationTargetParameterName !== null
  ) {
    contents.AutomationTargetParameterName =
      output.AutomationTargetParameterName;
  }
  if (
    output.ComplianceSeverity !== undefined &&
    output.ComplianceSeverity !== null
  ) {
    contents.ComplianceSeverity = output.ComplianceSeverity;
  }
  if (output.Date !== undefined && output.Date !== null) {
    contents.Date = new Date(Math.round(output.Date * 1000));
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (
    output.LastExecutionDate !== undefined &&
    output.LastExecutionDate !== null
  ) {
    contents.LastExecutionDate = new Date(
      Math.round(output.LastExecutionDate * 1000)
    );
  }
  if (
    output.LastSuccessfulExecutionDate !== undefined &&
    output.LastSuccessfulExecutionDate !== null
  ) {
    contents.LastSuccessfulExecutionDate = new Date(
      Math.round(output.LastSuccessfulExecutionDate * 1000)
    );
  }
  if (
    output.LastUpdateAssociationDate !== undefined &&
    output.LastUpdateAssociationDate !== null
  ) {
    contents.LastUpdateAssociationDate = new Date(
      Math.round(output.LastUpdateAssociationDate * 1000)
    );
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.OutputLocation !== undefined && output.OutputLocation !== null) {
    contents.OutputLocation = deserializeAws_json1_1InstanceAssociationOutputLocation(
      output.OutputLocation,
      context
    );
  }
  if (output.Overview !== undefined && output.Overview !== null) {
    contents.Overview = deserializeAws_json1_1AssociationOverview(
      output.Overview,
      context
    );
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1Parameters(
      output.Parameters,
      context
    );
  }
  if (
    output.ScheduleExpression !== undefined &&
    output.ScheduleExpression !== null
  ) {
    contents.ScheduleExpression = output.ScheduleExpression;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = deserializeAws_json1_1AssociationStatus(
      output.Status,
      context
    );
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  return contents;
};

const deserializeAws_json1_1AssociationDescriptionList = (
  output: any,
  context: __SerdeContext
): Array<AssociationDescription> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AssociationDescription(entry, context)
  );
};

const deserializeAws_json1_1AssociationDoesNotExist = (
  output: any,
  context: __SerdeContext
): AssociationDoesNotExist => {
  let contents: any = {
    __type: "AssociationDoesNotExist",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1AssociationExecution = (
  output: any,
  context: __SerdeContext
): AssociationExecution => {
  let contents: any = {
    __type: "AssociationExecution",
    AssociationId: undefined,
    AssociationVersion: undefined,
    CreatedTime: undefined,
    DetailedStatus: undefined,
    ExecutionId: undefined,
    LastExecutionDate: undefined,
    ResourceCountByStatus: undefined,
    Status: undefined
  };
  if (output.AssociationId !== undefined && output.AssociationId !== null) {
    contents.AssociationId = output.AssociationId;
  }
  if (
    output.AssociationVersion !== undefined &&
    output.AssociationVersion !== null
  ) {
    contents.AssociationVersion = output.AssociationVersion;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.DetailedStatus !== undefined && output.DetailedStatus !== null) {
    contents.DetailedStatus = output.DetailedStatus;
  }
  if (output.ExecutionId !== undefined && output.ExecutionId !== null) {
    contents.ExecutionId = output.ExecutionId;
  }
  if (
    output.LastExecutionDate !== undefined &&
    output.LastExecutionDate !== null
  ) {
    contents.LastExecutionDate = new Date(
      Math.round(output.LastExecutionDate * 1000)
    );
  }
  if (
    output.ResourceCountByStatus !== undefined &&
    output.ResourceCountByStatus !== null
  ) {
    contents.ResourceCountByStatus = output.ResourceCountByStatus;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1AssociationExecutionDoesNotExist = (
  output: any,
  context: __SerdeContext
): AssociationExecutionDoesNotExist => {
  let contents: any = {
    __type: "AssociationExecutionDoesNotExist",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1AssociationExecutionTarget = (
  output: any,
  context: __SerdeContext
): AssociationExecutionTarget => {
  let contents: any = {
    __type: "AssociationExecutionTarget",
    AssociationId: undefined,
    AssociationVersion: undefined,
    DetailedStatus: undefined,
    ExecutionId: undefined,
    LastExecutionDate: undefined,
    OutputSource: undefined,
    ResourceId: undefined,
    ResourceType: undefined,
    Status: undefined
  };
  if (output.AssociationId !== undefined && output.AssociationId !== null) {
    contents.AssociationId = output.AssociationId;
  }
  if (
    output.AssociationVersion !== undefined &&
    output.AssociationVersion !== null
  ) {
    contents.AssociationVersion = output.AssociationVersion;
  }
  if (output.DetailedStatus !== undefined && output.DetailedStatus !== null) {
    contents.DetailedStatus = output.DetailedStatus;
  }
  if (output.ExecutionId !== undefined && output.ExecutionId !== null) {
    contents.ExecutionId = output.ExecutionId;
  }
  if (
    output.LastExecutionDate !== undefined &&
    output.LastExecutionDate !== null
  ) {
    contents.LastExecutionDate = new Date(
      Math.round(output.LastExecutionDate * 1000)
    );
  }
  if (output.OutputSource !== undefined && output.OutputSource !== null) {
    contents.OutputSource = deserializeAws_json1_1OutputSource(
      output.OutputSource,
      context
    );
  }
  if (output.ResourceId !== undefined && output.ResourceId !== null) {
    contents.ResourceId = output.ResourceId;
  }
  if (output.ResourceType !== undefined && output.ResourceType !== null) {
    contents.ResourceType = output.ResourceType;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1AssociationExecutionTargetsList = (
  output: any,
  context: __SerdeContext
): Array<AssociationExecutionTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AssociationExecutionTarget(entry, context)
  );
};

const deserializeAws_json1_1AssociationExecutionsList = (
  output: any,
  context: __SerdeContext
): Array<AssociationExecution> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AssociationExecution(entry, context)
  );
};

const deserializeAws_json1_1AssociationLimitExceeded = (
  output: any,
  context: __SerdeContext
): AssociationLimitExceeded => {
  let contents: any = {
    __type: "AssociationLimitExceeded"
  };
  return contents;
};

const deserializeAws_json1_1AssociationList = (
  output: any,
  context: __SerdeContext
): Array<Association> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Association(entry, context)
  );
};

const deserializeAws_json1_1AssociationOverview = (
  output: any,
  context: __SerdeContext
): AssociationOverview => {
  let contents: any = {
    __type: "AssociationOverview",
    AssociationStatusAggregatedCount: undefined,
    DetailedStatus: undefined,
    Status: undefined
  };
  if (
    output.AssociationStatusAggregatedCount !== undefined &&
    output.AssociationStatusAggregatedCount !== null
  ) {
    contents.AssociationStatusAggregatedCount = deserializeAws_json1_1AssociationStatusAggregatedCount(
      output.AssociationStatusAggregatedCount,
      context
    );
  }
  if (output.DetailedStatus !== undefined && output.DetailedStatus !== null) {
    contents.DetailedStatus = output.DetailedStatus;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1AssociationStatus = (
  output: any,
  context: __SerdeContext
): AssociationStatus => {
  let contents: any = {
    __type: "AssociationStatus",
    AdditionalInfo: undefined,
    Date: undefined,
    Message: undefined,
    Name: undefined
  };
  if (output.AdditionalInfo !== undefined && output.AdditionalInfo !== null) {
    contents.AdditionalInfo = output.AdditionalInfo;
  }
  if (output.Date !== undefined && output.Date !== null) {
    contents.Date = new Date(Math.round(output.Date * 1000));
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1AssociationStatusAggregatedCount = (
  output: any,
  context: __SerdeContext
): { [key: string]: number } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1AssociationVersionInfo = (
  output: any,
  context: __SerdeContext
): AssociationVersionInfo => {
  let contents: any = {
    __type: "AssociationVersionInfo",
    AssociationId: undefined,
    AssociationName: undefined,
    AssociationVersion: undefined,
    ComplianceSeverity: undefined,
    CreatedDate: undefined,
    DocumentVersion: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    Name: undefined,
    OutputLocation: undefined,
    Parameters: undefined,
    ScheduleExpression: undefined,
    Targets: undefined
  };
  if (output.AssociationId !== undefined && output.AssociationId !== null) {
    contents.AssociationId = output.AssociationId;
  }
  if (output.AssociationName !== undefined && output.AssociationName !== null) {
    contents.AssociationName = output.AssociationName;
  }
  if (
    output.AssociationVersion !== undefined &&
    output.AssociationVersion !== null
  ) {
    contents.AssociationVersion = output.AssociationVersion;
  }
  if (
    output.ComplianceSeverity !== undefined &&
    output.ComplianceSeverity !== null
  ) {
    contents.ComplianceSeverity = output.ComplianceSeverity;
  }
  if (output.CreatedDate !== undefined && output.CreatedDate !== null) {
    contents.CreatedDate = new Date(Math.round(output.CreatedDate * 1000));
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.OutputLocation !== undefined && output.OutputLocation !== null) {
    contents.OutputLocation = deserializeAws_json1_1InstanceAssociationOutputLocation(
      output.OutputLocation,
      context
    );
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1Parameters(
      output.Parameters,
      context
    );
  }
  if (
    output.ScheduleExpression !== undefined &&
    output.ScheduleExpression !== null
  ) {
    contents.ScheduleExpression = output.ScheduleExpression;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  return contents;
};

const deserializeAws_json1_1AssociationVersionLimitExceeded = (
  output: any,
  context: __SerdeContext
): AssociationVersionLimitExceeded => {
  let contents: any = {
    __type: "AssociationVersionLimitExceeded",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1AssociationVersionList = (
  output: any,
  context: __SerdeContext
): Array<AssociationVersionInfo> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AssociationVersionInfo(entry, context)
  );
};

const deserializeAws_json1_1AttachmentContent = (
  output: any,
  context: __SerdeContext
): AttachmentContent => {
  let contents: any = {
    __type: "AttachmentContent",
    Hash: undefined,
    HashType: undefined,
    Name: undefined,
    Size: undefined,
    Url: undefined
  };
  if (output.Hash !== undefined && output.Hash !== null) {
    contents.Hash = output.Hash;
  }
  if (output.HashType !== undefined && output.HashType !== null) {
    contents.HashType = output.HashType;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Size !== undefined && output.Size !== null) {
    contents.Size = output.Size;
  }
  if (output.Url !== undefined && output.Url !== null) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_json1_1AttachmentContentList = (
  output: any,
  context: __SerdeContext
): Array<AttachmentContent> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AttachmentContent(entry, context)
  );
};

const deserializeAws_json1_1AttachmentInformation = (
  output: any,
  context: __SerdeContext
): AttachmentInformation => {
  let contents: any = {
    __type: "AttachmentInformation",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1AttachmentInformationList = (
  output: any,
  context: __SerdeContext
): Array<AttachmentInformation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AttachmentInformation(entry, context)
  );
};

const deserializeAws_json1_1AutomationDefinitionNotFoundException = (
  output: any,
  context: __SerdeContext
): AutomationDefinitionNotFoundException => {
  let contents: any = {
    __type: "AutomationDefinitionNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1AutomationDefinitionVersionNotFoundException = (
  output: any,
  context: __SerdeContext
): AutomationDefinitionVersionNotFoundException => {
  let contents: any = {
    __type: "AutomationDefinitionVersionNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1AutomationExecution = (
  output: any,
  context: __SerdeContext
): AutomationExecution => {
  let contents: any = {
    __type: "AutomationExecution",
    AutomationExecutionId: undefined,
    AutomationExecutionStatus: undefined,
    CurrentAction: undefined,
    CurrentStepName: undefined,
    DocumentName: undefined,
    DocumentVersion: undefined,
    ExecutedBy: undefined,
    ExecutionEndTime: undefined,
    ExecutionStartTime: undefined,
    FailureMessage: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    Mode: undefined,
    Outputs: undefined,
    Parameters: undefined,
    ParentAutomationExecutionId: undefined,
    ProgressCounters: undefined,
    ResolvedTargets: undefined,
    StepExecutions: undefined,
    StepExecutionsTruncated: undefined,
    Target: undefined,
    TargetLocations: undefined,
    TargetMaps: undefined,
    TargetParameterName: undefined,
    Targets: undefined
  };
  if (
    output.AutomationExecutionId !== undefined &&
    output.AutomationExecutionId !== null
  ) {
    contents.AutomationExecutionId = output.AutomationExecutionId;
  }
  if (
    output.AutomationExecutionStatus !== undefined &&
    output.AutomationExecutionStatus !== null
  ) {
    contents.AutomationExecutionStatus = output.AutomationExecutionStatus;
  }
  if (output.CurrentAction !== undefined && output.CurrentAction !== null) {
    contents.CurrentAction = output.CurrentAction;
  }
  if (output.CurrentStepName !== undefined && output.CurrentStepName !== null) {
    contents.CurrentStepName = output.CurrentStepName;
  }
  if (output.DocumentName !== undefined && output.DocumentName !== null) {
    contents.DocumentName = output.DocumentName;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.ExecutedBy !== undefined && output.ExecutedBy !== null) {
    contents.ExecutedBy = output.ExecutedBy;
  }
  if (
    output.ExecutionEndTime !== undefined &&
    output.ExecutionEndTime !== null
  ) {
    contents.ExecutionEndTime = new Date(
      Math.round(output.ExecutionEndTime * 1000)
    );
  }
  if (
    output.ExecutionStartTime !== undefined &&
    output.ExecutionStartTime !== null
  ) {
    contents.ExecutionStartTime = new Date(
      Math.round(output.ExecutionStartTime * 1000)
    );
  }
  if (output.FailureMessage !== undefined && output.FailureMessage !== null) {
    contents.FailureMessage = output.FailureMessage;
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (output.Mode !== undefined && output.Mode !== null) {
    contents.Mode = output.Mode;
  }
  if (output.Outputs !== undefined && output.Outputs !== null) {
    contents.Outputs = deserializeAws_json1_1AutomationParameterMap(
      output.Outputs,
      context
    );
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1AutomationParameterMap(
      output.Parameters,
      context
    );
  }
  if (
    output.ParentAutomationExecutionId !== undefined &&
    output.ParentAutomationExecutionId !== null
  ) {
    contents.ParentAutomationExecutionId = output.ParentAutomationExecutionId;
  }
  if (
    output.ProgressCounters !== undefined &&
    output.ProgressCounters !== null
  ) {
    contents.ProgressCounters = deserializeAws_json1_1ProgressCounters(
      output.ProgressCounters,
      context
    );
  }
  if (output.ResolvedTargets !== undefined && output.ResolvedTargets !== null) {
    contents.ResolvedTargets = deserializeAws_json1_1ResolvedTargets(
      output.ResolvedTargets,
      context
    );
  }
  if (output.StepExecutions !== undefined && output.StepExecutions !== null) {
    contents.StepExecutions = deserializeAws_json1_1StepExecutionList(
      output.StepExecutions,
      context
    );
  }
  if (
    output.StepExecutionsTruncated !== undefined &&
    output.StepExecutionsTruncated !== null
  ) {
    contents.StepExecutionsTruncated = output.StepExecutionsTruncated;
  }
  if (output.Target !== undefined && output.Target !== null) {
    contents.Target = output.Target;
  }
  if (output.TargetLocations !== undefined && output.TargetLocations !== null) {
    contents.TargetLocations = deserializeAws_json1_1TargetLocations(
      output.TargetLocations,
      context
    );
  }
  if (output.TargetMaps !== undefined && output.TargetMaps !== null) {
    contents.TargetMaps = deserializeAws_json1_1TargetMaps(
      output.TargetMaps,
      context
    );
  }
  if (
    output.TargetParameterName !== undefined &&
    output.TargetParameterName !== null
  ) {
    contents.TargetParameterName = output.TargetParameterName;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  return contents;
};

const deserializeAws_json1_1AutomationExecutionLimitExceededException = (
  output: any,
  context: __SerdeContext
): AutomationExecutionLimitExceededException => {
  let contents: any = {
    __type: "AutomationExecutionLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1AutomationExecutionMetadata = (
  output: any,
  context: __SerdeContext
): AutomationExecutionMetadata => {
  let contents: any = {
    __type: "AutomationExecutionMetadata",
    AutomationExecutionId: undefined,
    AutomationExecutionStatus: undefined,
    AutomationType: undefined,
    CurrentAction: undefined,
    CurrentStepName: undefined,
    DocumentName: undefined,
    DocumentVersion: undefined,
    ExecutedBy: undefined,
    ExecutionEndTime: undefined,
    ExecutionStartTime: undefined,
    FailureMessage: undefined,
    LogFile: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    Mode: undefined,
    Outputs: undefined,
    ParentAutomationExecutionId: undefined,
    ResolvedTargets: undefined,
    Target: undefined,
    TargetMaps: undefined,
    TargetParameterName: undefined,
    Targets: undefined
  };
  if (
    output.AutomationExecutionId !== undefined &&
    output.AutomationExecutionId !== null
  ) {
    contents.AutomationExecutionId = output.AutomationExecutionId;
  }
  if (
    output.AutomationExecutionStatus !== undefined &&
    output.AutomationExecutionStatus !== null
  ) {
    contents.AutomationExecutionStatus = output.AutomationExecutionStatus;
  }
  if (output.AutomationType !== undefined && output.AutomationType !== null) {
    contents.AutomationType = output.AutomationType;
  }
  if (output.CurrentAction !== undefined && output.CurrentAction !== null) {
    contents.CurrentAction = output.CurrentAction;
  }
  if (output.CurrentStepName !== undefined && output.CurrentStepName !== null) {
    contents.CurrentStepName = output.CurrentStepName;
  }
  if (output.DocumentName !== undefined && output.DocumentName !== null) {
    contents.DocumentName = output.DocumentName;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.ExecutedBy !== undefined && output.ExecutedBy !== null) {
    contents.ExecutedBy = output.ExecutedBy;
  }
  if (
    output.ExecutionEndTime !== undefined &&
    output.ExecutionEndTime !== null
  ) {
    contents.ExecutionEndTime = new Date(
      Math.round(output.ExecutionEndTime * 1000)
    );
  }
  if (
    output.ExecutionStartTime !== undefined &&
    output.ExecutionStartTime !== null
  ) {
    contents.ExecutionStartTime = new Date(
      Math.round(output.ExecutionStartTime * 1000)
    );
  }
  if (output.FailureMessage !== undefined && output.FailureMessage !== null) {
    contents.FailureMessage = output.FailureMessage;
  }
  if (output.LogFile !== undefined && output.LogFile !== null) {
    contents.LogFile = output.LogFile;
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (output.Mode !== undefined && output.Mode !== null) {
    contents.Mode = output.Mode;
  }
  if (output.Outputs !== undefined && output.Outputs !== null) {
    contents.Outputs = deserializeAws_json1_1AutomationParameterMap(
      output.Outputs,
      context
    );
  }
  if (
    output.ParentAutomationExecutionId !== undefined &&
    output.ParentAutomationExecutionId !== null
  ) {
    contents.ParentAutomationExecutionId = output.ParentAutomationExecutionId;
  }
  if (output.ResolvedTargets !== undefined && output.ResolvedTargets !== null) {
    contents.ResolvedTargets = deserializeAws_json1_1ResolvedTargets(
      output.ResolvedTargets,
      context
    );
  }
  if (output.Target !== undefined && output.Target !== null) {
    contents.Target = output.Target;
  }
  if (output.TargetMaps !== undefined && output.TargetMaps !== null) {
    contents.TargetMaps = deserializeAws_json1_1TargetMaps(
      output.TargetMaps,
      context
    );
  }
  if (
    output.TargetParameterName !== undefined &&
    output.TargetParameterName !== null
  ) {
    contents.TargetParameterName = output.TargetParameterName;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  return contents;
};

const deserializeAws_json1_1AutomationExecutionMetadataList = (
  output: any,
  context: __SerdeContext
): Array<AutomationExecutionMetadata> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AutomationExecutionMetadata(entry, context)
  );
};

const deserializeAws_json1_1AutomationExecutionNotFoundException = (
  output: any,
  context: __SerdeContext
): AutomationExecutionNotFoundException => {
  let contents: any = {
    __type: "AutomationExecutionNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1AutomationParameterMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: Array<string> } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1AutomationParameterValueList(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_json1_1AutomationParameterValueList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1AutomationStepNotFoundException = (
  output: any,
  context: __SerdeContext
): AutomationStepNotFoundException => {
  let contents: any = {
    __type: "AutomationStepNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1CancelCommandResult = (
  output: any,
  context: __SerdeContext
): CancelCommandResult => {
  let contents: any = {
    __type: "CancelCommandResult"
  };
  return contents;
};

const deserializeAws_json1_1CancelMaintenanceWindowExecutionResult = (
  output: any,
  context: __SerdeContext
): CancelMaintenanceWindowExecutionResult => {
  let contents: any = {
    __type: "CancelMaintenanceWindowExecutionResult",
    WindowExecutionId: undefined
  };
  if (
    output.WindowExecutionId !== undefined &&
    output.WindowExecutionId !== null
  ) {
    contents.WindowExecutionId = output.WindowExecutionId;
  }
  return contents;
};

const deserializeAws_json1_1CloudWatchOutputConfig = (
  output: any,
  context: __SerdeContext
): CloudWatchOutputConfig => {
  let contents: any = {
    __type: "CloudWatchOutputConfig",
    CloudWatchLogGroupName: undefined,
    CloudWatchOutputEnabled: undefined
  };
  if (
    output.CloudWatchLogGroupName !== undefined &&
    output.CloudWatchLogGroupName !== null
  ) {
    contents.CloudWatchLogGroupName = output.CloudWatchLogGroupName;
  }
  if (
    output.CloudWatchOutputEnabled !== undefined &&
    output.CloudWatchOutputEnabled !== null
  ) {
    contents.CloudWatchOutputEnabled = output.CloudWatchOutputEnabled;
  }
  return contents;
};

const deserializeAws_json1_1Command = (
  output: any,
  context: __SerdeContext
): Command => {
  let contents: any = {
    __type: "Command",
    CloudWatchOutputConfig: undefined,
    CommandId: undefined,
    Comment: undefined,
    CompletedCount: undefined,
    DeliveryTimedOutCount: undefined,
    DocumentName: undefined,
    DocumentVersion: undefined,
    ErrorCount: undefined,
    ExpiresAfter: undefined,
    InstanceIds: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    NotificationConfig: undefined,
    OutputS3BucketName: undefined,
    OutputS3KeyPrefix: undefined,
    OutputS3Region: undefined,
    Parameters: undefined,
    RequestedDateTime: undefined,
    ServiceRole: undefined,
    Status: undefined,
    StatusDetails: undefined,
    TargetCount: undefined,
    Targets: undefined
  };
  if (
    output.CloudWatchOutputConfig !== undefined &&
    output.CloudWatchOutputConfig !== null
  ) {
    contents.CloudWatchOutputConfig = deserializeAws_json1_1CloudWatchOutputConfig(
      output.CloudWatchOutputConfig,
      context
    );
  }
  if (output.CommandId !== undefined && output.CommandId !== null) {
    contents.CommandId = output.CommandId;
  }
  if (output.Comment !== undefined && output.Comment !== null) {
    contents.Comment = output.Comment;
  }
  if (output.CompletedCount !== undefined && output.CompletedCount !== null) {
    contents.CompletedCount = output.CompletedCount;
  }
  if (
    output.DeliveryTimedOutCount !== undefined &&
    output.DeliveryTimedOutCount !== null
  ) {
    contents.DeliveryTimedOutCount = output.DeliveryTimedOutCount;
  }
  if (output.DocumentName !== undefined && output.DocumentName !== null) {
    contents.DocumentName = output.DocumentName;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.ErrorCount !== undefined && output.ErrorCount !== null) {
    contents.ErrorCount = output.ErrorCount;
  }
  if (output.ExpiresAfter !== undefined && output.ExpiresAfter !== null) {
    contents.ExpiresAfter = new Date(Math.round(output.ExpiresAfter * 1000));
  }
  if (output.InstanceIds !== undefined && output.InstanceIds !== null) {
    contents.InstanceIds = deserializeAws_json1_1InstanceIdList(
      output.InstanceIds,
      context
    );
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (
    output.NotificationConfig !== undefined &&
    output.NotificationConfig !== null
  ) {
    contents.NotificationConfig = deserializeAws_json1_1NotificationConfig(
      output.NotificationConfig,
      context
    );
  }
  if (
    output.OutputS3BucketName !== undefined &&
    output.OutputS3BucketName !== null
  ) {
    contents.OutputS3BucketName = output.OutputS3BucketName;
  }
  if (
    output.OutputS3KeyPrefix !== undefined &&
    output.OutputS3KeyPrefix !== null
  ) {
    contents.OutputS3KeyPrefix = output.OutputS3KeyPrefix;
  }
  if (output.OutputS3Region !== undefined && output.OutputS3Region !== null) {
    contents.OutputS3Region = output.OutputS3Region;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1Parameters(
      output.Parameters,
      context
    );
  }
  if (
    output.RequestedDateTime !== undefined &&
    output.RequestedDateTime !== null
  ) {
    contents.RequestedDateTime = new Date(
      Math.round(output.RequestedDateTime * 1000)
    );
  }
  if (output.ServiceRole !== undefined && output.ServiceRole !== null) {
    contents.ServiceRole = output.ServiceRole;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  if (output.TargetCount !== undefined && output.TargetCount !== null) {
    contents.TargetCount = output.TargetCount;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  return contents;
};

const deserializeAws_json1_1CommandInvocation = (
  output: any,
  context: __SerdeContext
): CommandInvocation => {
  let contents: any = {
    __type: "CommandInvocation",
    CloudWatchOutputConfig: undefined,
    CommandId: undefined,
    CommandPlugins: undefined,
    Comment: undefined,
    DocumentName: undefined,
    DocumentVersion: undefined,
    InstanceId: undefined,
    InstanceName: undefined,
    NotificationConfig: undefined,
    RequestedDateTime: undefined,
    ServiceRole: undefined,
    StandardErrorUrl: undefined,
    StandardOutputUrl: undefined,
    Status: undefined,
    StatusDetails: undefined,
    TraceOutput: undefined
  };
  if (
    output.CloudWatchOutputConfig !== undefined &&
    output.CloudWatchOutputConfig !== null
  ) {
    contents.CloudWatchOutputConfig = deserializeAws_json1_1CloudWatchOutputConfig(
      output.CloudWatchOutputConfig,
      context
    );
  }
  if (output.CommandId !== undefined && output.CommandId !== null) {
    contents.CommandId = output.CommandId;
  }
  if (output.CommandPlugins !== undefined && output.CommandPlugins !== null) {
    contents.CommandPlugins = deserializeAws_json1_1CommandPluginList(
      output.CommandPlugins,
      context
    );
  }
  if (output.Comment !== undefined && output.Comment !== null) {
    contents.Comment = output.Comment;
  }
  if (output.DocumentName !== undefined && output.DocumentName !== null) {
    contents.DocumentName = output.DocumentName;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (output.InstanceName !== undefined && output.InstanceName !== null) {
    contents.InstanceName = output.InstanceName;
  }
  if (
    output.NotificationConfig !== undefined &&
    output.NotificationConfig !== null
  ) {
    contents.NotificationConfig = deserializeAws_json1_1NotificationConfig(
      output.NotificationConfig,
      context
    );
  }
  if (
    output.RequestedDateTime !== undefined &&
    output.RequestedDateTime !== null
  ) {
    contents.RequestedDateTime = new Date(
      Math.round(output.RequestedDateTime * 1000)
    );
  }
  if (output.ServiceRole !== undefined && output.ServiceRole !== null) {
    contents.ServiceRole = output.ServiceRole;
  }
  if (
    output.StandardErrorUrl !== undefined &&
    output.StandardErrorUrl !== null
  ) {
    contents.StandardErrorUrl = output.StandardErrorUrl;
  }
  if (
    output.StandardOutputUrl !== undefined &&
    output.StandardOutputUrl !== null
  ) {
    contents.StandardOutputUrl = output.StandardOutputUrl;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  if (output.TraceOutput !== undefined && output.TraceOutput !== null) {
    contents.TraceOutput = output.TraceOutput;
  }
  return contents;
};

const deserializeAws_json1_1CommandInvocationList = (
  output: any,
  context: __SerdeContext
): Array<CommandInvocation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CommandInvocation(entry, context)
  );
};

const deserializeAws_json1_1CommandList = (
  output: any,
  context: __SerdeContext
): Array<Command> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Command(entry, context)
  );
};

const deserializeAws_json1_1CommandPlugin = (
  output: any,
  context: __SerdeContext
): CommandPlugin => {
  let contents: any = {
    __type: "CommandPlugin",
    Name: undefined,
    Output: undefined,
    OutputS3BucketName: undefined,
    OutputS3KeyPrefix: undefined,
    OutputS3Region: undefined,
    ResponseCode: undefined,
    ResponseFinishDateTime: undefined,
    ResponseStartDateTime: undefined,
    StandardErrorUrl: undefined,
    StandardOutputUrl: undefined,
    Status: undefined,
    StatusDetails: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Output !== undefined && output.Output !== null) {
    contents.Output = output.Output;
  }
  if (
    output.OutputS3BucketName !== undefined &&
    output.OutputS3BucketName !== null
  ) {
    contents.OutputS3BucketName = output.OutputS3BucketName;
  }
  if (
    output.OutputS3KeyPrefix !== undefined &&
    output.OutputS3KeyPrefix !== null
  ) {
    contents.OutputS3KeyPrefix = output.OutputS3KeyPrefix;
  }
  if (output.OutputS3Region !== undefined && output.OutputS3Region !== null) {
    contents.OutputS3Region = output.OutputS3Region;
  }
  if (output.ResponseCode !== undefined && output.ResponseCode !== null) {
    contents.ResponseCode = output.ResponseCode;
  }
  if (
    output.ResponseFinishDateTime !== undefined &&
    output.ResponseFinishDateTime !== null
  ) {
    contents.ResponseFinishDateTime = new Date(
      Math.round(output.ResponseFinishDateTime * 1000)
    );
  }
  if (
    output.ResponseStartDateTime !== undefined &&
    output.ResponseStartDateTime !== null
  ) {
    contents.ResponseStartDateTime = new Date(
      Math.round(output.ResponseStartDateTime * 1000)
    );
  }
  if (
    output.StandardErrorUrl !== undefined &&
    output.StandardErrorUrl !== null
  ) {
    contents.StandardErrorUrl = output.StandardErrorUrl;
  }
  if (
    output.StandardOutputUrl !== undefined &&
    output.StandardOutputUrl !== null
  ) {
    contents.StandardOutputUrl = output.StandardOutputUrl;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  return contents;
};

const deserializeAws_json1_1CommandPluginList = (
  output: any,
  context: __SerdeContext
): Array<CommandPlugin> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CommandPlugin(entry, context)
  );
};

const deserializeAws_json1_1ComplianceExecutionSummary = (
  output: any,
  context: __SerdeContext
): ComplianceExecutionSummary => {
  let contents: any = {
    __type: "ComplianceExecutionSummary",
    ExecutionId: undefined,
    ExecutionTime: undefined,
    ExecutionType: undefined
  };
  if (output.ExecutionId !== undefined && output.ExecutionId !== null) {
    contents.ExecutionId = output.ExecutionId;
  }
  if (output.ExecutionTime !== undefined && output.ExecutionTime !== null) {
    contents.ExecutionTime = new Date(Math.round(output.ExecutionTime * 1000));
  }
  if (output.ExecutionType !== undefined && output.ExecutionType !== null) {
    contents.ExecutionType = output.ExecutionType;
  }
  return contents;
};

const deserializeAws_json1_1ComplianceItem = (
  output: any,
  context: __SerdeContext
): ComplianceItem => {
  let contents: any = {
    __type: "ComplianceItem",
    ComplianceType: undefined,
    Details: undefined,
    ExecutionSummary: undefined,
    Id: undefined,
    ResourceId: undefined,
    ResourceType: undefined,
    Severity: undefined,
    Status: undefined,
    Title: undefined
  };
  if (output.ComplianceType !== undefined && output.ComplianceType !== null) {
    contents.ComplianceType = output.ComplianceType;
  }
  if (output.Details !== undefined && output.Details !== null) {
    contents.Details = deserializeAws_json1_1ComplianceItemDetails(
      output.Details,
      context
    );
  }
  if (
    output.ExecutionSummary !== undefined &&
    output.ExecutionSummary !== null
  ) {
    contents.ExecutionSummary = deserializeAws_json1_1ComplianceExecutionSummary(
      output.ExecutionSummary,
      context
    );
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.ResourceId !== undefined && output.ResourceId !== null) {
    contents.ResourceId = output.ResourceId;
  }
  if (output.ResourceType !== undefined && output.ResourceType !== null) {
    contents.ResourceType = output.ResourceType;
  }
  if (output.Severity !== undefined && output.Severity !== null) {
    contents.Severity = output.Severity;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  return contents;
};

const deserializeAws_json1_1ComplianceItemDetails = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1ComplianceItemList = (
  output: any,
  context: __SerdeContext
): Array<ComplianceItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ComplianceItem(entry, context)
  );
};

const deserializeAws_json1_1ComplianceSummaryItem = (
  output: any,
  context: __SerdeContext
): ComplianceSummaryItem => {
  let contents: any = {
    __type: "ComplianceSummaryItem",
    ComplianceType: undefined,
    CompliantSummary: undefined,
    NonCompliantSummary: undefined
  };
  if (output.ComplianceType !== undefined && output.ComplianceType !== null) {
    contents.ComplianceType = output.ComplianceType;
  }
  if (
    output.CompliantSummary !== undefined &&
    output.CompliantSummary !== null
  ) {
    contents.CompliantSummary = deserializeAws_json1_1CompliantSummary(
      output.CompliantSummary,
      context
    );
  }
  if (
    output.NonCompliantSummary !== undefined &&
    output.NonCompliantSummary !== null
  ) {
    contents.NonCompliantSummary = deserializeAws_json1_1NonCompliantSummary(
      output.NonCompliantSummary,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ComplianceSummaryItemList = (
  output: any,
  context: __SerdeContext
): Array<ComplianceSummaryItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ComplianceSummaryItem(entry, context)
  );
};

const deserializeAws_json1_1ComplianceTypeCountLimitExceededException = (
  output: any,
  context: __SerdeContext
): ComplianceTypeCountLimitExceededException => {
  let contents: any = {
    __type: "ComplianceTypeCountLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1CompliantSummary = (
  output: any,
  context: __SerdeContext
): CompliantSummary => {
  let contents: any = {
    __type: "CompliantSummary",
    CompliantCount: undefined,
    SeveritySummary: undefined
  };
  if (output.CompliantCount !== undefined && output.CompliantCount !== null) {
    contents.CompliantCount = output.CompliantCount;
  }
  if (output.SeveritySummary !== undefined && output.SeveritySummary !== null) {
    contents.SeveritySummary = deserializeAws_json1_1SeveritySummary(
      output.SeveritySummary,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateActivationResult = (
  output: any,
  context: __SerdeContext
): CreateActivationResult => {
  let contents: any = {
    __type: "CreateActivationResult",
    ActivationCode: undefined,
    ActivationId: undefined
  };
  if (output.ActivationCode !== undefined && output.ActivationCode !== null) {
    contents.ActivationCode = output.ActivationCode;
  }
  if (output.ActivationId !== undefined && output.ActivationId !== null) {
    contents.ActivationId = output.ActivationId;
  }
  return contents;
};

const deserializeAws_json1_1CreateAssociationBatchRequestEntry = (
  output: any,
  context: __SerdeContext
): CreateAssociationBatchRequestEntry => {
  let contents: any = {
    __type: "CreateAssociationBatchRequestEntry",
    AssociationName: undefined,
    AutomationTargetParameterName: undefined,
    ComplianceSeverity: undefined,
    DocumentVersion: undefined,
    InstanceId: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    Name: undefined,
    OutputLocation: undefined,
    Parameters: undefined,
    ScheduleExpression: undefined,
    Targets: undefined
  };
  if (output.AssociationName !== undefined && output.AssociationName !== null) {
    contents.AssociationName = output.AssociationName;
  }
  if (
    output.AutomationTargetParameterName !== undefined &&
    output.AutomationTargetParameterName !== null
  ) {
    contents.AutomationTargetParameterName =
      output.AutomationTargetParameterName;
  }
  if (
    output.ComplianceSeverity !== undefined &&
    output.ComplianceSeverity !== null
  ) {
    contents.ComplianceSeverity = output.ComplianceSeverity;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.OutputLocation !== undefined && output.OutputLocation !== null) {
    contents.OutputLocation = deserializeAws_json1_1InstanceAssociationOutputLocation(
      output.OutputLocation,
      context
    );
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1Parameters(
      output.Parameters,
      context
    );
  }
  if (
    output.ScheduleExpression !== undefined &&
    output.ScheduleExpression !== null
  ) {
    contents.ScheduleExpression = output.ScheduleExpression;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  return contents;
};

const deserializeAws_json1_1CreateAssociationBatchResult = (
  output: any,
  context: __SerdeContext
): CreateAssociationBatchResult => {
  let contents: any = {
    __type: "CreateAssociationBatchResult",
    Failed: undefined,
    Successful: undefined
  };
  if (output.Failed !== undefined && output.Failed !== null) {
    contents.Failed = deserializeAws_json1_1FailedCreateAssociationList(
      output.Failed,
      context
    );
  }
  if (output.Successful !== undefined && output.Successful !== null) {
    contents.Successful = deserializeAws_json1_1AssociationDescriptionList(
      output.Successful,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateAssociationResult = (
  output: any,
  context: __SerdeContext
): CreateAssociationResult => {
  let contents: any = {
    __type: "CreateAssociationResult",
    AssociationDescription: undefined
  };
  if (
    output.AssociationDescription !== undefined &&
    output.AssociationDescription !== null
  ) {
    contents.AssociationDescription = deserializeAws_json1_1AssociationDescription(
      output.AssociationDescription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateDocumentResult = (
  output: any,
  context: __SerdeContext
): CreateDocumentResult => {
  let contents: any = {
    __type: "CreateDocumentResult",
    DocumentDescription: undefined
  };
  if (
    output.DocumentDescription !== undefined &&
    output.DocumentDescription !== null
  ) {
    contents.DocumentDescription = deserializeAws_json1_1DocumentDescription(
      output.DocumentDescription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateMaintenanceWindowResult = (
  output: any,
  context: __SerdeContext
): CreateMaintenanceWindowResult => {
  let contents: any = {
    __type: "CreateMaintenanceWindowResult",
    WindowId: undefined
  };
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  return contents;
};

const deserializeAws_json1_1CreateOpsItemResponse = (
  output: any,
  context: __SerdeContext
): CreateOpsItemResponse => {
  let contents: any = {
    __type: "CreateOpsItemResponse",
    OpsItemId: undefined
  };
  if (output.OpsItemId !== undefined && output.OpsItemId !== null) {
    contents.OpsItemId = output.OpsItemId;
  }
  return contents;
};

const deserializeAws_json1_1CreatePatchBaselineResult = (
  output: any,
  context: __SerdeContext
): CreatePatchBaselineResult => {
  let contents: any = {
    __type: "CreatePatchBaselineResult",
    BaselineId: undefined
  };
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  return contents;
};

const deserializeAws_json1_1CreateResourceDataSyncResult = (
  output: any,
  context: __SerdeContext
): CreateResourceDataSyncResult => {
  let contents: any = {
    __type: "CreateResourceDataSyncResult"
  };
  return contents;
};

const deserializeAws_json1_1CustomSchemaCountLimitExceededException = (
  output: any,
  context: __SerdeContext
): CustomSchemaCountLimitExceededException => {
  let contents: any = {
    __type: "CustomSchemaCountLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1DeleteActivationResult = (
  output: any,
  context: __SerdeContext
): DeleteActivationResult => {
  let contents: any = {
    __type: "DeleteActivationResult"
  };
  return contents;
};

const deserializeAws_json1_1DeleteAssociationResult = (
  output: any,
  context: __SerdeContext
): DeleteAssociationResult => {
  let contents: any = {
    __type: "DeleteAssociationResult"
  };
  return contents;
};

const deserializeAws_json1_1DeleteDocumentResult = (
  output: any,
  context: __SerdeContext
): DeleteDocumentResult => {
  let contents: any = {
    __type: "DeleteDocumentResult"
  };
  return contents;
};

const deserializeAws_json1_1DeleteInventoryResult = (
  output: any,
  context: __SerdeContext
): DeleteInventoryResult => {
  let contents: any = {
    __type: "DeleteInventoryResult",
    DeletionId: undefined,
    DeletionSummary: undefined,
    TypeName: undefined
  };
  if (output.DeletionId !== undefined && output.DeletionId !== null) {
    contents.DeletionId = output.DeletionId;
  }
  if (output.DeletionSummary !== undefined && output.DeletionSummary !== null) {
    contents.DeletionSummary = deserializeAws_json1_1InventoryDeletionSummary(
      output.DeletionSummary,
      context
    );
  }
  if (output.TypeName !== undefined && output.TypeName !== null) {
    contents.TypeName = output.TypeName;
  }
  return contents;
};

const deserializeAws_json1_1DeleteMaintenanceWindowResult = (
  output: any,
  context: __SerdeContext
): DeleteMaintenanceWindowResult => {
  let contents: any = {
    __type: "DeleteMaintenanceWindowResult",
    WindowId: undefined
  };
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  return contents;
};

const deserializeAws_json1_1DeleteParameterResult = (
  output: any,
  context: __SerdeContext
): DeleteParameterResult => {
  let contents: any = {
    __type: "DeleteParameterResult"
  };
  return contents;
};

const deserializeAws_json1_1DeleteParametersResult = (
  output: any,
  context: __SerdeContext
): DeleteParametersResult => {
  let contents: any = {
    __type: "DeleteParametersResult",
    DeletedParameters: undefined,
    InvalidParameters: undefined
  };
  if (
    output.DeletedParameters !== undefined &&
    output.DeletedParameters !== null
  ) {
    contents.DeletedParameters = deserializeAws_json1_1ParameterNameList(
      output.DeletedParameters,
      context
    );
  }
  if (
    output.InvalidParameters !== undefined &&
    output.InvalidParameters !== null
  ) {
    contents.InvalidParameters = deserializeAws_json1_1ParameterNameList(
      output.InvalidParameters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeletePatchBaselineResult = (
  output: any,
  context: __SerdeContext
): DeletePatchBaselineResult => {
  let contents: any = {
    __type: "DeletePatchBaselineResult",
    BaselineId: undefined
  };
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  return contents;
};

const deserializeAws_json1_1DeleteResourceDataSyncResult = (
  output: any,
  context: __SerdeContext
): DeleteResourceDataSyncResult => {
  let contents: any = {
    __type: "DeleteResourceDataSyncResult"
  };
  return contents;
};

const deserializeAws_json1_1DeregisterManagedInstanceResult = (
  output: any,
  context: __SerdeContext
): DeregisterManagedInstanceResult => {
  let contents: any = {
    __type: "DeregisterManagedInstanceResult"
  };
  return contents;
};

const deserializeAws_json1_1DeregisterPatchBaselineForPatchGroupResult = (
  output: any,
  context: __SerdeContext
): DeregisterPatchBaselineForPatchGroupResult => {
  let contents: any = {
    __type: "DeregisterPatchBaselineForPatchGroupResult",
    BaselineId: undefined,
    PatchGroup: undefined
  };
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  if (output.PatchGroup !== undefined && output.PatchGroup !== null) {
    contents.PatchGroup = output.PatchGroup;
  }
  return contents;
};

const deserializeAws_json1_1DeregisterTargetFromMaintenanceWindowResult = (
  output: any,
  context: __SerdeContext
): DeregisterTargetFromMaintenanceWindowResult => {
  let contents: any = {
    __type: "DeregisterTargetFromMaintenanceWindowResult",
    WindowId: undefined,
    WindowTargetId: undefined
  };
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  if (output.WindowTargetId !== undefined && output.WindowTargetId !== null) {
    contents.WindowTargetId = output.WindowTargetId;
  }
  return contents;
};

const deserializeAws_json1_1DeregisterTaskFromMaintenanceWindowResult = (
  output: any,
  context: __SerdeContext
): DeregisterTaskFromMaintenanceWindowResult => {
  let contents: any = {
    __type: "DeregisterTaskFromMaintenanceWindowResult",
    WindowId: undefined,
    WindowTaskId: undefined
  };
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  if (output.WindowTaskId !== undefined && output.WindowTaskId !== null) {
    contents.WindowTaskId = output.WindowTaskId;
  }
  return contents;
};

const deserializeAws_json1_1DescribeActivationsResult = (
  output: any,
  context: __SerdeContext
): DescribeActivationsResult => {
  let contents: any = {
    __type: "DescribeActivationsResult",
    ActivationList: undefined,
    NextToken: undefined
  };
  if (output.ActivationList !== undefined && output.ActivationList !== null) {
    contents.ActivationList = deserializeAws_json1_1ActivationList(
      output.ActivationList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeAssociationExecutionTargetsResult = (
  output: any,
  context: __SerdeContext
): DescribeAssociationExecutionTargetsResult => {
  let contents: any = {
    __type: "DescribeAssociationExecutionTargetsResult",
    AssociationExecutionTargets: undefined,
    NextToken: undefined
  };
  if (
    output.AssociationExecutionTargets !== undefined &&
    output.AssociationExecutionTargets !== null
  ) {
    contents.AssociationExecutionTargets = deserializeAws_json1_1AssociationExecutionTargetsList(
      output.AssociationExecutionTargets,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeAssociationExecutionsResult = (
  output: any,
  context: __SerdeContext
): DescribeAssociationExecutionsResult => {
  let contents: any = {
    __type: "DescribeAssociationExecutionsResult",
    AssociationExecutions: undefined,
    NextToken: undefined
  };
  if (
    output.AssociationExecutions !== undefined &&
    output.AssociationExecutions !== null
  ) {
    contents.AssociationExecutions = deserializeAws_json1_1AssociationExecutionsList(
      output.AssociationExecutions,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeAssociationResult = (
  output: any,
  context: __SerdeContext
): DescribeAssociationResult => {
  let contents: any = {
    __type: "DescribeAssociationResult",
    AssociationDescription: undefined
  };
  if (
    output.AssociationDescription !== undefined &&
    output.AssociationDescription !== null
  ) {
    contents.AssociationDescription = deserializeAws_json1_1AssociationDescription(
      output.AssociationDescription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeAutomationExecutionsResult = (
  output: any,
  context: __SerdeContext
): DescribeAutomationExecutionsResult => {
  let contents: any = {
    __type: "DescribeAutomationExecutionsResult",
    AutomationExecutionMetadataList: undefined,
    NextToken: undefined
  };
  if (
    output.AutomationExecutionMetadataList !== undefined &&
    output.AutomationExecutionMetadataList !== null
  ) {
    contents.AutomationExecutionMetadataList = deserializeAws_json1_1AutomationExecutionMetadataList(
      output.AutomationExecutionMetadataList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeAutomationStepExecutionsResult = (
  output: any,
  context: __SerdeContext
): DescribeAutomationStepExecutionsResult => {
  let contents: any = {
    __type: "DescribeAutomationStepExecutionsResult",
    NextToken: undefined,
    StepExecutions: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.StepExecutions !== undefined && output.StepExecutions !== null) {
    contents.StepExecutions = deserializeAws_json1_1StepExecutionList(
      output.StepExecutions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeAvailablePatchesResult = (
  output: any,
  context: __SerdeContext
): DescribeAvailablePatchesResult => {
  let contents: any = {
    __type: "DescribeAvailablePatchesResult",
    NextToken: undefined,
    Patches: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Patches !== undefined && output.Patches !== null) {
    contents.Patches = deserializeAws_json1_1PatchList(output.Patches, context);
  }
  return contents;
};

const deserializeAws_json1_1DescribeDocumentPermissionResponse = (
  output: any,
  context: __SerdeContext
): DescribeDocumentPermissionResponse => {
  let contents: any = {
    __type: "DescribeDocumentPermissionResponse",
    AccountIds: undefined,
    AccountSharingInfoList: undefined
  };
  if (output.AccountIds !== undefined && output.AccountIds !== null) {
    contents.AccountIds = deserializeAws_json1_1AccountIdList(
      output.AccountIds,
      context
    );
  }
  if (
    output.AccountSharingInfoList !== undefined &&
    output.AccountSharingInfoList !== null
  ) {
    contents.AccountSharingInfoList = deserializeAws_json1_1AccountSharingInfoList(
      output.AccountSharingInfoList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeDocumentResult = (
  output: any,
  context: __SerdeContext
): DescribeDocumentResult => {
  let contents: any = {
    __type: "DescribeDocumentResult",
    Document: undefined
  };
  if (output.Document !== undefined && output.Document !== null) {
    contents.Document = deserializeAws_json1_1DocumentDescription(
      output.Document,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEffectiveInstanceAssociationsResult = (
  output: any,
  context: __SerdeContext
): DescribeEffectiveInstanceAssociationsResult => {
  let contents: any = {
    __type: "DescribeEffectiveInstanceAssociationsResult",
    Associations: undefined,
    NextToken: undefined
  };
  if (output.Associations !== undefined && output.Associations !== null) {
    contents.Associations = deserializeAws_json1_1InstanceAssociationList(
      output.Associations,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeEffectivePatchesForPatchBaselineResult = (
  output: any,
  context: __SerdeContext
): DescribeEffectivePatchesForPatchBaselineResult => {
  let contents: any = {
    __type: "DescribeEffectivePatchesForPatchBaselineResult",
    EffectivePatches: undefined,
    NextToken: undefined
  };
  if (
    output.EffectivePatches !== undefined &&
    output.EffectivePatches !== null
  ) {
    contents.EffectivePatches = deserializeAws_json1_1EffectivePatchList(
      output.EffectivePatches,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeInstanceAssociationsStatusResult = (
  output: any,
  context: __SerdeContext
): DescribeInstanceAssociationsStatusResult => {
  let contents: any = {
    __type: "DescribeInstanceAssociationsStatusResult",
    InstanceAssociationStatusInfos: undefined,
    NextToken: undefined
  };
  if (
    output.InstanceAssociationStatusInfos !== undefined &&
    output.InstanceAssociationStatusInfos !== null
  ) {
    contents.InstanceAssociationStatusInfos = deserializeAws_json1_1InstanceAssociationStatusInfos(
      output.InstanceAssociationStatusInfos,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeInstanceInformationResult = (
  output: any,
  context: __SerdeContext
): DescribeInstanceInformationResult => {
  let contents: any = {
    __type: "DescribeInstanceInformationResult",
    InstanceInformationList: undefined,
    NextToken: undefined
  };
  if (
    output.InstanceInformationList !== undefined &&
    output.InstanceInformationList !== null
  ) {
    contents.InstanceInformationList = deserializeAws_json1_1InstanceInformationList(
      output.InstanceInformationList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeInstancePatchStatesForPatchGroupResult = (
  output: any,
  context: __SerdeContext
): DescribeInstancePatchStatesForPatchGroupResult => {
  let contents: any = {
    __type: "DescribeInstancePatchStatesForPatchGroupResult",
    InstancePatchStates: undefined,
    NextToken: undefined
  };
  if (
    output.InstancePatchStates !== undefined &&
    output.InstancePatchStates !== null
  ) {
    contents.InstancePatchStates = deserializeAws_json1_1InstancePatchStatesList(
      output.InstancePatchStates,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeInstancePatchStatesResult = (
  output: any,
  context: __SerdeContext
): DescribeInstancePatchStatesResult => {
  let contents: any = {
    __type: "DescribeInstancePatchStatesResult",
    InstancePatchStates: undefined,
    NextToken: undefined
  };
  if (
    output.InstancePatchStates !== undefined &&
    output.InstancePatchStates !== null
  ) {
    contents.InstancePatchStates = deserializeAws_json1_1InstancePatchStateList(
      output.InstancePatchStates,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeInstancePatchesResult = (
  output: any,
  context: __SerdeContext
): DescribeInstancePatchesResult => {
  let contents: any = {
    __type: "DescribeInstancePatchesResult",
    NextToken: undefined,
    Patches: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Patches !== undefined && output.Patches !== null) {
    contents.Patches = deserializeAws_json1_1PatchComplianceDataList(
      output.Patches,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeInventoryDeletionsResult = (
  output: any,
  context: __SerdeContext
): DescribeInventoryDeletionsResult => {
  let contents: any = {
    __type: "DescribeInventoryDeletionsResult",
    InventoryDeletions: undefined,
    NextToken: undefined
  };
  if (
    output.InventoryDeletions !== undefined &&
    output.InventoryDeletions !== null
  ) {
    contents.InventoryDeletions = deserializeAws_json1_1InventoryDeletionsList(
      output.InventoryDeletions,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeMaintenanceWindowExecutionTaskInvocationsResult = (
  output: any,
  context: __SerdeContext
): DescribeMaintenanceWindowExecutionTaskInvocationsResult => {
  let contents: any = {
    __type: "DescribeMaintenanceWindowExecutionTaskInvocationsResult",
    NextToken: undefined,
    WindowExecutionTaskInvocationIdentities: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.WindowExecutionTaskInvocationIdentities !== undefined &&
    output.WindowExecutionTaskInvocationIdentities !== null
  ) {
    contents.WindowExecutionTaskInvocationIdentities = deserializeAws_json1_1MaintenanceWindowExecutionTaskInvocationIdentityList(
      output.WindowExecutionTaskInvocationIdentities,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeMaintenanceWindowExecutionTasksResult = (
  output: any,
  context: __SerdeContext
): DescribeMaintenanceWindowExecutionTasksResult => {
  let contents: any = {
    __type: "DescribeMaintenanceWindowExecutionTasksResult",
    NextToken: undefined,
    WindowExecutionTaskIdentities: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.WindowExecutionTaskIdentities !== undefined &&
    output.WindowExecutionTaskIdentities !== null
  ) {
    contents.WindowExecutionTaskIdentities = deserializeAws_json1_1MaintenanceWindowExecutionTaskIdentityList(
      output.WindowExecutionTaskIdentities,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeMaintenanceWindowExecutionsResult = (
  output: any,
  context: __SerdeContext
): DescribeMaintenanceWindowExecutionsResult => {
  let contents: any = {
    __type: "DescribeMaintenanceWindowExecutionsResult",
    NextToken: undefined,
    WindowExecutions: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.WindowExecutions !== undefined &&
    output.WindowExecutions !== null
  ) {
    contents.WindowExecutions = deserializeAws_json1_1MaintenanceWindowExecutionList(
      output.WindowExecutions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeMaintenanceWindowScheduleResult = (
  output: any,
  context: __SerdeContext
): DescribeMaintenanceWindowScheduleResult => {
  let contents: any = {
    __type: "DescribeMaintenanceWindowScheduleResult",
    NextToken: undefined,
    ScheduledWindowExecutions: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.ScheduledWindowExecutions !== undefined &&
    output.ScheduledWindowExecutions !== null
  ) {
    contents.ScheduledWindowExecutions = deserializeAws_json1_1ScheduledWindowExecutionList(
      output.ScheduledWindowExecutions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeMaintenanceWindowTargetsResult = (
  output: any,
  context: __SerdeContext
): DescribeMaintenanceWindowTargetsResult => {
  let contents: any = {
    __type: "DescribeMaintenanceWindowTargetsResult",
    NextToken: undefined,
    Targets: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1MaintenanceWindowTargetList(
      output.Targets,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeMaintenanceWindowTasksResult = (
  output: any,
  context: __SerdeContext
): DescribeMaintenanceWindowTasksResult => {
  let contents: any = {
    __type: "DescribeMaintenanceWindowTasksResult",
    NextToken: undefined,
    Tasks: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Tasks !== undefined && output.Tasks !== null) {
    contents.Tasks = deserializeAws_json1_1MaintenanceWindowTaskList(
      output.Tasks,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeMaintenanceWindowsForTargetResult = (
  output: any,
  context: __SerdeContext
): DescribeMaintenanceWindowsForTargetResult => {
  let contents: any = {
    __type: "DescribeMaintenanceWindowsForTargetResult",
    NextToken: undefined,
    WindowIdentities: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.WindowIdentities !== undefined &&
    output.WindowIdentities !== null
  ) {
    contents.WindowIdentities = deserializeAws_json1_1MaintenanceWindowsForTargetList(
      output.WindowIdentities,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeMaintenanceWindowsResult = (
  output: any,
  context: __SerdeContext
): DescribeMaintenanceWindowsResult => {
  let contents: any = {
    __type: "DescribeMaintenanceWindowsResult",
    NextToken: undefined,
    WindowIdentities: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.WindowIdentities !== undefined &&
    output.WindowIdentities !== null
  ) {
    contents.WindowIdentities = deserializeAws_json1_1MaintenanceWindowIdentityList(
      output.WindowIdentities,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeOpsItemsResponse = (
  output: any,
  context: __SerdeContext
): DescribeOpsItemsResponse => {
  let contents: any = {
    __type: "DescribeOpsItemsResponse",
    NextToken: undefined,
    OpsItemSummaries: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.OpsItemSummaries !== undefined &&
    output.OpsItemSummaries !== null
  ) {
    contents.OpsItemSummaries = deserializeAws_json1_1OpsItemSummaries(
      output.OpsItemSummaries,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeParametersResult = (
  output: any,
  context: __SerdeContext
): DescribeParametersResult => {
  let contents: any = {
    __type: "DescribeParametersResult",
    NextToken: undefined,
    Parameters: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParameterMetadataList(
      output.Parameters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribePatchBaselinesResult = (
  output: any,
  context: __SerdeContext
): DescribePatchBaselinesResult => {
  let contents: any = {
    __type: "DescribePatchBaselinesResult",
    BaselineIdentities: undefined,
    NextToken: undefined
  };
  if (
    output.BaselineIdentities !== undefined &&
    output.BaselineIdentities !== null
  ) {
    contents.BaselineIdentities = deserializeAws_json1_1PatchBaselineIdentityList(
      output.BaselineIdentities,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribePatchGroupStateResult = (
  output: any,
  context: __SerdeContext
): DescribePatchGroupStateResult => {
  let contents: any = {
    __type: "DescribePatchGroupStateResult",
    Instances: undefined,
    InstancesWithFailedPatches: undefined,
    InstancesWithInstalledOtherPatches: undefined,
    InstancesWithInstalledPatches: undefined,
    InstancesWithInstalledPendingRebootPatches: undefined,
    InstancesWithInstalledRejectedPatches: undefined,
    InstancesWithMissingPatches: undefined,
    InstancesWithNotApplicablePatches: undefined,
    InstancesWithUnreportedNotApplicablePatches: undefined
  };
  if (output.Instances !== undefined && output.Instances !== null) {
    contents.Instances = output.Instances;
  }
  if (
    output.InstancesWithFailedPatches !== undefined &&
    output.InstancesWithFailedPatches !== null
  ) {
    contents.InstancesWithFailedPatches = output.InstancesWithFailedPatches;
  }
  if (
    output.InstancesWithInstalledOtherPatches !== undefined &&
    output.InstancesWithInstalledOtherPatches !== null
  ) {
    contents.InstancesWithInstalledOtherPatches =
      output.InstancesWithInstalledOtherPatches;
  }
  if (
    output.InstancesWithInstalledPatches !== undefined &&
    output.InstancesWithInstalledPatches !== null
  ) {
    contents.InstancesWithInstalledPatches =
      output.InstancesWithInstalledPatches;
  }
  if (
    output.InstancesWithInstalledPendingRebootPatches !== undefined &&
    output.InstancesWithInstalledPendingRebootPatches !== null
  ) {
    contents.InstancesWithInstalledPendingRebootPatches =
      output.InstancesWithInstalledPendingRebootPatches;
  }
  if (
    output.InstancesWithInstalledRejectedPatches !== undefined &&
    output.InstancesWithInstalledRejectedPatches !== null
  ) {
    contents.InstancesWithInstalledRejectedPatches =
      output.InstancesWithInstalledRejectedPatches;
  }
  if (
    output.InstancesWithMissingPatches !== undefined &&
    output.InstancesWithMissingPatches !== null
  ) {
    contents.InstancesWithMissingPatches = output.InstancesWithMissingPatches;
  }
  if (
    output.InstancesWithNotApplicablePatches !== undefined &&
    output.InstancesWithNotApplicablePatches !== null
  ) {
    contents.InstancesWithNotApplicablePatches =
      output.InstancesWithNotApplicablePatches;
  }
  if (
    output.InstancesWithUnreportedNotApplicablePatches !== undefined &&
    output.InstancesWithUnreportedNotApplicablePatches !== null
  ) {
    contents.InstancesWithUnreportedNotApplicablePatches =
      output.InstancesWithUnreportedNotApplicablePatches;
  }
  return contents;
};

const deserializeAws_json1_1DescribePatchGroupsResult = (
  output: any,
  context: __SerdeContext
): DescribePatchGroupsResult => {
  let contents: any = {
    __type: "DescribePatchGroupsResult",
    Mappings: undefined,
    NextToken: undefined
  };
  if (output.Mappings !== undefined && output.Mappings !== null) {
    contents.Mappings = deserializeAws_json1_1PatchGroupPatchBaselineMappingList(
      output.Mappings,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribePatchPropertiesResult = (
  output: any,
  context: __SerdeContext
): DescribePatchPropertiesResult => {
  let contents: any = {
    __type: "DescribePatchPropertiesResult",
    NextToken: undefined,
    Properties: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Properties !== undefined && output.Properties !== null) {
    contents.Properties = deserializeAws_json1_1PatchPropertiesList(
      output.Properties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeSessionsResponse = (
  output: any,
  context: __SerdeContext
): DescribeSessionsResponse => {
  let contents: any = {
    __type: "DescribeSessionsResponse",
    NextToken: undefined,
    Sessions: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Sessions !== undefined && output.Sessions !== null) {
    contents.Sessions = deserializeAws_json1_1SessionList(
      output.Sessions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DocumentAlreadyExists = (
  output: any,
  context: __SerdeContext
): DocumentAlreadyExists => {
  let contents: any = {
    __type: "DocumentAlreadyExists",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1DocumentDefaultVersionDescription = (
  output: any,
  context: __SerdeContext
): DocumentDefaultVersionDescription => {
  let contents: any = {
    __type: "DocumentDefaultVersionDescription",
    DefaultVersion: undefined,
    DefaultVersionName: undefined,
    Name: undefined
  };
  if (output.DefaultVersion !== undefined && output.DefaultVersion !== null) {
    contents.DefaultVersion = output.DefaultVersion;
  }
  if (
    output.DefaultVersionName !== undefined &&
    output.DefaultVersionName !== null
  ) {
    contents.DefaultVersionName = output.DefaultVersionName;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1DocumentDescription = (
  output: any,
  context: __SerdeContext
): DocumentDescription => {
  let contents: any = {
    __type: "DocumentDescription",
    AttachmentsInformation: undefined,
    CreatedDate: undefined,
    DefaultVersion: undefined,
    Description: undefined,
    DocumentFormat: undefined,
    DocumentType: undefined,
    DocumentVersion: undefined,
    Hash: undefined,
    HashType: undefined,
    LatestVersion: undefined,
    Name: undefined,
    Owner: undefined,
    Parameters: undefined,
    PlatformTypes: undefined,
    Requires: undefined,
    SchemaVersion: undefined,
    Sha1: undefined,
    Status: undefined,
    StatusInformation: undefined,
    Tags: undefined,
    TargetType: undefined,
    VersionName: undefined
  };
  if (
    output.AttachmentsInformation !== undefined &&
    output.AttachmentsInformation !== null
  ) {
    contents.AttachmentsInformation = deserializeAws_json1_1AttachmentInformationList(
      output.AttachmentsInformation,
      context
    );
  }
  if (output.CreatedDate !== undefined && output.CreatedDate !== null) {
    contents.CreatedDate = new Date(Math.round(output.CreatedDate * 1000));
  }
  if (output.DefaultVersion !== undefined && output.DefaultVersion !== null) {
    contents.DefaultVersion = output.DefaultVersion;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.DocumentFormat !== undefined && output.DocumentFormat !== null) {
    contents.DocumentFormat = output.DocumentFormat;
  }
  if (output.DocumentType !== undefined && output.DocumentType !== null) {
    contents.DocumentType = output.DocumentType;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.Hash !== undefined && output.Hash !== null) {
    contents.Hash = output.Hash;
  }
  if (output.HashType !== undefined && output.HashType !== null) {
    contents.HashType = output.HashType;
  }
  if (output.LatestVersion !== undefined && output.LatestVersion !== null) {
    contents.LatestVersion = output.LatestVersion;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Owner !== undefined && output.Owner !== null) {
    contents.Owner = output.Owner;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1DocumentParameterList(
      output.Parameters,
      context
    );
  }
  if (output.PlatformTypes !== undefined && output.PlatformTypes !== null) {
    contents.PlatformTypes = deserializeAws_json1_1PlatformTypeList(
      output.PlatformTypes,
      context
    );
  }
  if (output.Requires !== undefined && output.Requires !== null) {
    contents.Requires = deserializeAws_json1_1DocumentRequiresList(
      output.Requires,
      context
    );
  }
  if (output.SchemaVersion !== undefined && output.SchemaVersion !== null) {
    contents.SchemaVersion = output.SchemaVersion;
  }
  if (output.Sha1 !== undefined && output.Sha1 !== null) {
    contents.Sha1 = output.Sha1;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (
    output.StatusInformation !== undefined &&
    output.StatusInformation !== null
  ) {
    contents.StatusInformation = output.StatusInformation;
  }
  if (output.Tags !== undefined && output.Tags !== null) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  if (output.TargetType !== undefined && output.TargetType !== null) {
    contents.TargetType = output.TargetType;
  }
  if (output.VersionName !== undefined && output.VersionName !== null) {
    contents.VersionName = output.VersionName;
  }
  return contents;
};

const deserializeAws_json1_1DocumentIdentifier = (
  output: any,
  context: __SerdeContext
): DocumentIdentifier => {
  let contents: any = {
    __type: "DocumentIdentifier",
    DocumentFormat: undefined,
    DocumentType: undefined,
    DocumentVersion: undefined,
    Name: undefined,
    Owner: undefined,
    PlatformTypes: undefined,
    Requires: undefined,
    SchemaVersion: undefined,
    Tags: undefined,
    TargetType: undefined,
    VersionName: undefined
  };
  if (output.DocumentFormat !== undefined && output.DocumentFormat !== null) {
    contents.DocumentFormat = output.DocumentFormat;
  }
  if (output.DocumentType !== undefined && output.DocumentType !== null) {
    contents.DocumentType = output.DocumentType;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Owner !== undefined && output.Owner !== null) {
    contents.Owner = output.Owner;
  }
  if (output.PlatformTypes !== undefined && output.PlatformTypes !== null) {
    contents.PlatformTypes = deserializeAws_json1_1PlatformTypeList(
      output.PlatformTypes,
      context
    );
  }
  if (output.Requires !== undefined && output.Requires !== null) {
    contents.Requires = deserializeAws_json1_1DocumentRequiresList(
      output.Requires,
      context
    );
  }
  if (output.SchemaVersion !== undefined && output.SchemaVersion !== null) {
    contents.SchemaVersion = output.SchemaVersion;
  }
  if (output.Tags !== undefined && output.Tags !== null) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  if (output.TargetType !== undefined && output.TargetType !== null) {
    contents.TargetType = output.TargetType;
  }
  if (output.VersionName !== undefined && output.VersionName !== null) {
    contents.VersionName = output.VersionName;
  }
  return contents;
};

const deserializeAws_json1_1DocumentIdentifierList = (
  output: any,
  context: __SerdeContext
): Array<DocumentIdentifier> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentIdentifier(entry, context)
  );
};

const deserializeAws_json1_1DocumentLimitExceeded = (
  output: any,
  context: __SerdeContext
): DocumentLimitExceeded => {
  let contents: any = {
    __type: "DocumentLimitExceeded",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1DocumentParameter = (
  output: any,
  context: __SerdeContext
): DocumentParameter => {
  let contents: any = {
    __type: "DocumentParameter",
    DefaultValue: undefined,
    Description: undefined,
    Name: undefined,
    Type: undefined
  };
  if (output.DefaultValue !== undefined && output.DefaultValue !== null) {
    contents.DefaultValue = output.DefaultValue;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1DocumentParameterList = (
  output: any,
  context: __SerdeContext
): Array<DocumentParameter> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentParameter(entry, context)
  );
};

const deserializeAws_json1_1DocumentPermissionLimit = (
  output: any,
  context: __SerdeContext
): DocumentPermissionLimit => {
  let contents: any = {
    __type: "DocumentPermissionLimit",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1DocumentRequires = (
  output: any,
  context: __SerdeContext
): DocumentRequires => {
  let contents: any = {
    __type: "DocumentRequires",
    Name: undefined,
    Version: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1DocumentRequiresList = (
  output: any,
  context: __SerdeContext
): Array<DocumentRequires> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentRequires(entry, context)
  );
};

const deserializeAws_json1_1DocumentVersionInfo = (
  output: any,
  context: __SerdeContext
): DocumentVersionInfo => {
  let contents: any = {
    __type: "DocumentVersionInfo",
    CreatedDate: undefined,
    DocumentFormat: undefined,
    DocumentVersion: undefined,
    IsDefaultVersion: undefined,
    Name: undefined,
    Status: undefined,
    StatusInformation: undefined,
    VersionName: undefined
  };
  if (output.CreatedDate !== undefined && output.CreatedDate !== null) {
    contents.CreatedDate = new Date(Math.round(output.CreatedDate * 1000));
  }
  if (output.DocumentFormat !== undefined && output.DocumentFormat !== null) {
    contents.DocumentFormat = output.DocumentFormat;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (
    output.IsDefaultVersion !== undefined &&
    output.IsDefaultVersion !== null
  ) {
    contents.IsDefaultVersion = output.IsDefaultVersion;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (
    output.StatusInformation !== undefined &&
    output.StatusInformation !== null
  ) {
    contents.StatusInformation = output.StatusInformation;
  }
  if (output.VersionName !== undefined && output.VersionName !== null) {
    contents.VersionName = output.VersionName;
  }
  return contents;
};

const deserializeAws_json1_1DocumentVersionLimitExceeded = (
  output: any,
  context: __SerdeContext
): DocumentVersionLimitExceeded => {
  let contents: any = {
    __type: "DocumentVersionLimitExceeded",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1DocumentVersionList = (
  output: any,
  context: __SerdeContext
): Array<DocumentVersionInfo> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentVersionInfo(entry, context)
  );
};

const deserializeAws_json1_1DoesNotExistException = (
  output: any,
  context: __SerdeContext
): DoesNotExistException => {
  let contents: any = {
    __type: "DoesNotExistException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1DuplicateDocumentContent = (
  output: any,
  context: __SerdeContext
): DuplicateDocumentContent => {
  let contents: any = {
    __type: "DuplicateDocumentContent",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1DuplicateDocumentVersionName = (
  output: any,
  context: __SerdeContext
): DuplicateDocumentVersionName => {
  let contents: any = {
    __type: "DuplicateDocumentVersionName",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1DuplicateInstanceId = (
  output: any,
  context: __SerdeContext
): DuplicateInstanceId => {
  let contents: any = {
    __type: "DuplicateInstanceId"
  };
  return contents;
};

const deserializeAws_json1_1EffectivePatch = (
  output: any,
  context: __SerdeContext
): EffectivePatch => {
  let contents: any = {
    __type: "EffectivePatch",
    Patch: undefined,
    PatchStatus: undefined
  };
  if (output.Patch !== undefined && output.Patch !== null) {
    contents.Patch = deserializeAws_json1_1Patch(output.Patch, context);
  }
  if (output.PatchStatus !== undefined && output.PatchStatus !== null) {
    contents.PatchStatus = deserializeAws_json1_1PatchStatus(
      output.PatchStatus,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1EffectivePatchList = (
  output: any,
  context: __SerdeContext
): Array<EffectivePatch> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EffectivePatch(entry, context)
  );
};

const deserializeAws_json1_1FailedCreateAssociation = (
  output: any,
  context: __SerdeContext
): FailedCreateAssociation => {
  let contents: any = {
    __type: "FailedCreateAssociation",
    Entry: undefined,
    Fault: undefined,
    Message: undefined
  };
  if (output.Entry !== undefined && output.Entry !== null) {
    contents.Entry = deserializeAws_json1_1CreateAssociationBatchRequestEntry(
      output.Entry,
      context
    );
  }
  if (output.Fault !== undefined && output.Fault !== null) {
    contents.Fault = output.Fault;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1FailedCreateAssociationList = (
  output: any,
  context: __SerdeContext
): Array<FailedCreateAssociation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1FailedCreateAssociation(entry, context)
  );
};

const deserializeAws_json1_1FailureDetails = (
  output: any,
  context: __SerdeContext
): FailureDetails => {
  let contents: any = {
    __type: "FailureDetails",
    Details: undefined,
    FailureStage: undefined,
    FailureType: undefined
  };
  if (output.Details !== undefined && output.Details !== null) {
    contents.Details = deserializeAws_json1_1AutomationParameterMap(
      output.Details,
      context
    );
  }
  if (output.FailureStage !== undefined && output.FailureStage !== null) {
    contents.FailureStage = output.FailureStage;
  }
  if (output.FailureType !== undefined && output.FailureType !== null) {
    contents.FailureType = output.FailureType;
  }
  return contents;
};

const deserializeAws_json1_1FeatureNotAvailableException = (
  output: any,
  context: __SerdeContext
): FeatureNotAvailableException => {
  let contents: any = {
    __type: "FeatureNotAvailableException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1GetAutomationExecutionResult = (
  output: any,
  context: __SerdeContext
): GetAutomationExecutionResult => {
  let contents: any = {
    __type: "GetAutomationExecutionResult",
    AutomationExecution: undefined
  };
  if (
    output.AutomationExecution !== undefined &&
    output.AutomationExecution !== null
  ) {
    contents.AutomationExecution = deserializeAws_json1_1AutomationExecution(
      output.AutomationExecution,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetCalendarStateResponse = (
  output: any,
  context: __SerdeContext
): GetCalendarStateResponse => {
  let contents: any = {
    __type: "GetCalendarStateResponse",
    AtTime: undefined,
    NextTransitionTime: undefined,
    State: undefined
  };
  if (output.AtTime !== undefined && output.AtTime !== null) {
    contents.AtTime = output.AtTime;
  }
  if (
    output.NextTransitionTime !== undefined &&
    output.NextTransitionTime !== null
  ) {
    contents.NextTransitionTime = output.NextTransitionTime;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  return contents;
};

const deserializeAws_json1_1GetCommandInvocationResult = (
  output: any,
  context: __SerdeContext
): GetCommandInvocationResult => {
  let contents: any = {
    __type: "GetCommandInvocationResult",
    CloudWatchOutputConfig: undefined,
    CommandId: undefined,
    Comment: undefined,
    DocumentName: undefined,
    DocumentVersion: undefined,
    ExecutionElapsedTime: undefined,
    ExecutionEndDateTime: undefined,
    ExecutionStartDateTime: undefined,
    InstanceId: undefined,
    PluginName: undefined,
    ResponseCode: undefined,
    StandardErrorContent: undefined,
    StandardErrorUrl: undefined,
    StandardOutputContent: undefined,
    StandardOutputUrl: undefined,
    Status: undefined,
    StatusDetails: undefined
  };
  if (
    output.CloudWatchOutputConfig !== undefined &&
    output.CloudWatchOutputConfig !== null
  ) {
    contents.CloudWatchOutputConfig = deserializeAws_json1_1CloudWatchOutputConfig(
      output.CloudWatchOutputConfig,
      context
    );
  }
  if (output.CommandId !== undefined && output.CommandId !== null) {
    contents.CommandId = output.CommandId;
  }
  if (output.Comment !== undefined && output.Comment !== null) {
    contents.Comment = output.Comment;
  }
  if (output.DocumentName !== undefined && output.DocumentName !== null) {
    contents.DocumentName = output.DocumentName;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (
    output.ExecutionElapsedTime !== undefined &&
    output.ExecutionElapsedTime !== null
  ) {
    contents.ExecutionElapsedTime = output.ExecutionElapsedTime;
  }
  if (
    output.ExecutionEndDateTime !== undefined &&
    output.ExecutionEndDateTime !== null
  ) {
    contents.ExecutionEndDateTime = output.ExecutionEndDateTime;
  }
  if (
    output.ExecutionStartDateTime !== undefined &&
    output.ExecutionStartDateTime !== null
  ) {
    contents.ExecutionStartDateTime = output.ExecutionStartDateTime;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (output.PluginName !== undefined && output.PluginName !== null) {
    contents.PluginName = output.PluginName;
  }
  if (output.ResponseCode !== undefined && output.ResponseCode !== null) {
    contents.ResponseCode = output.ResponseCode;
  }
  if (
    output.StandardErrorContent !== undefined &&
    output.StandardErrorContent !== null
  ) {
    contents.StandardErrorContent = output.StandardErrorContent;
  }
  if (
    output.StandardErrorUrl !== undefined &&
    output.StandardErrorUrl !== null
  ) {
    contents.StandardErrorUrl = output.StandardErrorUrl;
  }
  if (
    output.StandardOutputContent !== undefined &&
    output.StandardOutputContent !== null
  ) {
    contents.StandardOutputContent = output.StandardOutputContent;
  }
  if (
    output.StandardOutputUrl !== undefined &&
    output.StandardOutputUrl !== null
  ) {
    contents.StandardOutputUrl = output.StandardOutputUrl;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  return contents;
};

const deserializeAws_json1_1GetConnectionStatusResponse = (
  output: any,
  context: __SerdeContext
): GetConnectionStatusResponse => {
  let contents: any = {
    __type: "GetConnectionStatusResponse",
    Status: undefined,
    Target: undefined
  };
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Target !== undefined && output.Target !== null) {
    contents.Target = output.Target;
  }
  return contents;
};

const deserializeAws_json1_1GetDefaultPatchBaselineResult = (
  output: any,
  context: __SerdeContext
): GetDefaultPatchBaselineResult => {
  let contents: any = {
    __type: "GetDefaultPatchBaselineResult",
    BaselineId: undefined,
    OperatingSystem: undefined
  };
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  if (output.OperatingSystem !== undefined && output.OperatingSystem !== null) {
    contents.OperatingSystem = output.OperatingSystem;
  }
  return contents;
};

const deserializeAws_json1_1GetDeployablePatchSnapshotForInstanceResult = (
  output: any,
  context: __SerdeContext
): GetDeployablePatchSnapshotForInstanceResult => {
  let contents: any = {
    __type: "GetDeployablePatchSnapshotForInstanceResult",
    InstanceId: undefined,
    Product: undefined,
    SnapshotDownloadUrl: undefined,
    SnapshotId: undefined
  };
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (output.Product !== undefined && output.Product !== null) {
    contents.Product = output.Product;
  }
  if (
    output.SnapshotDownloadUrl !== undefined &&
    output.SnapshotDownloadUrl !== null
  ) {
    contents.SnapshotDownloadUrl = output.SnapshotDownloadUrl;
  }
  if (output.SnapshotId !== undefined && output.SnapshotId !== null) {
    contents.SnapshotId = output.SnapshotId;
  }
  return contents;
};

const deserializeAws_json1_1GetDocumentResult = (
  output: any,
  context: __SerdeContext
): GetDocumentResult => {
  let contents: any = {
    __type: "GetDocumentResult",
    AttachmentsContent: undefined,
    Content: undefined,
    DocumentFormat: undefined,
    DocumentType: undefined,
    DocumentVersion: undefined,
    Name: undefined,
    Requires: undefined,
    Status: undefined,
    StatusInformation: undefined,
    VersionName: undefined
  };
  if (
    output.AttachmentsContent !== undefined &&
    output.AttachmentsContent !== null
  ) {
    contents.AttachmentsContent = deserializeAws_json1_1AttachmentContentList(
      output.AttachmentsContent,
      context
    );
  }
  if (output.Content !== undefined && output.Content !== null) {
    contents.Content = output.Content;
  }
  if (output.DocumentFormat !== undefined && output.DocumentFormat !== null) {
    contents.DocumentFormat = output.DocumentFormat;
  }
  if (output.DocumentType !== undefined && output.DocumentType !== null) {
    contents.DocumentType = output.DocumentType;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Requires !== undefined && output.Requires !== null) {
    contents.Requires = deserializeAws_json1_1DocumentRequiresList(
      output.Requires,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (
    output.StatusInformation !== undefined &&
    output.StatusInformation !== null
  ) {
    contents.StatusInformation = output.StatusInformation;
  }
  if (output.VersionName !== undefined && output.VersionName !== null) {
    contents.VersionName = output.VersionName;
  }
  return contents;
};

const deserializeAws_json1_1GetInventoryResult = (
  output: any,
  context: __SerdeContext
): GetInventoryResult => {
  let contents: any = {
    __type: "GetInventoryResult",
    Entities: undefined,
    NextToken: undefined
  };
  if (output.Entities !== undefined && output.Entities !== null) {
    contents.Entities = deserializeAws_json1_1InventoryResultEntityList(
      output.Entities,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetInventorySchemaResult = (
  output: any,
  context: __SerdeContext
): GetInventorySchemaResult => {
  let contents: any = {
    __type: "GetInventorySchemaResult",
    NextToken: undefined,
    Schemas: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Schemas !== undefined && output.Schemas !== null) {
    contents.Schemas = deserializeAws_json1_1InventoryItemSchemaResultList(
      output.Schemas,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetMaintenanceWindowExecutionResult = (
  output: any,
  context: __SerdeContext
): GetMaintenanceWindowExecutionResult => {
  let contents: any = {
    __type: "GetMaintenanceWindowExecutionResult",
    EndTime: undefined,
    StartTime: undefined,
    Status: undefined,
    StatusDetails: undefined,
    TaskIds: undefined,
    WindowExecutionId: undefined
  };
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  if (output.TaskIds !== undefined && output.TaskIds !== null) {
    contents.TaskIds = deserializeAws_json1_1MaintenanceWindowExecutionTaskIdList(
      output.TaskIds,
      context
    );
  }
  if (
    output.WindowExecutionId !== undefined &&
    output.WindowExecutionId !== null
  ) {
    contents.WindowExecutionId = output.WindowExecutionId;
  }
  return contents;
};

const deserializeAws_json1_1GetMaintenanceWindowExecutionTaskInvocationResult = (
  output: any,
  context: __SerdeContext
): GetMaintenanceWindowExecutionTaskInvocationResult => {
  let contents: any = {
    __type: "GetMaintenanceWindowExecutionTaskInvocationResult",
    EndTime: undefined,
    ExecutionId: undefined,
    InvocationId: undefined,
    OwnerInformation: undefined,
    Parameters: undefined,
    StartTime: undefined,
    Status: undefined,
    StatusDetails: undefined,
    TaskExecutionId: undefined,
    TaskType: undefined,
    WindowExecutionId: undefined,
    WindowTargetId: undefined
  };
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.ExecutionId !== undefined && output.ExecutionId !== null) {
    contents.ExecutionId = output.ExecutionId;
  }
  if (output.InvocationId !== undefined && output.InvocationId !== null) {
    contents.InvocationId = output.InvocationId;
  }
  if (
    output.OwnerInformation !== undefined &&
    output.OwnerInformation !== null
  ) {
    contents.OwnerInformation = output.OwnerInformation;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = output.Parameters;
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  if (output.TaskExecutionId !== undefined && output.TaskExecutionId !== null) {
    contents.TaskExecutionId = output.TaskExecutionId;
  }
  if (output.TaskType !== undefined && output.TaskType !== null) {
    contents.TaskType = output.TaskType;
  }
  if (
    output.WindowExecutionId !== undefined &&
    output.WindowExecutionId !== null
  ) {
    contents.WindowExecutionId = output.WindowExecutionId;
  }
  if (output.WindowTargetId !== undefined && output.WindowTargetId !== null) {
    contents.WindowTargetId = output.WindowTargetId;
  }
  return contents;
};

const deserializeAws_json1_1GetMaintenanceWindowExecutionTaskResult = (
  output: any,
  context: __SerdeContext
): GetMaintenanceWindowExecutionTaskResult => {
  let contents: any = {
    __type: "GetMaintenanceWindowExecutionTaskResult",
    EndTime: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    Priority: undefined,
    ServiceRole: undefined,
    StartTime: undefined,
    Status: undefined,
    StatusDetails: undefined,
    TaskArn: undefined,
    TaskExecutionId: undefined,
    TaskParameters: undefined,
    Type: undefined,
    WindowExecutionId: undefined
  };
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (output.Priority !== undefined && output.Priority !== null) {
    contents.Priority = output.Priority;
  }
  if (output.ServiceRole !== undefined && output.ServiceRole !== null) {
    contents.ServiceRole = output.ServiceRole;
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  if (output.TaskArn !== undefined && output.TaskArn !== null) {
    contents.TaskArn = output.TaskArn;
  }
  if (output.TaskExecutionId !== undefined && output.TaskExecutionId !== null) {
    contents.TaskExecutionId = output.TaskExecutionId;
  }
  if (output.TaskParameters !== undefined && output.TaskParameters !== null) {
    contents.TaskParameters = deserializeAws_json1_1MaintenanceWindowTaskParametersList(
      output.TaskParameters,
      context
    );
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (
    output.WindowExecutionId !== undefined &&
    output.WindowExecutionId !== null
  ) {
    contents.WindowExecutionId = output.WindowExecutionId;
  }
  return contents;
};

const deserializeAws_json1_1GetMaintenanceWindowResult = (
  output: any,
  context: __SerdeContext
): GetMaintenanceWindowResult => {
  let contents: any = {
    __type: "GetMaintenanceWindowResult",
    AllowUnassociatedTargets: undefined,
    CreatedDate: undefined,
    Cutoff: undefined,
    Description: undefined,
    Duration: undefined,
    Enabled: undefined,
    EndDate: undefined,
    ModifiedDate: undefined,
    Name: undefined,
    NextExecutionTime: undefined,
    Schedule: undefined,
    ScheduleTimezone: undefined,
    StartDate: undefined,
    WindowId: undefined
  };
  if (
    output.AllowUnassociatedTargets !== undefined &&
    output.AllowUnassociatedTargets !== null
  ) {
    contents.AllowUnassociatedTargets = output.AllowUnassociatedTargets;
  }
  if (output.CreatedDate !== undefined && output.CreatedDate !== null) {
    contents.CreatedDate = new Date(Math.round(output.CreatedDate * 1000));
  }
  if (output.Cutoff !== undefined && output.Cutoff !== null) {
    contents.Cutoff = output.Cutoff;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Duration !== undefined && output.Duration !== null) {
    contents.Duration = output.Duration;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.EndDate !== undefined && output.EndDate !== null) {
    contents.EndDate = output.EndDate;
  }
  if (output.ModifiedDate !== undefined && output.ModifiedDate !== null) {
    contents.ModifiedDate = new Date(Math.round(output.ModifiedDate * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.NextExecutionTime !== undefined &&
    output.NextExecutionTime !== null
  ) {
    contents.NextExecutionTime = output.NextExecutionTime;
  }
  if (output.Schedule !== undefined && output.Schedule !== null) {
    contents.Schedule = output.Schedule;
  }
  if (
    output.ScheduleTimezone !== undefined &&
    output.ScheduleTimezone !== null
  ) {
    contents.ScheduleTimezone = output.ScheduleTimezone;
  }
  if (output.StartDate !== undefined && output.StartDate !== null) {
    contents.StartDate = output.StartDate;
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  return contents;
};

const deserializeAws_json1_1GetMaintenanceWindowTaskResult = (
  output: any,
  context: __SerdeContext
): GetMaintenanceWindowTaskResult => {
  let contents: any = {
    __type: "GetMaintenanceWindowTaskResult",
    Description: undefined,
    LoggingInfo: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    Name: undefined,
    Priority: undefined,
    ServiceRoleArn: undefined,
    Targets: undefined,
    TaskArn: undefined,
    TaskInvocationParameters: undefined,
    TaskParameters: undefined,
    TaskType: undefined,
    WindowId: undefined,
    WindowTaskId: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.LoggingInfo !== undefined && output.LoggingInfo !== null) {
    contents.LoggingInfo = deserializeAws_json1_1LoggingInfo(
      output.LoggingInfo,
      context
    );
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Priority !== undefined && output.Priority !== null) {
    contents.Priority = output.Priority;
  }
  if (output.ServiceRoleArn !== undefined && output.ServiceRoleArn !== null) {
    contents.ServiceRoleArn = output.ServiceRoleArn;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  if (output.TaskArn !== undefined && output.TaskArn !== null) {
    contents.TaskArn = output.TaskArn;
  }
  if (
    output.TaskInvocationParameters !== undefined &&
    output.TaskInvocationParameters !== null
  ) {
    contents.TaskInvocationParameters = deserializeAws_json1_1MaintenanceWindowTaskInvocationParameters(
      output.TaskInvocationParameters,
      context
    );
  }
  if (output.TaskParameters !== undefined && output.TaskParameters !== null) {
    contents.TaskParameters = deserializeAws_json1_1MaintenanceWindowTaskParameters(
      output.TaskParameters,
      context
    );
  }
  if (output.TaskType !== undefined && output.TaskType !== null) {
    contents.TaskType = output.TaskType;
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  if (output.WindowTaskId !== undefined && output.WindowTaskId !== null) {
    contents.WindowTaskId = output.WindowTaskId;
  }
  return contents;
};

const deserializeAws_json1_1GetOpsItemResponse = (
  output: any,
  context: __SerdeContext
): GetOpsItemResponse => {
  let contents: any = {
    __type: "GetOpsItemResponse",
    OpsItem: undefined
  };
  if (output.OpsItem !== undefined && output.OpsItem !== null) {
    contents.OpsItem = deserializeAws_json1_1OpsItem(output.OpsItem, context);
  }
  return contents;
};

const deserializeAws_json1_1GetOpsSummaryResult = (
  output: any,
  context: __SerdeContext
): GetOpsSummaryResult => {
  let contents: any = {
    __type: "GetOpsSummaryResult",
    Entities: undefined,
    NextToken: undefined
  };
  if (output.Entities !== undefined && output.Entities !== null) {
    contents.Entities = deserializeAws_json1_1OpsEntityList(
      output.Entities,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1GetParameterHistoryResult = (
  output: any,
  context: __SerdeContext
): GetParameterHistoryResult => {
  let contents: any = {
    __type: "GetParameterHistoryResult",
    NextToken: undefined,
    Parameters: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParameterHistoryList(
      output.Parameters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetParameterResult = (
  output: any,
  context: __SerdeContext
): GetParameterResult => {
  let contents: any = {
    __type: "GetParameterResult",
    Parameter: undefined
  };
  if (output.Parameter !== undefined && output.Parameter !== null) {
    contents.Parameter = deserializeAws_json1_1Parameter(
      output.Parameter,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetParametersByPathResult = (
  output: any,
  context: __SerdeContext
): GetParametersByPathResult => {
  let contents: any = {
    __type: "GetParametersByPathResult",
    NextToken: undefined,
    Parameters: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParameterList(
      output.Parameters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetParametersResult = (
  output: any,
  context: __SerdeContext
): GetParametersResult => {
  let contents: any = {
    __type: "GetParametersResult",
    InvalidParameters: undefined,
    Parameters: undefined
  };
  if (
    output.InvalidParameters !== undefined &&
    output.InvalidParameters !== null
  ) {
    contents.InvalidParameters = deserializeAws_json1_1ParameterNameList(
      output.InvalidParameters,
      context
    );
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1ParameterList(
      output.Parameters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetPatchBaselineForPatchGroupResult = (
  output: any,
  context: __SerdeContext
): GetPatchBaselineForPatchGroupResult => {
  let contents: any = {
    __type: "GetPatchBaselineForPatchGroupResult",
    BaselineId: undefined,
    OperatingSystem: undefined,
    PatchGroup: undefined
  };
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  if (output.OperatingSystem !== undefined && output.OperatingSystem !== null) {
    contents.OperatingSystem = output.OperatingSystem;
  }
  if (output.PatchGroup !== undefined && output.PatchGroup !== null) {
    contents.PatchGroup = output.PatchGroup;
  }
  return contents;
};

const deserializeAws_json1_1GetPatchBaselineResult = (
  output: any,
  context: __SerdeContext
): GetPatchBaselineResult => {
  let contents: any = {
    __type: "GetPatchBaselineResult",
    ApprovalRules: undefined,
    ApprovedPatches: undefined,
    ApprovedPatchesComplianceLevel: undefined,
    ApprovedPatchesEnableNonSecurity: undefined,
    BaselineId: undefined,
    CreatedDate: undefined,
    Description: undefined,
    GlobalFilters: undefined,
    ModifiedDate: undefined,
    Name: undefined,
    OperatingSystem: undefined,
    PatchGroups: undefined,
    RejectedPatches: undefined,
    RejectedPatchesAction: undefined,
    Sources: undefined
  };
  if (output.ApprovalRules !== undefined && output.ApprovalRules !== null) {
    contents.ApprovalRules = deserializeAws_json1_1PatchRuleGroup(
      output.ApprovalRules,
      context
    );
  }
  if (output.ApprovedPatches !== undefined && output.ApprovedPatches !== null) {
    contents.ApprovedPatches = deserializeAws_json1_1PatchIdList(
      output.ApprovedPatches,
      context
    );
  }
  if (
    output.ApprovedPatchesComplianceLevel !== undefined &&
    output.ApprovedPatchesComplianceLevel !== null
  ) {
    contents.ApprovedPatchesComplianceLevel =
      output.ApprovedPatchesComplianceLevel;
  }
  if (
    output.ApprovedPatchesEnableNonSecurity !== undefined &&
    output.ApprovedPatchesEnableNonSecurity !== null
  ) {
    contents.ApprovedPatchesEnableNonSecurity =
      output.ApprovedPatchesEnableNonSecurity;
  }
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  if (output.CreatedDate !== undefined && output.CreatedDate !== null) {
    contents.CreatedDate = new Date(Math.round(output.CreatedDate * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.GlobalFilters !== undefined && output.GlobalFilters !== null) {
    contents.GlobalFilters = deserializeAws_json1_1PatchFilterGroup(
      output.GlobalFilters,
      context
    );
  }
  if (output.ModifiedDate !== undefined && output.ModifiedDate !== null) {
    contents.ModifiedDate = new Date(Math.round(output.ModifiedDate * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.OperatingSystem !== undefined && output.OperatingSystem !== null) {
    contents.OperatingSystem = output.OperatingSystem;
  }
  if (output.PatchGroups !== undefined && output.PatchGroups !== null) {
    contents.PatchGroups = deserializeAws_json1_1PatchGroupList(
      output.PatchGroups,
      context
    );
  }
  if (output.RejectedPatches !== undefined && output.RejectedPatches !== null) {
    contents.RejectedPatches = deserializeAws_json1_1PatchIdList(
      output.RejectedPatches,
      context
    );
  }
  if (
    output.RejectedPatchesAction !== undefined &&
    output.RejectedPatchesAction !== null
  ) {
    contents.RejectedPatchesAction = output.RejectedPatchesAction;
  }
  if (output.Sources !== undefined && output.Sources !== null) {
    contents.Sources = deserializeAws_json1_1PatchSourceList(
      output.Sources,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetServiceSettingResult = (
  output: any,
  context: __SerdeContext
): GetServiceSettingResult => {
  let contents: any = {
    __type: "GetServiceSettingResult",
    ServiceSetting: undefined
  };
  if (output.ServiceSetting !== undefined && output.ServiceSetting !== null) {
    contents.ServiceSetting = deserializeAws_json1_1ServiceSetting(
      output.ServiceSetting,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1HierarchyLevelLimitExceededException = (
  output: any,
  context: __SerdeContext
): HierarchyLevelLimitExceededException => {
  let contents: any = {
    __type: "HierarchyLevelLimitExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1HierarchyTypeMismatchException = (
  output: any,
  context: __SerdeContext
): HierarchyTypeMismatchException => {
  let contents: any = {
    __type: "HierarchyTypeMismatchException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1IdempotentParameterMismatch = (
  output: any,
  context: __SerdeContext
): IdempotentParameterMismatch => {
  let contents: any = {
    __type: "IdempotentParameterMismatch",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1IncompatiblePolicyException = (
  output: any,
  context: __SerdeContext
): IncompatiblePolicyException => {
  let contents: any = {
    __type: "IncompatiblePolicyException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InstanceAggregatedAssociationOverview = (
  output: any,
  context: __SerdeContext
): InstanceAggregatedAssociationOverview => {
  let contents: any = {
    __type: "InstanceAggregatedAssociationOverview",
    DetailedStatus: undefined,
    InstanceAssociationStatusAggregatedCount: undefined
  };
  if (output.DetailedStatus !== undefined && output.DetailedStatus !== null) {
    contents.DetailedStatus = output.DetailedStatus;
  }
  if (
    output.InstanceAssociationStatusAggregatedCount !== undefined &&
    output.InstanceAssociationStatusAggregatedCount !== null
  ) {
    contents.InstanceAssociationStatusAggregatedCount = deserializeAws_json1_1InstanceAssociationStatusAggregatedCount(
      output.InstanceAssociationStatusAggregatedCount,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1InstanceAssociation = (
  output: any,
  context: __SerdeContext
): InstanceAssociation => {
  let contents: any = {
    __type: "InstanceAssociation",
    AssociationId: undefined,
    AssociationVersion: undefined,
    Content: undefined,
    InstanceId: undefined
  };
  if (output.AssociationId !== undefined && output.AssociationId !== null) {
    contents.AssociationId = output.AssociationId;
  }
  if (
    output.AssociationVersion !== undefined &&
    output.AssociationVersion !== null
  ) {
    contents.AssociationVersion = output.AssociationVersion;
  }
  if (output.Content !== undefined && output.Content !== null) {
    contents.Content = output.Content;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  return contents;
};

const deserializeAws_json1_1InstanceAssociationList = (
  output: any,
  context: __SerdeContext
): Array<InstanceAssociation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InstanceAssociation(entry, context)
  );
};

const deserializeAws_json1_1InstanceAssociationOutputLocation = (
  output: any,
  context: __SerdeContext
): InstanceAssociationOutputLocation => {
  let contents: any = {
    __type: "InstanceAssociationOutputLocation",
    S3Location: undefined
  };
  if (output.S3Location !== undefined && output.S3Location !== null) {
    contents.S3Location = deserializeAws_json1_1S3OutputLocation(
      output.S3Location,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1InstanceAssociationOutputUrl = (
  output: any,
  context: __SerdeContext
): InstanceAssociationOutputUrl => {
  let contents: any = {
    __type: "InstanceAssociationOutputUrl",
    S3OutputUrl: undefined
  };
  if (output.S3OutputUrl !== undefined && output.S3OutputUrl !== null) {
    contents.S3OutputUrl = deserializeAws_json1_1S3OutputUrl(
      output.S3OutputUrl,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1InstanceAssociationStatusAggregatedCount = (
  output: any,
  context: __SerdeContext
): { [key: string]: number } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1InstanceAssociationStatusInfo = (
  output: any,
  context: __SerdeContext
): InstanceAssociationStatusInfo => {
  let contents: any = {
    __type: "InstanceAssociationStatusInfo",
    AssociationId: undefined,
    AssociationName: undefined,
    AssociationVersion: undefined,
    DetailedStatus: undefined,
    DocumentVersion: undefined,
    ErrorCode: undefined,
    ExecutionDate: undefined,
    ExecutionSummary: undefined,
    InstanceId: undefined,
    Name: undefined,
    OutputUrl: undefined,
    Status: undefined
  };
  if (output.AssociationId !== undefined && output.AssociationId !== null) {
    contents.AssociationId = output.AssociationId;
  }
  if (output.AssociationName !== undefined && output.AssociationName !== null) {
    contents.AssociationName = output.AssociationName;
  }
  if (
    output.AssociationVersion !== undefined &&
    output.AssociationVersion !== null
  ) {
    contents.AssociationVersion = output.AssociationVersion;
  }
  if (output.DetailedStatus !== undefined && output.DetailedStatus !== null) {
    contents.DetailedStatus = output.DetailedStatus;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.ErrorCode !== undefined && output.ErrorCode !== null) {
    contents.ErrorCode = output.ErrorCode;
  }
  if (output.ExecutionDate !== undefined && output.ExecutionDate !== null) {
    contents.ExecutionDate = new Date(Math.round(output.ExecutionDate * 1000));
  }
  if (
    output.ExecutionSummary !== undefined &&
    output.ExecutionSummary !== null
  ) {
    contents.ExecutionSummary = output.ExecutionSummary;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.OutputUrl !== undefined && output.OutputUrl !== null) {
    contents.OutputUrl = deserializeAws_json1_1InstanceAssociationOutputUrl(
      output.OutputUrl,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1InstanceAssociationStatusInfos = (
  output: any,
  context: __SerdeContext
): Array<InstanceAssociationStatusInfo> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InstanceAssociationStatusInfo(entry, context)
  );
};

const deserializeAws_json1_1InstanceIdList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1InstanceInformation = (
  output: any,
  context: __SerdeContext
): InstanceInformation => {
  let contents: any = {
    __type: "InstanceInformation",
    ActivationId: undefined,
    AgentVersion: undefined,
    AssociationOverview: undefined,
    AssociationStatus: undefined,
    ComputerName: undefined,
    IPAddress: undefined,
    IamRole: undefined,
    InstanceId: undefined,
    IsLatestVersion: undefined,
    LastAssociationExecutionDate: undefined,
    LastPingDateTime: undefined,
    LastSuccessfulAssociationExecutionDate: undefined,
    Name: undefined,
    PingStatus: undefined,
    PlatformName: undefined,
    PlatformType: undefined,
    PlatformVersion: undefined,
    RegistrationDate: undefined,
    ResourceType: undefined
  };
  if (output.ActivationId !== undefined && output.ActivationId !== null) {
    contents.ActivationId = output.ActivationId;
  }
  if (output.AgentVersion !== undefined && output.AgentVersion !== null) {
    contents.AgentVersion = output.AgentVersion;
  }
  if (
    output.AssociationOverview !== undefined &&
    output.AssociationOverview !== null
  ) {
    contents.AssociationOverview = deserializeAws_json1_1InstanceAggregatedAssociationOverview(
      output.AssociationOverview,
      context
    );
  }
  if (
    output.AssociationStatus !== undefined &&
    output.AssociationStatus !== null
  ) {
    contents.AssociationStatus = output.AssociationStatus;
  }
  if (output.ComputerName !== undefined && output.ComputerName !== null) {
    contents.ComputerName = output.ComputerName;
  }
  if (output.IPAddress !== undefined && output.IPAddress !== null) {
    contents.IPAddress = output.IPAddress;
  }
  if (output.IamRole !== undefined && output.IamRole !== null) {
    contents.IamRole = output.IamRole;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (output.IsLatestVersion !== undefined && output.IsLatestVersion !== null) {
    contents.IsLatestVersion = output.IsLatestVersion;
  }
  if (
    output.LastAssociationExecutionDate !== undefined &&
    output.LastAssociationExecutionDate !== null
  ) {
    contents.LastAssociationExecutionDate = new Date(
      Math.round(output.LastAssociationExecutionDate * 1000)
    );
  }
  if (
    output.LastPingDateTime !== undefined &&
    output.LastPingDateTime !== null
  ) {
    contents.LastPingDateTime = new Date(
      Math.round(output.LastPingDateTime * 1000)
    );
  }
  if (
    output.LastSuccessfulAssociationExecutionDate !== undefined &&
    output.LastSuccessfulAssociationExecutionDate !== null
  ) {
    contents.LastSuccessfulAssociationExecutionDate = new Date(
      Math.round(output.LastSuccessfulAssociationExecutionDate * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.PingStatus !== undefined && output.PingStatus !== null) {
    contents.PingStatus = output.PingStatus;
  }
  if (output.PlatformName !== undefined && output.PlatformName !== null) {
    contents.PlatformName = output.PlatformName;
  }
  if (output.PlatformType !== undefined && output.PlatformType !== null) {
    contents.PlatformType = output.PlatformType;
  }
  if (output.PlatformVersion !== undefined && output.PlatformVersion !== null) {
    contents.PlatformVersion = output.PlatformVersion;
  }
  if (
    output.RegistrationDate !== undefined &&
    output.RegistrationDate !== null
  ) {
    contents.RegistrationDate = new Date(
      Math.round(output.RegistrationDate * 1000)
    );
  }
  if (output.ResourceType !== undefined && output.ResourceType !== null) {
    contents.ResourceType = output.ResourceType;
  }
  return contents;
};

const deserializeAws_json1_1InstanceInformationList = (
  output: any,
  context: __SerdeContext
): Array<InstanceInformation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InstanceInformation(entry, context)
  );
};

const deserializeAws_json1_1InstancePatchState = (
  output: any,
  context: __SerdeContext
): InstancePatchState => {
  let contents: any = {
    __type: "InstancePatchState",
    BaselineId: undefined,
    FailedCount: undefined,
    InstallOverrideList: undefined,
    InstalledCount: undefined,
    InstalledOtherCount: undefined,
    InstalledPendingRebootCount: undefined,
    InstalledRejectedCount: undefined,
    InstanceId: undefined,
    LastNoRebootInstallOperationTime: undefined,
    MissingCount: undefined,
    NotApplicableCount: undefined,
    Operation: undefined,
    OperationEndTime: undefined,
    OperationStartTime: undefined,
    OwnerInformation: undefined,
    PatchGroup: undefined,
    RebootOption: undefined,
    SnapshotId: undefined,
    UnreportedNotApplicableCount: undefined
  };
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  if (output.FailedCount !== undefined && output.FailedCount !== null) {
    contents.FailedCount = output.FailedCount;
  }
  if (
    output.InstallOverrideList !== undefined &&
    output.InstallOverrideList !== null
  ) {
    contents.InstallOverrideList = output.InstallOverrideList;
  }
  if (output.InstalledCount !== undefined && output.InstalledCount !== null) {
    contents.InstalledCount = output.InstalledCount;
  }
  if (
    output.InstalledOtherCount !== undefined &&
    output.InstalledOtherCount !== null
  ) {
    contents.InstalledOtherCount = output.InstalledOtherCount;
  }
  if (
    output.InstalledPendingRebootCount !== undefined &&
    output.InstalledPendingRebootCount !== null
  ) {
    contents.InstalledPendingRebootCount = output.InstalledPendingRebootCount;
  }
  if (
    output.InstalledRejectedCount !== undefined &&
    output.InstalledRejectedCount !== null
  ) {
    contents.InstalledRejectedCount = output.InstalledRejectedCount;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (
    output.LastNoRebootInstallOperationTime !== undefined &&
    output.LastNoRebootInstallOperationTime !== null
  ) {
    contents.LastNoRebootInstallOperationTime = new Date(
      Math.round(output.LastNoRebootInstallOperationTime * 1000)
    );
  }
  if (output.MissingCount !== undefined && output.MissingCount !== null) {
    contents.MissingCount = output.MissingCount;
  }
  if (
    output.NotApplicableCount !== undefined &&
    output.NotApplicableCount !== null
  ) {
    contents.NotApplicableCount = output.NotApplicableCount;
  }
  if (output.Operation !== undefined && output.Operation !== null) {
    contents.Operation = output.Operation;
  }
  if (
    output.OperationEndTime !== undefined &&
    output.OperationEndTime !== null
  ) {
    contents.OperationEndTime = new Date(
      Math.round(output.OperationEndTime * 1000)
    );
  }
  if (
    output.OperationStartTime !== undefined &&
    output.OperationStartTime !== null
  ) {
    contents.OperationStartTime = new Date(
      Math.round(output.OperationStartTime * 1000)
    );
  }
  if (
    output.OwnerInformation !== undefined &&
    output.OwnerInformation !== null
  ) {
    contents.OwnerInformation = output.OwnerInformation;
  }
  if (output.PatchGroup !== undefined && output.PatchGroup !== null) {
    contents.PatchGroup = output.PatchGroup;
  }
  if (output.RebootOption !== undefined && output.RebootOption !== null) {
    contents.RebootOption = output.RebootOption;
  }
  if (output.SnapshotId !== undefined && output.SnapshotId !== null) {
    contents.SnapshotId = output.SnapshotId;
  }
  if (
    output.UnreportedNotApplicableCount !== undefined &&
    output.UnreportedNotApplicableCount !== null
  ) {
    contents.UnreportedNotApplicableCount = output.UnreportedNotApplicableCount;
  }
  return contents;
};

const deserializeAws_json1_1InstancePatchStateList = (
  output: any,
  context: __SerdeContext
): Array<InstancePatchState> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InstancePatchState(entry, context)
  );
};

const deserializeAws_json1_1InstancePatchStatesList = (
  output: any,
  context: __SerdeContext
): Array<InstancePatchState> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InstancePatchState(entry, context)
  );
};

const deserializeAws_json1_1InternalServerError = (
  output: any,
  context: __SerdeContext
): InternalServerError => {
  let contents: any = {
    __type: "InternalServerError",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidActivation = (
  output: any,
  context: __SerdeContext
): InvalidActivation => {
  let contents: any = {
    __type: "InvalidActivation",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidActivationId = (
  output: any,
  context: __SerdeContext
): InvalidActivationId => {
  let contents: any = {
    __type: "InvalidActivationId",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidAggregatorException = (
  output: any,
  context: __SerdeContext
): InvalidAggregatorException => {
  let contents: any = {
    __type: "InvalidAggregatorException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidAllowedPatternException = (
  output: any,
  context: __SerdeContext
): InvalidAllowedPatternException => {
  let contents: any = {
    __type: "InvalidAllowedPatternException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidAssociation = (
  output: any,
  context: __SerdeContext
): InvalidAssociation => {
  let contents: any = {
    __type: "InvalidAssociation",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidAssociationVersion = (
  output: any,
  context: __SerdeContext
): InvalidAssociationVersion => {
  let contents: any = {
    __type: "InvalidAssociationVersion",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidAutomationExecutionParametersException = (
  output: any,
  context: __SerdeContext
): InvalidAutomationExecutionParametersException => {
  let contents: any = {
    __type: "InvalidAutomationExecutionParametersException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidAutomationSignalException = (
  output: any,
  context: __SerdeContext
): InvalidAutomationSignalException => {
  let contents: any = {
    __type: "InvalidAutomationSignalException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidAutomationStatusUpdateException = (
  output: any,
  context: __SerdeContext
): InvalidAutomationStatusUpdateException => {
  let contents: any = {
    __type: "InvalidAutomationStatusUpdateException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidCommandId = (
  output: any,
  context: __SerdeContext
): InvalidCommandId => {
  let contents: any = {
    __type: "InvalidCommandId"
  };
  return contents;
};

const deserializeAws_json1_1InvalidDeleteInventoryParametersException = (
  output: any,
  context: __SerdeContext
): InvalidDeleteInventoryParametersException => {
  let contents: any = {
    __type: "InvalidDeleteInventoryParametersException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDeletionIdException = (
  output: any,
  context: __SerdeContext
): InvalidDeletionIdException => {
  let contents: any = {
    __type: "InvalidDeletionIdException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDocument = (
  output: any,
  context: __SerdeContext
): InvalidDocument => {
  let contents: any = {
    __type: "InvalidDocument",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDocumentContent = (
  output: any,
  context: __SerdeContext
): InvalidDocumentContent => {
  let contents: any = {
    __type: "InvalidDocumentContent",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDocumentOperation = (
  output: any,
  context: __SerdeContext
): InvalidDocumentOperation => {
  let contents: any = {
    __type: "InvalidDocumentOperation",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDocumentSchemaVersion = (
  output: any,
  context: __SerdeContext
): InvalidDocumentSchemaVersion => {
  let contents: any = {
    __type: "InvalidDocumentSchemaVersion",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDocumentType = (
  output: any,
  context: __SerdeContext
): InvalidDocumentType => {
  let contents: any = {
    __type: "InvalidDocumentType",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidDocumentVersion = (
  output: any,
  context: __SerdeContext
): InvalidDocumentVersion => {
  let contents: any = {
    __type: "InvalidDocumentVersion",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidFilter = (
  output: any,
  context: __SerdeContext
): InvalidFilter => {
  let contents: any = {
    __type: "InvalidFilter",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidFilterKey = (
  output: any,
  context: __SerdeContext
): InvalidFilterKey => {
  let contents: any = {
    __type: "InvalidFilterKey"
  };
  return contents;
};

const deserializeAws_json1_1InvalidFilterOption = (
  output: any,
  context: __SerdeContext
): InvalidFilterOption => {
  let contents: any = {
    __type: "InvalidFilterOption",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidFilterValue = (
  output: any,
  context: __SerdeContext
): InvalidFilterValue => {
  let contents: any = {
    __type: "InvalidFilterValue",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidInstanceId = (
  output: any,
  context: __SerdeContext
): InvalidInstanceId => {
  let contents: any = {
    __type: "InvalidInstanceId",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidInstanceInformationFilterValue = (
  output: any,
  context: __SerdeContext
): InvalidInstanceInformationFilterValue => {
  let contents: any = {
    __type: "InvalidInstanceInformationFilterValue",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidInventoryGroupException = (
  output: any,
  context: __SerdeContext
): InvalidInventoryGroupException => {
  let contents: any = {
    __type: "InvalidInventoryGroupException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidInventoryItemContextException = (
  output: any,
  context: __SerdeContext
): InvalidInventoryItemContextException => {
  let contents: any = {
    __type: "InvalidInventoryItemContextException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidInventoryRequestException = (
  output: any,
  context: __SerdeContext
): InvalidInventoryRequestException => {
  let contents: any = {
    __type: "InvalidInventoryRequestException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidItemContentException = (
  output: any,
  context: __SerdeContext
): InvalidItemContentException => {
  let contents: any = {
    __type: "InvalidItemContentException",
    Message: undefined,
    TypeName: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.TypeName !== undefined && output.TypeName !== null) {
    contents.TypeName = output.TypeName;
  }
  return contents;
};

const deserializeAws_json1_1InvalidKeyId = (
  output: any,
  context: __SerdeContext
): InvalidKeyId => {
  let contents: any = {
    __type: "InvalidKeyId",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidNextToken = (
  output: any,
  context: __SerdeContext
): InvalidNextToken => {
  let contents: any = {
    __type: "InvalidNextToken",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidNotificationConfig = (
  output: any,
  context: __SerdeContext
): InvalidNotificationConfig => {
  let contents: any = {
    __type: "InvalidNotificationConfig",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidOptionException = (
  output: any,
  context: __SerdeContext
): InvalidOptionException => {
  let contents: any = {
    __type: "InvalidOptionException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidOutputFolder = (
  output: any,
  context: __SerdeContext
): InvalidOutputFolder => {
  let contents: any = {
    __type: "InvalidOutputFolder"
  };
  return contents;
};

const deserializeAws_json1_1InvalidOutputLocation = (
  output: any,
  context: __SerdeContext
): InvalidOutputLocation => {
  let contents: any = {
    __type: "InvalidOutputLocation"
  };
  return contents;
};

const deserializeAws_json1_1InvalidParameters = (
  output: any,
  context: __SerdeContext
): InvalidParameters => {
  let contents: any = {
    __type: "InvalidParameters",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidPermissionType = (
  output: any,
  context: __SerdeContext
): InvalidPermissionType => {
  let contents: any = {
    __type: "InvalidPermissionType",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidPluginName = (
  output: any,
  context: __SerdeContext
): InvalidPluginName => {
  let contents: any = {
    __type: "InvalidPluginName"
  };
  return contents;
};

const deserializeAws_json1_1InvalidPolicyAttributeException = (
  output: any,
  context: __SerdeContext
): InvalidPolicyAttributeException => {
  let contents: any = {
    __type: "InvalidPolicyAttributeException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidPolicyTypeException = (
  output: any,
  context: __SerdeContext
): InvalidPolicyTypeException => {
  let contents: any = {
    __type: "InvalidPolicyTypeException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidResourceId = (
  output: any,
  context: __SerdeContext
): InvalidResourceId => {
  let contents: any = {
    __type: "InvalidResourceId"
  };
  return contents;
};

const deserializeAws_json1_1InvalidResourceType = (
  output: any,
  context: __SerdeContext
): InvalidResourceType => {
  let contents: any = {
    __type: "InvalidResourceType"
  };
  return contents;
};

const deserializeAws_json1_1InvalidResultAttributeException = (
  output: any,
  context: __SerdeContext
): InvalidResultAttributeException => {
  let contents: any = {
    __type: "InvalidResultAttributeException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRole = (
  output: any,
  context: __SerdeContext
): InvalidRole => {
  let contents: any = {
    __type: "InvalidRole",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidSchedule = (
  output: any,
  context: __SerdeContext
): InvalidSchedule => {
  let contents: any = {
    __type: "InvalidSchedule",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidTarget = (
  output: any,
  context: __SerdeContext
): InvalidTarget => {
  let contents: any = {
    __type: "InvalidTarget",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidTypeNameException = (
  output: any,
  context: __SerdeContext
): InvalidTypeNameException => {
  let contents: any = {
    __type: "InvalidTypeNameException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidUpdate = (
  output: any,
  context: __SerdeContext
): InvalidUpdate => {
  let contents: any = {
    __type: "InvalidUpdate",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InventoryDeletionStatusItem = (
  output: any,
  context: __SerdeContext
): InventoryDeletionStatusItem => {
  let contents: any = {
    __type: "InventoryDeletionStatusItem",
    DeletionId: undefined,
    DeletionStartTime: undefined,
    DeletionSummary: undefined,
    LastStatus: undefined,
    LastStatusMessage: undefined,
    LastStatusUpdateTime: undefined,
    TypeName: undefined
  };
  if (output.DeletionId !== undefined && output.DeletionId !== null) {
    contents.DeletionId = output.DeletionId;
  }
  if (
    output.DeletionStartTime !== undefined &&
    output.DeletionStartTime !== null
  ) {
    contents.DeletionStartTime = new Date(
      Math.round(output.DeletionStartTime * 1000)
    );
  }
  if (output.DeletionSummary !== undefined && output.DeletionSummary !== null) {
    contents.DeletionSummary = deserializeAws_json1_1InventoryDeletionSummary(
      output.DeletionSummary,
      context
    );
  }
  if (output.LastStatus !== undefined && output.LastStatus !== null) {
    contents.LastStatus = output.LastStatus;
  }
  if (
    output.LastStatusMessage !== undefined &&
    output.LastStatusMessage !== null
  ) {
    contents.LastStatusMessage = output.LastStatusMessage;
  }
  if (
    output.LastStatusUpdateTime !== undefined &&
    output.LastStatusUpdateTime !== null
  ) {
    contents.LastStatusUpdateTime = new Date(
      Math.round(output.LastStatusUpdateTime * 1000)
    );
  }
  if (output.TypeName !== undefined && output.TypeName !== null) {
    contents.TypeName = output.TypeName;
  }
  return contents;
};

const deserializeAws_json1_1InventoryDeletionSummary = (
  output: any,
  context: __SerdeContext
): InventoryDeletionSummary => {
  let contents: any = {
    __type: "InventoryDeletionSummary",
    RemainingCount: undefined,
    SummaryItems: undefined,
    TotalCount: undefined
  };
  if (output.RemainingCount !== undefined && output.RemainingCount !== null) {
    contents.RemainingCount = output.RemainingCount;
  }
  if (output.SummaryItems !== undefined && output.SummaryItems !== null) {
    contents.SummaryItems = deserializeAws_json1_1InventoryDeletionSummaryItems(
      output.SummaryItems,
      context
    );
  }
  if (output.TotalCount !== undefined && output.TotalCount !== null) {
    contents.TotalCount = output.TotalCount;
  }
  return contents;
};

const deserializeAws_json1_1InventoryDeletionSummaryItem = (
  output: any,
  context: __SerdeContext
): InventoryDeletionSummaryItem => {
  let contents: any = {
    __type: "InventoryDeletionSummaryItem",
    Count: undefined,
    RemainingCount: undefined,
    Version: undefined
  };
  if (output.Count !== undefined && output.Count !== null) {
    contents.Count = output.Count;
  }
  if (output.RemainingCount !== undefined && output.RemainingCount !== null) {
    contents.RemainingCount = output.RemainingCount;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1InventoryDeletionSummaryItems = (
  output: any,
  context: __SerdeContext
): Array<InventoryDeletionSummaryItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InventoryDeletionSummaryItem(entry, context)
  );
};

const deserializeAws_json1_1InventoryDeletionsList = (
  output: any,
  context: __SerdeContext
): Array<InventoryDeletionStatusItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InventoryDeletionStatusItem(entry, context)
  );
};

const deserializeAws_json1_1InventoryItemAttribute = (
  output: any,
  context: __SerdeContext
): InventoryItemAttribute => {
  let contents: any = {
    __type: "InventoryItemAttribute",
    DataType: undefined,
    Name: undefined
  };
  if (output.DataType !== undefined && output.DataType !== null) {
    contents.DataType = output.DataType;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1InventoryItemAttributeList = (
  output: any,
  context: __SerdeContext
): Array<InventoryItemAttribute> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InventoryItemAttribute(entry, context)
  );
};

const deserializeAws_json1_1InventoryItemEntry = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1InventoryItemEntryList = (
  output: any,
  context: __SerdeContext
): Array<{ [key: string]: string }> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InventoryItemEntry(entry, context)
  );
};

const deserializeAws_json1_1InventoryItemSchema = (
  output: any,
  context: __SerdeContext
): InventoryItemSchema => {
  let contents: any = {
    __type: "InventoryItemSchema",
    Attributes: undefined,
    DisplayName: undefined,
    TypeName: undefined,
    Version: undefined
  };
  if (output.Attributes !== undefined && output.Attributes !== null) {
    contents.Attributes = deserializeAws_json1_1InventoryItemAttributeList(
      output.Attributes,
      context
    );
  }
  if (output.DisplayName !== undefined && output.DisplayName !== null) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.TypeName !== undefined && output.TypeName !== null) {
    contents.TypeName = output.TypeName;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1InventoryItemSchemaResultList = (
  output: any,
  context: __SerdeContext
): Array<InventoryItemSchema> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InventoryItemSchema(entry, context)
  );
};

const deserializeAws_json1_1InventoryResultEntity = (
  output: any,
  context: __SerdeContext
): InventoryResultEntity => {
  let contents: any = {
    __type: "InventoryResultEntity",
    Data: undefined,
    Id: undefined
  };
  if (output.Data !== undefined && output.Data !== null) {
    contents.Data = deserializeAws_json1_1InventoryResultItemMap(
      output.Data,
      context
    );
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  return contents;
};

const deserializeAws_json1_1InventoryResultEntityList = (
  output: any,
  context: __SerdeContext
): Array<InventoryResultEntity> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1InventoryResultEntity(entry, context)
  );
};

const deserializeAws_json1_1InventoryResultItem = (
  output: any,
  context: __SerdeContext
): InventoryResultItem => {
  let contents: any = {
    __type: "InventoryResultItem",
    CaptureTime: undefined,
    Content: undefined,
    ContentHash: undefined,
    SchemaVersion: undefined,
    TypeName: undefined
  };
  if (output.CaptureTime !== undefined && output.CaptureTime !== null) {
    contents.CaptureTime = output.CaptureTime;
  }
  if (output.Content !== undefined && output.Content !== null) {
    contents.Content = deserializeAws_json1_1InventoryItemEntryList(
      output.Content,
      context
    );
  }
  if (output.ContentHash !== undefined && output.ContentHash !== null) {
    contents.ContentHash = output.ContentHash;
  }
  if (output.SchemaVersion !== undefined && output.SchemaVersion !== null) {
    contents.SchemaVersion = output.SchemaVersion;
  }
  if (output.TypeName !== undefined && output.TypeName !== null) {
    contents.TypeName = output.TypeName;
  }
  return contents;
};

const deserializeAws_json1_1InventoryResultItemMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: InventoryResultItem } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1InventoryResultItem(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_json1_1InvocationDoesNotExist = (
  output: any,
  context: __SerdeContext
): InvocationDoesNotExist => {
  let contents: any = {
    __type: "InvocationDoesNotExist"
  };
  return contents;
};

const deserializeAws_json1_1ItemContentMismatchException = (
  output: any,
  context: __SerdeContext
): ItemContentMismatchException => {
  let contents: any = {
    __type: "ItemContentMismatchException",
    Message: undefined,
    TypeName: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.TypeName !== undefined && output.TypeName !== null) {
    contents.TypeName = output.TypeName;
  }
  return contents;
};

const deserializeAws_json1_1ItemSizeLimitExceededException = (
  output: any,
  context: __SerdeContext
): ItemSizeLimitExceededException => {
  let contents: any = {
    __type: "ItemSizeLimitExceededException",
    Message: undefined,
    TypeName: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.TypeName !== undefined && output.TypeName !== null) {
    contents.TypeName = output.TypeName;
  }
  return contents;
};

const deserializeAws_json1_1LabelParameterVersionResult = (
  output: any,
  context: __SerdeContext
): LabelParameterVersionResult => {
  let contents: any = {
    __type: "LabelParameterVersionResult",
    InvalidLabels: undefined,
    ParameterVersion: undefined
  };
  if (output.InvalidLabels !== undefined && output.InvalidLabels !== null) {
    contents.InvalidLabels = deserializeAws_json1_1ParameterLabelList(
      output.InvalidLabels,
      context
    );
  }
  if (
    output.ParameterVersion !== undefined &&
    output.ParameterVersion !== null
  ) {
    contents.ParameterVersion = output.ParameterVersion;
  }
  return contents;
};

const deserializeAws_json1_1ListAssociationVersionsResult = (
  output: any,
  context: __SerdeContext
): ListAssociationVersionsResult => {
  let contents: any = {
    __type: "ListAssociationVersionsResult",
    AssociationVersions: undefined,
    NextToken: undefined
  };
  if (
    output.AssociationVersions !== undefined &&
    output.AssociationVersions !== null
  ) {
    contents.AssociationVersions = deserializeAws_json1_1AssociationVersionList(
      output.AssociationVersions,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListAssociationsResult = (
  output: any,
  context: __SerdeContext
): ListAssociationsResult => {
  let contents: any = {
    __type: "ListAssociationsResult",
    Associations: undefined,
    NextToken: undefined
  };
  if (output.Associations !== undefined && output.Associations !== null) {
    contents.Associations = deserializeAws_json1_1AssociationList(
      output.Associations,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListCommandInvocationsResult = (
  output: any,
  context: __SerdeContext
): ListCommandInvocationsResult => {
  let contents: any = {
    __type: "ListCommandInvocationsResult",
    CommandInvocations: undefined,
    NextToken: undefined
  };
  if (
    output.CommandInvocations !== undefined &&
    output.CommandInvocations !== null
  ) {
    contents.CommandInvocations = deserializeAws_json1_1CommandInvocationList(
      output.CommandInvocations,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListCommandsResult = (
  output: any,
  context: __SerdeContext
): ListCommandsResult => {
  let contents: any = {
    __type: "ListCommandsResult",
    Commands: undefined,
    NextToken: undefined
  };
  if (output.Commands !== undefined && output.Commands !== null) {
    contents.Commands = deserializeAws_json1_1CommandList(
      output.Commands,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListComplianceItemsResult = (
  output: any,
  context: __SerdeContext
): ListComplianceItemsResult => {
  let contents: any = {
    __type: "ListComplianceItemsResult",
    ComplianceItems: undefined,
    NextToken: undefined
  };
  if (output.ComplianceItems !== undefined && output.ComplianceItems !== null) {
    contents.ComplianceItems = deserializeAws_json1_1ComplianceItemList(
      output.ComplianceItems,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListComplianceSummariesResult = (
  output: any,
  context: __SerdeContext
): ListComplianceSummariesResult => {
  let contents: any = {
    __type: "ListComplianceSummariesResult",
    ComplianceSummaryItems: undefined,
    NextToken: undefined
  };
  if (
    output.ComplianceSummaryItems !== undefined &&
    output.ComplianceSummaryItems !== null
  ) {
    contents.ComplianceSummaryItems = deserializeAws_json1_1ComplianceSummaryItemList(
      output.ComplianceSummaryItems,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListDocumentVersionsResult = (
  output: any,
  context: __SerdeContext
): ListDocumentVersionsResult => {
  let contents: any = {
    __type: "ListDocumentVersionsResult",
    DocumentVersions: undefined,
    NextToken: undefined
  };
  if (
    output.DocumentVersions !== undefined &&
    output.DocumentVersions !== null
  ) {
    contents.DocumentVersions = deserializeAws_json1_1DocumentVersionList(
      output.DocumentVersions,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListDocumentsResult = (
  output: any,
  context: __SerdeContext
): ListDocumentsResult => {
  let contents: any = {
    __type: "ListDocumentsResult",
    DocumentIdentifiers: undefined,
    NextToken: undefined
  };
  if (
    output.DocumentIdentifiers !== undefined &&
    output.DocumentIdentifiers !== null
  ) {
    contents.DocumentIdentifiers = deserializeAws_json1_1DocumentIdentifierList(
      output.DocumentIdentifiers,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListInventoryEntriesResult = (
  output: any,
  context: __SerdeContext
): ListInventoryEntriesResult => {
  let contents: any = {
    __type: "ListInventoryEntriesResult",
    CaptureTime: undefined,
    Entries: undefined,
    InstanceId: undefined,
    NextToken: undefined,
    SchemaVersion: undefined,
    TypeName: undefined
  };
  if (output.CaptureTime !== undefined && output.CaptureTime !== null) {
    contents.CaptureTime = output.CaptureTime;
  }
  if (output.Entries !== undefined && output.Entries !== null) {
    contents.Entries = deserializeAws_json1_1InventoryItemEntryList(
      output.Entries,
      context
    );
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.SchemaVersion !== undefined && output.SchemaVersion !== null) {
    contents.SchemaVersion = output.SchemaVersion;
  }
  if (output.TypeName !== undefined && output.TypeName !== null) {
    contents.TypeName = output.TypeName;
  }
  return contents;
};

const deserializeAws_json1_1ListResourceComplianceSummariesResult = (
  output: any,
  context: __SerdeContext
): ListResourceComplianceSummariesResult => {
  let contents: any = {
    __type: "ListResourceComplianceSummariesResult",
    NextToken: undefined,
    ResourceComplianceSummaryItems: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.ResourceComplianceSummaryItems !== undefined &&
    output.ResourceComplianceSummaryItems !== null
  ) {
    contents.ResourceComplianceSummaryItems = deserializeAws_json1_1ResourceComplianceSummaryItemList(
      output.ResourceComplianceSummaryItems,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListResourceDataSyncResult = (
  output: any,
  context: __SerdeContext
): ListResourceDataSyncResult => {
  let contents: any = {
    __type: "ListResourceDataSyncResult",
    NextToken: undefined,
    ResourceDataSyncItems: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.ResourceDataSyncItems !== undefined &&
    output.ResourceDataSyncItems !== null
  ) {
    contents.ResourceDataSyncItems = deserializeAws_json1_1ResourceDataSyncItemList(
      output.ResourceDataSyncItems,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTagsForResourceResult = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResult => {
  let contents: any = {
    __type: "ListTagsForResourceResult",
    TagList: undefined
  };
  if (output.TagList !== undefined && output.TagList !== null) {
    contents.TagList = deserializeAws_json1_1TagList(output.TagList, context);
  }
  return contents;
};

const deserializeAws_json1_1LoggingInfo = (
  output: any,
  context: __SerdeContext
): LoggingInfo => {
  let contents: any = {
    __type: "LoggingInfo",
    S3BucketName: undefined,
    S3KeyPrefix: undefined,
    S3Region: undefined
  };
  if (output.S3BucketName !== undefined && output.S3BucketName !== null) {
    contents.S3BucketName = output.S3BucketName;
  }
  if (output.S3KeyPrefix !== undefined && output.S3KeyPrefix !== null) {
    contents.S3KeyPrefix = output.S3KeyPrefix;
  }
  if (output.S3Region !== undefined && output.S3Region !== null) {
    contents.S3Region = output.S3Region;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowAutomationParameters = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowAutomationParameters => {
  let contents: any = {
    __type: "MaintenanceWindowAutomationParameters",
    DocumentVersion: undefined,
    Parameters: undefined
  };
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1AutomationParameterMap(
      output.Parameters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowExecution = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowExecution => {
  let contents: any = {
    __type: "MaintenanceWindowExecution",
    EndTime: undefined,
    StartTime: undefined,
    Status: undefined,
    StatusDetails: undefined,
    WindowExecutionId: undefined,
    WindowId: undefined
  };
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  if (
    output.WindowExecutionId !== undefined &&
    output.WindowExecutionId !== null
  ) {
    contents.WindowExecutionId = output.WindowExecutionId;
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowExecutionList = (
  output: any,
  context: __SerdeContext
): Array<MaintenanceWindowExecution> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MaintenanceWindowExecution(entry, context)
  );
};

const deserializeAws_json1_1MaintenanceWindowExecutionTaskIdList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1MaintenanceWindowExecutionTaskIdentity = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowExecutionTaskIdentity => {
  let contents: any = {
    __type: "MaintenanceWindowExecutionTaskIdentity",
    EndTime: undefined,
    StartTime: undefined,
    Status: undefined,
    StatusDetails: undefined,
    TaskArn: undefined,
    TaskExecutionId: undefined,
    TaskType: undefined,
    WindowExecutionId: undefined
  };
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  if (output.TaskArn !== undefined && output.TaskArn !== null) {
    contents.TaskArn = output.TaskArn;
  }
  if (output.TaskExecutionId !== undefined && output.TaskExecutionId !== null) {
    contents.TaskExecutionId = output.TaskExecutionId;
  }
  if (output.TaskType !== undefined && output.TaskType !== null) {
    contents.TaskType = output.TaskType;
  }
  if (
    output.WindowExecutionId !== undefined &&
    output.WindowExecutionId !== null
  ) {
    contents.WindowExecutionId = output.WindowExecutionId;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowExecutionTaskIdentityList = (
  output: any,
  context: __SerdeContext
): Array<MaintenanceWindowExecutionTaskIdentity> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MaintenanceWindowExecutionTaskIdentity(entry, context)
  );
};

const deserializeAws_json1_1MaintenanceWindowExecutionTaskInvocationIdentity = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowExecutionTaskInvocationIdentity => {
  let contents: any = {
    __type: "MaintenanceWindowExecutionTaskInvocationIdentity",
    EndTime: undefined,
    ExecutionId: undefined,
    InvocationId: undefined,
    OwnerInformation: undefined,
    Parameters: undefined,
    StartTime: undefined,
    Status: undefined,
    StatusDetails: undefined,
    TaskExecutionId: undefined,
    TaskType: undefined,
    WindowExecutionId: undefined,
    WindowTargetId: undefined
  };
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.ExecutionId !== undefined && output.ExecutionId !== null) {
    contents.ExecutionId = output.ExecutionId;
  }
  if (output.InvocationId !== undefined && output.InvocationId !== null) {
    contents.InvocationId = output.InvocationId;
  }
  if (
    output.OwnerInformation !== undefined &&
    output.OwnerInformation !== null
  ) {
    contents.OwnerInformation = output.OwnerInformation;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = output.Parameters;
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusDetails !== undefined && output.StatusDetails !== null) {
    contents.StatusDetails = output.StatusDetails;
  }
  if (output.TaskExecutionId !== undefined && output.TaskExecutionId !== null) {
    contents.TaskExecutionId = output.TaskExecutionId;
  }
  if (output.TaskType !== undefined && output.TaskType !== null) {
    contents.TaskType = output.TaskType;
  }
  if (
    output.WindowExecutionId !== undefined &&
    output.WindowExecutionId !== null
  ) {
    contents.WindowExecutionId = output.WindowExecutionId;
  }
  if (output.WindowTargetId !== undefined && output.WindowTargetId !== null) {
    contents.WindowTargetId = output.WindowTargetId;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowExecutionTaskInvocationIdentityList = (
  output: any,
  context: __SerdeContext
): Array<MaintenanceWindowExecutionTaskInvocationIdentity> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MaintenanceWindowExecutionTaskInvocationIdentity(
      entry,
      context
    )
  );
};

const deserializeAws_json1_1MaintenanceWindowIdentity = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowIdentity => {
  let contents: any = {
    __type: "MaintenanceWindowIdentity",
    Cutoff: undefined,
    Description: undefined,
    Duration: undefined,
    Enabled: undefined,
    EndDate: undefined,
    Name: undefined,
    NextExecutionTime: undefined,
    Schedule: undefined,
    ScheduleTimezone: undefined,
    StartDate: undefined,
    WindowId: undefined
  };
  if (output.Cutoff !== undefined && output.Cutoff !== null) {
    contents.Cutoff = output.Cutoff;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Duration !== undefined && output.Duration !== null) {
    contents.Duration = output.Duration;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.EndDate !== undefined && output.EndDate !== null) {
    contents.EndDate = output.EndDate;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.NextExecutionTime !== undefined &&
    output.NextExecutionTime !== null
  ) {
    contents.NextExecutionTime = output.NextExecutionTime;
  }
  if (output.Schedule !== undefined && output.Schedule !== null) {
    contents.Schedule = output.Schedule;
  }
  if (
    output.ScheduleTimezone !== undefined &&
    output.ScheduleTimezone !== null
  ) {
    contents.ScheduleTimezone = output.ScheduleTimezone;
  }
  if (output.StartDate !== undefined && output.StartDate !== null) {
    contents.StartDate = output.StartDate;
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowIdentityForTarget = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowIdentityForTarget => {
  let contents: any = {
    __type: "MaintenanceWindowIdentityForTarget",
    Name: undefined,
    WindowId: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowIdentityList = (
  output: any,
  context: __SerdeContext
): Array<MaintenanceWindowIdentity> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MaintenanceWindowIdentity(entry, context)
  );
};

const deserializeAws_json1_1MaintenanceWindowLambdaParameters = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowLambdaParameters => {
  let contents: any = {
    __type: "MaintenanceWindowLambdaParameters",
    ClientContext: undefined,
    Payload: undefined,
    Qualifier: undefined
  };
  if (output.ClientContext !== undefined && output.ClientContext !== null) {
    contents.ClientContext = output.ClientContext;
  }
  if (output.Payload !== undefined && output.Payload !== null) {
    contents.Payload = context.base64Decoder(output.Payload);
  }
  if (output.Qualifier !== undefined && output.Qualifier !== null) {
    contents.Qualifier = output.Qualifier;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowRunCommandParameters = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowRunCommandParameters => {
  let contents: any = {
    __type: "MaintenanceWindowRunCommandParameters",
    CloudWatchOutputConfig: undefined,
    Comment: undefined,
    DocumentHash: undefined,
    DocumentHashType: undefined,
    DocumentVersion: undefined,
    NotificationConfig: undefined,
    OutputS3BucketName: undefined,
    OutputS3KeyPrefix: undefined,
    Parameters: undefined,
    ServiceRoleArn: undefined,
    TimeoutSeconds: undefined
  };
  if (
    output.CloudWatchOutputConfig !== undefined &&
    output.CloudWatchOutputConfig !== null
  ) {
    contents.CloudWatchOutputConfig = deserializeAws_json1_1CloudWatchOutputConfig(
      output.CloudWatchOutputConfig,
      context
    );
  }
  if (output.Comment !== undefined && output.Comment !== null) {
    contents.Comment = output.Comment;
  }
  if (output.DocumentHash !== undefined && output.DocumentHash !== null) {
    contents.DocumentHash = output.DocumentHash;
  }
  if (
    output.DocumentHashType !== undefined &&
    output.DocumentHashType !== null
  ) {
    contents.DocumentHashType = output.DocumentHashType;
  }
  if (output.DocumentVersion !== undefined && output.DocumentVersion !== null) {
    contents.DocumentVersion = output.DocumentVersion;
  }
  if (
    output.NotificationConfig !== undefined &&
    output.NotificationConfig !== null
  ) {
    contents.NotificationConfig = deserializeAws_json1_1NotificationConfig(
      output.NotificationConfig,
      context
    );
  }
  if (
    output.OutputS3BucketName !== undefined &&
    output.OutputS3BucketName !== null
  ) {
    contents.OutputS3BucketName = output.OutputS3BucketName;
  }
  if (
    output.OutputS3KeyPrefix !== undefined &&
    output.OutputS3KeyPrefix !== null
  ) {
    contents.OutputS3KeyPrefix = output.OutputS3KeyPrefix;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_json1_1Parameters(
      output.Parameters,
      context
    );
  }
  if (output.ServiceRoleArn !== undefined && output.ServiceRoleArn !== null) {
    contents.ServiceRoleArn = output.ServiceRoleArn;
  }
  if (output.TimeoutSeconds !== undefined && output.TimeoutSeconds !== null) {
    contents.TimeoutSeconds = output.TimeoutSeconds;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowStepFunctionsParameters = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowStepFunctionsParameters => {
  let contents: any = {
    __type: "MaintenanceWindowStepFunctionsParameters",
    Input: undefined,
    Name: undefined
  };
  if (output.Input !== undefined && output.Input !== null) {
    contents.Input = output.Input;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowTarget = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowTarget => {
  let contents: any = {
    __type: "MaintenanceWindowTarget",
    Description: undefined,
    Name: undefined,
    OwnerInformation: undefined,
    ResourceType: undefined,
    Targets: undefined,
    WindowId: undefined,
    WindowTargetId: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.OwnerInformation !== undefined &&
    output.OwnerInformation !== null
  ) {
    contents.OwnerInformation = output.OwnerInformation;
  }
  if (output.ResourceType !== undefined && output.ResourceType !== null) {
    contents.ResourceType = output.ResourceType;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  if (output.WindowTargetId !== undefined && output.WindowTargetId !== null) {
    contents.WindowTargetId = output.WindowTargetId;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowTargetList = (
  output: any,
  context: __SerdeContext
): Array<MaintenanceWindowTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MaintenanceWindowTarget(entry, context)
  );
};

const deserializeAws_json1_1MaintenanceWindowTask = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowTask => {
  let contents: any = {
    __type: "MaintenanceWindowTask",
    Description: undefined,
    LoggingInfo: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    Name: undefined,
    Priority: undefined,
    ServiceRoleArn: undefined,
    Targets: undefined,
    TaskArn: undefined,
    TaskParameters: undefined,
    Type: undefined,
    WindowId: undefined,
    WindowTaskId: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.LoggingInfo !== undefined && output.LoggingInfo !== null) {
    contents.LoggingInfo = deserializeAws_json1_1LoggingInfo(
      output.LoggingInfo,
      context
    );
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Priority !== undefined && output.Priority !== null) {
    contents.Priority = output.Priority;
  }
  if (output.ServiceRoleArn !== undefined && output.ServiceRoleArn !== null) {
    contents.ServiceRoleArn = output.ServiceRoleArn;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  if (output.TaskArn !== undefined && output.TaskArn !== null) {
    contents.TaskArn = output.TaskArn;
  }
  if (output.TaskParameters !== undefined && output.TaskParameters !== null) {
    contents.TaskParameters = deserializeAws_json1_1MaintenanceWindowTaskParameters(
      output.TaskParameters,
      context
    );
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  if (output.WindowTaskId !== undefined && output.WindowTaskId !== null) {
    contents.WindowTaskId = output.WindowTaskId;
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowTaskInvocationParameters = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowTaskInvocationParameters => {
  let contents: any = {
    __type: "MaintenanceWindowTaskInvocationParameters",
    Automation: undefined,
    Lambda: undefined,
    RunCommand: undefined,
    StepFunctions: undefined
  };
  if (output.Automation !== undefined && output.Automation !== null) {
    contents.Automation = deserializeAws_json1_1MaintenanceWindowAutomationParameters(
      output.Automation,
      context
    );
  }
  if (output.Lambda !== undefined && output.Lambda !== null) {
    contents.Lambda = deserializeAws_json1_1MaintenanceWindowLambdaParameters(
      output.Lambda,
      context
    );
  }
  if (output.RunCommand !== undefined && output.RunCommand !== null) {
    contents.RunCommand = deserializeAws_json1_1MaintenanceWindowRunCommandParameters(
      output.RunCommand,
      context
    );
  }
  if (output.StepFunctions !== undefined && output.StepFunctions !== null) {
    contents.StepFunctions = deserializeAws_json1_1MaintenanceWindowStepFunctionsParameters(
      output.StepFunctions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowTaskList = (
  output: any,
  context: __SerdeContext
): Array<MaintenanceWindowTask> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MaintenanceWindowTask(entry, context)
  );
};

const deserializeAws_json1_1MaintenanceWindowTaskParameterValueExpression = (
  output: any,
  context: __SerdeContext
): MaintenanceWindowTaskParameterValueExpression => {
  let contents: any = {
    __type: "MaintenanceWindowTaskParameterValueExpression",
    Values: undefined
  };
  if (output.Values !== undefined && output.Values !== null) {
    contents.Values = deserializeAws_json1_1MaintenanceWindowTaskParameterValueList(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MaintenanceWindowTaskParameterValueList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1MaintenanceWindowTaskParameters = (
  output: any,
  context: __SerdeContext
): { [key: string]: MaintenanceWindowTaskParameterValueExpression } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[
      key
    ] = deserializeAws_json1_1MaintenanceWindowTaskParameterValueExpression(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_json1_1MaintenanceWindowTaskParametersList = (
  output: any,
  context: __SerdeContext
): Array<{ [key: string]: MaintenanceWindowTaskParameterValueExpression }> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MaintenanceWindowTaskParameters(entry, context)
  );
};

const deserializeAws_json1_1MaintenanceWindowsForTargetList = (
  output: any,
  context: __SerdeContext
): Array<MaintenanceWindowIdentityForTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MaintenanceWindowIdentityForTarget(entry, context)
  );
};

const deserializeAws_json1_1MaxDocumentSizeExceeded = (
  output: any,
  context: __SerdeContext
): MaxDocumentSizeExceeded => {
  let contents: any = {
    __type: "MaxDocumentSizeExceeded",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ModifyDocumentPermissionResponse = (
  output: any,
  context: __SerdeContext
): ModifyDocumentPermissionResponse => {
  let contents: any = {
    __type: "ModifyDocumentPermissionResponse"
  };
  return contents;
};

const deserializeAws_json1_1NonCompliantSummary = (
  output: any,
  context: __SerdeContext
): NonCompliantSummary => {
  let contents: any = {
    __type: "NonCompliantSummary",
    NonCompliantCount: undefined,
    SeveritySummary: undefined
  };
  if (
    output.NonCompliantCount !== undefined &&
    output.NonCompliantCount !== null
  ) {
    contents.NonCompliantCount = output.NonCompliantCount;
  }
  if (output.SeveritySummary !== undefined && output.SeveritySummary !== null) {
    contents.SeveritySummary = deserializeAws_json1_1SeveritySummary(
      output.SeveritySummary,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1NormalStringMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1NotificationConfig = (
  output: any,
  context: __SerdeContext
): NotificationConfig => {
  let contents: any = {
    __type: "NotificationConfig",
    NotificationArn: undefined,
    NotificationEvents: undefined,
    NotificationType: undefined
  };
  if (output.NotificationArn !== undefined && output.NotificationArn !== null) {
    contents.NotificationArn = output.NotificationArn;
  }
  if (
    output.NotificationEvents !== undefined &&
    output.NotificationEvents !== null
  ) {
    contents.NotificationEvents = deserializeAws_json1_1NotificationEventList(
      output.NotificationEvents,
      context
    );
  }
  if (
    output.NotificationType !== undefined &&
    output.NotificationType !== null
  ) {
    contents.NotificationType = output.NotificationType;
  }
  return contents;
};

const deserializeAws_json1_1NotificationEventList = (
  output: any,
  context: __SerdeContext
): Array<NotificationEvent | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1OpsEntity = (
  output: any,
  context: __SerdeContext
): OpsEntity => {
  let contents: any = {
    __type: "OpsEntity",
    Data: undefined,
    Id: undefined
  };
  if (output.Data !== undefined && output.Data !== null) {
    contents.Data = deserializeAws_json1_1OpsEntityItemMap(
      output.Data,
      context
    );
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  return contents;
};

const deserializeAws_json1_1OpsEntityItem = (
  output: any,
  context: __SerdeContext
): OpsEntityItem => {
  let contents: any = {
    __type: "OpsEntityItem",
    CaptureTime: undefined,
    Content: undefined
  };
  if (output.CaptureTime !== undefined && output.CaptureTime !== null) {
    contents.CaptureTime = output.CaptureTime;
  }
  if (output.Content !== undefined && output.Content !== null) {
    contents.Content = deserializeAws_json1_1OpsEntityItemEntryList(
      output.Content,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1OpsEntityItemEntry = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1OpsEntityItemEntryList = (
  output: any,
  context: __SerdeContext
): Array<{ [key: string]: string }> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1OpsEntityItemEntry(entry, context)
  );
};

const deserializeAws_json1_1OpsEntityItemMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: OpsEntityItem } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1OpsEntityItem(output[key], context);
  });
  return mapParams;
};

const deserializeAws_json1_1OpsEntityList = (
  output: any,
  context: __SerdeContext
): Array<OpsEntity> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1OpsEntity(entry, context)
  );
};

const deserializeAws_json1_1OpsItem = (
  output: any,
  context: __SerdeContext
): OpsItem => {
  let contents: any = {
    __type: "OpsItem",
    Category: undefined,
    CreatedBy: undefined,
    CreatedTime: undefined,
    Description: undefined,
    LastModifiedBy: undefined,
    LastModifiedTime: undefined,
    Notifications: undefined,
    OperationalData: undefined,
    OpsItemId: undefined,
    Priority: undefined,
    RelatedOpsItems: undefined,
    Severity: undefined,
    Source: undefined,
    Status: undefined,
    Title: undefined,
    Version: undefined
  };
  if (output.Category !== undefined && output.Category !== null) {
    contents.Category = output.Category;
  }
  if (output.CreatedBy !== undefined && output.CreatedBy !== null) {
    contents.CreatedBy = output.CreatedBy;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedTime !== undefined &&
    output.LastModifiedTime !== null
  ) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Notifications !== undefined && output.Notifications !== null) {
    contents.Notifications = deserializeAws_json1_1OpsItemNotifications(
      output.Notifications,
      context
    );
  }
  if (output.OperationalData !== undefined && output.OperationalData !== null) {
    contents.OperationalData = deserializeAws_json1_1OpsItemOperationalData(
      output.OperationalData,
      context
    );
  }
  if (output.OpsItemId !== undefined && output.OpsItemId !== null) {
    contents.OpsItemId = output.OpsItemId;
  }
  if (output.Priority !== undefined && output.Priority !== null) {
    contents.Priority = output.Priority;
  }
  if (output.RelatedOpsItems !== undefined && output.RelatedOpsItems !== null) {
    contents.RelatedOpsItems = deserializeAws_json1_1RelatedOpsItems(
      output.RelatedOpsItems,
      context
    );
  }
  if (output.Severity !== undefined && output.Severity !== null) {
    contents.Severity = output.Severity;
  }
  if (output.Source !== undefined && output.Source !== null) {
    contents.Source = output.Source;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1OpsItemAlreadyExistsException = (
  output: any,
  context: __SerdeContext
): OpsItemAlreadyExistsException => {
  let contents: any = {
    __type: "OpsItemAlreadyExistsException",
    Message: undefined,
    OpsItemId: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.OpsItemId !== undefined && output.OpsItemId !== null) {
    contents.OpsItemId = output.OpsItemId;
  }
  return contents;
};

const deserializeAws_json1_1OpsItemDataValue = (
  output: any,
  context: __SerdeContext
): OpsItemDataValue => {
  let contents: any = {
    __type: "OpsItemDataValue",
    Type: undefined,
    Value: undefined
  };
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1OpsItemInvalidParameterException = (
  output: any,
  context: __SerdeContext
): OpsItemInvalidParameterException => {
  let contents: any = {
    __type: "OpsItemInvalidParameterException",
    Message: undefined,
    ParameterNames: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.ParameterNames !== undefined && output.ParameterNames !== null) {
    contents.ParameterNames = deserializeAws_json1_1OpsItemParameterNamesList(
      output.ParameterNames,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1OpsItemLimitExceededException = (
  output: any,
  context: __SerdeContext
): OpsItemLimitExceededException => {
  let contents: any = {
    __type: "OpsItemLimitExceededException",
    Limit: undefined,
    LimitType: undefined,
    Message: undefined,
    ResourceTypes: undefined
  };
  if (output.Limit !== undefined && output.Limit !== null) {
    contents.Limit = output.Limit;
  }
  if (output.LimitType !== undefined && output.LimitType !== null) {
    contents.LimitType = output.LimitType;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.ResourceTypes !== undefined && output.ResourceTypes !== null) {
    contents.ResourceTypes = deserializeAws_json1_1OpsItemParameterNamesList(
      output.ResourceTypes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1OpsItemNotFoundException = (
  output: any,
  context: __SerdeContext
): OpsItemNotFoundException => {
  let contents: any = {
    __type: "OpsItemNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1OpsItemNotification = (
  output: any,
  context: __SerdeContext
): OpsItemNotification => {
  let contents: any = {
    __type: "OpsItemNotification",
    Arn: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  return contents;
};

const deserializeAws_json1_1OpsItemNotifications = (
  output: any,
  context: __SerdeContext
): Array<OpsItemNotification> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1OpsItemNotification(entry, context)
  );
};

const deserializeAws_json1_1OpsItemOperationalData = (
  output: any,
  context: __SerdeContext
): { [key: string]: OpsItemDataValue } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1OpsItemDataValue(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_json1_1OpsItemParameterNamesList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1OpsItemSummaries = (
  output: any,
  context: __SerdeContext
): Array<OpsItemSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1OpsItemSummary(entry, context)
  );
};

const deserializeAws_json1_1OpsItemSummary = (
  output: any,
  context: __SerdeContext
): OpsItemSummary => {
  let contents: any = {
    __type: "OpsItemSummary",
    Category: undefined,
    CreatedBy: undefined,
    CreatedTime: undefined,
    LastModifiedBy: undefined,
    LastModifiedTime: undefined,
    OperationalData: undefined,
    OpsItemId: undefined,
    Priority: undefined,
    Severity: undefined,
    Source: undefined,
    Status: undefined,
    Title: undefined
  };
  if (output.Category !== undefined && output.Category !== null) {
    contents.Category = output.Category;
  }
  if (output.CreatedBy !== undefined && output.CreatedBy !== null) {
    contents.CreatedBy = output.CreatedBy;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedTime !== undefined &&
    output.LastModifiedTime !== null
  ) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.OperationalData !== undefined && output.OperationalData !== null) {
    contents.OperationalData = deserializeAws_json1_1OpsItemOperationalData(
      output.OperationalData,
      context
    );
  }
  if (output.OpsItemId !== undefined && output.OpsItemId !== null) {
    contents.OpsItemId = output.OpsItemId;
  }
  if (output.Priority !== undefined && output.Priority !== null) {
    contents.Priority = output.Priority;
  }
  if (output.Severity !== undefined && output.Severity !== null) {
    contents.Severity = output.Severity;
  }
  if (output.Source !== undefined && output.Source !== null) {
    contents.Source = output.Source;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  return contents;
};

const deserializeAws_json1_1OutputSource = (
  output: any,
  context: __SerdeContext
): OutputSource => {
  let contents: any = {
    __type: "OutputSource",
    OutputSourceId: undefined,
    OutputSourceType: undefined
  };
  if (output.OutputSourceId !== undefined && output.OutputSourceId !== null) {
    contents.OutputSourceId = output.OutputSourceId;
  }
  if (
    output.OutputSourceType !== undefined &&
    output.OutputSourceType !== null
  ) {
    contents.OutputSourceType = output.OutputSourceType;
  }
  return contents;
};

const deserializeAws_json1_1Parameter = (
  output: any,
  context: __SerdeContext
): Parameter => {
  let contents: any = {
    __type: "Parameter",
    ARN: undefined,
    LastModifiedDate: undefined,
    Name: undefined,
    Selector: undefined,
    SourceResult: undefined,
    Type: undefined,
    Value: undefined,
    Version: undefined
  };
  if (output.ARN !== undefined && output.ARN !== null) {
    contents.ARN = output.ARN;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = new Date(
      Math.round(output.LastModifiedDate * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Selector !== undefined && output.Selector !== null) {
    contents.Selector = output.Selector;
  }
  if (output.SourceResult !== undefined && output.SourceResult !== null) {
    contents.SourceResult = output.SourceResult;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1ParameterAlreadyExists = (
  output: any,
  context: __SerdeContext
): ParameterAlreadyExists => {
  let contents: any = {
    __type: "ParameterAlreadyExists",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParameterHistory = (
  output: any,
  context: __SerdeContext
): ParameterHistory => {
  let contents: any = {
    __type: "ParameterHistory",
    AllowedPattern: undefined,
    Description: undefined,
    KeyId: undefined,
    Labels: undefined,
    LastModifiedDate: undefined,
    LastModifiedUser: undefined,
    Name: undefined,
    Policies: undefined,
    Tier: undefined,
    Type: undefined,
    Value: undefined,
    Version: undefined
  };
  if (output.AllowedPattern !== undefined && output.AllowedPattern !== null) {
    contents.AllowedPattern = output.AllowedPattern;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.KeyId !== undefined && output.KeyId !== null) {
    contents.KeyId = output.KeyId;
  }
  if (output.Labels !== undefined && output.Labels !== null) {
    contents.Labels = deserializeAws_json1_1ParameterLabelList(
      output.Labels,
      context
    );
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = new Date(
      Math.round(output.LastModifiedDate * 1000)
    );
  }
  if (
    output.LastModifiedUser !== undefined &&
    output.LastModifiedUser !== null
  ) {
    contents.LastModifiedUser = output.LastModifiedUser;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Policies !== undefined && output.Policies !== null) {
    contents.Policies = deserializeAws_json1_1ParameterPolicyList(
      output.Policies,
      context
    );
  }
  if (output.Tier !== undefined && output.Tier !== null) {
    contents.Tier = output.Tier;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1ParameterHistoryList = (
  output: any,
  context: __SerdeContext
): Array<ParameterHistory> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ParameterHistory(entry, context)
  );
};

const deserializeAws_json1_1ParameterInlinePolicy = (
  output: any,
  context: __SerdeContext
): ParameterInlinePolicy => {
  let contents: any = {
    __type: "ParameterInlinePolicy",
    PolicyStatus: undefined,
    PolicyText: undefined,
    PolicyType: undefined
  };
  if (output.PolicyStatus !== undefined && output.PolicyStatus !== null) {
    contents.PolicyStatus = output.PolicyStatus;
  }
  if (output.PolicyText !== undefined && output.PolicyText !== null) {
    contents.PolicyText = output.PolicyText;
  }
  if (output.PolicyType !== undefined && output.PolicyType !== null) {
    contents.PolicyType = output.PolicyType;
  }
  return contents;
};

const deserializeAws_json1_1ParameterLabelList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ParameterLimitExceeded = (
  output: any,
  context: __SerdeContext
): ParameterLimitExceeded => {
  let contents: any = {
    __type: "ParameterLimitExceeded",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParameterList = (
  output: any,
  context: __SerdeContext
): Array<Parameter> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Parameter(entry, context)
  );
};

const deserializeAws_json1_1ParameterMaxVersionLimitExceeded = (
  output: any,
  context: __SerdeContext
): ParameterMaxVersionLimitExceeded => {
  let contents: any = {
    __type: "ParameterMaxVersionLimitExceeded",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParameterMetadata = (
  output: any,
  context: __SerdeContext
): ParameterMetadata => {
  let contents: any = {
    __type: "ParameterMetadata",
    AllowedPattern: undefined,
    Description: undefined,
    KeyId: undefined,
    LastModifiedDate: undefined,
    LastModifiedUser: undefined,
    Name: undefined,
    Policies: undefined,
    Tier: undefined,
    Type: undefined,
    Version: undefined
  };
  if (output.AllowedPattern !== undefined && output.AllowedPattern !== null) {
    contents.AllowedPattern = output.AllowedPattern;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.KeyId !== undefined && output.KeyId !== null) {
    contents.KeyId = output.KeyId;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = new Date(
      Math.round(output.LastModifiedDate * 1000)
    );
  }
  if (
    output.LastModifiedUser !== undefined &&
    output.LastModifiedUser !== null
  ) {
    contents.LastModifiedUser = output.LastModifiedUser;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Policies !== undefined && output.Policies !== null) {
    contents.Policies = deserializeAws_json1_1ParameterPolicyList(
      output.Policies,
      context
    );
  }
  if (output.Tier !== undefined && output.Tier !== null) {
    contents.Tier = output.Tier;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1ParameterMetadataList = (
  output: any,
  context: __SerdeContext
): Array<ParameterMetadata> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ParameterMetadata(entry, context)
  );
};

const deserializeAws_json1_1ParameterNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ParameterNotFound = (
  output: any,
  context: __SerdeContext
): ParameterNotFound => {
  let contents: any = {
    __type: "ParameterNotFound",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParameterPatternMismatchException = (
  output: any,
  context: __SerdeContext
): ParameterPatternMismatchException => {
  let contents: any = {
    __type: "ParameterPatternMismatchException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParameterPolicyList = (
  output: any,
  context: __SerdeContext
): Array<ParameterInlinePolicy> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ParameterInlinePolicy(entry, context)
  );
};

const deserializeAws_json1_1ParameterValueList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ParameterVersionLabelLimitExceeded = (
  output: any,
  context: __SerdeContext
): ParameterVersionLabelLimitExceeded => {
  let contents: any = {
    __type: "ParameterVersionLabelLimitExceeded",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ParameterVersionNotFound = (
  output: any,
  context: __SerdeContext
): ParameterVersionNotFound => {
  let contents: any = {
    __type: "ParameterVersionNotFound",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1Parameters = (
  output: any,
  context: __SerdeContext
): { [key: string]: Array<string> } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1ParameterValueList(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_json1_1Patch = (
  output: any,
  context: __SerdeContext
): Patch => {
  let contents: any = {
    __type: "Patch",
    Classification: undefined,
    ContentUrl: undefined,
    Description: undefined,
    Id: undefined,
    KbNumber: undefined,
    Language: undefined,
    MsrcNumber: undefined,
    MsrcSeverity: undefined,
    Product: undefined,
    ProductFamily: undefined,
    ReleaseDate: undefined,
    Title: undefined,
    Vendor: undefined
  };
  if (output.Classification !== undefined && output.Classification !== null) {
    contents.Classification = output.Classification;
  }
  if (output.ContentUrl !== undefined && output.ContentUrl !== null) {
    contents.ContentUrl = output.ContentUrl;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.KbNumber !== undefined && output.KbNumber !== null) {
    contents.KbNumber = output.KbNumber;
  }
  if (output.Language !== undefined && output.Language !== null) {
    contents.Language = output.Language;
  }
  if (output.MsrcNumber !== undefined && output.MsrcNumber !== null) {
    contents.MsrcNumber = output.MsrcNumber;
  }
  if (output.MsrcSeverity !== undefined && output.MsrcSeverity !== null) {
    contents.MsrcSeverity = output.MsrcSeverity;
  }
  if (output.Product !== undefined && output.Product !== null) {
    contents.Product = output.Product;
  }
  if (output.ProductFamily !== undefined && output.ProductFamily !== null) {
    contents.ProductFamily = output.ProductFamily;
  }
  if (output.ReleaseDate !== undefined && output.ReleaseDate !== null) {
    contents.ReleaseDate = new Date(Math.round(output.ReleaseDate * 1000));
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  if (output.Vendor !== undefined && output.Vendor !== null) {
    contents.Vendor = output.Vendor;
  }
  return contents;
};

const deserializeAws_json1_1PatchBaselineIdentity = (
  output: any,
  context: __SerdeContext
): PatchBaselineIdentity => {
  let contents: any = {
    __type: "PatchBaselineIdentity",
    BaselineDescription: undefined,
    BaselineId: undefined,
    BaselineName: undefined,
    DefaultBaseline: undefined,
    OperatingSystem: undefined
  };
  if (
    output.BaselineDescription !== undefined &&
    output.BaselineDescription !== null
  ) {
    contents.BaselineDescription = output.BaselineDescription;
  }
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  if (output.BaselineName !== undefined && output.BaselineName !== null) {
    contents.BaselineName = output.BaselineName;
  }
  if (output.DefaultBaseline !== undefined && output.DefaultBaseline !== null) {
    contents.DefaultBaseline = output.DefaultBaseline;
  }
  if (output.OperatingSystem !== undefined && output.OperatingSystem !== null) {
    contents.OperatingSystem = output.OperatingSystem;
  }
  return contents;
};

const deserializeAws_json1_1PatchBaselineIdentityList = (
  output: any,
  context: __SerdeContext
): Array<PatchBaselineIdentity> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PatchBaselineIdentity(entry, context)
  );
};

const deserializeAws_json1_1PatchComplianceData = (
  output: any,
  context: __SerdeContext
): PatchComplianceData => {
  let contents: any = {
    __type: "PatchComplianceData",
    Classification: undefined,
    InstalledTime: undefined,
    KBId: undefined,
    Severity: undefined,
    State: undefined,
    Title: undefined
  };
  if (output.Classification !== undefined && output.Classification !== null) {
    contents.Classification = output.Classification;
  }
  if (output.InstalledTime !== undefined && output.InstalledTime !== null) {
    contents.InstalledTime = new Date(Math.round(output.InstalledTime * 1000));
  }
  if (output.KBId !== undefined && output.KBId !== null) {
    contents.KBId = output.KBId;
  }
  if (output.Severity !== undefined && output.Severity !== null) {
    contents.Severity = output.Severity;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  return contents;
};

const deserializeAws_json1_1PatchComplianceDataList = (
  output: any,
  context: __SerdeContext
): Array<PatchComplianceData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PatchComplianceData(entry, context)
  );
};

const deserializeAws_json1_1PatchFilter = (
  output: any,
  context: __SerdeContext
): PatchFilter => {
  let contents: any = {
    __type: "PatchFilter",
    Key: undefined,
    Values: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Values !== undefined && output.Values !== null) {
    contents.Values = deserializeAws_json1_1PatchFilterValueList(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PatchFilterGroup = (
  output: any,
  context: __SerdeContext
): PatchFilterGroup => {
  let contents: any = {
    __type: "PatchFilterGroup",
    PatchFilters: undefined
  };
  if (output.PatchFilters !== undefined && output.PatchFilters !== null) {
    contents.PatchFilters = deserializeAws_json1_1PatchFilterList(
      output.PatchFilters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PatchFilterList = (
  output: any,
  context: __SerdeContext
): Array<PatchFilter> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PatchFilter(entry, context)
  );
};

const deserializeAws_json1_1PatchFilterValueList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PatchGroupList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PatchGroupPatchBaselineMapping = (
  output: any,
  context: __SerdeContext
): PatchGroupPatchBaselineMapping => {
  let contents: any = {
    __type: "PatchGroupPatchBaselineMapping",
    BaselineIdentity: undefined,
    PatchGroup: undefined
  };
  if (
    output.BaselineIdentity !== undefined &&
    output.BaselineIdentity !== null
  ) {
    contents.BaselineIdentity = deserializeAws_json1_1PatchBaselineIdentity(
      output.BaselineIdentity,
      context
    );
  }
  if (output.PatchGroup !== undefined && output.PatchGroup !== null) {
    contents.PatchGroup = output.PatchGroup;
  }
  return contents;
};

const deserializeAws_json1_1PatchGroupPatchBaselineMappingList = (
  output: any,
  context: __SerdeContext
): Array<PatchGroupPatchBaselineMapping> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PatchGroupPatchBaselineMapping(entry, context)
  );
};

const deserializeAws_json1_1PatchIdList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PatchList = (
  output: any,
  context: __SerdeContext
): Array<Patch> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Patch(entry, context)
  );
};

const deserializeAws_json1_1PatchPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<{ [key: string]: string }> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PatchPropertyEntry(entry, context)
  );
};

const deserializeAws_json1_1PatchPropertyEntry = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1PatchRule = (
  output: any,
  context: __SerdeContext
): PatchRule => {
  let contents: any = {
    __type: "PatchRule",
    ApproveAfterDays: undefined,
    ComplianceLevel: undefined,
    EnableNonSecurity: undefined,
    PatchFilterGroup: undefined
  };
  if (
    output.ApproveAfterDays !== undefined &&
    output.ApproveAfterDays !== null
  ) {
    contents.ApproveAfterDays = output.ApproveAfterDays;
  }
  if (output.ComplianceLevel !== undefined && output.ComplianceLevel !== null) {
    contents.ComplianceLevel = output.ComplianceLevel;
  }
  if (
    output.EnableNonSecurity !== undefined &&
    output.EnableNonSecurity !== null
  ) {
    contents.EnableNonSecurity = output.EnableNonSecurity;
  }
  if (
    output.PatchFilterGroup !== undefined &&
    output.PatchFilterGroup !== null
  ) {
    contents.PatchFilterGroup = deserializeAws_json1_1PatchFilterGroup(
      output.PatchFilterGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PatchRuleGroup = (
  output: any,
  context: __SerdeContext
): PatchRuleGroup => {
  let contents: any = {
    __type: "PatchRuleGroup",
    PatchRules: undefined
  };
  if (output.PatchRules !== undefined && output.PatchRules !== null) {
    contents.PatchRules = deserializeAws_json1_1PatchRuleList(
      output.PatchRules,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PatchRuleList = (
  output: any,
  context: __SerdeContext
): Array<PatchRule> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PatchRule(entry, context)
  );
};

const deserializeAws_json1_1PatchSource = (
  output: any,
  context: __SerdeContext
): PatchSource => {
  let contents: any = {
    __type: "PatchSource",
    Configuration: undefined,
    Name: undefined,
    Products: undefined
  };
  if (output.Configuration !== undefined && output.Configuration !== null) {
    contents.Configuration = output.Configuration;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Products !== undefined && output.Products !== null) {
    contents.Products = deserializeAws_json1_1PatchSourceProductList(
      output.Products,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PatchSourceList = (
  output: any,
  context: __SerdeContext
): Array<PatchSource> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PatchSource(entry, context)
  );
};

const deserializeAws_json1_1PatchSourceProductList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PatchStatus = (
  output: any,
  context: __SerdeContext
): PatchStatus => {
  let contents: any = {
    __type: "PatchStatus",
    ApprovalDate: undefined,
    ComplianceLevel: undefined,
    DeploymentStatus: undefined
  };
  if (output.ApprovalDate !== undefined && output.ApprovalDate !== null) {
    contents.ApprovalDate = new Date(Math.round(output.ApprovalDate * 1000));
  }
  if (output.ComplianceLevel !== undefined && output.ComplianceLevel !== null) {
    contents.ComplianceLevel = output.ComplianceLevel;
  }
  if (
    output.DeploymentStatus !== undefined &&
    output.DeploymentStatus !== null
  ) {
    contents.DeploymentStatus = output.DeploymentStatus;
  }
  return contents;
};

const deserializeAws_json1_1PlatformTypeList = (
  output: any,
  context: __SerdeContext
): Array<PlatformType | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1PoliciesLimitExceededException = (
  output: any,
  context: __SerdeContext
): PoliciesLimitExceededException => {
  let contents: any = {
    __type: "PoliciesLimitExceededException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ProgressCounters = (
  output: any,
  context: __SerdeContext
): ProgressCounters => {
  let contents: any = {
    __type: "ProgressCounters",
    CancelledSteps: undefined,
    FailedSteps: undefined,
    SuccessSteps: undefined,
    TimedOutSteps: undefined,
    TotalSteps: undefined
  };
  if (output.CancelledSteps !== undefined && output.CancelledSteps !== null) {
    contents.CancelledSteps = output.CancelledSteps;
  }
  if (output.FailedSteps !== undefined && output.FailedSteps !== null) {
    contents.FailedSteps = output.FailedSteps;
  }
  if (output.SuccessSteps !== undefined && output.SuccessSteps !== null) {
    contents.SuccessSteps = output.SuccessSteps;
  }
  if (output.TimedOutSteps !== undefined && output.TimedOutSteps !== null) {
    contents.TimedOutSteps = output.TimedOutSteps;
  }
  if (output.TotalSteps !== undefined && output.TotalSteps !== null) {
    contents.TotalSteps = output.TotalSteps;
  }
  return contents;
};

const deserializeAws_json1_1PutComplianceItemsResult = (
  output: any,
  context: __SerdeContext
): PutComplianceItemsResult => {
  let contents: any = {
    __type: "PutComplianceItemsResult"
  };
  return contents;
};

const deserializeAws_json1_1PutInventoryResult = (
  output: any,
  context: __SerdeContext
): PutInventoryResult => {
  let contents: any = {
    __type: "PutInventoryResult",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1PutParameterResult = (
  output: any,
  context: __SerdeContext
): PutParameterResult => {
  let contents: any = {
    __type: "PutParameterResult",
    Tier: undefined,
    Version: undefined
  };
  if (output.Tier !== undefined && output.Tier !== null) {
    contents.Tier = output.Tier;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1Regions = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1RegisterDefaultPatchBaselineResult = (
  output: any,
  context: __SerdeContext
): RegisterDefaultPatchBaselineResult => {
  let contents: any = {
    __type: "RegisterDefaultPatchBaselineResult",
    BaselineId: undefined
  };
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  return contents;
};

const deserializeAws_json1_1RegisterPatchBaselineForPatchGroupResult = (
  output: any,
  context: __SerdeContext
): RegisterPatchBaselineForPatchGroupResult => {
  let contents: any = {
    __type: "RegisterPatchBaselineForPatchGroupResult",
    BaselineId: undefined,
    PatchGroup: undefined
  };
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  if (output.PatchGroup !== undefined && output.PatchGroup !== null) {
    contents.PatchGroup = output.PatchGroup;
  }
  return contents;
};

const deserializeAws_json1_1RegisterTargetWithMaintenanceWindowResult = (
  output: any,
  context: __SerdeContext
): RegisterTargetWithMaintenanceWindowResult => {
  let contents: any = {
    __type: "RegisterTargetWithMaintenanceWindowResult",
    WindowTargetId: undefined
  };
  if (output.WindowTargetId !== undefined && output.WindowTargetId !== null) {
    contents.WindowTargetId = output.WindowTargetId;
  }
  return contents;
};

const deserializeAws_json1_1RegisterTaskWithMaintenanceWindowResult = (
  output: any,
  context: __SerdeContext
): RegisterTaskWithMaintenanceWindowResult => {
  let contents: any = {
    __type: "RegisterTaskWithMaintenanceWindowResult",
    WindowTaskId: undefined
  };
  if (output.WindowTaskId !== undefined && output.WindowTaskId !== null) {
    contents.WindowTaskId = output.WindowTaskId;
  }
  return contents;
};

const deserializeAws_json1_1RelatedOpsItem = (
  output: any,
  context: __SerdeContext
): RelatedOpsItem => {
  let contents: any = {
    __type: "RelatedOpsItem",
    OpsItemId: undefined
  };
  if (output.OpsItemId !== undefined && output.OpsItemId !== null) {
    contents.OpsItemId = output.OpsItemId;
  }
  return contents;
};

const deserializeAws_json1_1RelatedOpsItems = (
  output: any,
  context: __SerdeContext
): Array<RelatedOpsItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RelatedOpsItem(entry, context)
  );
};

const deserializeAws_json1_1RemoveTagsFromResourceResult = (
  output: any,
  context: __SerdeContext
): RemoveTagsFromResourceResult => {
  let contents: any = {
    __type: "RemoveTagsFromResourceResult"
  };
  return contents;
};

const deserializeAws_json1_1ResetServiceSettingResult = (
  output: any,
  context: __SerdeContext
): ResetServiceSettingResult => {
  let contents: any = {
    __type: "ResetServiceSettingResult",
    ServiceSetting: undefined
  };
  if (output.ServiceSetting !== undefined && output.ServiceSetting !== null) {
    contents.ServiceSetting = deserializeAws_json1_1ServiceSetting(
      output.ServiceSetting,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ResolvedTargets = (
  output: any,
  context: __SerdeContext
): ResolvedTargets => {
  let contents: any = {
    __type: "ResolvedTargets",
    ParameterValues: undefined,
    Truncated: undefined
  };
  if (output.ParameterValues !== undefined && output.ParameterValues !== null) {
    contents.ParameterValues = deserializeAws_json1_1TargetParameterList(
      output.ParameterValues,
      context
    );
  }
  if (output.Truncated !== undefined && output.Truncated !== null) {
    contents.Truncated = output.Truncated;
  }
  return contents;
};

const deserializeAws_json1_1ResourceComplianceSummaryItem = (
  output: any,
  context: __SerdeContext
): ResourceComplianceSummaryItem => {
  let contents: any = {
    __type: "ResourceComplianceSummaryItem",
    ComplianceType: undefined,
    CompliantSummary: undefined,
    ExecutionSummary: undefined,
    NonCompliantSummary: undefined,
    OverallSeverity: undefined,
    ResourceId: undefined,
    ResourceType: undefined,
    Status: undefined
  };
  if (output.ComplianceType !== undefined && output.ComplianceType !== null) {
    contents.ComplianceType = output.ComplianceType;
  }
  if (
    output.CompliantSummary !== undefined &&
    output.CompliantSummary !== null
  ) {
    contents.CompliantSummary = deserializeAws_json1_1CompliantSummary(
      output.CompliantSummary,
      context
    );
  }
  if (
    output.ExecutionSummary !== undefined &&
    output.ExecutionSummary !== null
  ) {
    contents.ExecutionSummary = deserializeAws_json1_1ComplianceExecutionSummary(
      output.ExecutionSummary,
      context
    );
  }
  if (
    output.NonCompliantSummary !== undefined &&
    output.NonCompliantSummary !== null
  ) {
    contents.NonCompliantSummary = deserializeAws_json1_1NonCompliantSummary(
      output.NonCompliantSummary,
      context
    );
  }
  if (output.OverallSeverity !== undefined && output.OverallSeverity !== null) {
    contents.OverallSeverity = output.OverallSeverity;
  }
  if (output.ResourceId !== undefined && output.ResourceId !== null) {
    contents.ResourceId = output.ResourceId;
  }
  if (output.ResourceType !== undefined && output.ResourceType !== null) {
    contents.ResourceType = output.ResourceType;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1ResourceComplianceSummaryItemList = (
  output: any,
  context: __SerdeContext
): Array<ResourceComplianceSummaryItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ResourceComplianceSummaryItem(entry, context)
  );
};

const deserializeAws_json1_1ResourceDataSyncAlreadyExistsException = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncAlreadyExistsException => {
  let contents: any = {
    __type: "ResourceDataSyncAlreadyExistsException",
    SyncName: undefined
  };
  if (output.SyncName !== undefined && output.SyncName !== null) {
    contents.SyncName = output.SyncName;
  }
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncAwsOrganizationsSource = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncAwsOrganizationsSource => {
  let contents: any = {
    __type: "ResourceDataSyncAwsOrganizationsSource",
    OrganizationSourceType: undefined,
    OrganizationalUnits: undefined
  };
  if (
    output.OrganizationSourceType !== undefined &&
    output.OrganizationSourceType !== null
  ) {
    contents.OrganizationSourceType = output.OrganizationSourceType;
  }
  if (
    output.OrganizationalUnits !== undefined &&
    output.OrganizationalUnits !== null
  ) {
    contents.OrganizationalUnits = deserializeAws_json1_1ResourceDataSyncOrganizationalUnitList(
      output.OrganizationalUnits,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncConflictException = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncConflictException => {
  let contents: any = {
    __type: "ResourceDataSyncConflictException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncCountExceededException = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncCountExceededException => {
  let contents: any = {
    __type: "ResourceDataSyncCountExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncInvalidConfigurationException = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncInvalidConfigurationException => {
  let contents: any = {
    __type: "ResourceDataSyncInvalidConfigurationException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncItem = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncItem => {
  let contents: any = {
    __type: "ResourceDataSyncItem",
    LastStatus: undefined,
    LastSuccessfulSyncTime: undefined,
    LastSyncStatusMessage: undefined,
    LastSyncTime: undefined,
    S3Destination: undefined,
    SyncCreatedTime: undefined,
    SyncLastModifiedTime: undefined,
    SyncName: undefined,
    SyncSource: undefined,
    SyncType: undefined
  };
  if (output.LastStatus !== undefined && output.LastStatus !== null) {
    contents.LastStatus = output.LastStatus;
  }
  if (
    output.LastSuccessfulSyncTime !== undefined &&
    output.LastSuccessfulSyncTime !== null
  ) {
    contents.LastSuccessfulSyncTime = new Date(
      Math.round(output.LastSuccessfulSyncTime * 1000)
    );
  }
  if (
    output.LastSyncStatusMessage !== undefined &&
    output.LastSyncStatusMessage !== null
  ) {
    contents.LastSyncStatusMessage = output.LastSyncStatusMessage;
  }
  if (output.LastSyncTime !== undefined && output.LastSyncTime !== null) {
    contents.LastSyncTime = new Date(Math.round(output.LastSyncTime * 1000));
  }
  if (output.S3Destination !== undefined && output.S3Destination !== null) {
    contents.S3Destination = deserializeAws_json1_1ResourceDataSyncS3Destination(
      output.S3Destination,
      context
    );
  }
  if (output.SyncCreatedTime !== undefined && output.SyncCreatedTime !== null) {
    contents.SyncCreatedTime = new Date(
      Math.round(output.SyncCreatedTime * 1000)
    );
  }
  if (
    output.SyncLastModifiedTime !== undefined &&
    output.SyncLastModifiedTime !== null
  ) {
    contents.SyncLastModifiedTime = new Date(
      Math.round(output.SyncLastModifiedTime * 1000)
    );
  }
  if (output.SyncName !== undefined && output.SyncName !== null) {
    contents.SyncName = output.SyncName;
  }
  if (output.SyncSource !== undefined && output.SyncSource !== null) {
    contents.SyncSource = deserializeAws_json1_1ResourceDataSyncSourceWithState(
      output.SyncSource,
      context
    );
  }
  if (output.SyncType !== undefined && output.SyncType !== null) {
    contents.SyncType = output.SyncType;
  }
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncItemList = (
  output: any,
  context: __SerdeContext
): Array<ResourceDataSyncItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ResourceDataSyncItem(entry, context)
  );
};

const deserializeAws_json1_1ResourceDataSyncNotFoundException = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncNotFoundException => {
  let contents: any = {
    __type: "ResourceDataSyncNotFoundException",
    Message: undefined,
    SyncName: undefined,
    SyncType: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.SyncName !== undefined && output.SyncName !== null) {
    contents.SyncName = output.SyncName;
  }
  if (output.SyncType !== undefined && output.SyncType !== null) {
    contents.SyncType = output.SyncType;
  }
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncOrganizationalUnit = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncOrganizationalUnit => {
  let contents: any = {
    __type: "ResourceDataSyncOrganizationalUnit",
    OrganizationalUnitId: undefined
  };
  if (
    output.OrganizationalUnitId !== undefined &&
    output.OrganizationalUnitId !== null
  ) {
    contents.OrganizationalUnitId = output.OrganizationalUnitId;
  }
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncOrganizationalUnitList = (
  output: any,
  context: __SerdeContext
): Array<ResourceDataSyncOrganizationalUnit> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ResourceDataSyncOrganizationalUnit(entry, context)
  );
};

const deserializeAws_json1_1ResourceDataSyncS3Destination = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncS3Destination => {
  let contents: any = {
    __type: "ResourceDataSyncS3Destination",
    AWSKMSKeyARN: undefined,
    BucketName: undefined,
    Prefix: undefined,
    Region: undefined,
    SyncFormat: undefined
  };
  if (output.AWSKMSKeyARN !== undefined && output.AWSKMSKeyARN !== null) {
    contents.AWSKMSKeyARN = output.AWSKMSKeyARN;
  }
  if (output.BucketName !== undefined && output.BucketName !== null) {
    contents.BucketName = output.BucketName;
  }
  if (output.Prefix !== undefined && output.Prefix !== null) {
    contents.Prefix = output.Prefix;
  }
  if (output.Region !== undefined && output.Region !== null) {
    contents.Region = output.Region;
  }
  if (output.SyncFormat !== undefined && output.SyncFormat !== null) {
    contents.SyncFormat = output.SyncFormat;
  }
  return contents;
};

const deserializeAws_json1_1ResourceDataSyncSourceRegionList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ResourceDataSyncSourceWithState = (
  output: any,
  context: __SerdeContext
): ResourceDataSyncSourceWithState => {
  let contents: any = {
    __type: "ResourceDataSyncSourceWithState",
    AwsOrganizationsSource: undefined,
    IncludeFutureRegions: undefined,
    SourceRegions: undefined,
    SourceType: undefined,
    State: undefined
  };
  if (
    output.AwsOrganizationsSource !== undefined &&
    output.AwsOrganizationsSource !== null
  ) {
    contents.AwsOrganizationsSource = deserializeAws_json1_1ResourceDataSyncAwsOrganizationsSource(
      output.AwsOrganizationsSource,
      context
    );
  }
  if (
    output.IncludeFutureRegions !== undefined &&
    output.IncludeFutureRegions !== null
  ) {
    contents.IncludeFutureRegions = output.IncludeFutureRegions;
  }
  if (output.SourceRegions !== undefined && output.SourceRegions !== null) {
    contents.SourceRegions = deserializeAws_json1_1ResourceDataSyncSourceRegionList(
      output.SourceRegions,
      context
    );
  }
  if (output.SourceType !== undefined && output.SourceType !== null) {
    contents.SourceType = output.SourceType;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  return contents;
};

const deserializeAws_json1_1ResourceInUseException = (
  output: any,
  context: __SerdeContext
): ResourceInUseException => {
  let contents: any = {
    __type: "ResourceInUseException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceLimitExceededException = (
  output: any,
  context: __SerdeContext
): ResourceLimitExceededException => {
  let contents: any = {
    __type: "ResourceLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResumeSessionResponse = (
  output: any,
  context: __SerdeContext
): ResumeSessionResponse => {
  let contents: any = {
    __type: "ResumeSessionResponse",
    SessionId: undefined,
    StreamUrl: undefined,
    TokenValue: undefined
  };
  if (output.SessionId !== undefined && output.SessionId !== null) {
    contents.SessionId = output.SessionId;
  }
  if (output.StreamUrl !== undefined && output.StreamUrl !== null) {
    contents.StreamUrl = output.StreamUrl;
  }
  if (output.TokenValue !== undefined && output.TokenValue !== null) {
    contents.TokenValue = output.TokenValue;
  }
  return contents;
};

const deserializeAws_json1_1S3OutputLocation = (
  output: any,
  context: __SerdeContext
): S3OutputLocation => {
  let contents: any = {
    __type: "S3OutputLocation",
    OutputS3BucketName: undefined,
    OutputS3KeyPrefix: undefined,
    OutputS3Region: undefined
  };
  if (
    output.OutputS3BucketName !== undefined &&
    output.OutputS3BucketName !== null
  ) {
    contents.OutputS3BucketName = output.OutputS3BucketName;
  }
  if (
    output.OutputS3KeyPrefix !== undefined &&
    output.OutputS3KeyPrefix !== null
  ) {
    contents.OutputS3KeyPrefix = output.OutputS3KeyPrefix;
  }
  if (output.OutputS3Region !== undefined && output.OutputS3Region !== null) {
    contents.OutputS3Region = output.OutputS3Region;
  }
  return contents;
};

const deserializeAws_json1_1S3OutputUrl = (
  output: any,
  context: __SerdeContext
): S3OutputUrl => {
  let contents: any = {
    __type: "S3OutputUrl",
    OutputUrl: undefined
  };
  if (output.OutputUrl !== undefined && output.OutputUrl !== null) {
    contents.OutputUrl = output.OutputUrl;
  }
  return contents;
};

const deserializeAws_json1_1ScheduledWindowExecution = (
  output: any,
  context: __SerdeContext
): ScheduledWindowExecution => {
  let contents: any = {
    __type: "ScheduledWindowExecution",
    ExecutionTime: undefined,
    Name: undefined,
    WindowId: undefined
  };
  if (output.ExecutionTime !== undefined && output.ExecutionTime !== null) {
    contents.ExecutionTime = output.ExecutionTime;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  return contents;
};

const deserializeAws_json1_1ScheduledWindowExecutionList = (
  output: any,
  context: __SerdeContext
): Array<ScheduledWindowExecution> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ScheduledWindowExecution(entry, context)
  );
};

const deserializeAws_json1_1SendAutomationSignalResult = (
  output: any,
  context: __SerdeContext
): SendAutomationSignalResult => {
  let contents: any = {
    __type: "SendAutomationSignalResult"
  };
  return contents;
};

const deserializeAws_json1_1SendCommandResult = (
  output: any,
  context: __SerdeContext
): SendCommandResult => {
  let contents: any = {
    __type: "SendCommandResult",
    Command: undefined
  };
  if (output.Command !== undefined && output.Command !== null) {
    contents.Command = deserializeAws_json1_1Command(output.Command, context);
  }
  return contents;
};

const deserializeAws_json1_1ServiceSetting = (
  output: any,
  context: __SerdeContext
): ServiceSetting => {
  let contents: any = {
    __type: "ServiceSetting",
    ARN: undefined,
    LastModifiedDate: undefined,
    LastModifiedUser: undefined,
    SettingId: undefined,
    SettingValue: undefined,
    Status: undefined
  };
  if (output.ARN !== undefined && output.ARN !== null) {
    contents.ARN = output.ARN;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = new Date(
      Math.round(output.LastModifiedDate * 1000)
    );
  }
  if (
    output.LastModifiedUser !== undefined &&
    output.LastModifiedUser !== null
  ) {
    contents.LastModifiedUser = output.LastModifiedUser;
  }
  if (output.SettingId !== undefined && output.SettingId !== null) {
    contents.SettingId = output.SettingId;
  }
  if (output.SettingValue !== undefined && output.SettingValue !== null) {
    contents.SettingValue = output.SettingValue;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1ServiceSettingNotFound = (
  output: any,
  context: __SerdeContext
): ServiceSettingNotFound => {
  let contents: any = {
    __type: "ServiceSettingNotFound",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1Session = (
  output: any,
  context: __SerdeContext
): Session => {
  let contents: any = {
    __type: "Session",
    Details: undefined,
    DocumentName: undefined,
    EndDate: undefined,
    OutputUrl: undefined,
    Owner: undefined,
    SessionId: undefined,
    StartDate: undefined,
    Status: undefined,
    Target: undefined
  };
  if (output.Details !== undefined && output.Details !== null) {
    contents.Details = output.Details;
  }
  if (output.DocumentName !== undefined && output.DocumentName !== null) {
    contents.DocumentName = output.DocumentName;
  }
  if (output.EndDate !== undefined && output.EndDate !== null) {
    contents.EndDate = new Date(Math.round(output.EndDate * 1000));
  }
  if (output.OutputUrl !== undefined && output.OutputUrl !== null) {
    contents.OutputUrl = deserializeAws_json1_1SessionManagerOutputUrl(
      output.OutputUrl,
      context
    );
  }
  if (output.Owner !== undefined && output.Owner !== null) {
    contents.Owner = output.Owner;
  }
  if (output.SessionId !== undefined && output.SessionId !== null) {
    contents.SessionId = output.SessionId;
  }
  if (output.StartDate !== undefined && output.StartDate !== null) {
    contents.StartDate = new Date(Math.round(output.StartDate * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Target !== undefined && output.Target !== null) {
    contents.Target = output.Target;
  }
  return contents;
};

const deserializeAws_json1_1SessionList = (
  output: any,
  context: __SerdeContext
): Array<Session> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Session(entry, context)
  );
};

const deserializeAws_json1_1SessionManagerOutputUrl = (
  output: any,
  context: __SerdeContext
): SessionManagerOutputUrl => {
  let contents: any = {
    __type: "SessionManagerOutputUrl",
    CloudWatchOutputUrl: undefined,
    S3OutputUrl: undefined
  };
  if (
    output.CloudWatchOutputUrl !== undefined &&
    output.CloudWatchOutputUrl !== null
  ) {
    contents.CloudWatchOutputUrl = output.CloudWatchOutputUrl;
  }
  if (output.S3OutputUrl !== undefined && output.S3OutputUrl !== null) {
    contents.S3OutputUrl = output.S3OutputUrl;
  }
  return contents;
};

const deserializeAws_json1_1SeveritySummary = (
  output: any,
  context: __SerdeContext
): SeveritySummary => {
  let contents: any = {
    __type: "SeveritySummary",
    CriticalCount: undefined,
    HighCount: undefined,
    InformationalCount: undefined,
    LowCount: undefined,
    MediumCount: undefined,
    UnspecifiedCount: undefined
  };
  if (output.CriticalCount !== undefined && output.CriticalCount !== null) {
    contents.CriticalCount = output.CriticalCount;
  }
  if (output.HighCount !== undefined && output.HighCount !== null) {
    contents.HighCount = output.HighCount;
  }
  if (
    output.InformationalCount !== undefined &&
    output.InformationalCount !== null
  ) {
    contents.InformationalCount = output.InformationalCount;
  }
  if (output.LowCount !== undefined && output.LowCount !== null) {
    contents.LowCount = output.LowCount;
  }
  if (output.MediumCount !== undefined && output.MediumCount !== null) {
    contents.MediumCount = output.MediumCount;
  }
  if (
    output.UnspecifiedCount !== undefined &&
    output.UnspecifiedCount !== null
  ) {
    contents.UnspecifiedCount = output.UnspecifiedCount;
  }
  return contents;
};

const deserializeAws_json1_1StartAssociationsOnceResult = (
  output: any,
  context: __SerdeContext
): StartAssociationsOnceResult => {
  let contents: any = {
    __type: "StartAssociationsOnceResult"
  };
  return contents;
};

const deserializeAws_json1_1StartAutomationExecutionResult = (
  output: any,
  context: __SerdeContext
): StartAutomationExecutionResult => {
  let contents: any = {
    __type: "StartAutomationExecutionResult",
    AutomationExecutionId: undefined
  };
  if (
    output.AutomationExecutionId !== undefined &&
    output.AutomationExecutionId !== null
  ) {
    contents.AutomationExecutionId = output.AutomationExecutionId;
  }
  return contents;
};

const deserializeAws_json1_1StartSessionResponse = (
  output: any,
  context: __SerdeContext
): StartSessionResponse => {
  let contents: any = {
    __type: "StartSessionResponse",
    SessionId: undefined,
    StreamUrl: undefined,
    TokenValue: undefined
  };
  if (output.SessionId !== undefined && output.SessionId !== null) {
    contents.SessionId = output.SessionId;
  }
  if (output.StreamUrl !== undefined && output.StreamUrl !== null) {
    contents.StreamUrl = output.StreamUrl;
  }
  if (output.TokenValue !== undefined && output.TokenValue !== null) {
    contents.TokenValue = output.TokenValue;
  }
  return contents;
};

const deserializeAws_json1_1StatusUnchanged = (
  output: any,
  context: __SerdeContext
): StatusUnchanged => {
  let contents: any = {
    __type: "StatusUnchanged"
  };
  return contents;
};

const deserializeAws_json1_1StepExecution = (
  output: any,
  context: __SerdeContext
): StepExecution => {
  let contents: any = {
    __type: "StepExecution",
    Action: undefined,
    ExecutionEndTime: undefined,
    ExecutionStartTime: undefined,
    FailureDetails: undefined,
    FailureMessage: undefined,
    Inputs: undefined,
    IsCritical: undefined,
    IsEnd: undefined,
    MaxAttempts: undefined,
    NextStep: undefined,
    OnFailure: undefined,
    Outputs: undefined,
    OverriddenParameters: undefined,
    Response: undefined,
    ResponseCode: undefined,
    StepExecutionId: undefined,
    StepName: undefined,
    StepStatus: undefined,
    TargetLocation: undefined,
    Targets: undefined,
    TimeoutSeconds: undefined,
    ValidNextSteps: undefined
  };
  if (output.Action !== undefined && output.Action !== null) {
    contents.Action = output.Action;
  }
  if (
    output.ExecutionEndTime !== undefined &&
    output.ExecutionEndTime !== null
  ) {
    contents.ExecutionEndTime = new Date(
      Math.round(output.ExecutionEndTime * 1000)
    );
  }
  if (
    output.ExecutionStartTime !== undefined &&
    output.ExecutionStartTime !== null
  ) {
    contents.ExecutionStartTime = new Date(
      Math.round(output.ExecutionStartTime * 1000)
    );
  }
  if (output.FailureDetails !== undefined && output.FailureDetails !== null) {
    contents.FailureDetails = deserializeAws_json1_1FailureDetails(
      output.FailureDetails,
      context
    );
  }
  if (output.FailureMessage !== undefined && output.FailureMessage !== null) {
    contents.FailureMessage = output.FailureMessage;
  }
  if (output.Inputs !== undefined && output.Inputs !== null) {
    contents.Inputs = deserializeAws_json1_1NormalStringMap(
      output.Inputs,
      context
    );
  }
  if (output.IsCritical !== undefined && output.IsCritical !== null) {
    contents.IsCritical = output.IsCritical;
  }
  if (output.IsEnd !== undefined && output.IsEnd !== null) {
    contents.IsEnd = output.IsEnd;
  }
  if (output.MaxAttempts !== undefined && output.MaxAttempts !== null) {
    contents.MaxAttempts = output.MaxAttempts;
  }
  if (output.NextStep !== undefined && output.NextStep !== null) {
    contents.NextStep = output.NextStep;
  }
  if (output.OnFailure !== undefined && output.OnFailure !== null) {
    contents.OnFailure = output.OnFailure;
  }
  if (output.Outputs !== undefined && output.Outputs !== null) {
    contents.Outputs = deserializeAws_json1_1AutomationParameterMap(
      output.Outputs,
      context
    );
  }
  if (
    output.OverriddenParameters !== undefined &&
    output.OverriddenParameters !== null
  ) {
    contents.OverriddenParameters = deserializeAws_json1_1AutomationParameterMap(
      output.OverriddenParameters,
      context
    );
  }
  if (output.Response !== undefined && output.Response !== null) {
    contents.Response = output.Response;
  }
  if (output.ResponseCode !== undefined && output.ResponseCode !== null) {
    contents.ResponseCode = output.ResponseCode;
  }
  if (output.StepExecutionId !== undefined && output.StepExecutionId !== null) {
    contents.StepExecutionId = output.StepExecutionId;
  }
  if (output.StepName !== undefined && output.StepName !== null) {
    contents.StepName = output.StepName;
  }
  if (output.StepStatus !== undefined && output.StepStatus !== null) {
    contents.StepStatus = output.StepStatus;
  }
  if (output.TargetLocation !== undefined && output.TargetLocation !== null) {
    contents.TargetLocation = deserializeAws_json1_1TargetLocation(
      output.TargetLocation,
      context
    );
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  if (output.TimeoutSeconds !== undefined && output.TimeoutSeconds !== null) {
    contents.TimeoutSeconds = output.TimeoutSeconds;
  }
  if (output.ValidNextSteps !== undefined && output.ValidNextSteps !== null) {
    contents.ValidNextSteps = deserializeAws_json1_1ValidNextStepList(
      output.ValidNextSteps,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StepExecutionList = (
  output: any,
  context: __SerdeContext
): Array<StepExecution> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1StepExecution(entry, context)
  );
};

const deserializeAws_json1_1StopAutomationExecutionResult = (
  output: any,
  context: __SerdeContext
): StopAutomationExecutionResult => {
  let contents: any = {
    __type: "StopAutomationExecutionResult"
  };
  return contents;
};

const deserializeAws_json1_1SubTypeCountLimitExceededException = (
  output: any,
  context: __SerdeContext
): SubTypeCountLimitExceededException => {
  let contents: any = {
    __type: "SubTypeCountLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1Target = (
  output: any,
  context: __SerdeContext
): Target => {
  let contents: any = {
    __type: "Target",
    Key: undefined,
    Values: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Values !== undefined && output.Values !== null) {
    contents.Values = deserializeAws_json1_1TargetValues(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TargetInUseException = (
  output: any,
  context: __SerdeContext
): TargetInUseException => {
  let contents: any = {
    __type: "TargetInUseException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TargetLocation = (
  output: any,
  context: __SerdeContext
): TargetLocation => {
  let contents: any = {
    __type: "TargetLocation",
    Accounts: undefined,
    ExecutionRoleName: undefined,
    Regions: undefined,
    TargetLocationMaxConcurrency: undefined,
    TargetLocationMaxErrors: undefined
  };
  if (output.Accounts !== undefined && output.Accounts !== null) {
    contents.Accounts = deserializeAws_json1_1Accounts(
      output.Accounts,
      context
    );
  }
  if (
    output.ExecutionRoleName !== undefined &&
    output.ExecutionRoleName !== null
  ) {
    contents.ExecutionRoleName = output.ExecutionRoleName;
  }
  if (output.Regions !== undefined && output.Regions !== null) {
    contents.Regions = deserializeAws_json1_1Regions(output.Regions, context);
  }
  if (
    output.TargetLocationMaxConcurrency !== undefined &&
    output.TargetLocationMaxConcurrency !== null
  ) {
    contents.TargetLocationMaxConcurrency = output.TargetLocationMaxConcurrency;
  }
  if (
    output.TargetLocationMaxErrors !== undefined &&
    output.TargetLocationMaxErrors !== null
  ) {
    contents.TargetLocationMaxErrors = output.TargetLocationMaxErrors;
  }
  return contents;
};

const deserializeAws_json1_1TargetLocations = (
  output: any,
  context: __SerdeContext
): Array<TargetLocation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TargetLocation(entry, context)
  );
};

const deserializeAws_json1_1TargetMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: Array<string> } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1TargetMapValueList(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_json1_1TargetMapValueList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1TargetMaps = (
  output: any,
  context: __SerdeContext
): Array<{ [key: string]: Array<string> }> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TargetMap(entry, context)
  );
};

const deserializeAws_json1_1TargetNotConnected = (
  output: any,
  context: __SerdeContext
): TargetNotConnected => {
  let contents: any = {
    __type: "TargetNotConnected",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TargetParameterList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1TargetValues = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Targets = (
  output: any,
  context: __SerdeContext
): Array<Target> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Target(entry, context)
  );
};

const deserializeAws_json1_1TerminateSessionResponse = (
  output: any,
  context: __SerdeContext
): TerminateSessionResponse => {
  let contents: any = {
    __type: "TerminateSessionResponse",
    SessionId: undefined
  };
  if (output.SessionId !== undefined && output.SessionId !== null) {
    contents.SessionId = output.SessionId;
  }
  return contents;
};

const deserializeAws_json1_1TooManyTagsError = (
  output: any,
  context: __SerdeContext
): TooManyTagsError => {
  let contents: any = {
    __type: "TooManyTagsError"
  };
  return contents;
};

const deserializeAws_json1_1TooManyUpdates = (
  output: any,
  context: __SerdeContext
): TooManyUpdates => {
  let contents: any = {
    __type: "TooManyUpdates",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TotalSizeLimitExceededException = (
  output: any,
  context: __SerdeContext
): TotalSizeLimitExceededException => {
  let contents: any = {
    __type: "TotalSizeLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UnsupportedCalendarException = (
  output: any,
  context: __SerdeContext
): UnsupportedCalendarException => {
  let contents: any = {
    __type: "UnsupportedCalendarException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UnsupportedFeatureRequiredException = (
  output: any,
  context: __SerdeContext
): UnsupportedFeatureRequiredException => {
  let contents: any = {
    __type: "UnsupportedFeatureRequiredException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UnsupportedInventoryItemContextException = (
  output: any,
  context: __SerdeContext
): UnsupportedInventoryItemContextException => {
  let contents: any = {
    __type: "UnsupportedInventoryItemContextException",
    Message: undefined,
    TypeName: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.TypeName !== undefined && output.TypeName !== null) {
    contents.TypeName = output.TypeName;
  }
  return contents;
};

const deserializeAws_json1_1UnsupportedInventorySchemaVersionException = (
  output: any,
  context: __SerdeContext
): UnsupportedInventorySchemaVersionException => {
  let contents: any = {
    __type: "UnsupportedInventorySchemaVersionException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UnsupportedOperatingSystem = (
  output: any,
  context: __SerdeContext
): UnsupportedOperatingSystem => {
  let contents: any = {
    __type: "UnsupportedOperatingSystem",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UnsupportedParameterType = (
  output: any,
  context: __SerdeContext
): UnsupportedParameterType => {
  let contents: any = {
    __type: "UnsupportedParameterType",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1UnsupportedPlatformType = (
  output: any,
  context: __SerdeContext
): UnsupportedPlatformType => {
  let contents: any = {
    __type: "UnsupportedPlatformType",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UpdateAssociationResult = (
  output: any,
  context: __SerdeContext
): UpdateAssociationResult => {
  let contents: any = {
    __type: "UpdateAssociationResult",
    AssociationDescription: undefined
  };
  if (
    output.AssociationDescription !== undefined &&
    output.AssociationDescription !== null
  ) {
    contents.AssociationDescription = deserializeAws_json1_1AssociationDescription(
      output.AssociationDescription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateAssociationStatusResult = (
  output: any,
  context: __SerdeContext
): UpdateAssociationStatusResult => {
  let contents: any = {
    __type: "UpdateAssociationStatusResult",
    AssociationDescription: undefined
  };
  if (
    output.AssociationDescription !== undefined &&
    output.AssociationDescription !== null
  ) {
    contents.AssociationDescription = deserializeAws_json1_1AssociationDescription(
      output.AssociationDescription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateDocumentDefaultVersionResult = (
  output: any,
  context: __SerdeContext
): UpdateDocumentDefaultVersionResult => {
  let contents: any = {
    __type: "UpdateDocumentDefaultVersionResult",
    Description: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = deserializeAws_json1_1DocumentDefaultVersionDescription(
      output.Description,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateDocumentResult = (
  output: any,
  context: __SerdeContext
): UpdateDocumentResult => {
  let contents: any = {
    __type: "UpdateDocumentResult",
    DocumentDescription: undefined
  };
  if (
    output.DocumentDescription !== undefined &&
    output.DocumentDescription !== null
  ) {
    contents.DocumentDescription = deserializeAws_json1_1DocumentDescription(
      output.DocumentDescription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateMaintenanceWindowResult = (
  output: any,
  context: __SerdeContext
): UpdateMaintenanceWindowResult => {
  let contents: any = {
    __type: "UpdateMaintenanceWindowResult",
    AllowUnassociatedTargets: undefined,
    Cutoff: undefined,
    Description: undefined,
    Duration: undefined,
    Enabled: undefined,
    EndDate: undefined,
    Name: undefined,
    Schedule: undefined,
    ScheduleTimezone: undefined,
    StartDate: undefined,
    WindowId: undefined
  };
  if (
    output.AllowUnassociatedTargets !== undefined &&
    output.AllowUnassociatedTargets !== null
  ) {
    contents.AllowUnassociatedTargets = output.AllowUnassociatedTargets;
  }
  if (output.Cutoff !== undefined && output.Cutoff !== null) {
    contents.Cutoff = output.Cutoff;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Duration !== undefined && output.Duration !== null) {
    contents.Duration = output.Duration;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.EndDate !== undefined && output.EndDate !== null) {
    contents.EndDate = output.EndDate;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Schedule !== undefined && output.Schedule !== null) {
    contents.Schedule = output.Schedule;
  }
  if (
    output.ScheduleTimezone !== undefined &&
    output.ScheduleTimezone !== null
  ) {
    contents.ScheduleTimezone = output.ScheduleTimezone;
  }
  if (output.StartDate !== undefined && output.StartDate !== null) {
    contents.StartDate = output.StartDate;
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  return contents;
};

const deserializeAws_json1_1UpdateMaintenanceWindowTargetResult = (
  output: any,
  context: __SerdeContext
): UpdateMaintenanceWindowTargetResult => {
  let contents: any = {
    __type: "UpdateMaintenanceWindowTargetResult",
    Description: undefined,
    Name: undefined,
    OwnerInformation: undefined,
    Targets: undefined,
    WindowId: undefined,
    WindowTargetId: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.OwnerInformation !== undefined &&
    output.OwnerInformation !== null
  ) {
    contents.OwnerInformation = output.OwnerInformation;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  if (output.WindowTargetId !== undefined && output.WindowTargetId !== null) {
    contents.WindowTargetId = output.WindowTargetId;
  }
  return contents;
};

const deserializeAws_json1_1UpdateMaintenanceWindowTaskResult = (
  output: any,
  context: __SerdeContext
): UpdateMaintenanceWindowTaskResult => {
  let contents: any = {
    __type: "UpdateMaintenanceWindowTaskResult",
    Description: undefined,
    LoggingInfo: undefined,
    MaxConcurrency: undefined,
    MaxErrors: undefined,
    Name: undefined,
    Priority: undefined,
    ServiceRoleArn: undefined,
    Targets: undefined,
    TaskArn: undefined,
    TaskInvocationParameters: undefined,
    TaskParameters: undefined,
    WindowId: undefined,
    WindowTaskId: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.LoggingInfo !== undefined && output.LoggingInfo !== null) {
    contents.LoggingInfo = deserializeAws_json1_1LoggingInfo(
      output.LoggingInfo,
      context
    );
  }
  if (output.MaxConcurrency !== undefined && output.MaxConcurrency !== null) {
    contents.MaxConcurrency = output.MaxConcurrency;
  }
  if (output.MaxErrors !== undefined && output.MaxErrors !== null) {
    contents.MaxErrors = output.MaxErrors;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Priority !== undefined && output.Priority !== null) {
    contents.Priority = output.Priority;
  }
  if (output.ServiceRoleArn !== undefined && output.ServiceRoleArn !== null) {
    contents.ServiceRoleArn = output.ServiceRoleArn;
  }
  if (output.Targets !== undefined && output.Targets !== null) {
    contents.Targets = deserializeAws_json1_1Targets(output.Targets, context);
  }
  if (output.TaskArn !== undefined && output.TaskArn !== null) {
    contents.TaskArn = output.TaskArn;
  }
  if (
    output.TaskInvocationParameters !== undefined &&
    output.TaskInvocationParameters !== null
  ) {
    contents.TaskInvocationParameters = deserializeAws_json1_1MaintenanceWindowTaskInvocationParameters(
      output.TaskInvocationParameters,
      context
    );
  }
  if (output.TaskParameters !== undefined && output.TaskParameters !== null) {
    contents.TaskParameters = deserializeAws_json1_1MaintenanceWindowTaskParameters(
      output.TaskParameters,
      context
    );
  }
  if (output.WindowId !== undefined && output.WindowId !== null) {
    contents.WindowId = output.WindowId;
  }
  if (output.WindowTaskId !== undefined && output.WindowTaskId !== null) {
    contents.WindowTaskId = output.WindowTaskId;
  }
  return contents;
};

const deserializeAws_json1_1UpdateManagedInstanceRoleResult = (
  output: any,
  context: __SerdeContext
): UpdateManagedInstanceRoleResult => {
  let contents: any = {
    __type: "UpdateManagedInstanceRoleResult"
  };
  return contents;
};

const deserializeAws_json1_1UpdateOpsItemResponse = (
  output: any,
  context: __SerdeContext
): UpdateOpsItemResponse => {
  let contents: any = {
    __type: "UpdateOpsItemResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdatePatchBaselineResult = (
  output: any,
  context: __SerdeContext
): UpdatePatchBaselineResult => {
  let contents: any = {
    __type: "UpdatePatchBaselineResult",
    ApprovalRules: undefined,
    ApprovedPatches: undefined,
    ApprovedPatchesComplianceLevel: undefined,
    ApprovedPatchesEnableNonSecurity: undefined,
    BaselineId: undefined,
    CreatedDate: undefined,
    Description: undefined,
    GlobalFilters: undefined,
    ModifiedDate: undefined,
    Name: undefined,
    OperatingSystem: undefined,
    RejectedPatches: undefined,
    RejectedPatchesAction: undefined,
    Sources: undefined
  };
  if (output.ApprovalRules !== undefined && output.ApprovalRules !== null) {
    contents.ApprovalRules = deserializeAws_json1_1PatchRuleGroup(
      output.ApprovalRules,
      context
    );
  }
  if (output.ApprovedPatches !== undefined && output.ApprovedPatches !== null) {
    contents.ApprovedPatches = deserializeAws_json1_1PatchIdList(
      output.ApprovedPatches,
      context
    );
  }
  if (
    output.ApprovedPatchesComplianceLevel !== undefined &&
    output.ApprovedPatchesComplianceLevel !== null
  ) {
    contents.ApprovedPatchesComplianceLevel =
      output.ApprovedPatchesComplianceLevel;
  }
  if (
    output.ApprovedPatchesEnableNonSecurity !== undefined &&
    output.ApprovedPatchesEnableNonSecurity !== null
  ) {
    contents.ApprovedPatchesEnableNonSecurity =
      output.ApprovedPatchesEnableNonSecurity;
  }
  if (output.BaselineId !== undefined && output.BaselineId !== null) {
    contents.BaselineId = output.BaselineId;
  }
  if (output.CreatedDate !== undefined && output.CreatedDate !== null) {
    contents.CreatedDate = new Date(Math.round(output.CreatedDate * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.GlobalFilters !== undefined && output.GlobalFilters !== null) {
    contents.GlobalFilters = deserializeAws_json1_1PatchFilterGroup(
      output.GlobalFilters,
      context
    );
  }
  if (output.ModifiedDate !== undefined && output.ModifiedDate !== null) {
    contents.ModifiedDate = new Date(Math.round(output.ModifiedDate * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.OperatingSystem !== undefined && output.OperatingSystem !== null) {
    contents.OperatingSystem = output.OperatingSystem;
  }
  if (output.RejectedPatches !== undefined && output.RejectedPatches !== null) {
    contents.RejectedPatches = deserializeAws_json1_1PatchIdList(
      output.RejectedPatches,
      context
    );
  }
  if (
    output.RejectedPatchesAction !== undefined &&
    output.RejectedPatchesAction !== null
  ) {
    contents.RejectedPatchesAction = output.RejectedPatchesAction;
  }
  if (output.Sources !== undefined && output.Sources !== null) {
    contents.Sources = deserializeAws_json1_1PatchSourceList(
      output.Sources,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateResourceDataSyncResult = (
  output: any,
  context: __SerdeContext
): UpdateResourceDataSyncResult => {
  let contents: any = {
    __type: "UpdateResourceDataSyncResult"
  };
  return contents;
};

const deserializeAws_json1_1UpdateServiceSettingResult = (
  output: any,
  context: __SerdeContext
): UpdateServiceSettingResult => {
  let contents: any = {
    __type: "UpdateServiceSettingResult"
  };
  return contents;
};

const deserializeAws_json1_1ValidNextStepList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
