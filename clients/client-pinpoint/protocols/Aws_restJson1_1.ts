import {
  CreateAppCommandInput,
  CreateAppCommandOutput
} from "../commands/CreateAppCommand";
import {
  CreateCampaignCommandInput,
  CreateCampaignCommandOutput
} from "../commands/CreateCampaignCommand";
import {
  CreateEmailTemplateCommandInput,
  CreateEmailTemplateCommandOutput
} from "../commands/CreateEmailTemplateCommand";
import {
  CreateExportJobCommandInput,
  CreateExportJobCommandOutput
} from "../commands/CreateExportJobCommand";
import {
  CreateImportJobCommandInput,
  CreateImportJobCommandOutput
} from "../commands/CreateImportJobCommand";
import {
  CreateJourneyCommandInput,
  CreateJourneyCommandOutput
} from "../commands/CreateJourneyCommand";
import {
  CreatePushTemplateCommandInput,
  CreatePushTemplateCommandOutput
} from "../commands/CreatePushTemplateCommand";
import {
  CreateSegmentCommandInput,
  CreateSegmentCommandOutput
} from "../commands/CreateSegmentCommand";
import {
  CreateSmsTemplateCommandInput,
  CreateSmsTemplateCommandOutput
} from "../commands/CreateSmsTemplateCommand";
import {
  CreateVoiceTemplateCommandInput,
  CreateVoiceTemplateCommandOutput
} from "../commands/CreateVoiceTemplateCommand";
import {
  DeleteAdmChannelCommandInput,
  DeleteAdmChannelCommandOutput
} from "../commands/DeleteAdmChannelCommand";
import {
  DeleteApnsChannelCommandInput,
  DeleteApnsChannelCommandOutput
} from "../commands/DeleteApnsChannelCommand";
import {
  DeleteApnsSandboxChannelCommandInput,
  DeleteApnsSandboxChannelCommandOutput
} from "../commands/DeleteApnsSandboxChannelCommand";
import {
  DeleteApnsVoipChannelCommandInput,
  DeleteApnsVoipChannelCommandOutput
} from "../commands/DeleteApnsVoipChannelCommand";
import {
  DeleteApnsVoipSandboxChannelCommandInput,
  DeleteApnsVoipSandboxChannelCommandOutput
} from "../commands/DeleteApnsVoipSandboxChannelCommand";
import {
  DeleteAppCommandInput,
  DeleteAppCommandOutput
} from "../commands/DeleteAppCommand";
import {
  DeleteBaiduChannelCommandInput,
  DeleteBaiduChannelCommandOutput
} from "../commands/DeleteBaiduChannelCommand";
import {
  DeleteCampaignCommandInput,
  DeleteCampaignCommandOutput
} from "../commands/DeleteCampaignCommand";
import {
  DeleteEmailChannelCommandInput,
  DeleteEmailChannelCommandOutput
} from "../commands/DeleteEmailChannelCommand";
import {
  DeleteEmailTemplateCommandInput,
  DeleteEmailTemplateCommandOutput
} from "../commands/DeleteEmailTemplateCommand";
import {
  DeleteEndpointCommandInput,
  DeleteEndpointCommandOutput
} from "../commands/DeleteEndpointCommand";
import {
  DeleteEventStreamCommandInput,
  DeleteEventStreamCommandOutput
} from "../commands/DeleteEventStreamCommand";
import {
  DeleteGcmChannelCommandInput,
  DeleteGcmChannelCommandOutput
} from "../commands/DeleteGcmChannelCommand";
import {
  DeleteJourneyCommandInput,
  DeleteJourneyCommandOutput
} from "../commands/DeleteJourneyCommand";
import {
  DeletePushTemplateCommandInput,
  DeletePushTemplateCommandOutput
} from "../commands/DeletePushTemplateCommand";
import {
  DeleteSegmentCommandInput,
  DeleteSegmentCommandOutput
} from "../commands/DeleteSegmentCommand";
import {
  DeleteSmsChannelCommandInput,
  DeleteSmsChannelCommandOutput
} from "../commands/DeleteSmsChannelCommand";
import {
  DeleteSmsTemplateCommandInput,
  DeleteSmsTemplateCommandOutput
} from "../commands/DeleteSmsTemplateCommand";
import {
  DeleteUserEndpointsCommandInput,
  DeleteUserEndpointsCommandOutput
} from "../commands/DeleteUserEndpointsCommand";
import {
  DeleteVoiceChannelCommandInput,
  DeleteVoiceChannelCommandOutput
} from "../commands/DeleteVoiceChannelCommand";
import {
  DeleteVoiceTemplateCommandInput,
  DeleteVoiceTemplateCommandOutput
} from "../commands/DeleteVoiceTemplateCommand";
import {
  GetAdmChannelCommandInput,
  GetAdmChannelCommandOutput
} from "../commands/GetAdmChannelCommand";
import {
  GetApnsChannelCommandInput,
  GetApnsChannelCommandOutput
} from "../commands/GetApnsChannelCommand";
import {
  GetApnsSandboxChannelCommandInput,
  GetApnsSandboxChannelCommandOutput
} from "../commands/GetApnsSandboxChannelCommand";
import {
  GetApnsVoipChannelCommandInput,
  GetApnsVoipChannelCommandOutput
} from "../commands/GetApnsVoipChannelCommand";
import {
  GetApnsVoipSandboxChannelCommandInput,
  GetApnsVoipSandboxChannelCommandOutput
} from "../commands/GetApnsVoipSandboxChannelCommand";
import {
  GetAppCommandInput,
  GetAppCommandOutput
} from "../commands/GetAppCommand";
import {
  GetApplicationDateRangeKpiCommandInput,
  GetApplicationDateRangeKpiCommandOutput
} from "../commands/GetApplicationDateRangeKpiCommand";
import {
  GetApplicationSettingsCommandInput,
  GetApplicationSettingsCommandOutput
} from "../commands/GetApplicationSettingsCommand";
import {
  GetAppsCommandInput,
  GetAppsCommandOutput
} from "../commands/GetAppsCommand";
import {
  GetBaiduChannelCommandInput,
  GetBaiduChannelCommandOutput
} from "../commands/GetBaiduChannelCommand";
import {
  GetCampaignActivitiesCommandInput,
  GetCampaignActivitiesCommandOutput
} from "../commands/GetCampaignActivitiesCommand";
import {
  GetCampaignCommandInput,
  GetCampaignCommandOutput
} from "../commands/GetCampaignCommand";
import {
  GetCampaignDateRangeKpiCommandInput,
  GetCampaignDateRangeKpiCommandOutput
} from "../commands/GetCampaignDateRangeKpiCommand";
import {
  GetCampaignVersionCommandInput,
  GetCampaignVersionCommandOutput
} from "../commands/GetCampaignVersionCommand";
import {
  GetCampaignVersionsCommandInput,
  GetCampaignVersionsCommandOutput
} from "../commands/GetCampaignVersionsCommand";
import {
  GetCampaignsCommandInput,
  GetCampaignsCommandOutput
} from "../commands/GetCampaignsCommand";
import {
  GetChannelsCommandInput,
  GetChannelsCommandOutput
} from "../commands/GetChannelsCommand";
import {
  GetEmailChannelCommandInput,
  GetEmailChannelCommandOutput
} from "../commands/GetEmailChannelCommand";
import {
  GetEmailTemplateCommandInput,
  GetEmailTemplateCommandOutput
} from "../commands/GetEmailTemplateCommand";
import {
  GetEndpointCommandInput,
  GetEndpointCommandOutput
} from "../commands/GetEndpointCommand";
import {
  GetEventStreamCommandInput,
  GetEventStreamCommandOutput
} from "../commands/GetEventStreamCommand";
import {
  GetExportJobCommandInput,
  GetExportJobCommandOutput
} from "../commands/GetExportJobCommand";
import {
  GetExportJobsCommandInput,
  GetExportJobsCommandOutput
} from "../commands/GetExportJobsCommand";
import {
  GetGcmChannelCommandInput,
  GetGcmChannelCommandOutput
} from "../commands/GetGcmChannelCommand";
import {
  GetImportJobCommandInput,
  GetImportJobCommandOutput
} from "../commands/GetImportJobCommand";
import {
  GetImportJobsCommandInput,
  GetImportJobsCommandOutput
} from "../commands/GetImportJobsCommand";
import {
  GetJourneyCommandInput,
  GetJourneyCommandOutput
} from "../commands/GetJourneyCommand";
import {
  GetJourneyDateRangeKpiCommandInput,
  GetJourneyDateRangeKpiCommandOutput
} from "../commands/GetJourneyDateRangeKpiCommand";
import {
  GetJourneyExecutionActivityMetricsCommandInput,
  GetJourneyExecutionActivityMetricsCommandOutput
} from "../commands/GetJourneyExecutionActivityMetricsCommand";
import {
  GetJourneyExecutionMetricsCommandInput,
  GetJourneyExecutionMetricsCommandOutput
} from "../commands/GetJourneyExecutionMetricsCommand";
import {
  GetPushTemplateCommandInput,
  GetPushTemplateCommandOutput
} from "../commands/GetPushTemplateCommand";
import {
  GetSegmentCommandInput,
  GetSegmentCommandOutput
} from "../commands/GetSegmentCommand";
import {
  GetSegmentExportJobsCommandInput,
  GetSegmentExportJobsCommandOutput
} from "../commands/GetSegmentExportJobsCommand";
import {
  GetSegmentImportJobsCommandInput,
  GetSegmentImportJobsCommandOutput
} from "../commands/GetSegmentImportJobsCommand";
import {
  GetSegmentVersionCommandInput,
  GetSegmentVersionCommandOutput
} from "../commands/GetSegmentVersionCommand";
import {
  GetSegmentVersionsCommandInput,
  GetSegmentVersionsCommandOutput
} from "../commands/GetSegmentVersionsCommand";
import {
  GetSegmentsCommandInput,
  GetSegmentsCommandOutput
} from "../commands/GetSegmentsCommand";
import {
  GetSmsChannelCommandInput,
  GetSmsChannelCommandOutput
} from "../commands/GetSmsChannelCommand";
import {
  GetSmsTemplateCommandInput,
  GetSmsTemplateCommandOutput
} from "../commands/GetSmsTemplateCommand";
import {
  GetUserEndpointsCommandInput,
  GetUserEndpointsCommandOutput
} from "../commands/GetUserEndpointsCommand";
import {
  GetVoiceChannelCommandInput,
  GetVoiceChannelCommandOutput
} from "../commands/GetVoiceChannelCommand";
import {
  GetVoiceTemplateCommandInput,
  GetVoiceTemplateCommandOutput
} from "../commands/GetVoiceTemplateCommand";
import {
  ListJourneysCommandInput,
  ListJourneysCommandOutput
} from "../commands/ListJourneysCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ListTemplateVersionsCommandInput,
  ListTemplateVersionsCommandOutput
} from "../commands/ListTemplateVersionsCommand";
import {
  ListTemplatesCommandInput,
  ListTemplatesCommandOutput
} from "../commands/ListTemplatesCommand";
import {
  PhoneNumberValidateCommandInput,
  PhoneNumberValidateCommandOutput
} from "../commands/PhoneNumberValidateCommand";
import {
  PutEventStreamCommandInput,
  PutEventStreamCommandOutput
} from "../commands/PutEventStreamCommand";
import {
  PutEventsCommandInput,
  PutEventsCommandOutput
} from "../commands/PutEventsCommand";
import {
  RemoveAttributesCommandInput,
  RemoveAttributesCommandOutput
} from "../commands/RemoveAttributesCommand";
import {
  SendMessagesCommandInput,
  SendMessagesCommandOutput
} from "../commands/SendMessagesCommand";
import {
  SendUsersMessagesCommandInput,
  SendUsersMessagesCommandOutput
} from "../commands/SendUsersMessagesCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateAdmChannelCommandInput,
  UpdateAdmChannelCommandOutput
} from "../commands/UpdateAdmChannelCommand";
import {
  UpdateApnsChannelCommandInput,
  UpdateApnsChannelCommandOutput
} from "../commands/UpdateApnsChannelCommand";
import {
  UpdateApnsSandboxChannelCommandInput,
  UpdateApnsSandboxChannelCommandOutput
} from "../commands/UpdateApnsSandboxChannelCommand";
import {
  UpdateApnsVoipChannelCommandInput,
  UpdateApnsVoipChannelCommandOutput
} from "../commands/UpdateApnsVoipChannelCommand";
import {
  UpdateApnsVoipSandboxChannelCommandInput,
  UpdateApnsVoipSandboxChannelCommandOutput
} from "../commands/UpdateApnsVoipSandboxChannelCommand";
import {
  UpdateApplicationSettingsCommandInput,
  UpdateApplicationSettingsCommandOutput
} from "../commands/UpdateApplicationSettingsCommand";
import {
  UpdateBaiduChannelCommandInput,
  UpdateBaiduChannelCommandOutput
} from "../commands/UpdateBaiduChannelCommand";
import {
  UpdateCampaignCommandInput,
  UpdateCampaignCommandOutput
} from "../commands/UpdateCampaignCommand";
import {
  UpdateEmailChannelCommandInput,
  UpdateEmailChannelCommandOutput
} from "../commands/UpdateEmailChannelCommand";
import {
  UpdateEmailTemplateCommandInput,
  UpdateEmailTemplateCommandOutput
} from "../commands/UpdateEmailTemplateCommand";
import {
  UpdateEndpointCommandInput,
  UpdateEndpointCommandOutput
} from "../commands/UpdateEndpointCommand";
import {
  UpdateEndpointsBatchCommandInput,
  UpdateEndpointsBatchCommandOutput
} from "../commands/UpdateEndpointsBatchCommand";
import {
  UpdateGcmChannelCommandInput,
  UpdateGcmChannelCommandOutput
} from "../commands/UpdateGcmChannelCommand";
import {
  UpdateJourneyCommandInput,
  UpdateJourneyCommandOutput
} from "../commands/UpdateJourneyCommand";
import {
  UpdateJourneyStateCommandInput,
  UpdateJourneyStateCommandOutput
} from "../commands/UpdateJourneyStateCommand";
import {
  UpdatePushTemplateCommandInput,
  UpdatePushTemplateCommandOutput
} from "../commands/UpdatePushTemplateCommand";
import {
  UpdateSegmentCommandInput,
  UpdateSegmentCommandOutput
} from "../commands/UpdateSegmentCommand";
import {
  UpdateSmsChannelCommandInput,
  UpdateSmsChannelCommandOutput
} from "../commands/UpdateSmsChannelCommand";
import {
  UpdateSmsTemplateCommandInput,
  UpdateSmsTemplateCommandOutput
} from "../commands/UpdateSmsTemplateCommand";
import {
  UpdateTemplateActiveVersionCommandInput,
  UpdateTemplateActiveVersionCommandOutput
} from "../commands/UpdateTemplateActiveVersionCommand";
import {
  UpdateVoiceChannelCommandInput,
  UpdateVoiceChannelCommandOutput
} from "../commands/UpdateVoiceChannelCommand";
import {
  UpdateVoiceTemplateCommandInput,
  UpdateVoiceTemplateCommandOutput
} from "../commands/UpdateVoiceTemplateCommand";
import {
  ADMChannelRequest,
  ADMChannelResponse,
  ADMMessage,
  APNSChannelRequest,
  APNSChannelResponse,
  APNSMessage,
  APNSPushNotificationTemplate,
  APNSSandboxChannelRequest,
  APNSSandboxChannelResponse,
  APNSVoipChannelRequest,
  APNSVoipChannelResponse,
  APNSVoipSandboxChannelRequest,
  APNSVoipSandboxChannelResponse,
  ActivitiesResponse,
  Activity,
  ActivityResponse,
  AddressConfiguration,
  AndroidPushNotificationTemplate,
  ApplicationDateRangeKpiResponse,
  ApplicationResponse,
  ApplicationSettingsResource,
  ApplicationsResponse,
  AttributeDimension,
  AttributesResource,
  BadRequestException,
  BaiduChannelRequest,
  BaiduChannelResponse,
  BaiduMessage,
  BaseKpiResult,
  CampaignDateRangeKpiResponse,
  CampaignEmailMessage,
  CampaignEventFilter,
  CampaignHook,
  CampaignLimits,
  CampaignResponse,
  CampaignSmsMessage,
  CampaignState,
  CampaignsResponse,
  ChannelResponse,
  ChannelsResponse,
  Condition,
  ConditionalSplitActivity,
  CreateApplicationRequest,
  CreateTemplateMessageBody,
  DefaultMessage,
  DefaultPushNotificationMessage,
  DefaultPushNotificationTemplate,
  DirectMessageConfiguration,
  EmailChannelRequest,
  EmailChannelResponse,
  EmailMessage,
  EmailMessageActivity,
  EmailTemplateRequest,
  EmailTemplateResponse,
  EndpointBatchItem,
  EndpointBatchRequest,
  EndpointDemographic,
  EndpointItemResponse,
  EndpointLocation,
  EndpointMessageResult,
  EndpointRequest,
  EndpointResponse,
  EndpointSendConfiguration,
  EndpointUser,
  EndpointsResponse,
  Event,
  EventCondition,
  EventDimensions,
  EventItemResponse,
  EventStream,
  EventsBatch,
  EventsRequest,
  EventsResponse,
  ExportJobRequest,
  ExportJobResource,
  ExportJobResponse,
  ExportJobsResponse,
  ForbiddenException,
  GCMChannelRequest,
  GCMChannelResponse,
  GCMMessage,
  GPSCoordinates,
  GPSPointDimension,
  HoldoutActivity,
  ImportJobRequest,
  ImportJobResource,
  ImportJobResponse,
  ImportJobsResponse,
  InternalServerErrorException,
  ItemResponse,
  JourneyDateRangeKpiResponse,
  JourneyEmailMessage,
  JourneyExecutionActivityMetricsResponse,
  JourneyExecutionMetricsResponse,
  JourneyLimits,
  JourneyResponse,
  JourneySchedule,
  JourneyStateRequest,
  JourneysResponse,
  Message,
  MessageBody,
  MessageConfiguration,
  MessageRequest,
  MessageResponse,
  MessageResult,
  MethodNotAllowedException,
  MetricDimension,
  MultiConditionalBranch,
  MultiConditionalSplitActivity,
  NotFoundException,
  NumberValidateRequest,
  NumberValidateResponse,
  PublicEndpoint,
  PushNotificationTemplateRequest,
  PushNotificationTemplateResponse,
  QuietTime,
  RandomSplitActivity,
  RandomSplitEntry,
  RawEmail,
  RecencyDimension,
  ResultRow,
  ResultRowValue,
  SMSChannelRequest,
  SMSChannelResponse,
  SMSMessage,
  SMSTemplateRequest,
  SMSTemplateResponse,
  Schedule,
  SegmentBehaviors,
  SegmentCondition,
  SegmentDemographics,
  SegmentDimensions,
  SegmentGroup,
  SegmentGroupList,
  SegmentImportResource,
  SegmentLocation,
  SegmentReference,
  SegmentResponse,
  SegmentsResponse,
  SendUsersMessageRequest,
  SendUsersMessageResponse,
  Session,
  SetDimension,
  SimpleCondition,
  SimpleEmail,
  SimpleEmailPart,
  StartCondition,
  TagsModel,
  Template,
  TemplateActiveVersionRequest,
  TemplateConfiguration,
  TemplateResponse,
  TemplateVersionResponse,
  TemplateVersionsResponse,
  TemplatesResponse,
  TooManyRequestsException,
  TreatmentResource,
  UpdateAttributesRequest,
  VoiceChannelRequest,
  VoiceChannelResponse,
  VoiceMessage,
  VoiceTemplateRequest,
  VoiceTemplateResponse,
  WaitActivity,
  WaitTime,
  WriteApplicationSettingsRequest,
  WriteCampaignRequest,
  WriteEventStream,
  WriteJourneyRequest,
  WriteSegmentRequest,
  WriteTreatmentResource
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_restJson1_1CreateAppCommand(
  input: CreateAppCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps";
  let body: any;
  if (input.CreateApplicationRequest !== undefined) {
    body = serializeAws_restJson1_1CreateApplicationRequest(
      input.CreateApplicationRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateCampaignCommand(
  input: CreateCampaignCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/campaigns";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.WriteCampaignRequest !== undefined) {
    body = serializeAws_restJson1_1WriteCampaignRequest(
      input.WriteCampaignRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateEmailTemplateCommand(
  input: CreateEmailTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/templates/{TemplateName}/email";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  let body: any;
  if (input.EmailTemplateRequest !== undefined) {
    body = serializeAws_restJson1_1EmailTemplateRequest(
      input.EmailTemplateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateExportJobCommand(
  input: CreateExportJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/jobs/export";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.ExportJobRequest !== undefined) {
    body = serializeAws_restJson1_1ExportJobRequest(
      input.ExportJobRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateImportJobCommand(
  input: CreateImportJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/jobs/import";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.ImportJobRequest !== undefined) {
    body = serializeAws_restJson1_1ImportJobRequest(
      input.ImportJobRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateJourneyCommand(
  input: CreateJourneyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/journeys";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.WriteJourneyRequest !== undefined) {
    body = serializeAws_restJson1_1WriteJourneyRequest(
      input.WriteJourneyRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreatePushTemplateCommand(
  input: CreatePushTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/templates/{TemplateName}/push";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  let body: any;
  if (input.PushNotificationTemplateRequest !== undefined) {
    body = serializeAws_restJson1_1PushNotificationTemplateRequest(
      input.PushNotificationTemplateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateSegmentCommand(
  input: CreateSegmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/segments";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.WriteSegmentRequest !== undefined) {
    body = serializeAws_restJson1_1WriteSegmentRequest(
      input.WriteSegmentRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateSmsTemplateCommand(
  input: CreateSmsTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/templates/{TemplateName}/sms";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  let body: any;
  if (input.SMSTemplateRequest !== undefined) {
    body = serializeAws_restJson1_1SMSTemplateRequest(
      input.SMSTemplateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateVoiceTemplateCommand(
  input: CreateVoiceTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/templates/{TemplateName}/voice";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  let body: any;
  if (input.VoiceTemplateRequest !== undefined) {
    body = serializeAws_restJson1_1VoiceTemplateRequest(
      input.VoiceTemplateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteAdmChannelCommand(
  input: DeleteAdmChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/adm";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteApnsChannelCommand(
  input: DeleteApnsChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteApnsSandboxChannelCommand(
  input: DeleteApnsSandboxChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_sandbox";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteApnsVoipChannelCommand(
  input: DeleteApnsVoipChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommand(
  input: DeleteApnsVoipSandboxChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip_sandbox";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteAppCommand(
  input: DeleteAppCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteBaiduChannelCommand(
  input: DeleteBaiduChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/baidu";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteCampaignCommand(
  input: DeleteCampaignCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.CampaignId !== undefined) {
    const labelValue: string = input.CampaignId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: CampaignId.");
    }
    resolvedPath = resolvedPath.replace(
      "{CampaignId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: CampaignId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteEmailChannelCommand(
  input: DeleteEmailChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/email";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteEmailTemplateCommand(
  input: DeleteEmailTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates/{TemplateName}/email";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteEndpointCommand(
  input: DeleteEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/endpoints/{EndpointId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.EndpointId !== undefined) {
    const labelValue: string = input.EndpointId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: EndpointId.");
    }
    resolvedPath = resolvedPath.replace(
      "{EndpointId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: EndpointId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteEventStreamCommand(
  input: DeleteEventStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/eventstream";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteGcmChannelCommand(
  input: DeleteGcmChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/gcm";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteJourneyCommand(
  input: DeleteJourneyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.JourneyId !== undefined) {
    const labelValue: string = input.JourneyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: JourneyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{JourneyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: JourneyId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeletePushTemplateCommand(
  input: DeletePushTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates/{TemplateName}/push";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteSegmentCommand(
  input: DeleteSegmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.SegmentId !== undefined) {
    const labelValue: string = input.SegmentId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SegmentId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SegmentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SegmentId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteSmsChannelCommand(
  input: DeleteSmsChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/sms";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteSmsTemplateCommand(
  input: DeleteSmsTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates/{TemplateName}/sms";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteUserEndpointsCommand(
  input: DeleteUserEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/users/{UserId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteVoiceChannelCommand(
  input: DeleteVoiceChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/voice";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteVoiceTemplateCommand(
  input: DeleteVoiceTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates/{TemplateName}/voice";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetAdmChannelCommand(
  input: GetAdmChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/adm";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetApnsChannelCommand(
  input: GetApnsChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetApnsSandboxChannelCommand(
  input: GetApnsSandboxChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_sandbox";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetApnsVoipChannelCommand(
  input: GetApnsVoipChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetApnsVoipSandboxChannelCommand(
  input: GetApnsVoipSandboxChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip_sandbox";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetAppCommand(
  input: GetAppCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetApplicationDateRangeKpiCommand(
  input: GetApplicationDateRangeKpiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/kpis/daterange/{KpiName}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.KpiName !== undefined) {
    const labelValue: string = input.KpiName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: KpiName.");
    }
    resolvedPath = resolvedPath.replace(
      "{KpiName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: KpiName.");
  }
  const query: any = {};
  if (input.EndTime !== undefined) {
    query["end-time"] = (
      input.EndTime.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.StartTime !== undefined) {
    query["start-time"] = (
      input.StartTime.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetApplicationSettingsCommand(
  input: GetApplicationSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/settings";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetAppsCommand(
  input: GetAppsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps";
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetBaiduChannelCommand(
  input: GetBaiduChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/baidu";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetCampaignCommand(
  input: GetCampaignCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.CampaignId !== undefined) {
    const labelValue: string = input.CampaignId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: CampaignId.");
    }
    resolvedPath = resolvedPath.replace(
      "{CampaignId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: CampaignId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetCampaignActivitiesCommand(
  input: GetCampaignActivitiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/v1/apps/{ApplicationId}/campaigns/{CampaignId}/activities";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.CampaignId !== undefined) {
    const labelValue: string = input.CampaignId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: CampaignId.");
    }
    resolvedPath = resolvedPath.replace(
      "{CampaignId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: CampaignId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetCampaignDateRangeKpiCommand(
  input: GetCampaignDateRangeKpiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/v1/apps/{ApplicationId}/campaigns/{CampaignId}/kpis/daterange/{KpiName}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.CampaignId !== undefined) {
    const labelValue: string = input.CampaignId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: CampaignId.");
    }
    resolvedPath = resolvedPath.replace(
      "{CampaignId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: CampaignId.");
  }
  if (input.KpiName !== undefined) {
    const labelValue: string = input.KpiName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: KpiName.");
    }
    resolvedPath = resolvedPath.replace(
      "{KpiName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: KpiName.");
  }
  const query: any = {};
  if (input.EndTime !== undefined) {
    query["end-time"] = (
      input.EndTime.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.StartTime !== undefined) {
    query["start-time"] = (
      input.StartTime.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetCampaignVersionCommand(
  input: GetCampaignVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/v1/apps/{ApplicationId}/campaigns/{CampaignId}/versions/{Version}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.CampaignId !== undefined) {
    const labelValue: string = input.CampaignId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: CampaignId.");
    }
    resolvedPath = resolvedPath.replace(
      "{CampaignId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: CampaignId.");
  }
  if (input.Version !== undefined) {
    const labelValue: string = input.Version;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Version.");
    }
    resolvedPath = resolvedPath.replace(
      "{Version}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Version.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetCampaignVersionsCommand(
  input: GetCampaignVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}/versions";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.CampaignId !== undefined) {
    const labelValue: string = input.CampaignId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: CampaignId.");
    }
    resolvedPath = resolvedPath.replace(
      "{CampaignId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: CampaignId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetCampaignsCommand(
  input: GetCampaignsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/campaigns";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetChannelsCommand(
  input: GetChannelsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetEmailChannelCommand(
  input: GetEmailChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/email";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetEmailTemplateCommand(
  input: GetEmailTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates/{TemplateName}/email";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetEndpointCommand(
  input: GetEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/endpoints/{EndpointId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.EndpointId !== undefined) {
    const labelValue: string = input.EndpointId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: EndpointId.");
    }
    resolvedPath = resolvedPath.replace(
      "{EndpointId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: EndpointId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetEventStreamCommand(
  input: GetEventStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/eventstream";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetExportJobCommand(
  input: GetExportJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/jobs/export/{JobId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.JobId !== undefined) {
    const labelValue: string = input.JobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: JobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{JobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: JobId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetExportJobsCommand(
  input: GetExportJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/jobs/export";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetGcmChannelCommand(
  input: GetGcmChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/gcm";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetImportJobCommand(
  input: GetImportJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/jobs/import/{JobId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.JobId !== undefined) {
    const labelValue: string = input.JobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: JobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{JobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: JobId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetImportJobsCommand(
  input: GetImportJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/jobs/import";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetJourneyCommand(
  input: GetJourneyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.JourneyId !== undefined) {
    const labelValue: string = input.JourneyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: JourneyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{JourneyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: JourneyId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetJourneyDateRangeKpiCommand(
  input: GetJourneyDateRangeKpiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/v1/apps/{ApplicationId}/journeys/{JourneyId}/kpis/daterange/{KpiName}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.JourneyId !== undefined) {
    const labelValue: string = input.JourneyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: JourneyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{JourneyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: JourneyId.");
  }
  if (input.KpiName !== undefined) {
    const labelValue: string = input.KpiName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: KpiName.");
    }
    resolvedPath = resolvedPath.replace(
      "{KpiName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: KpiName.");
  }
  const query: any = {};
  if (input.EndTime !== undefined) {
    query["end-time"] = (
      input.EndTime.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.StartTime !== undefined) {
    query["start-time"] = (
      input.StartTime.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommand(
  input: GetJourneyExecutionActivityMetricsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/v1/apps/{ApplicationId}/journeys/{JourneyId}/activities/{JourneyActivityId}/execution-metrics";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.JourneyActivityId !== undefined) {
    const labelValue: string = input.JourneyActivityId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: JourneyActivityId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{JourneyActivityId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: JourneyActivityId."
    );
  }
  if (input.JourneyId !== undefined) {
    const labelValue: string = input.JourneyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: JourneyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{JourneyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: JourneyId.");
  }
  const query: any = {};
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetJourneyExecutionMetricsCommand(
  input: GetJourneyExecutionMetricsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/v1/apps/{ApplicationId}/journeys/{JourneyId}/execution-metrics";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.JourneyId !== undefined) {
    const labelValue: string = input.JourneyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: JourneyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{JourneyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: JourneyId.");
  }
  const query: any = {};
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetPushTemplateCommand(
  input: GetPushTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates/{TemplateName}/push";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetSegmentCommand(
  input: GetSegmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.SegmentId !== undefined) {
    const labelValue: string = input.SegmentId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SegmentId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SegmentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SegmentId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetSegmentExportJobsCommand(
  input: GetSegmentExportJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/v1/apps/{ApplicationId}/segments/{SegmentId}/jobs/export";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.SegmentId !== undefined) {
    const labelValue: string = input.SegmentId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SegmentId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SegmentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SegmentId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetSegmentImportJobsCommand(
  input: GetSegmentImportJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/v1/apps/{ApplicationId}/segments/{SegmentId}/jobs/import";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.SegmentId !== undefined) {
    const labelValue: string = input.SegmentId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SegmentId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SegmentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SegmentId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetSegmentVersionCommand(
  input: GetSegmentVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/v1/apps/{ApplicationId}/segments/{SegmentId}/versions/{Version}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.SegmentId !== undefined) {
    const labelValue: string = input.SegmentId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SegmentId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SegmentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SegmentId.");
  }
  if (input.Version !== undefined) {
    const labelValue: string = input.Version;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Version.");
    }
    resolvedPath = resolvedPath.replace(
      "{Version}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Version.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetSegmentVersionsCommand(
  input: GetSegmentVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}/versions";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.SegmentId !== undefined) {
    const labelValue: string = input.SegmentId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SegmentId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SegmentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SegmentId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetSegmentsCommand(
  input: GetSegmentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/segments";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetSmsChannelCommand(
  input: GetSmsChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/sms";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetSmsTemplateCommand(
  input: GetSmsTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates/{TemplateName}/sms";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetUserEndpointsCommand(
  input: GetUserEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/users/{UserId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetVoiceChannelCommand(
  input: GetVoiceChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/voice";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetVoiceTemplateCommand(
  input: GetVoiceTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates/{TemplateName}/voice";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1ListJourneysCommand(
  input: ListJourneysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/apps/{ApplicationId}/journeys";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  const query: any = {};
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Token !== undefined) {
    query["token"] = input.Token;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/tags/{ResourceArn}";
  if (input.ResourceArn !== undefined) {
    const labelValue: string = input.ResourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceArn.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1ListTemplateVersionsCommand(
  input: ListTemplateVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates/{TemplateName}/{TemplateType}/versions";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  if (input.TemplateType !== undefined) {
    const labelValue: string = input.TemplateType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateType.");
  }
  const query: any = {};
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1ListTemplatesCommand(
  input: ListTemplatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/templates";
  const query: any = {};
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.PageSize !== undefined) {
    query["page-size"] = input.PageSize;
  }
  if (input.Prefix !== undefined) {
    query["prefix"] = input.Prefix;
  }
  if (input.TemplateType !== undefined) {
    query["template-type"] = input.TemplateType;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1PhoneNumberValidateCommand(
  input: PhoneNumberValidateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/phone/number/validate";
  let body: any;
  if (input.NumberValidateRequest !== undefined) {
    body = serializeAws_restJson1_1NumberValidateRequest(
      input.NumberValidateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1PutEventStreamCommand(
  input: PutEventStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/eventstream";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.WriteEventStream !== undefined) {
    body = serializeAws_restJson1_1WriteEventStream(
      input.WriteEventStream,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1PutEventsCommand(
  input: PutEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/events";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.EventsRequest !== undefined) {
    body = serializeAws_restJson1_1EventsRequest(input.EventsRequest, context);
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1RemoveAttributesCommand(
  input: RemoveAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/attributes/{AttributeType}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.AttributeType !== undefined) {
    const labelValue: string = input.AttributeType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AttributeType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AttributeType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AttributeType.");
  }
  let body: any;
  if (input.UpdateAttributesRequest !== undefined) {
    body = serializeAws_restJson1_1UpdateAttributesRequest(
      input.UpdateAttributesRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1SendMessagesCommand(
  input: SendMessagesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/messages";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.MessageRequest !== undefined) {
    body = serializeAws_restJson1_1MessageRequest(
      input.MessageRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1SendUsersMessagesCommand(
  input: SendUsersMessagesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/users-messages";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.SendUsersMessageRequest !== undefined) {
    body = serializeAws_restJson1_1SendUsersMessageRequest(
      input.SendUsersMessageRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/tags/{ResourceArn}";
  if (input.ResourceArn !== undefined) {
    const labelValue: string = input.ResourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceArn.");
  }
  let body: any;
  if (input.TagsModel !== undefined) {
    body = serializeAws_restJson1_1TagsModel(input.TagsModel, context);
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v1/tags/{ResourceArn}";
  if (input.ResourceArn !== undefined) {
    const labelValue: string = input.ResourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceArn.");
  }
  const query: any = {};
  if (input.TagKeys !== undefined) {
    query["tagKeys"] = (input.TagKeys || []).map(_entry => _entry);
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateAdmChannelCommand(
  input: UpdateAdmChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/adm";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.ADMChannelRequest !== undefined) {
    body = serializeAws_restJson1_1ADMChannelRequest(
      input.ADMChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateApnsChannelCommand(
  input: UpdateApnsChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.APNSChannelRequest !== undefined) {
    body = serializeAws_restJson1_1APNSChannelRequest(
      input.APNSChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateApnsSandboxChannelCommand(
  input: UpdateApnsSandboxChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_sandbox";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.APNSSandboxChannelRequest !== undefined) {
    body = serializeAws_restJson1_1APNSSandboxChannelRequest(
      input.APNSSandboxChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateApnsVoipChannelCommand(
  input: UpdateApnsVoipChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.APNSVoipChannelRequest !== undefined) {
    body = serializeAws_restJson1_1APNSVoipChannelRequest(
      input.APNSVoipChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommand(
  input: UpdateApnsVoipSandboxChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/apns_voip_sandbox";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.APNSVoipSandboxChannelRequest !== undefined) {
    body = serializeAws_restJson1_1APNSVoipSandboxChannelRequest(
      input.APNSVoipSandboxChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateApplicationSettingsCommand(
  input: UpdateApplicationSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/settings";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.WriteApplicationSettingsRequest !== undefined) {
    body = serializeAws_restJson1_1WriteApplicationSettingsRequest(
      input.WriteApplicationSettingsRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateBaiduChannelCommand(
  input: UpdateBaiduChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/baidu";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.BaiduChannelRequest !== undefined) {
    body = serializeAws_restJson1_1BaiduChannelRequest(
      input.BaiduChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateCampaignCommand(
  input: UpdateCampaignCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/campaigns/{CampaignId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.CampaignId !== undefined) {
    const labelValue: string = input.CampaignId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: CampaignId.");
    }
    resolvedPath = resolvedPath.replace(
      "{CampaignId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: CampaignId.");
  }
  let body: any;
  if (input.WriteCampaignRequest !== undefined) {
    body = serializeAws_restJson1_1WriteCampaignRequest(
      input.WriteCampaignRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateEmailChannelCommand(
  input: UpdateEmailChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/email";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.EmailChannelRequest !== undefined) {
    body = serializeAws_restJson1_1EmailChannelRequest(
      input.EmailChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateEmailTemplateCommand(
  input: UpdateEmailTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/templates/{TemplateName}/email";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.CreateNewVersion !== undefined) {
    query["create-new-version"] = input.CreateNewVersion.toString();
  }
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  if (input.EmailTemplateRequest !== undefined) {
    body = serializeAws_restJson1_1EmailTemplateRequest(
      input.EmailTemplateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateEndpointCommand(
  input: UpdateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/endpoints/{EndpointId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.EndpointId !== undefined) {
    const labelValue: string = input.EndpointId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: EndpointId.");
    }
    resolvedPath = resolvedPath.replace(
      "{EndpointId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: EndpointId.");
  }
  let body: any;
  if (input.EndpointRequest !== undefined) {
    body = serializeAws_restJson1_1EndpointRequest(
      input.EndpointRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateEndpointsBatchCommand(
  input: UpdateEndpointsBatchCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/endpoints";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.EndpointBatchRequest !== undefined) {
    body = serializeAws_restJson1_1EndpointBatchRequest(
      input.EndpointBatchRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateGcmChannelCommand(
  input: UpdateGcmChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/gcm";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.GCMChannelRequest !== undefined) {
    body = serializeAws_restJson1_1GCMChannelRequest(
      input.GCMChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateJourneyCommand(
  input: UpdateJourneyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.JourneyId !== undefined) {
    const labelValue: string = input.JourneyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: JourneyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{JourneyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: JourneyId.");
  }
  let body: any;
  if (input.WriteJourneyRequest !== undefined) {
    body = serializeAws_restJson1_1WriteJourneyRequest(
      input.WriteJourneyRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateJourneyStateCommand(
  input: UpdateJourneyStateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/journeys/{JourneyId}/state";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.JourneyId !== undefined) {
    const labelValue: string = input.JourneyId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: JourneyId.");
    }
    resolvedPath = resolvedPath.replace(
      "{JourneyId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: JourneyId.");
  }
  let body: any;
  if (input.JourneyStateRequest !== undefined) {
    body = serializeAws_restJson1_1JourneyStateRequest(
      input.JourneyStateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdatePushTemplateCommand(
  input: UpdatePushTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/templates/{TemplateName}/push";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.CreateNewVersion !== undefined) {
    query["create-new-version"] = input.CreateNewVersion.toString();
  }
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  if (input.PushNotificationTemplateRequest !== undefined) {
    body = serializeAws_restJson1_1PushNotificationTemplateRequest(
      input.PushNotificationTemplateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateSegmentCommand(
  input: UpdateSegmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/segments/{SegmentId}";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  if (input.SegmentId !== undefined) {
    const labelValue: string = input.SegmentId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SegmentId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SegmentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SegmentId.");
  }
  let body: any;
  if (input.WriteSegmentRequest !== undefined) {
    body = serializeAws_restJson1_1WriteSegmentRequest(
      input.WriteSegmentRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateSmsChannelCommand(
  input: UpdateSmsChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/sms";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.SMSChannelRequest !== undefined) {
    body = serializeAws_restJson1_1SMSChannelRequest(
      input.SMSChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateSmsTemplateCommand(
  input: UpdateSmsTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/templates/{TemplateName}/sms";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.CreateNewVersion !== undefined) {
    query["create-new-version"] = input.CreateNewVersion.toString();
  }
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  if (input.SMSTemplateRequest !== undefined) {
    body = serializeAws_restJson1_1SMSTemplateRequest(
      input.SMSTemplateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateTemplateActiveVersionCommand(
  input: UpdateTemplateActiveVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/v1/templates/{TemplateName}/{TemplateType}/active-version";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  if (input.TemplateType !== undefined) {
    const labelValue: string = input.TemplateType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateType.");
  }
  let body: any;
  if (input.TemplateActiveVersionRequest !== undefined) {
    body = serializeAws_restJson1_1TemplateActiveVersionRequest(
      input.TemplateActiveVersionRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateVoiceChannelCommand(
  input: UpdateVoiceChannelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/apps/{ApplicationId}/channels/voice";
  if (input.ApplicationId !== undefined) {
    const labelValue: string = input.ApplicationId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ApplicationId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ApplicationId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ApplicationId.");
  }
  let body: any;
  if (input.VoiceChannelRequest !== undefined) {
    body = serializeAws_restJson1_1VoiceChannelRequest(
      input.VoiceChannelRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateVoiceTemplateCommand(
  input: UpdateVoiceTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v1/templates/{TemplateName}/voice";
  if (input.TemplateName !== undefined) {
    const labelValue: string = input.TemplateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: TemplateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateName.");
  }
  const query: any = {};
  if (input.CreateNewVersion !== undefined) {
    query["create-new-version"] = input.CreateNewVersion.toString();
  }
  if (input.Version !== undefined) {
    query["version"] = input.Version;
  }
  let body: any;
  if (input.VoiceTemplateRequest !== undefined) {
    body = serializeAws_restJson1_1VoiceTemplateRequest(
      input.VoiceTemplateRequest,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function deserializeAws_restJson1_1CreateAppCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAppCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateAppCommandError(output, context);
  }
  const contents: CreateAppCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAppResponse",
    ApplicationResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ApplicationResponse = deserializeAws_restJson1_1ApplicationResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateAppCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAppCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateCampaignCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCampaignCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateCampaignCommandError(
      output,
      context
    );
  }
  const contents: CreateCampaignCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCampaignResponse",
    CampaignResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateCampaignCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCampaignCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateEmailTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEmailTemplateCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateEmailTemplateCommandError(
      output,
      context
    );
  }
  const contents: CreateEmailTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEmailTemplateResponse",
    CreateTemplateMessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CreateTemplateMessageBody = deserializeAws_restJson1_1CreateTemplateMessageBody(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateEmailTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEmailTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateExportJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateExportJobCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateExportJobCommandError(
      output,
      context
    );
  }
  const contents: CreateExportJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateExportJobResponse",
    ExportJobResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ExportJobResponse = deserializeAws_restJson1_1ExportJobResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateExportJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateExportJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateImportJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateImportJobCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateImportJobCommandError(
      output,
      context
    );
  }
  const contents: CreateImportJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateImportJobResponse",
    ImportJobResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ImportJobResponse = deserializeAws_restJson1_1ImportJobResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateImportJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateImportJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateJourneyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJourneyCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateJourneyCommandError(output, context);
  }
  const contents: CreateJourneyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateJourneyResponse",
    JourneyResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateJourneyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJourneyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreatePushTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePushTemplateCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreatePushTemplateCommandError(
      output,
      context
    );
  }
  const contents: CreatePushTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePushTemplateResponse",
    CreateTemplateMessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CreateTemplateMessageBody = deserializeAws_restJson1_1CreateTemplateMessageBody(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreatePushTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePushTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateSegmentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSegmentCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateSegmentCommandError(output, context);
  }
  const contents: CreateSegmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSegmentResponse",
    SegmentResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateSegmentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSegmentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateSmsTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSmsTemplateCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateSmsTemplateCommandError(
      output,
      context
    );
  }
  const contents: CreateSmsTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSmsTemplateResponse",
    CreateTemplateMessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CreateTemplateMessageBody = deserializeAws_restJson1_1CreateTemplateMessageBody(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateSmsTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSmsTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateVoiceTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVoiceTemplateCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateVoiceTemplateCommandError(
      output,
      context
    );
  }
  const contents: CreateVoiceTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVoiceTemplateResponse",
    CreateTemplateMessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CreateTemplateMessageBody = deserializeAws_restJson1_1CreateTemplateMessageBody(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateVoiceTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVoiceTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteAdmChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAdmChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteAdmChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteAdmChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteAdmChannelResponse",
    ADMChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ADMChannelResponse = deserializeAws_restJson1_1ADMChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteAdmChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAdmChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteApnsChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApnsChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteApnsChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteApnsChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteApnsChannelResponse",
    APNSChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSChannelResponse = deserializeAws_restJson1_1APNSChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteApnsChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApnsChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteApnsSandboxChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApnsSandboxChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteApnsSandboxChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteApnsSandboxChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteApnsSandboxChannelResponse",
    APNSSandboxChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSSandboxChannelResponse = deserializeAws_restJson1_1APNSSandboxChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteApnsSandboxChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApnsSandboxChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteApnsVoipChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApnsVoipChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteApnsVoipChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteApnsVoipChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteApnsVoipChannelResponse",
    APNSVoipChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSVoipChannelResponse = deserializeAws_restJson1_1APNSVoipChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteApnsVoipChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApnsVoipChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApnsVoipSandboxChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteApnsVoipSandboxChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteApnsVoipSandboxChannelResponse",
    APNSVoipSandboxChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSVoipSandboxChannelResponse = deserializeAws_restJson1_1APNSVoipSandboxChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteApnsVoipSandboxChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteApnsVoipSandboxChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteAppCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAppCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteAppCommandError(output, context);
  }
  const contents: DeleteAppCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteAppResponse",
    ApplicationResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ApplicationResponse = deserializeAws_restJson1_1ApplicationResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteAppCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAppCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteBaiduChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBaiduChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteBaiduChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteBaiduChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteBaiduChannelResponse",
    BaiduChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.BaiduChannelResponse = deserializeAws_restJson1_1BaiduChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteBaiduChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBaiduChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteCampaignCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCampaignCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteCampaignCommandError(
      output,
      context
    );
  }
  const contents: DeleteCampaignCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCampaignResponse",
    CampaignResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteCampaignCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCampaignCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteEmailChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEmailChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteEmailChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteEmailChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEmailChannelResponse",
    EmailChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EmailChannelResponse = deserializeAws_restJson1_1EmailChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteEmailChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEmailChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteEmailTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEmailTemplateCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteEmailTemplateCommandError(
      output,
      context
    );
  }
  const contents: DeleteEmailTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEmailTemplateResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteEmailTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEmailTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteEndpointCommandError(
      output,
      context
    );
  }
  const contents: DeleteEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEndpointResponse",
    EndpointResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EndpointResponse = deserializeAws_restJson1_1EndpointResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteEventStreamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventStreamCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteEventStreamCommandError(
      output,
      context
    );
  }
  const contents: DeleteEventStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEventStreamResponse",
    EventStream: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EventStream = deserializeAws_restJson1_1EventStream(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteEventStreamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventStreamCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteGcmChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGcmChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteGcmChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteGcmChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteGcmChannelResponse",
    GCMChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.GCMChannelResponse = deserializeAws_restJson1_1GCMChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteGcmChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGcmChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteJourneyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJourneyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteJourneyCommandError(output, context);
  }
  const contents: DeleteJourneyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteJourneyResponse",
    JourneyResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteJourneyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJourneyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeletePushTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePushTemplateCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeletePushTemplateCommandError(
      output,
      context
    );
  }
  const contents: DeletePushTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeletePushTemplateResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeletePushTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePushTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteSegmentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSegmentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteSegmentCommandError(output, context);
  }
  const contents: DeleteSegmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSegmentResponse",
    SegmentResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteSegmentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSegmentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteSmsChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSmsChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteSmsChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteSmsChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSmsChannelResponse",
    SMSChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SMSChannelResponse = deserializeAws_restJson1_1SMSChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteSmsChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSmsChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteSmsTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSmsTemplateCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteSmsTemplateCommandError(
      output,
      context
    );
  }
  const contents: DeleteSmsTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSmsTemplateResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteSmsTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSmsTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteUserEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserEndpointsCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteUserEndpointsCommandError(
      output,
      context
    );
  }
  const contents: DeleteUserEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteUserEndpointsResponse",
    EndpointsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EndpointsResponse = deserializeAws_restJson1_1EndpointsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteUserEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserEndpointsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteVoiceChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteVoiceChannelCommandError(
      output,
      context
    );
  }
  const contents: DeleteVoiceChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVoiceChannelResponse",
    VoiceChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.VoiceChannelResponse = deserializeAws_restJson1_1VoiceChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteVoiceChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteVoiceTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceTemplateCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteVoiceTemplateCommandError(
      output,
      context
    );
  }
  const contents: DeleteVoiceTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVoiceTemplateResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteVoiceTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetAdmChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAdmChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetAdmChannelCommandError(output, context);
  }
  const contents: GetAdmChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAdmChannelResponse",
    ADMChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ADMChannelResponse = deserializeAws_restJson1_1ADMChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAdmChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAdmChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetApnsChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApnsChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetApnsChannelCommandError(
      output,
      context
    );
  }
  const contents: GetApnsChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetApnsChannelResponse",
    APNSChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSChannelResponse = deserializeAws_restJson1_1APNSChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetApnsChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApnsChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetApnsSandboxChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApnsSandboxChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetApnsSandboxChannelCommandError(
      output,
      context
    );
  }
  const contents: GetApnsSandboxChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetApnsSandboxChannelResponse",
    APNSSandboxChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSSandboxChannelResponse = deserializeAws_restJson1_1APNSSandboxChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetApnsSandboxChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApnsSandboxChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetApnsVoipChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApnsVoipChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetApnsVoipChannelCommandError(
      output,
      context
    );
  }
  const contents: GetApnsVoipChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetApnsVoipChannelResponse",
    APNSVoipChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSVoipChannelResponse = deserializeAws_restJson1_1APNSVoipChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetApnsVoipChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApnsVoipChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetApnsVoipSandboxChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApnsVoipSandboxChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetApnsVoipSandboxChannelCommandError(
      output,
      context
    );
  }
  const contents: GetApnsVoipSandboxChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetApnsVoipSandboxChannelResponse",
    APNSVoipSandboxChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSVoipSandboxChannelResponse = deserializeAws_restJson1_1APNSVoipSandboxChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetApnsVoipSandboxChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApnsVoipSandboxChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetAppCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAppCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetAppCommandError(output, context);
  }
  const contents: GetAppCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAppResponse",
    ApplicationResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ApplicationResponse = deserializeAws_restJson1_1ApplicationResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAppCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAppCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetApplicationDateRangeKpiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApplicationDateRangeKpiCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetApplicationDateRangeKpiCommandError(
      output,
      context
    );
  }
  const contents: GetApplicationDateRangeKpiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetApplicationDateRangeKpiResponse",
    ApplicationDateRangeKpiResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ApplicationDateRangeKpiResponse = deserializeAws_restJson1_1ApplicationDateRangeKpiResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetApplicationDateRangeKpiCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApplicationDateRangeKpiCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetApplicationSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApplicationSettingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetApplicationSettingsCommandError(
      output,
      context
    );
  }
  const contents: GetApplicationSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetApplicationSettingsResponse",
    ApplicationSettingsResource: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ApplicationSettingsResource = deserializeAws_restJson1_1ApplicationSettingsResource(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetApplicationSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetApplicationSettingsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetAppsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAppsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetAppsCommandError(output, context);
  }
  const contents: GetAppsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAppsResponse",
    ApplicationsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ApplicationsResponse = deserializeAws_restJson1_1ApplicationsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAppsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAppsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetBaiduChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBaiduChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetBaiduChannelCommandError(
      output,
      context
    );
  }
  const contents: GetBaiduChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBaiduChannelResponse",
    BaiduChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.BaiduChannelResponse = deserializeAws_restJson1_1BaiduChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetBaiduChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBaiduChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetCampaignCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetCampaignCommandError(output, context);
  }
  const contents: GetCampaignCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCampaignResponse",
    CampaignResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetCampaignCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetCampaignActivitiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignActivitiesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetCampaignActivitiesCommandError(
      output,
      context
    );
  }
  const contents: GetCampaignActivitiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCampaignActivitiesResponse",
    ActivitiesResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ActivitiesResponse = deserializeAws_restJson1_1ActivitiesResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetCampaignActivitiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignActivitiesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetCampaignDateRangeKpiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignDateRangeKpiCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetCampaignDateRangeKpiCommandError(
      output,
      context
    );
  }
  const contents: GetCampaignDateRangeKpiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCampaignDateRangeKpiResponse",
    CampaignDateRangeKpiResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CampaignDateRangeKpiResponse = deserializeAws_restJson1_1CampaignDateRangeKpiResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetCampaignDateRangeKpiCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignDateRangeKpiCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetCampaignVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetCampaignVersionCommandError(
      output,
      context
    );
  }
  const contents: GetCampaignVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCampaignVersionResponse",
    CampaignResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetCampaignVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignVersionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetCampaignVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetCampaignVersionsCommandError(
      output,
      context
    );
  }
  const contents: GetCampaignVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCampaignVersionsResponse",
    CampaignsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CampaignsResponse = deserializeAws_restJson1_1CampaignsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetCampaignVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignVersionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetCampaignsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetCampaignsCommandError(output, context);
  }
  const contents: GetCampaignsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCampaignsResponse",
    CampaignsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CampaignsResponse = deserializeAws_restJson1_1CampaignsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetCampaignsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCampaignsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetChannelsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChannelsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetChannelsCommandError(output, context);
  }
  const contents: GetChannelsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetChannelsResponse",
    ChannelsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ChannelsResponse = deserializeAws_restJson1_1ChannelsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetChannelsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChannelsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetEmailChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEmailChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetEmailChannelCommandError(
      output,
      context
    );
  }
  const contents: GetEmailChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetEmailChannelResponse",
    EmailChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EmailChannelResponse = deserializeAws_restJson1_1EmailChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetEmailChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEmailChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetEmailTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEmailTemplateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetEmailTemplateCommandError(
      output,
      context
    );
  }
  const contents: GetEmailTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetEmailTemplateResponse",
    EmailTemplateResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EmailTemplateResponse = deserializeAws_restJson1_1EmailTemplateResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetEmailTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEmailTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEndpointCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetEndpointCommandError(output, context);
  }
  const contents: GetEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetEndpointResponse",
    EndpointResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EndpointResponse = deserializeAws_restJson1_1EndpointResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetEventStreamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEventStreamCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetEventStreamCommandError(
      output,
      context
    );
  }
  const contents: GetEventStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetEventStreamResponse",
    EventStream: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EventStream = deserializeAws_restJson1_1EventStream(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetEventStreamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEventStreamCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetExportJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetExportJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetExportJobCommandError(output, context);
  }
  const contents: GetExportJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetExportJobResponse",
    ExportJobResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ExportJobResponse = deserializeAws_restJson1_1ExportJobResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetExportJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetExportJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetExportJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetExportJobsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetExportJobsCommandError(output, context);
  }
  const contents: GetExportJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetExportJobsResponse",
    ExportJobsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ExportJobsResponse = deserializeAws_restJson1_1ExportJobsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetExportJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetExportJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetGcmChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGcmChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetGcmChannelCommandError(output, context);
  }
  const contents: GetGcmChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGcmChannelResponse",
    GCMChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.GCMChannelResponse = deserializeAws_restJson1_1GCMChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetGcmChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGcmChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetImportJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetImportJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetImportJobCommandError(output, context);
  }
  const contents: GetImportJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetImportJobResponse",
    ImportJobResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ImportJobResponse = deserializeAws_restJson1_1ImportJobResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetImportJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetImportJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetImportJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetImportJobsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetImportJobsCommandError(output, context);
  }
  const contents: GetImportJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetImportJobsResponse",
    ImportJobsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ImportJobsResponse = deserializeAws_restJson1_1ImportJobsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetImportJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetImportJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetJourneyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJourneyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetJourneyCommandError(output, context);
  }
  const contents: GetJourneyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJourneyResponse",
    JourneyResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetJourneyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJourneyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetJourneyDateRangeKpiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJourneyDateRangeKpiCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetJourneyDateRangeKpiCommandError(
      output,
      context
    );
  }
  const contents: GetJourneyDateRangeKpiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJourneyDateRangeKpiResponse",
    JourneyDateRangeKpiResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.JourneyDateRangeKpiResponse = deserializeAws_restJson1_1JourneyDateRangeKpiResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetJourneyDateRangeKpiCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJourneyDateRangeKpiCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJourneyExecutionActivityMetricsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommandError(
      output,
      context
    );
  }
  const contents: GetJourneyExecutionActivityMetricsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJourneyExecutionActivityMetricsResponse",
    JourneyExecutionActivityMetricsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.JourneyExecutionActivityMetricsResponse = deserializeAws_restJson1_1JourneyExecutionActivityMetricsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetJourneyExecutionActivityMetricsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJourneyExecutionActivityMetricsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetJourneyExecutionMetricsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJourneyExecutionMetricsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetJourneyExecutionMetricsCommandError(
      output,
      context
    );
  }
  const contents: GetJourneyExecutionMetricsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJourneyExecutionMetricsResponse",
    JourneyExecutionMetricsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.JourneyExecutionMetricsResponse = deserializeAws_restJson1_1JourneyExecutionMetricsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetJourneyExecutionMetricsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJourneyExecutionMetricsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetPushTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPushTemplateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetPushTemplateCommandError(
      output,
      context
    );
  }
  const contents: GetPushTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPushTemplateResponse",
    PushNotificationTemplateResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.PushNotificationTemplateResponse = deserializeAws_restJson1_1PushNotificationTemplateResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetPushTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPushTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSegmentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSegmentCommandError(output, context);
  }
  const contents: GetSegmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSegmentResponse",
    SegmentResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSegmentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSegmentExportJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentExportJobsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSegmentExportJobsCommandError(
      output,
      context
    );
  }
  const contents: GetSegmentExportJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSegmentExportJobsResponse",
    ExportJobsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ExportJobsResponse = deserializeAws_restJson1_1ExportJobsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSegmentExportJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentExportJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSegmentImportJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentImportJobsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSegmentImportJobsCommandError(
      output,
      context
    );
  }
  const contents: GetSegmentImportJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSegmentImportJobsResponse",
    ImportJobsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ImportJobsResponse = deserializeAws_restJson1_1ImportJobsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSegmentImportJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentImportJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSegmentVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSegmentVersionCommandError(
      output,
      context
    );
  }
  const contents: GetSegmentVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSegmentVersionResponse",
    SegmentResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSegmentVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentVersionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSegmentVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSegmentVersionsCommandError(
      output,
      context
    );
  }
  const contents: GetSegmentVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSegmentVersionsResponse",
    SegmentsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SegmentsResponse = deserializeAws_restJson1_1SegmentsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSegmentVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentVersionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSegmentsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSegmentsCommandError(output, context);
  }
  const contents: GetSegmentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSegmentsResponse",
    SegmentsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SegmentsResponse = deserializeAws_restJson1_1SegmentsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSegmentsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSegmentsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSmsChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSmsChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSmsChannelCommandError(output, context);
  }
  const contents: GetSmsChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSmsChannelResponse",
    SMSChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SMSChannelResponse = deserializeAws_restJson1_1SMSChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSmsChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSmsChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSmsTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSmsTemplateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSmsTemplateCommandError(
      output,
      context
    );
  }
  const contents: GetSmsTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSmsTemplateResponse",
    SMSTemplateResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SMSTemplateResponse = deserializeAws_restJson1_1SMSTemplateResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSmsTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSmsTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetUserEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserEndpointsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetUserEndpointsCommandError(
      output,
      context
    );
  }
  const contents: GetUserEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetUserEndpointsResponse",
    EndpointsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EndpointsResponse = deserializeAws_restJson1_1EndpointsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetUserEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserEndpointsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetVoiceChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetVoiceChannelCommandError(
      output,
      context
    );
  }
  const contents: GetVoiceChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetVoiceChannelResponse",
    VoiceChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.VoiceChannelResponse = deserializeAws_restJson1_1VoiceChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVoiceChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetVoiceTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceTemplateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetVoiceTemplateCommandError(
      output,
      context
    );
  }
  const contents: GetVoiceTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetVoiceTemplateResponse",
    VoiceTemplateResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.VoiceTemplateResponse = deserializeAws_restJson1_1VoiceTemplateResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVoiceTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListJourneysCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJourneysCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListJourneysCommandError(output, context);
  }
  const contents: ListJourneysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListJourneysResponse",
    JourneysResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.JourneysResponse = deserializeAws_restJson1_1JourneysResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListJourneysCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJourneysCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const contents: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    TagsModel: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.TagsModel = deserializeAws_restJson1_1TagsModel(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListTemplateVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplateVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTemplateVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListTemplateVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTemplateVersionsResponse",
    TemplateVersionsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.TemplateVersionsResponse = deserializeAws_restJson1_1TemplateVersionsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListTemplateVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplateVersionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListTemplatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplatesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTemplatesCommandError(output, context);
  }
  const contents: ListTemplatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTemplatesResponse",
    TemplatesResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.TemplatesResponse = deserializeAws_restJson1_1TemplatesResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListTemplatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplatesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1PhoneNumberValidateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PhoneNumberValidateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1PhoneNumberValidateCommandError(
      output,
      context
    );
  }
  const contents: PhoneNumberValidateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PhoneNumberValidateResponse",
    NumberValidateResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.NumberValidateResponse = deserializeAws_restJson1_1NumberValidateResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PhoneNumberValidateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PhoneNumberValidateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1PutEventStreamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutEventStreamCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1PutEventStreamCommandError(
      output,
      context
    );
  }
  const contents: PutEventStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutEventStreamResponse",
    EventStream: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EventStream = deserializeAws_restJson1_1EventStream(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutEventStreamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutEventStreamCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1PutEventsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutEventsCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1PutEventsCommandError(output, context);
  }
  const contents: PutEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutEventsResponse",
    EventsResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EventsResponse = deserializeAws_restJson1_1EventsResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutEventsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutEventsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1RemoveAttributesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveAttributesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RemoveAttributesCommandError(
      output,
      context
    );
  }
  const contents: RemoveAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveAttributesResponse",
    AttributesResource: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.AttributesResource = deserializeAws_restJson1_1AttributesResource(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1RemoveAttributesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveAttributesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1SendMessagesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendMessagesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1SendMessagesCommandError(output, context);
  }
  const contents: SendMessagesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SendMessagesResponse",
    MessageResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageResponse = deserializeAws_restJson1_1MessageResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1SendMessagesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendMessagesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1SendUsersMessagesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendUsersMessagesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1SendUsersMessagesCommandError(
      output,
      context
    );
  }
  const contents: SendUsersMessagesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SendUsersMessagesResponse",
    SendUsersMessageResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SendUsersMessageResponse = deserializeAws_restJson1_1SendUsersMessageResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1SendUsersMessagesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SendUsersMessagesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1TagResourceCommandError(output, context);
  }
  const contents: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UntagResourceCommandError(output, context);
  }
  const contents: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateAdmChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAdmChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateAdmChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateAdmChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateAdmChannelResponse",
    ADMChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ADMChannelResponse = deserializeAws_restJson1_1ADMChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateAdmChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAdmChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateApnsChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApnsChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateApnsChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateApnsChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateApnsChannelResponse",
    APNSChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSChannelResponse = deserializeAws_restJson1_1APNSChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateApnsChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApnsChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateApnsSandboxChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApnsSandboxChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateApnsSandboxChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateApnsSandboxChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateApnsSandboxChannelResponse",
    APNSSandboxChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSSandboxChannelResponse = deserializeAws_restJson1_1APNSSandboxChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateApnsSandboxChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApnsSandboxChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateApnsVoipChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApnsVoipChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateApnsVoipChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateApnsVoipChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateApnsVoipChannelResponse",
    APNSVoipChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSVoipChannelResponse = deserializeAws_restJson1_1APNSVoipChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateApnsVoipChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApnsVoipChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApnsVoipSandboxChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateApnsVoipSandboxChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateApnsVoipSandboxChannelResponse",
    APNSVoipSandboxChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.APNSVoipSandboxChannelResponse = deserializeAws_restJson1_1APNSVoipSandboxChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateApnsVoipSandboxChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApnsVoipSandboxChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateApplicationSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApplicationSettingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateApplicationSettingsCommandError(
      output,
      context
    );
  }
  const contents: UpdateApplicationSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateApplicationSettingsResponse",
    ApplicationSettingsResource: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ApplicationSettingsResource = deserializeAws_restJson1_1ApplicationSettingsResource(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateApplicationSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateApplicationSettingsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateBaiduChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBaiduChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateBaiduChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateBaiduChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateBaiduChannelResponse",
    BaiduChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.BaiduChannelResponse = deserializeAws_restJson1_1BaiduChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateBaiduChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBaiduChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateCampaignCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCampaignCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateCampaignCommandError(
      output,
      context
    );
  }
  const contents: UpdateCampaignCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCampaignResponse",
    CampaignResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.CampaignResponse = deserializeAws_restJson1_1CampaignResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateCampaignCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCampaignCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateEmailChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEmailChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateEmailChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateEmailChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateEmailChannelResponse",
    EmailChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.EmailChannelResponse = deserializeAws_restJson1_1EmailChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateEmailChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEmailChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateEmailTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEmailTemplateCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateEmailTemplateCommandError(
      output,
      context
    );
  }
  const contents: UpdateEmailTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateEmailTemplateResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateEmailTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEmailTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateEndpointCommandError(
      output,
      context
    );
  }
  const contents: UpdateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateEndpointResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateEndpointsBatchCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointsBatchCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateEndpointsBatchCommandError(
      output,
      context
    );
  }
  const contents: UpdateEndpointsBatchCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateEndpointsBatchResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateEndpointsBatchCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointsBatchCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateGcmChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGcmChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateGcmChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateGcmChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGcmChannelResponse",
    GCMChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.GCMChannelResponse = deserializeAws_restJson1_1GCMChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateGcmChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGcmChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateJourneyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJourneyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateJourneyCommandError(output, context);
  }
  const contents: UpdateJourneyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateJourneyResponse",
    JourneyResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateJourneyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJourneyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateJourneyStateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJourneyStateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateJourneyStateCommandError(
      output,
      context
    );
  }
  const contents: UpdateJourneyStateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateJourneyStateResponse",
    JourneyResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.JourneyResponse = deserializeAws_restJson1_1JourneyResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateJourneyStateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJourneyStateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdatePushTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePushTemplateCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdatePushTemplateCommandError(
      output,
      context
    );
  }
  const contents: UpdatePushTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePushTemplateResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdatePushTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePushTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateSegmentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSegmentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateSegmentCommandError(output, context);
  }
  const contents: UpdateSegmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSegmentResponse",
    SegmentResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SegmentResponse = deserializeAws_restJson1_1SegmentResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateSegmentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSegmentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateSmsChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSmsChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateSmsChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateSmsChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSmsChannelResponse",
    SMSChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.SMSChannelResponse = deserializeAws_restJson1_1SMSChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateSmsChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSmsChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateSmsTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSmsTemplateCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateSmsTemplateCommandError(
      output,
      context
    );
  }
  const contents: UpdateSmsTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSmsTemplateResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateSmsTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSmsTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateTemplateActiveVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTemplateActiveVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateTemplateActiveVersionCommandError(
      output,
      context
    );
  }
  const contents: UpdateTemplateActiveVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTemplateActiveVersionResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateTemplateActiveVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTemplateActiveVersionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateVoiceChannelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVoiceChannelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateVoiceChannelCommandError(
      output,
      context
    );
  }
  const contents: UpdateVoiceChannelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateVoiceChannelResponse",
    VoiceChannelResponse: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.VoiceChannelResponse = deserializeAws_restJson1_1VoiceChannelResponse(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateVoiceChannelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVoiceChannelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateVoiceTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVoiceTemplateCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateVoiceTemplateCommandError(
      output,
      context
    );
  }
  const contents: UpdateVoiceTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateVoiceTemplateResponse",
    MessageBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MessageBody = deserializeAws_restJson1_1MessageBody(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateVoiceTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVoiceTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.pinpoint#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.pinpoint#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.pinpoint#InternalServerErrorException":
      response = {
        ...(await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MethodNotAllowedException":
    case "com.amazonaws.pinpoint#MethodNotAllowedException":
      response = {
        ...(await deserializeAws_restJson1_1MethodNotAllowedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.pinpoint#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.pinpoint#TooManyRequestsException":
      response = {
        ...(await deserializeAws_restJson1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_restJson1_1BadRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BadRequestException> => {
  const contents: BadRequestException = {
    name: "BadRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestID: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestID !== undefined && data.RequestID !== null) {
    contents.RequestID = data.RequestID;
  }
  return contents;
};

const deserializeAws_restJson1_1ForbiddenExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ForbiddenException> => {
  const contents: ForbiddenException = {
    name: "ForbiddenException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestID: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestID !== undefined && data.RequestID !== null) {
    contents.RequestID = data.RequestID;
  }
  return contents;
};

const deserializeAws_restJson1_1InternalServerErrorExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalServerErrorException> => {
  const contents: InternalServerErrorException = {
    name: "InternalServerErrorException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestID: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestID !== undefined && data.RequestID !== null) {
    contents.RequestID = data.RequestID;
  }
  return contents;
};

const deserializeAws_restJson1_1MethodNotAllowedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MethodNotAllowedException> => {
  const contents: MethodNotAllowedException = {
    name: "MethodNotAllowedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestID: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestID !== undefined && data.RequestID !== null) {
    contents.RequestID = data.RequestID;
  }
  return contents;
};

const deserializeAws_restJson1_1NotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NotFoundException> => {
  const contents: NotFoundException = {
    name: "NotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestID: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestID !== undefined && data.RequestID !== null) {
    contents.RequestID = data.RequestID;
  }
  return contents;
};

const deserializeAws_restJson1_1TooManyRequestsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyRequestsException> => {
  const contents: TooManyRequestsException = {
    name: "TooManyRequestsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestID: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestID !== undefined && data.RequestID !== null) {
    contents.RequestID = data.RequestID;
  }
  return contents;
};

const serializeAws_restJson1_1ADMChannelRequest = (
  input: ADMChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientId !== undefined) {
    bodyParams["ClientId"] = input.ClientId;
  }
  if (input.ClientSecret !== undefined) {
    bodyParams["ClientSecret"] = input.ClientSecret;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ADMMessage = (
  input: ADMMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.ConsolidationKey !== undefined) {
    bodyParams["ConsolidationKey"] = input.ConsolidationKey;
  }
  if (input.Data !== undefined) {
    bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(
      input.Data,
      context
    );
  }
  if (input.ExpiresAfter !== undefined) {
    bodyParams["ExpiresAfter"] = input.ExpiresAfter;
  }
  if (input.IconReference !== undefined) {
    bodyParams["IconReference"] = input.IconReference;
  }
  if (input.ImageIconUrl !== undefined) {
    bodyParams["ImageIconUrl"] = input.ImageIconUrl;
  }
  if (input.ImageUrl !== undefined) {
    bodyParams["ImageUrl"] = input.ImageUrl;
  }
  if (input.MD5 !== undefined) {
    bodyParams["MD5"] = input.MD5;
  }
  if (input.RawContent !== undefined) {
    bodyParams["RawContent"] = input.RawContent;
  }
  if (input.SilentPush !== undefined) {
    bodyParams["SilentPush"] = input.SilentPush;
  }
  if (input.SmallImageIconUrl !== undefined) {
    bodyParams["SmallImageIconUrl"] = input.SmallImageIconUrl;
  }
  if (input.Sound !== undefined) {
    bodyParams["Sound"] = input.Sound;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  if (input.Url !== undefined) {
    bodyParams["Url"] = input.Url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1APNSChannelRequest = (
  input: APNSChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BundleId !== undefined) {
    bodyParams["BundleId"] = input.BundleId;
  }
  if (input.Certificate !== undefined) {
    bodyParams["Certificate"] = input.Certificate;
  }
  if (input.DefaultAuthenticationMethod !== undefined) {
    bodyParams["DefaultAuthenticationMethod"] =
      input.DefaultAuthenticationMethod;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.PrivateKey !== undefined) {
    bodyParams["PrivateKey"] = input.PrivateKey;
  }
  if (input.TeamId !== undefined) {
    bodyParams["TeamId"] = input.TeamId;
  }
  if (input.TokenKey !== undefined) {
    bodyParams["TokenKey"] = input.TokenKey;
  }
  if (input.TokenKeyId !== undefined) {
    bodyParams["TokenKeyId"] = input.TokenKeyId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1APNSMessage = (
  input: APNSMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.APNSPushType !== undefined) {
    bodyParams["APNSPushType"] = input.APNSPushType;
  }
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Badge !== undefined) {
    bodyParams["Badge"] = input.Badge;
  }
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.Category !== undefined) {
    bodyParams["Category"] = input.Category;
  }
  if (input.CollapseId !== undefined) {
    bodyParams["CollapseId"] = input.CollapseId;
  }
  if (input.Data !== undefined) {
    bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(
      input.Data,
      context
    );
  }
  if (input.MediaUrl !== undefined) {
    bodyParams["MediaUrl"] = input.MediaUrl;
  }
  if (input.PreferredAuthenticationMethod !== undefined) {
    bodyParams["PreferredAuthenticationMethod"] =
      input.PreferredAuthenticationMethod;
  }
  if (input.Priority !== undefined) {
    bodyParams["Priority"] = input.Priority;
  }
  if (input.RawContent !== undefined) {
    bodyParams["RawContent"] = input.RawContent;
  }
  if (input.SilentPush !== undefined) {
    bodyParams["SilentPush"] = input.SilentPush;
  }
  if (input.Sound !== undefined) {
    bodyParams["Sound"] = input.Sound;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  if (input.ThreadId !== undefined) {
    bodyParams["ThreadId"] = input.ThreadId;
  }
  if (input.TimeToLive !== undefined) {
    bodyParams["TimeToLive"] = input.TimeToLive;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  if (input.Url !== undefined) {
    bodyParams["Url"] = input.Url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1APNSPushNotificationTemplate = (
  input: APNSPushNotificationTemplate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.MediaUrl !== undefined) {
    bodyParams["MediaUrl"] = input.MediaUrl;
  }
  if (input.RawContent !== undefined) {
    bodyParams["RawContent"] = input.RawContent;
  }
  if (input.Sound !== undefined) {
    bodyParams["Sound"] = input.Sound;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  if (input.Url !== undefined) {
    bodyParams["Url"] = input.Url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1APNSSandboxChannelRequest = (
  input: APNSSandboxChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BundleId !== undefined) {
    bodyParams["BundleId"] = input.BundleId;
  }
  if (input.Certificate !== undefined) {
    bodyParams["Certificate"] = input.Certificate;
  }
  if (input.DefaultAuthenticationMethod !== undefined) {
    bodyParams["DefaultAuthenticationMethod"] =
      input.DefaultAuthenticationMethod;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.PrivateKey !== undefined) {
    bodyParams["PrivateKey"] = input.PrivateKey;
  }
  if (input.TeamId !== undefined) {
    bodyParams["TeamId"] = input.TeamId;
  }
  if (input.TokenKey !== undefined) {
    bodyParams["TokenKey"] = input.TokenKey;
  }
  if (input.TokenKeyId !== undefined) {
    bodyParams["TokenKeyId"] = input.TokenKeyId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1APNSVoipChannelRequest = (
  input: APNSVoipChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BundleId !== undefined) {
    bodyParams["BundleId"] = input.BundleId;
  }
  if (input.Certificate !== undefined) {
    bodyParams["Certificate"] = input.Certificate;
  }
  if (input.DefaultAuthenticationMethod !== undefined) {
    bodyParams["DefaultAuthenticationMethod"] =
      input.DefaultAuthenticationMethod;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.PrivateKey !== undefined) {
    bodyParams["PrivateKey"] = input.PrivateKey;
  }
  if (input.TeamId !== undefined) {
    bodyParams["TeamId"] = input.TeamId;
  }
  if (input.TokenKey !== undefined) {
    bodyParams["TokenKey"] = input.TokenKey;
  }
  if (input.TokenKeyId !== undefined) {
    bodyParams["TokenKeyId"] = input.TokenKeyId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1APNSVoipSandboxChannelRequest = (
  input: APNSVoipSandboxChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BundleId !== undefined) {
    bodyParams["BundleId"] = input.BundleId;
  }
  if (input.Certificate !== undefined) {
    bodyParams["Certificate"] = input.Certificate;
  }
  if (input.DefaultAuthenticationMethod !== undefined) {
    bodyParams["DefaultAuthenticationMethod"] =
      input.DefaultAuthenticationMethod;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.PrivateKey !== undefined) {
    bodyParams["PrivateKey"] = input.PrivateKey;
  }
  if (input.TeamId !== undefined) {
    bodyParams["TeamId"] = input.TeamId;
  }
  if (input.TokenKey !== undefined) {
    bodyParams["TokenKey"] = input.TokenKey;
  }
  if (input.TokenKeyId !== undefined) {
    bodyParams["TokenKeyId"] = input.TokenKeyId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Activity = (
  input: Activity,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConditionalSplit !== undefined) {
    bodyParams[
      "ConditionalSplit"
    ] = serializeAws_restJson1_1ConditionalSplitActivity(
      input.ConditionalSplit,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.EMAIL !== undefined) {
    bodyParams["EMAIL"] = serializeAws_restJson1_1EmailMessageActivity(
      input.EMAIL,
      context
    );
  }
  if (input.Holdout !== undefined) {
    bodyParams["Holdout"] = serializeAws_restJson1_1HoldoutActivity(
      input.Holdout,
      context
    );
  }
  if (input.MultiCondition !== undefined) {
    bodyParams[
      "MultiCondition"
    ] = serializeAws_restJson1_1MultiConditionalSplitActivity(
      input.MultiCondition,
      context
    );
  }
  if (input.RandomSplit !== undefined) {
    bodyParams["RandomSplit"] = serializeAws_restJson1_1RandomSplitActivity(
      input.RandomSplit,
      context
    );
  }
  if (input.Wait !== undefined) {
    bodyParams["Wait"] = serializeAws_restJson1_1WaitActivity(
      input.Wait,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1AddressConfiguration = (
  input: AddressConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BodyOverride !== undefined) {
    bodyParams["BodyOverride"] = input.BodyOverride;
  }
  if (input.ChannelType !== undefined) {
    bodyParams["ChannelType"] = input.ChannelType;
  }
  if (input.Context !== undefined) {
    bodyParams["Context"] = serializeAws_restJson1_1MapOf__string(
      input.Context,
      context
    );
  }
  if (input.RawContent !== undefined) {
    bodyParams["RawContent"] = input.RawContent;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  if (input.TitleOverride !== undefined) {
    bodyParams["TitleOverride"] = input.TitleOverride;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AndroidPushNotificationTemplate = (
  input: AndroidPushNotificationTemplate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.ImageIconUrl !== undefined) {
    bodyParams["ImageIconUrl"] = input.ImageIconUrl;
  }
  if (input.ImageUrl !== undefined) {
    bodyParams["ImageUrl"] = input.ImageUrl;
  }
  if (input.RawContent !== undefined) {
    bodyParams["RawContent"] = input.RawContent;
  }
  if (input.SmallImageIconUrl !== undefined) {
    bodyParams["SmallImageIconUrl"] = input.SmallImageIconUrl;
  }
  if (input.Sound !== undefined) {
    bodyParams["Sound"] = input.Sound;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  if (input.Url !== undefined) {
    bodyParams["Url"] = input.Url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AttributeDimension = (
  input: AttributeDimension,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AttributeType !== undefined) {
    bodyParams["AttributeType"] = input.AttributeType;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_restJson1_1ListOf__string(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1BaiduChannelRequest = (
  input: BaiduChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ApiKey !== undefined) {
    bodyParams["ApiKey"] = input.ApiKey;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.SecretKey !== undefined) {
    bodyParams["SecretKey"] = input.SecretKey;
  }
  return bodyParams;
};

const serializeAws_restJson1_1BaiduMessage = (
  input: BaiduMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.Data !== undefined) {
    bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(
      input.Data,
      context
    );
  }
  if (input.IconReference !== undefined) {
    bodyParams["IconReference"] = input.IconReference;
  }
  if (input.ImageIconUrl !== undefined) {
    bodyParams["ImageIconUrl"] = input.ImageIconUrl;
  }
  if (input.ImageUrl !== undefined) {
    bodyParams["ImageUrl"] = input.ImageUrl;
  }
  if (input.RawContent !== undefined) {
    bodyParams["RawContent"] = input.RawContent;
  }
  if (input.SilentPush !== undefined) {
    bodyParams["SilentPush"] = input.SilentPush;
  }
  if (input.SmallImageIconUrl !== undefined) {
    bodyParams["SmallImageIconUrl"] = input.SmallImageIconUrl;
  }
  if (input.Sound !== undefined) {
    bodyParams["Sound"] = input.Sound;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  if (input.TimeToLive !== undefined) {
    bodyParams["TimeToLive"] = input.TimeToLive;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  if (input.Url !== undefined) {
    bodyParams["Url"] = input.Url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CampaignEmailMessage = (
  input: CampaignEmailMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.FromAddress !== undefined) {
    bodyParams["FromAddress"] = input.FromAddress;
  }
  if (input.HtmlBody !== undefined) {
    bodyParams["HtmlBody"] = input.HtmlBody;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CampaignEventFilter = (
  input: CampaignEventFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Dimensions !== undefined) {
    bodyParams["Dimensions"] = serializeAws_restJson1_1EventDimensions(
      input.Dimensions,
      context
    );
  }
  if (input.FilterType !== undefined) {
    bodyParams["FilterType"] = input.FilterType;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CampaignHook = (
  input: CampaignHook,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LambdaFunctionName !== undefined) {
    bodyParams["LambdaFunctionName"] = input.LambdaFunctionName;
  }
  if (input.Mode !== undefined) {
    bodyParams["Mode"] = input.Mode;
  }
  if (input.WebUrl !== undefined) {
    bodyParams["WebUrl"] = input.WebUrl;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CampaignLimits = (
  input: CampaignLimits,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Daily !== undefined) {
    bodyParams["Daily"] = input.Daily;
  }
  if (input.MaximumDuration !== undefined) {
    bodyParams["MaximumDuration"] = input.MaximumDuration;
  }
  if (input.MessagesPerSecond !== undefined) {
    bodyParams["MessagesPerSecond"] = input.MessagesPerSecond;
  }
  if (input.Total !== undefined) {
    bodyParams["Total"] = input.Total;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CampaignSmsMessage = (
  input: CampaignSmsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.MessageType !== undefined) {
    bodyParams["MessageType"] = input.MessageType;
  }
  if (input.SenderId !== undefined) {
    bodyParams["SenderId"] = input.SenderId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Condition = (
  input: Condition,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Conditions !== undefined) {
    bodyParams["Conditions"] = serializeAws_restJson1_1ListOfSimpleCondition(
      input.Conditions,
      context
    );
  }
  if (input.Operator !== undefined) {
    bodyParams["Operator"] = input.Operator;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ConditionalSplitActivity = (
  input: ConditionalSplitActivity,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Condition !== undefined) {
    bodyParams["Condition"] = serializeAws_restJson1_1Condition(
      input.Condition,
      context
    );
  }
  if (input.EvaluationWaitTime !== undefined) {
    bodyParams["EvaluationWaitTime"] = serializeAws_restJson1_1WaitTime(
      input.EvaluationWaitTime,
      context
    );
  }
  if (input.FalseActivity !== undefined) {
    bodyParams["FalseActivity"] = input.FalseActivity;
  }
  if (input.TrueActivity !== undefined) {
    bodyParams["TrueActivity"] = input.TrueActivity;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CreateApplicationRequest = (
  input: CreateApplicationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(
      input.tags,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1DefaultMessage = (
  input: DefaultMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1DefaultPushNotificationMessage = (
  input: DefaultPushNotificationMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.Data !== undefined) {
    bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(
      input.Data,
      context
    );
  }
  if (input.SilentPush !== undefined) {
    bodyParams["SilentPush"] = input.SilentPush;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  if (input.Url !== undefined) {
    bodyParams["Url"] = input.Url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1DefaultPushNotificationTemplate = (
  input: DefaultPushNotificationTemplate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.Sound !== undefined) {
    bodyParams["Sound"] = input.Sound;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  if (input.Url !== undefined) {
    bodyParams["Url"] = input.Url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1DirectMessageConfiguration = (
  input: DirectMessageConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ADMMessage !== undefined) {
    bodyParams["ADMMessage"] = serializeAws_restJson1_1ADMMessage(
      input.ADMMessage,
      context
    );
  }
  if (input.APNSMessage !== undefined) {
    bodyParams["APNSMessage"] = serializeAws_restJson1_1APNSMessage(
      input.APNSMessage,
      context
    );
  }
  if (input.BaiduMessage !== undefined) {
    bodyParams["BaiduMessage"] = serializeAws_restJson1_1BaiduMessage(
      input.BaiduMessage,
      context
    );
  }
  if (input.DefaultMessage !== undefined) {
    bodyParams["DefaultMessage"] = serializeAws_restJson1_1DefaultMessage(
      input.DefaultMessage,
      context
    );
  }
  if (input.DefaultPushNotificationMessage !== undefined) {
    bodyParams[
      "DefaultPushNotificationMessage"
    ] = serializeAws_restJson1_1DefaultPushNotificationMessage(
      input.DefaultPushNotificationMessage,
      context
    );
  }
  if (input.EmailMessage !== undefined) {
    bodyParams["EmailMessage"] = serializeAws_restJson1_1EmailMessage(
      input.EmailMessage,
      context
    );
  }
  if (input.GCMMessage !== undefined) {
    bodyParams["GCMMessage"] = serializeAws_restJson1_1GCMMessage(
      input.GCMMessage,
      context
    );
  }
  if (input.SMSMessage !== undefined) {
    bodyParams["SMSMessage"] = serializeAws_restJson1_1SMSMessage(
      input.SMSMessage,
      context
    );
  }
  if (input.VoiceMessage !== undefined) {
    bodyParams["VoiceMessage"] = serializeAws_restJson1_1VoiceMessage(
      input.VoiceMessage,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1EmailChannelRequest = (
  input: EmailChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConfigurationSet !== undefined) {
    bodyParams["ConfigurationSet"] = input.ConfigurationSet;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.FromAddress !== undefined) {
    bodyParams["FromAddress"] = input.FromAddress;
  }
  if (input.Identity !== undefined) {
    bodyParams["Identity"] = input.Identity;
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1EmailMessage = (
  input: EmailMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.FeedbackForwardingAddress !== undefined) {
    bodyParams["FeedbackForwardingAddress"] = input.FeedbackForwardingAddress;
  }
  if (input.FromAddress !== undefined) {
    bodyParams["FromAddress"] = input.FromAddress;
  }
  if (input.RawEmail !== undefined) {
    bodyParams["RawEmail"] = serializeAws_restJson1_1RawEmail(
      input.RawEmail,
      context
    );
  }
  if (input.ReplyToAddresses !== undefined) {
    bodyParams["ReplyToAddresses"] = serializeAws_restJson1_1ListOf__string(
      input.ReplyToAddresses,
      context
    );
  }
  if (input.SimpleEmail !== undefined) {
    bodyParams["SimpleEmail"] = serializeAws_restJson1_1SimpleEmail(
      input.SimpleEmail,
      context
    );
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1EmailMessageActivity = (
  input: EmailMessageActivity,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MessageConfig !== undefined) {
    bodyParams["MessageConfig"] = serializeAws_restJson1_1JourneyEmailMessage(
      input.MessageConfig,
      context
    );
  }
  if (input.NextActivity !== undefined) {
    bodyParams["NextActivity"] = input.NextActivity;
  }
  if (input.TemplateName !== undefined) {
    bodyParams["TemplateName"] = input.TemplateName;
  }
  if (input.TemplateVersion !== undefined) {
    bodyParams["TemplateVersion"] = input.TemplateVersion;
  }
  return bodyParams;
};

const serializeAws_restJson1_1EmailTemplateRequest = (
  input: EmailTemplateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DefaultSubstitutions !== undefined) {
    bodyParams["DefaultSubstitutions"] = input.DefaultSubstitutions;
  }
  if (input.HtmlPart !== undefined) {
    bodyParams["HtmlPart"] = input.HtmlPart;
  }
  if (input.Subject !== undefined) {
    bodyParams["Subject"] = input.Subject;
  }
  if (input.TemplateDescription !== undefined) {
    bodyParams["TemplateDescription"] = input.TemplateDescription;
  }
  if (input.TextPart !== undefined) {
    bodyParams["TextPart"] = input.TextPart;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(
      input.tags,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1EndpointBatchItem = (
  input: EndpointBatchItem,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Address !== undefined) {
    bodyParams["Address"] = input.Address;
  }
  if (input.Attributes !== undefined) {
    bodyParams["Attributes"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Attributes,
      context
    );
  }
  if (input.ChannelType !== undefined) {
    bodyParams["ChannelType"] = input.ChannelType;
  }
  if (input.Demographic !== undefined) {
    bodyParams["Demographic"] = serializeAws_restJson1_1EndpointDemographic(
      input.Demographic,
      context
    );
  }
  if (input.EffectiveDate !== undefined) {
    bodyParams["EffectiveDate"] = input.EffectiveDate;
  }
  if (input.EndpointStatus !== undefined) {
    bodyParams["EndpointStatus"] = input.EndpointStatus;
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Location !== undefined) {
    bodyParams["Location"] = serializeAws_restJson1_1EndpointLocation(
      input.Location,
      context
    );
  }
  if (input.Metrics !== undefined) {
    bodyParams["Metrics"] = serializeAws_restJson1_1MapOf__double(
      input.Metrics,
      context
    );
  }
  if (input.OptOut !== undefined) {
    bodyParams["OptOut"] = input.OptOut;
  }
  if (input.RequestId !== undefined) {
    bodyParams["RequestId"] = input.RequestId;
  }
  if (input.User !== undefined) {
    bodyParams["User"] = serializeAws_restJson1_1EndpointUser(
      input.User,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1EndpointBatchRequest = (
  input: EndpointBatchRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Item !== undefined) {
    bodyParams["Item"] = serializeAws_restJson1_1ListOfEndpointBatchItem(
      input.Item,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1EndpointDemographic = (
  input: EndpointDemographic,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AppVersion !== undefined) {
    bodyParams["AppVersion"] = input.AppVersion;
  }
  if (input.Locale !== undefined) {
    bodyParams["Locale"] = input.Locale;
  }
  if (input.Make !== undefined) {
    bodyParams["Make"] = input.Make;
  }
  if (input.Model !== undefined) {
    bodyParams["Model"] = input.Model;
  }
  if (input.ModelVersion !== undefined) {
    bodyParams["ModelVersion"] = input.ModelVersion;
  }
  if (input.Platform !== undefined) {
    bodyParams["Platform"] = input.Platform;
  }
  if (input.PlatformVersion !== undefined) {
    bodyParams["PlatformVersion"] = input.PlatformVersion;
  }
  if (input.Timezone !== undefined) {
    bodyParams["Timezone"] = input.Timezone;
  }
  return bodyParams;
};

const serializeAws_restJson1_1EndpointLocation = (
  input: EndpointLocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.City !== undefined) {
    bodyParams["City"] = input.City;
  }
  if (input.Country !== undefined) {
    bodyParams["Country"] = input.Country;
  }
  if (input.Latitude !== undefined) {
    bodyParams["Latitude"] = input.Latitude;
  }
  if (input.Longitude !== undefined) {
    bodyParams["Longitude"] = input.Longitude;
  }
  if (input.PostalCode !== undefined) {
    bodyParams["PostalCode"] = input.PostalCode;
  }
  if (input.Region !== undefined) {
    bodyParams["Region"] = input.Region;
  }
  return bodyParams;
};

const serializeAws_restJson1_1EndpointRequest = (
  input: EndpointRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Address !== undefined) {
    bodyParams["Address"] = input.Address;
  }
  if (input.Attributes !== undefined) {
    bodyParams["Attributes"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Attributes,
      context
    );
  }
  if (input.ChannelType !== undefined) {
    bodyParams["ChannelType"] = input.ChannelType;
  }
  if (input.Demographic !== undefined) {
    bodyParams["Demographic"] = serializeAws_restJson1_1EndpointDemographic(
      input.Demographic,
      context
    );
  }
  if (input.EffectiveDate !== undefined) {
    bodyParams["EffectiveDate"] = input.EffectiveDate;
  }
  if (input.EndpointStatus !== undefined) {
    bodyParams["EndpointStatus"] = input.EndpointStatus;
  }
  if (input.Location !== undefined) {
    bodyParams["Location"] = serializeAws_restJson1_1EndpointLocation(
      input.Location,
      context
    );
  }
  if (input.Metrics !== undefined) {
    bodyParams["Metrics"] = serializeAws_restJson1_1MapOf__double(
      input.Metrics,
      context
    );
  }
  if (input.OptOut !== undefined) {
    bodyParams["OptOut"] = input.OptOut;
  }
  if (input.RequestId !== undefined) {
    bodyParams["RequestId"] = input.RequestId;
  }
  if (input.User !== undefined) {
    bodyParams["User"] = serializeAws_restJson1_1EndpointUser(
      input.User,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1EndpointSendConfiguration = (
  input: EndpointSendConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BodyOverride !== undefined) {
    bodyParams["BodyOverride"] = input.BodyOverride;
  }
  if (input.Context !== undefined) {
    bodyParams["Context"] = serializeAws_restJson1_1MapOf__string(
      input.Context,
      context
    );
  }
  if (input.RawContent !== undefined) {
    bodyParams["RawContent"] = input.RawContent;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  if (input.TitleOverride !== undefined) {
    bodyParams["TitleOverride"] = input.TitleOverride;
  }
  return bodyParams;
};

const serializeAws_restJson1_1EndpointUser = (
  input: EndpointUser,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.UserAttributes !== undefined) {
    bodyParams["UserAttributes"] = serializeAws_restJson1_1MapOfListOf__string(
      input.UserAttributes,
      context
    );
  }
  if (input.UserId !== undefined) {
    bodyParams["UserId"] = input.UserId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Event = (
  input: Event,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AppPackageName !== undefined) {
    bodyParams["AppPackageName"] = input.AppPackageName;
  }
  if (input.AppTitle !== undefined) {
    bodyParams["AppTitle"] = input.AppTitle;
  }
  if (input.AppVersionCode !== undefined) {
    bodyParams["AppVersionCode"] = input.AppVersionCode;
  }
  if (input.Attributes !== undefined) {
    bodyParams["Attributes"] = serializeAws_restJson1_1MapOf__string(
      input.Attributes,
      context
    );
  }
  if (input.ClientSdkVersion !== undefined) {
    bodyParams["ClientSdkVersion"] = input.ClientSdkVersion;
  }
  if (input.EventType !== undefined) {
    bodyParams["EventType"] = input.EventType;
  }
  if (input.Metrics !== undefined) {
    bodyParams["Metrics"] = serializeAws_restJson1_1MapOf__double(
      input.Metrics,
      context
    );
  }
  if (input.SdkName !== undefined) {
    bodyParams["SdkName"] = input.SdkName;
  }
  if (input.Session !== undefined) {
    bodyParams["Session"] = serializeAws_restJson1_1Session(
      input.Session,
      context
    );
  }
  if (input.Timestamp !== undefined) {
    bodyParams["Timestamp"] = input.Timestamp;
  }
  return bodyParams;
};

const serializeAws_restJson1_1EventCondition = (
  input: EventCondition,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Dimensions !== undefined) {
    bodyParams["Dimensions"] = serializeAws_restJson1_1EventDimensions(
      input.Dimensions,
      context
    );
  }
  if (input.MessageActivity !== undefined) {
    bodyParams["MessageActivity"] = input.MessageActivity;
  }
  return bodyParams;
};

const serializeAws_restJson1_1EventDimensions = (
  input: EventDimensions,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Attributes !== undefined) {
    bodyParams["Attributes"] = serializeAws_restJson1_1MapOfAttributeDimension(
      input.Attributes,
      context
    );
  }
  if (input.EventType !== undefined) {
    bodyParams["EventType"] = serializeAws_restJson1_1SetDimension(
      input.EventType,
      context
    );
  }
  if (input.Metrics !== undefined) {
    bodyParams["Metrics"] = serializeAws_restJson1_1MapOfMetricDimension(
      input.Metrics,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1EventsBatch = (
  input: EventsBatch,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Endpoint !== undefined) {
    bodyParams["Endpoint"] = serializeAws_restJson1_1PublicEndpoint(
      input.Endpoint,
      context
    );
  }
  if (input.Events !== undefined) {
    bodyParams["Events"] = serializeAws_restJson1_1MapOfEvent(
      input.Events,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1EventsRequest = (
  input: EventsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BatchItem !== undefined) {
    bodyParams["BatchItem"] = serializeAws_restJson1_1MapOfEventsBatch(
      input.BatchItem,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1ExportJobRequest = (
  input: ExportJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.S3UrlPrefix !== undefined) {
    bodyParams["S3UrlPrefix"] = input.S3UrlPrefix;
  }
  if (input.SegmentId !== undefined) {
    bodyParams["SegmentId"] = input.SegmentId;
  }
  if (input.SegmentVersion !== undefined) {
    bodyParams["SegmentVersion"] = input.SegmentVersion;
  }
  return bodyParams;
};

const serializeAws_restJson1_1GCMChannelRequest = (
  input: GCMChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ApiKey !== undefined) {
    bodyParams["ApiKey"] = input.ApiKey;
  }
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  return bodyParams;
};

const serializeAws_restJson1_1GCMMessage = (
  input: GCMMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.CollapseKey !== undefined) {
    bodyParams["CollapseKey"] = input.CollapseKey;
  }
  if (input.Data !== undefined) {
    bodyParams["Data"] = serializeAws_restJson1_1MapOf__string(
      input.Data,
      context
    );
  }
  if (input.IconReference !== undefined) {
    bodyParams["IconReference"] = input.IconReference;
  }
  if (input.ImageIconUrl !== undefined) {
    bodyParams["ImageIconUrl"] = input.ImageIconUrl;
  }
  if (input.ImageUrl !== undefined) {
    bodyParams["ImageUrl"] = input.ImageUrl;
  }
  if (input.Priority !== undefined) {
    bodyParams["Priority"] = input.Priority;
  }
  if (input.RawContent !== undefined) {
    bodyParams["RawContent"] = input.RawContent;
  }
  if (input.RestrictedPackageName !== undefined) {
    bodyParams["RestrictedPackageName"] = input.RestrictedPackageName;
  }
  if (input.SilentPush !== undefined) {
    bodyParams["SilentPush"] = input.SilentPush;
  }
  if (input.SmallImageIconUrl !== undefined) {
    bodyParams["SmallImageIconUrl"] = input.SmallImageIconUrl;
  }
  if (input.Sound !== undefined) {
    bodyParams["Sound"] = input.Sound;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  if (input.TimeToLive !== undefined) {
    bodyParams["TimeToLive"] = input.TimeToLive;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  if (input.Url !== undefined) {
    bodyParams["Url"] = input.Url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1GPSCoordinates = (
  input: GPSCoordinates,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Latitude !== undefined) {
    bodyParams["Latitude"] = input.Latitude;
  }
  if (input.Longitude !== undefined) {
    bodyParams["Longitude"] = input.Longitude;
  }
  return bodyParams;
};

const serializeAws_restJson1_1GPSPointDimension = (
  input: GPSPointDimension,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Coordinates !== undefined) {
    bodyParams["Coordinates"] = serializeAws_restJson1_1GPSCoordinates(
      input.Coordinates,
      context
    );
  }
  if (input.RangeInKilometers !== undefined) {
    bodyParams["RangeInKilometers"] = input.RangeInKilometers;
  }
  return bodyParams;
};

const serializeAws_restJson1_1HoldoutActivity = (
  input: HoldoutActivity,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.NextActivity !== undefined) {
    bodyParams["NextActivity"] = input.NextActivity;
  }
  if (input.Percentage !== undefined) {
    bodyParams["Percentage"] = input.Percentage;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ImportJobRequest = (
  input: ImportJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DefineSegment !== undefined) {
    bodyParams["DefineSegment"] = input.DefineSegment;
  }
  if (input.ExternalId !== undefined) {
    bodyParams["ExternalId"] = input.ExternalId;
  }
  if (input.Format !== undefined) {
    bodyParams["Format"] = input.Format;
  }
  if (input.RegisterEndpoints !== undefined) {
    bodyParams["RegisterEndpoints"] = input.RegisterEndpoints;
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.S3Url !== undefined) {
    bodyParams["S3Url"] = input.S3Url;
  }
  if (input.SegmentId !== undefined) {
    bodyParams["SegmentId"] = input.SegmentId;
  }
  if (input.SegmentName !== undefined) {
    bodyParams["SegmentName"] = input.SegmentName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1JourneyEmailMessage = (
  input: JourneyEmailMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FromAddress !== undefined) {
    bodyParams["FromAddress"] = input.FromAddress;
  }
  return bodyParams;
};

const serializeAws_restJson1_1JourneyLimits = (
  input: JourneyLimits,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DailyCap !== undefined) {
    bodyParams["DailyCap"] = input.DailyCap;
  }
  if (input.EndpointReentryCap !== undefined) {
    bodyParams["EndpointReentryCap"] = input.EndpointReentryCap;
  }
  if (input.MessagesPerSecond !== undefined) {
    bodyParams["MessagesPerSecond"] = input.MessagesPerSecond;
  }
  return bodyParams;
};

const serializeAws_restJson1_1JourneySchedule = (
  input: JourneySchedule,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndTime !== undefined) {
    bodyParams["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
  }
  if (input.StartTime !== undefined) {
    bodyParams["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
  }
  if (input.Timezone !== undefined) {
    bodyParams["Timezone"] = input.Timezone;
  }
  return bodyParams;
};

const serializeAws_restJson1_1JourneyStateRequest = (
  input: JourneyStateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.State !== undefined) {
    bodyParams["State"] = input.State;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ListOfEndpointBatchItem = (
  input: Array<EndpointBatchItem>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1EndpointBatchItem(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1ListOfMultiConditionalBranch = (
  input: Array<MultiConditionalBranch>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_restJson1_1MultiConditionalBranch(entry, context)
    );
  }
  return contents;
};

const serializeAws_restJson1_1ListOfRandomSplitEntry = (
  input: Array<RandomSplitEntry>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1RandomSplitEntry(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1ListOfSegmentDimensions = (
  input: Array<SegmentDimensions>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1SegmentDimensions(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1ListOfSegmentGroup = (
  input: Array<SegmentGroup>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1SegmentGroup(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1ListOfSegmentReference = (
  input: Array<SegmentReference>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1SegmentReference(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1ListOfSimpleCondition = (
  input: Array<SimpleCondition>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1SimpleCondition(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1ListOfWriteTreatmentResource = (
  input: Array<WriteTreatmentResource>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_restJson1_1WriteTreatmentResource(entry, context)
    );
  }
  return contents;
};

const serializeAws_restJson1_1ListOf__string = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1MapOfActivity = (
  input: { [key: string]: Activity },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1Activity(input[key], context);
  });
  return mapParams;
};

const serializeAws_restJson1_1MapOfAddressConfiguration = (
  input: { [key: string]: AddressConfiguration },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1AddressConfiguration(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1MapOfAttributeDimension = (
  input: { [key: string]: AttributeDimension },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1AttributeDimension(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1MapOfEndpointSendConfiguration = (
  input: { [key: string]: EndpointSendConfiguration },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1EndpointSendConfiguration(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1MapOfEvent = (
  input: { [key: string]: Event },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1Event(input[key], context);
  });
  return mapParams;
};

const serializeAws_restJson1_1MapOfEventsBatch = (
  input: { [key: string]: EventsBatch },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1EventsBatch(input[key], context);
  });
  return mapParams;
};

const serializeAws_restJson1_1MapOfListOf__string = (
  input: { [key: string]: Array<string> },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1ListOf__string(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1MapOfMetricDimension = (
  input: { [key: string]: MetricDimension },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1MetricDimension(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1MapOf__double = (
  input: { [key: string]: number },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1MapOf__string = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1Message = (
  input: Message,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.ImageIconUrl !== undefined) {
    bodyParams["ImageIconUrl"] = input.ImageIconUrl;
  }
  if (input.ImageSmallIconUrl !== undefined) {
    bodyParams["ImageSmallIconUrl"] = input.ImageSmallIconUrl;
  }
  if (input.ImageUrl !== undefined) {
    bodyParams["ImageUrl"] = input.ImageUrl;
  }
  if (input.JsonBody !== undefined) {
    bodyParams["JsonBody"] = input.JsonBody;
  }
  if (input.MediaUrl !== undefined) {
    bodyParams["MediaUrl"] = input.MediaUrl;
  }
  if (input.RawContent !== undefined) {
    bodyParams["RawContent"] = input.RawContent;
  }
  if (input.SilentPush !== undefined) {
    bodyParams["SilentPush"] = input.SilentPush;
  }
  if (input.TimeToLive !== undefined) {
    bodyParams["TimeToLive"] = input.TimeToLive;
  }
  if (input.Title !== undefined) {
    bodyParams["Title"] = input.Title;
  }
  if (input.Url !== undefined) {
    bodyParams["Url"] = input.Url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MessageConfiguration = (
  input: MessageConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ADMMessage !== undefined) {
    bodyParams["ADMMessage"] = serializeAws_restJson1_1Message(
      input.ADMMessage,
      context
    );
  }
  if (input.APNSMessage !== undefined) {
    bodyParams["APNSMessage"] = serializeAws_restJson1_1Message(
      input.APNSMessage,
      context
    );
  }
  if (input.BaiduMessage !== undefined) {
    bodyParams["BaiduMessage"] = serializeAws_restJson1_1Message(
      input.BaiduMessage,
      context
    );
  }
  if (input.DefaultMessage !== undefined) {
    bodyParams["DefaultMessage"] = serializeAws_restJson1_1Message(
      input.DefaultMessage,
      context
    );
  }
  if (input.EmailMessage !== undefined) {
    bodyParams["EmailMessage"] = serializeAws_restJson1_1CampaignEmailMessage(
      input.EmailMessage,
      context
    );
  }
  if (input.GCMMessage !== undefined) {
    bodyParams["GCMMessage"] = serializeAws_restJson1_1Message(
      input.GCMMessage,
      context
    );
  }
  if (input.SMSMessage !== undefined) {
    bodyParams["SMSMessage"] = serializeAws_restJson1_1CampaignSmsMessage(
      input.SMSMessage,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1MessageRequest = (
  input: MessageRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Addresses !== undefined) {
    bodyParams["Addresses"] = serializeAws_restJson1_1MapOfAddressConfiguration(
      input.Addresses,
      context
    );
  }
  if (input.Context !== undefined) {
    bodyParams["Context"] = serializeAws_restJson1_1MapOf__string(
      input.Context,
      context
    );
  }
  if (input.Endpoints !== undefined) {
    bodyParams[
      "Endpoints"
    ] = serializeAws_restJson1_1MapOfEndpointSendConfiguration(
      input.Endpoints,
      context
    );
  }
  if (input.MessageConfiguration !== undefined) {
    bodyParams[
      "MessageConfiguration"
    ] = serializeAws_restJson1_1DirectMessageConfiguration(
      input.MessageConfiguration,
      context
    );
  }
  if (input.TemplateConfiguration !== undefined) {
    bodyParams[
      "TemplateConfiguration"
    ] = serializeAws_restJson1_1TemplateConfiguration(
      input.TemplateConfiguration,
      context
    );
  }
  if (input.TraceId !== undefined) {
    bodyParams["TraceId"] = input.TraceId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MetricDimension = (
  input: MetricDimension,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ComparisonOperator !== undefined) {
    bodyParams["ComparisonOperator"] = input.ComparisonOperator;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MultiConditionalBranch = (
  input: MultiConditionalBranch,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Condition !== undefined) {
    bodyParams["Condition"] = serializeAws_restJson1_1SimpleCondition(
      input.Condition,
      context
    );
  }
  if (input.NextActivity !== undefined) {
    bodyParams["NextActivity"] = input.NextActivity;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MultiConditionalSplitActivity = (
  input: MultiConditionalSplitActivity,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Branches !== undefined) {
    bodyParams[
      "Branches"
    ] = serializeAws_restJson1_1ListOfMultiConditionalBranch(
      input.Branches,
      context
    );
  }
  if (input.DefaultActivity !== undefined) {
    bodyParams["DefaultActivity"] = input.DefaultActivity;
  }
  if (input.EvaluationWaitTime !== undefined) {
    bodyParams["EvaluationWaitTime"] = serializeAws_restJson1_1WaitTime(
      input.EvaluationWaitTime,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1NumberValidateRequest = (
  input: NumberValidateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.IsoCountryCode !== undefined) {
    bodyParams["IsoCountryCode"] = input.IsoCountryCode;
  }
  if (input.PhoneNumber !== undefined) {
    bodyParams["PhoneNumber"] = input.PhoneNumber;
  }
  return bodyParams;
};

const serializeAws_restJson1_1PublicEndpoint = (
  input: PublicEndpoint,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Address !== undefined) {
    bodyParams["Address"] = input.Address;
  }
  if (input.Attributes !== undefined) {
    bodyParams["Attributes"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Attributes,
      context
    );
  }
  if (input.ChannelType !== undefined) {
    bodyParams["ChannelType"] = input.ChannelType;
  }
  if (input.Demographic !== undefined) {
    bodyParams["Demographic"] = serializeAws_restJson1_1EndpointDemographic(
      input.Demographic,
      context
    );
  }
  if (input.EffectiveDate !== undefined) {
    bodyParams["EffectiveDate"] = input.EffectiveDate;
  }
  if (input.EndpointStatus !== undefined) {
    bodyParams["EndpointStatus"] = input.EndpointStatus;
  }
  if (input.Location !== undefined) {
    bodyParams["Location"] = serializeAws_restJson1_1EndpointLocation(
      input.Location,
      context
    );
  }
  if (input.Metrics !== undefined) {
    bodyParams["Metrics"] = serializeAws_restJson1_1MapOf__double(
      input.Metrics,
      context
    );
  }
  if (input.OptOut !== undefined) {
    bodyParams["OptOut"] = input.OptOut;
  }
  if (input.RequestId !== undefined) {
    bodyParams["RequestId"] = input.RequestId;
  }
  if (input.User !== undefined) {
    bodyParams["User"] = serializeAws_restJson1_1EndpointUser(
      input.User,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1PushNotificationTemplateRequest = (
  input: PushNotificationTemplateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ADM !== undefined) {
    bodyParams["ADM"] = serializeAws_restJson1_1AndroidPushNotificationTemplate(
      input.ADM,
      context
    );
  }
  if (input.APNS !== undefined) {
    bodyParams["APNS"] = serializeAws_restJson1_1APNSPushNotificationTemplate(
      input.APNS,
      context
    );
  }
  if (input.Baidu !== undefined) {
    bodyParams[
      "Baidu"
    ] = serializeAws_restJson1_1AndroidPushNotificationTemplate(
      input.Baidu,
      context
    );
  }
  if (input.Default !== undefined) {
    bodyParams[
      "Default"
    ] = serializeAws_restJson1_1DefaultPushNotificationTemplate(
      input.Default,
      context
    );
  }
  if (input.DefaultSubstitutions !== undefined) {
    bodyParams["DefaultSubstitutions"] = input.DefaultSubstitutions;
  }
  if (input.GCM !== undefined) {
    bodyParams["GCM"] = serializeAws_restJson1_1AndroidPushNotificationTemplate(
      input.GCM,
      context
    );
  }
  if (input.TemplateDescription !== undefined) {
    bodyParams["TemplateDescription"] = input.TemplateDescription;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(
      input.tags,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1QuietTime = (
  input: QuietTime,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.End !== undefined) {
    bodyParams["End"] = input.End;
  }
  if (input.Start !== undefined) {
    bodyParams["Start"] = input.Start;
  }
  return bodyParams;
};

const serializeAws_restJson1_1RandomSplitActivity = (
  input: RandomSplitActivity,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Branches !== undefined) {
    bodyParams["Branches"] = serializeAws_restJson1_1ListOfRandomSplitEntry(
      input.Branches,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1RandomSplitEntry = (
  input: RandomSplitEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.NextActivity !== undefined) {
    bodyParams["NextActivity"] = input.NextActivity;
  }
  if (input.Percentage !== undefined) {
    bodyParams["Percentage"] = input.Percentage;
  }
  return bodyParams;
};

const serializeAws_restJson1_1RawEmail = (
  input: RawEmail,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Data !== undefined) {
    bodyParams["Data"] = context.base64Encoder(input.Data);
  }
  return bodyParams;
};

const serializeAws_restJson1_1RecencyDimension = (
  input: RecencyDimension,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Duration !== undefined) {
    bodyParams["Duration"] = input.Duration;
  }
  if (input.RecencyType !== undefined) {
    bodyParams["RecencyType"] = input.RecencyType;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SMSChannelRequest = (
  input: SMSChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.SenderId !== undefined) {
    bodyParams["SenderId"] = input.SenderId;
  }
  if (input.ShortCode !== undefined) {
    bodyParams["ShortCode"] = input.ShortCode;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SMSMessage = (
  input: SMSMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.Keyword !== undefined) {
    bodyParams["Keyword"] = input.Keyword;
  }
  if (input.MessageType !== undefined) {
    bodyParams["MessageType"] = input.MessageType;
  }
  if (input.OriginationNumber !== undefined) {
    bodyParams["OriginationNumber"] = input.OriginationNumber;
  }
  if (input.SenderId !== undefined) {
    bodyParams["SenderId"] = input.SenderId;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1SMSTemplateRequest = (
  input: SMSTemplateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.DefaultSubstitutions !== undefined) {
    bodyParams["DefaultSubstitutions"] = input.DefaultSubstitutions;
  }
  if (input.TemplateDescription !== undefined) {
    bodyParams["TemplateDescription"] = input.TemplateDescription;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(
      input.tags,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Schedule = (
  input: Schedule,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndTime !== undefined) {
    bodyParams["EndTime"] = input.EndTime;
  }
  if (input.EventFilter !== undefined) {
    bodyParams["EventFilter"] = serializeAws_restJson1_1CampaignEventFilter(
      input.EventFilter,
      context
    );
  }
  if (input.Frequency !== undefined) {
    bodyParams["Frequency"] = input.Frequency;
  }
  if (input.IsLocalTime !== undefined) {
    bodyParams["IsLocalTime"] = input.IsLocalTime;
  }
  if (input.QuietTime !== undefined) {
    bodyParams["QuietTime"] = serializeAws_restJson1_1QuietTime(
      input.QuietTime,
      context
    );
  }
  if (input.StartTime !== undefined) {
    bodyParams["StartTime"] = input.StartTime;
  }
  if (input.Timezone !== undefined) {
    bodyParams["Timezone"] = input.Timezone;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SegmentBehaviors = (
  input: SegmentBehaviors,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Recency !== undefined) {
    bodyParams["Recency"] = serializeAws_restJson1_1RecencyDimension(
      input.Recency,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1SegmentCondition = (
  input: SegmentCondition,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SegmentId !== undefined) {
    bodyParams["SegmentId"] = input.SegmentId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SegmentDemographics = (
  input: SegmentDemographics,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AppVersion !== undefined) {
    bodyParams["AppVersion"] = serializeAws_restJson1_1SetDimension(
      input.AppVersion,
      context
    );
  }
  if (input.Channel !== undefined) {
    bodyParams["Channel"] = serializeAws_restJson1_1SetDimension(
      input.Channel,
      context
    );
  }
  if (input.DeviceType !== undefined) {
    bodyParams["DeviceType"] = serializeAws_restJson1_1SetDimension(
      input.DeviceType,
      context
    );
  }
  if (input.Make !== undefined) {
    bodyParams["Make"] = serializeAws_restJson1_1SetDimension(
      input.Make,
      context
    );
  }
  if (input.Model !== undefined) {
    bodyParams["Model"] = serializeAws_restJson1_1SetDimension(
      input.Model,
      context
    );
  }
  if (input.Platform !== undefined) {
    bodyParams["Platform"] = serializeAws_restJson1_1SetDimension(
      input.Platform,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1SegmentDimensions = (
  input: SegmentDimensions,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Attributes !== undefined) {
    bodyParams["Attributes"] = serializeAws_restJson1_1MapOfAttributeDimension(
      input.Attributes,
      context
    );
  }
  if (input.Behavior !== undefined) {
    bodyParams["Behavior"] = serializeAws_restJson1_1SegmentBehaviors(
      input.Behavior,
      context
    );
  }
  if (input.Demographic !== undefined) {
    bodyParams["Demographic"] = serializeAws_restJson1_1SegmentDemographics(
      input.Demographic,
      context
    );
  }
  if (input.Location !== undefined) {
    bodyParams["Location"] = serializeAws_restJson1_1SegmentLocation(
      input.Location,
      context
    );
  }
  if (input.Metrics !== undefined) {
    bodyParams["Metrics"] = serializeAws_restJson1_1MapOfMetricDimension(
      input.Metrics,
      context
    );
  }
  if (input.UserAttributes !== undefined) {
    bodyParams[
      "UserAttributes"
    ] = serializeAws_restJson1_1MapOfAttributeDimension(
      input.UserAttributes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1SegmentGroup = (
  input: SegmentGroup,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Dimensions !== undefined) {
    bodyParams["Dimensions"] = serializeAws_restJson1_1ListOfSegmentDimensions(
      input.Dimensions,
      context
    );
  }
  if (input.SourceSegments !== undefined) {
    bodyParams[
      "SourceSegments"
    ] = serializeAws_restJson1_1ListOfSegmentReference(
      input.SourceSegments,
      context
    );
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SegmentGroupList = (
  input: SegmentGroupList,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Groups !== undefined) {
    bodyParams["Groups"] = serializeAws_restJson1_1ListOfSegmentGroup(
      input.Groups,
      context
    );
  }
  if (input.Include !== undefined) {
    bodyParams["Include"] = input.Include;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SegmentLocation = (
  input: SegmentLocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Country !== undefined) {
    bodyParams["Country"] = serializeAws_restJson1_1SetDimension(
      input.Country,
      context
    );
  }
  if (input.GPSPoint !== undefined) {
    bodyParams["GPSPoint"] = serializeAws_restJson1_1GPSPointDimension(
      input.GPSPoint,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1SegmentReference = (
  input: SegmentReference,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Version !== undefined) {
    bodyParams["Version"] = input.Version;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SendUsersMessageRequest = (
  input: SendUsersMessageRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Context !== undefined) {
    bodyParams["Context"] = serializeAws_restJson1_1MapOf__string(
      input.Context,
      context
    );
  }
  if (input.MessageConfiguration !== undefined) {
    bodyParams[
      "MessageConfiguration"
    ] = serializeAws_restJson1_1DirectMessageConfiguration(
      input.MessageConfiguration,
      context
    );
  }
  if (input.TemplateConfiguration !== undefined) {
    bodyParams[
      "TemplateConfiguration"
    ] = serializeAws_restJson1_1TemplateConfiguration(
      input.TemplateConfiguration,
      context
    );
  }
  if (input.TraceId !== undefined) {
    bodyParams["TraceId"] = input.TraceId;
  }
  if (input.Users !== undefined) {
    bodyParams[
      "Users"
    ] = serializeAws_restJson1_1MapOfEndpointSendConfiguration(
      input.Users,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Session = (
  input: Session,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Duration !== undefined) {
    bodyParams["Duration"] = input.Duration;
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.StartTimestamp !== undefined) {
    bodyParams["StartTimestamp"] = input.StartTimestamp;
  }
  if (input.StopTimestamp !== undefined) {
    bodyParams["StopTimestamp"] = input.StopTimestamp;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SetDimension = (
  input: SetDimension,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DimensionType !== undefined) {
    bodyParams["DimensionType"] = input.DimensionType;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_restJson1_1ListOf__string(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1SimpleCondition = (
  input: SimpleCondition,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EventCondition !== undefined) {
    bodyParams["EventCondition"] = serializeAws_restJson1_1EventCondition(
      input.EventCondition,
      context
    );
  }
  if (input.SegmentCondition !== undefined) {
    bodyParams["SegmentCondition"] = serializeAws_restJson1_1SegmentCondition(
      input.SegmentCondition,
      context
    );
  }
  if (input.SegmentDimensions !== undefined) {
    bodyParams["segmentDimensions"] = serializeAws_restJson1_1SegmentDimensions(
      input.SegmentDimensions,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1SimpleEmail = (
  input: SimpleEmail,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.HtmlPart !== undefined) {
    bodyParams["HtmlPart"] = serializeAws_restJson1_1SimpleEmailPart(
      input.HtmlPart,
      context
    );
  }
  if (input.Subject !== undefined) {
    bodyParams["Subject"] = serializeAws_restJson1_1SimpleEmailPart(
      input.Subject,
      context
    );
  }
  if (input.TextPart !== undefined) {
    bodyParams["TextPart"] = serializeAws_restJson1_1SimpleEmailPart(
      input.TextPart,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1SimpleEmailPart = (
  input: SimpleEmailPart,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Charset !== undefined) {
    bodyParams["Charset"] = input.Charset;
  }
  if (input.Data !== undefined) {
    bodyParams["Data"] = input.Data;
  }
  return bodyParams;
};

const serializeAws_restJson1_1StartCondition = (
  input: StartCondition,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.SegmentStartCondition !== undefined) {
    bodyParams[
      "SegmentStartCondition"
    ] = serializeAws_restJson1_1SegmentCondition(
      input.SegmentStartCondition,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1TagsModel = (
  input: TagsModel,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(
      input.tags,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Template = (
  input: Template,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Version !== undefined) {
    bodyParams["Version"] = input.Version;
  }
  return bodyParams;
};

const serializeAws_restJson1_1TemplateActiveVersionRequest = (
  input: TemplateActiveVersionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Version !== undefined) {
    bodyParams["Version"] = input.Version;
  }
  return bodyParams;
};

const serializeAws_restJson1_1TemplateConfiguration = (
  input: TemplateConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EmailTemplate !== undefined) {
    bodyParams["EmailTemplate"] = serializeAws_restJson1_1Template(
      input.EmailTemplate,
      context
    );
  }
  if (input.PushTemplate !== undefined) {
    bodyParams["PushTemplate"] = serializeAws_restJson1_1Template(
      input.PushTemplate,
      context
    );
  }
  if (input.SMSTemplate !== undefined) {
    bodyParams["SMSTemplate"] = serializeAws_restJson1_1Template(
      input.SMSTemplate,
      context
    );
  }
  if (input.VoiceTemplate !== undefined) {
    bodyParams["VoiceTemplate"] = serializeAws_restJson1_1Template(
      input.VoiceTemplate,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1UpdateAttributesRequest = (
  input: UpdateAttributesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Blacklist !== undefined) {
    bodyParams["Blacklist"] = serializeAws_restJson1_1ListOf__string(
      input.Blacklist,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1VoiceChannelRequest = (
  input: VoiceChannelRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  return bodyParams;
};

const serializeAws_restJson1_1VoiceMessage = (
  input: VoiceMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.OriginationNumber !== undefined) {
    bodyParams["OriginationNumber"] = input.OriginationNumber;
  }
  if (input.Substitutions !== undefined) {
    bodyParams["Substitutions"] = serializeAws_restJson1_1MapOfListOf__string(
      input.Substitutions,
      context
    );
  }
  if (input.VoiceId !== undefined) {
    bodyParams["VoiceId"] = input.VoiceId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1VoiceTemplateRequest = (
  input: VoiceTemplateRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Body !== undefined) {
    bodyParams["Body"] = input.Body;
  }
  if (input.DefaultSubstitutions !== undefined) {
    bodyParams["DefaultSubstitutions"] = input.DefaultSubstitutions;
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.TemplateDescription !== undefined) {
    bodyParams["TemplateDescription"] = input.TemplateDescription;
  }
  if (input.VoiceId !== undefined) {
    bodyParams["VoiceId"] = input.VoiceId;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(
      input.tags,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1WaitActivity = (
  input: WaitActivity,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.NextActivity !== undefined) {
    bodyParams["NextActivity"] = input.NextActivity;
  }
  if (input.WaitTime !== undefined) {
    bodyParams["WaitTime"] = serializeAws_restJson1_1WaitTime(
      input.WaitTime,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1WaitTime = (
  input: WaitTime,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.WaitFor !== undefined) {
    bodyParams["WaitFor"] = input.WaitFor;
  }
  if (input.WaitUntil !== undefined) {
    bodyParams["WaitUntil"] = input.WaitUntil;
  }
  return bodyParams;
};

const serializeAws_restJson1_1WriteApplicationSettingsRequest = (
  input: WriteApplicationSettingsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CampaignHook !== undefined) {
    bodyParams["CampaignHook"] = serializeAws_restJson1_1CampaignHook(
      input.CampaignHook,
      context
    );
  }
  if (input.CloudWatchMetricsEnabled !== undefined) {
    bodyParams["CloudWatchMetricsEnabled"] = input.CloudWatchMetricsEnabled;
  }
  if (input.Limits !== undefined) {
    bodyParams["Limits"] = serializeAws_restJson1_1CampaignLimits(
      input.Limits,
      context
    );
  }
  if (input.QuietTime !== undefined) {
    bodyParams["QuietTime"] = serializeAws_restJson1_1QuietTime(
      input.QuietTime,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1WriteCampaignRequest = (
  input: WriteCampaignRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AdditionalTreatments !== undefined) {
    bodyParams[
      "AdditionalTreatments"
    ] = serializeAws_restJson1_1ListOfWriteTreatmentResource(
      input.AdditionalTreatments,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.HoldoutPercent !== undefined) {
    bodyParams["HoldoutPercent"] = input.HoldoutPercent;
  }
  if (input.Hook !== undefined) {
    bodyParams["Hook"] = serializeAws_restJson1_1CampaignHook(
      input.Hook,
      context
    );
  }
  if (input.IsPaused !== undefined) {
    bodyParams["IsPaused"] = input.IsPaused;
  }
  if (input.Limits !== undefined) {
    bodyParams["Limits"] = serializeAws_restJson1_1CampaignLimits(
      input.Limits,
      context
    );
  }
  if (input.MessageConfiguration !== undefined) {
    bodyParams[
      "MessageConfiguration"
    ] = serializeAws_restJson1_1MessageConfiguration(
      input.MessageConfiguration,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = serializeAws_restJson1_1Schedule(
      input.Schedule,
      context
    );
  }
  if (input.SegmentId !== undefined) {
    bodyParams["SegmentId"] = input.SegmentId;
  }
  if (input.SegmentVersion !== undefined) {
    bodyParams["SegmentVersion"] = input.SegmentVersion;
  }
  if (input.TemplateConfiguration !== undefined) {
    bodyParams[
      "TemplateConfiguration"
    ] = serializeAws_restJson1_1TemplateConfiguration(
      input.TemplateConfiguration,
      context
    );
  }
  if (input.TreatmentDescription !== undefined) {
    bodyParams["TreatmentDescription"] = input.TreatmentDescription;
  }
  if (input.TreatmentName !== undefined) {
    bodyParams["TreatmentName"] = input.TreatmentName;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(
      input.tags,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1WriteEventStream = (
  input: WriteEventStream,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DestinationStreamArn !== undefined) {
    bodyParams["DestinationStreamArn"] = input.DestinationStreamArn;
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1WriteJourneyRequest = (
  input: WriteJourneyRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Activities !== undefined) {
    bodyParams["Activities"] = serializeAws_restJson1_1MapOfActivity(
      input.Activities,
      context
    );
  }
  if (input.CreationDate !== undefined) {
    bodyParams["CreationDate"] = input.CreationDate;
  }
  if (input.LastModifiedDate !== undefined) {
    bodyParams["LastModifiedDate"] = input.LastModifiedDate;
  }
  if (input.Limits !== undefined) {
    bodyParams["Limits"] = serializeAws_restJson1_1JourneyLimits(
      input.Limits,
      context
    );
  }
  if (input.LocalTime !== undefined) {
    bodyParams["LocalTime"] = input.LocalTime;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.QuietTime !== undefined) {
    bodyParams["QuietTime"] = serializeAws_restJson1_1QuietTime(
      input.QuietTime,
      context
    );
  }
  if (input.RefreshFrequency !== undefined) {
    bodyParams["RefreshFrequency"] = input.RefreshFrequency;
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = serializeAws_restJson1_1JourneySchedule(
      input.Schedule,
      context
    );
  }
  if (input.StartActivity !== undefined) {
    bodyParams["StartActivity"] = input.StartActivity;
  }
  if (input.StartCondition !== undefined) {
    bodyParams["StartCondition"] = serializeAws_restJson1_1StartCondition(
      input.StartCondition,
      context
    );
  }
  if (input.State !== undefined) {
    bodyParams["State"] = input.State;
  }
  return bodyParams;
};

const serializeAws_restJson1_1WriteSegmentRequest = (
  input: WriteSegmentRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Dimensions !== undefined) {
    bodyParams["Dimensions"] = serializeAws_restJson1_1SegmentDimensions(
      input.Dimensions,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.SegmentGroups !== undefined) {
    bodyParams["SegmentGroups"] = serializeAws_restJson1_1SegmentGroupList(
      input.SegmentGroups,
      context
    );
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1MapOf__string(
      input.tags,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1WriteTreatmentResource = (
  input: WriteTreatmentResource,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MessageConfiguration !== undefined) {
    bodyParams[
      "MessageConfiguration"
    ] = serializeAws_restJson1_1MessageConfiguration(
      input.MessageConfiguration,
      context
    );
  }
  if (input.Schedule !== undefined) {
    bodyParams["Schedule"] = serializeAws_restJson1_1Schedule(
      input.Schedule,
      context
    );
  }
  if (input.SizePercent !== undefined) {
    bodyParams["SizePercent"] = input.SizePercent;
  }
  if (input.TemplateConfiguration !== undefined) {
    bodyParams[
      "TemplateConfiguration"
    ] = serializeAws_restJson1_1TemplateConfiguration(
      input.TemplateConfiguration,
      context
    );
  }
  if (input.TreatmentDescription !== undefined) {
    bodyParams["TreatmentDescription"] = input.TreatmentDescription;
  }
  if (input.TreatmentName !== undefined) {
    bodyParams["TreatmentName"] = input.TreatmentName;
  }
  return bodyParams;
};

const deserializeAws_restJson1_1ADMChannelResponse = (
  output: any,
  context: __SerdeContext
): ADMChannelResponse => {
  let contents: any = {
    __type: "ADMChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Platform: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1APNSChannelResponse = (
  output: any,
  context: __SerdeContext
): APNSChannelResponse => {
  let contents: any = {
    __type: "APNSChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    DefaultAuthenticationMethod: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    HasTokenKey: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Platform: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (
    output.DefaultAuthenticationMethod !== undefined &&
    output.DefaultAuthenticationMethod !== null
  ) {
    contents.DefaultAuthenticationMethod = output.DefaultAuthenticationMethod;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.HasTokenKey !== undefined && output.HasTokenKey !== null) {
    contents.HasTokenKey = output.HasTokenKey;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1APNSPushNotificationTemplate = (
  output: any,
  context: __SerdeContext
): APNSPushNotificationTemplate => {
  let contents: any = {
    __type: "APNSPushNotificationTemplate",
    Action: undefined,
    Body: undefined,
    MediaUrl: undefined,
    RawContent: undefined,
    Sound: undefined,
    Title: undefined,
    Url: undefined
  };
  if (output.Action !== undefined && output.Action !== null) {
    contents.Action = output.Action;
  }
  if (output.Body !== undefined && output.Body !== null) {
    contents.Body = output.Body;
  }
  if (output.MediaUrl !== undefined && output.MediaUrl !== null) {
    contents.MediaUrl = output.MediaUrl;
  }
  if (output.RawContent !== undefined && output.RawContent !== null) {
    contents.RawContent = output.RawContent;
  }
  if (output.Sound !== undefined && output.Sound !== null) {
    contents.Sound = output.Sound;
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  if (output.Url !== undefined && output.Url !== null) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_restJson1_1APNSSandboxChannelResponse = (
  output: any,
  context: __SerdeContext
): APNSSandboxChannelResponse => {
  let contents: any = {
    __type: "APNSSandboxChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    DefaultAuthenticationMethod: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    HasTokenKey: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Platform: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (
    output.DefaultAuthenticationMethod !== undefined &&
    output.DefaultAuthenticationMethod !== null
  ) {
    contents.DefaultAuthenticationMethod = output.DefaultAuthenticationMethod;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.HasTokenKey !== undefined && output.HasTokenKey !== null) {
    contents.HasTokenKey = output.HasTokenKey;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1APNSVoipChannelResponse = (
  output: any,
  context: __SerdeContext
): APNSVoipChannelResponse => {
  let contents: any = {
    __type: "APNSVoipChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    DefaultAuthenticationMethod: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    HasTokenKey: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Platform: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (
    output.DefaultAuthenticationMethod !== undefined &&
    output.DefaultAuthenticationMethod !== null
  ) {
    contents.DefaultAuthenticationMethod = output.DefaultAuthenticationMethod;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.HasTokenKey !== undefined && output.HasTokenKey !== null) {
    contents.HasTokenKey = output.HasTokenKey;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1APNSVoipSandboxChannelResponse = (
  output: any,
  context: __SerdeContext
): APNSVoipSandboxChannelResponse => {
  let contents: any = {
    __type: "APNSVoipSandboxChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    DefaultAuthenticationMethod: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    HasTokenKey: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Platform: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (
    output.DefaultAuthenticationMethod !== undefined &&
    output.DefaultAuthenticationMethod !== null
  ) {
    contents.DefaultAuthenticationMethod = output.DefaultAuthenticationMethod;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.HasTokenKey !== undefined && output.HasTokenKey !== null) {
    contents.HasTokenKey = output.HasTokenKey;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1ActivitiesResponse = (
  output: any,
  context: __SerdeContext
): ActivitiesResponse => {
  let contents: any = {
    __type: "ActivitiesResponse",
    Item: undefined,
    NextToken: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfActivityResponse(
      output.Item,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_restJson1_1Activity = (
  output: any,
  context: __SerdeContext
): Activity => {
  let contents: any = {
    __type: "Activity",
    ConditionalSplit: undefined,
    Description: undefined,
    EMAIL: undefined,
    Holdout: undefined,
    MultiCondition: undefined,
    RandomSplit: undefined,
    Wait: undefined
  };
  if (
    output.ConditionalSplit !== undefined &&
    output.ConditionalSplit !== null
  ) {
    contents.ConditionalSplit = deserializeAws_restJson1_1ConditionalSplitActivity(
      output.ConditionalSplit,
      context
    );
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.EMAIL !== undefined && output.EMAIL !== null) {
    contents.EMAIL = deserializeAws_restJson1_1EmailMessageActivity(
      output.EMAIL,
      context
    );
  }
  if (output.Holdout !== undefined && output.Holdout !== null) {
    contents.Holdout = deserializeAws_restJson1_1HoldoutActivity(
      output.Holdout,
      context
    );
  }
  if (output.MultiCondition !== undefined && output.MultiCondition !== null) {
    contents.MultiCondition = deserializeAws_restJson1_1MultiConditionalSplitActivity(
      output.MultiCondition,
      context
    );
  }
  if (output.RandomSplit !== undefined && output.RandomSplit !== null) {
    contents.RandomSplit = deserializeAws_restJson1_1RandomSplitActivity(
      output.RandomSplit,
      context
    );
  }
  if (output.Wait !== undefined && output.Wait !== null) {
    contents.Wait = deserializeAws_restJson1_1WaitActivity(
      output.Wait,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ActivityResponse = (
  output: any,
  context: __SerdeContext
): ActivityResponse => {
  let contents: any = {
    __type: "ActivityResponse",
    ApplicationId: undefined,
    CampaignId: undefined,
    End: undefined,
    Id: undefined,
    Result: undefined,
    ScheduledStart: undefined,
    Start: undefined,
    State: undefined,
    SuccessfulEndpointCount: undefined,
    TimezonesCompletedCount: undefined,
    TimezonesTotalCount: undefined,
    TotalEndpointCount: undefined,
    TreatmentId: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CampaignId !== undefined && output.CampaignId !== null) {
    contents.CampaignId = output.CampaignId;
  }
  if (output.End !== undefined && output.End !== null) {
    contents.End = output.End;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Result !== undefined && output.Result !== null) {
    contents.Result = output.Result;
  }
  if (output.ScheduledStart !== undefined && output.ScheduledStart !== null) {
    contents.ScheduledStart = output.ScheduledStart;
  }
  if (output.Start !== undefined && output.Start !== null) {
    contents.Start = output.Start;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  if (
    output.SuccessfulEndpointCount !== undefined &&
    output.SuccessfulEndpointCount !== null
  ) {
    contents.SuccessfulEndpointCount = output.SuccessfulEndpointCount;
  }
  if (
    output.TimezonesCompletedCount !== undefined &&
    output.TimezonesCompletedCount !== null
  ) {
    contents.TimezonesCompletedCount = output.TimezonesCompletedCount;
  }
  if (
    output.TimezonesTotalCount !== undefined &&
    output.TimezonesTotalCount !== null
  ) {
    contents.TimezonesTotalCount = output.TimezonesTotalCount;
  }
  if (
    output.TotalEndpointCount !== undefined &&
    output.TotalEndpointCount !== null
  ) {
    contents.TotalEndpointCount = output.TotalEndpointCount;
  }
  if (output.TreatmentId !== undefined && output.TreatmentId !== null) {
    contents.TreatmentId = output.TreatmentId;
  }
  return contents;
};

const deserializeAws_restJson1_1AndroidPushNotificationTemplate = (
  output: any,
  context: __SerdeContext
): AndroidPushNotificationTemplate => {
  let contents: any = {
    __type: "AndroidPushNotificationTemplate",
    Action: undefined,
    Body: undefined,
    ImageIconUrl: undefined,
    ImageUrl: undefined,
    RawContent: undefined,
    SmallImageIconUrl: undefined,
    Sound: undefined,
    Title: undefined,
    Url: undefined
  };
  if (output.Action !== undefined && output.Action !== null) {
    contents.Action = output.Action;
  }
  if (output.Body !== undefined && output.Body !== null) {
    contents.Body = output.Body;
  }
  if (output.ImageIconUrl !== undefined && output.ImageIconUrl !== null) {
    contents.ImageIconUrl = output.ImageIconUrl;
  }
  if (output.ImageUrl !== undefined && output.ImageUrl !== null) {
    contents.ImageUrl = output.ImageUrl;
  }
  if (output.RawContent !== undefined && output.RawContent !== null) {
    contents.RawContent = output.RawContent;
  }
  if (
    output.SmallImageIconUrl !== undefined &&
    output.SmallImageIconUrl !== null
  ) {
    contents.SmallImageIconUrl = output.SmallImageIconUrl;
  }
  if (output.Sound !== undefined && output.Sound !== null) {
    contents.Sound = output.Sound;
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  if (output.Url !== undefined && output.Url !== null) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_restJson1_1ApplicationDateRangeKpiResponse = (
  output: any,
  context: __SerdeContext
): ApplicationDateRangeKpiResponse => {
  let contents: any = {
    __type: "ApplicationDateRangeKpiResponse",
    ApplicationId: undefined,
    EndTime: undefined,
    KpiName: undefined,
    KpiResult: undefined,
    NextToken: undefined,
    StartTime: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(output.EndTime);
  }
  if (output.KpiName !== undefined && output.KpiName !== null) {
    contents.KpiName = output.KpiName;
  }
  if (output.KpiResult !== undefined && output.KpiResult !== null) {
    contents.KpiResult = deserializeAws_restJson1_1BaseKpiResult(
      output.KpiResult,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(output.StartTime);
  }
  return contents;
};

const deserializeAws_restJson1_1ApplicationResponse = (
  output: any,
  context: __SerdeContext
): ApplicationResponse => {
  let contents: any = {
    __type: "ApplicationResponse",
    Arn: undefined,
    Id: undefined,
    Name: undefined,
    tags: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ApplicationSettingsResource = (
  output: any,
  context: __SerdeContext
): ApplicationSettingsResource => {
  let contents: any = {
    __type: "ApplicationSettingsResource",
    ApplicationId: undefined,
    CampaignHook: undefined,
    LastModifiedDate: undefined,
    Limits: undefined,
    QuietTime: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CampaignHook !== undefined && output.CampaignHook !== null) {
    contents.CampaignHook = deserializeAws_restJson1_1CampaignHook(
      output.CampaignHook,
      context
    );
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Limits !== undefined && output.Limits !== null) {
    contents.Limits = deserializeAws_restJson1_1CampaignLimits(
      output.Limits,
      context
    );
  }
  if (output.QuietTime !== undefined && output.QuietTime !== null) {
    contents.QuietTime = deserializeAws_restJson1_1QuietTime(
      output.QuietTime,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ApplicationsResponse = (
  output: any,
  context: __SerdeContext
): ApplicationsResponse => {
  let contents: any = {
    __type: "ApplicationsResponse",
    Item: undefined,
    NextToken: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfApplicationResponse(
      output.Item,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_restJson1_1AttributeDimension = (
  output: any,
  context: __SerdeContext
): AttributeDimension => {
  let contents: any = {
    __type: "AttributeDimension",
    AttributeType: undefined,
    Values: undefined
  };
  if (output.AttributeType !== undefined && output.AttributeType !== null) {
    contents.AttributeType = output.AttributeType;
  }
  if (output.Values !== undefined && output.Values !== null) {
    contents.Values = deserializeAws_restJson1_1ListOf__string(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1AttributesResource = (
  output: any,
  context: __SerdeContext
): AttributesResource => {
  let contents: any = {
    __type: "AttributesResource",
    ApplicationId: undefined,
    AttributeType: undefined,
    Attributes: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.AttributeType !== undefined && output.AttributeType !== null) {
    contents.AttributeType = output.AttributeType;
  }
  if (output.Attributes !== undefined && output.Attributes !== null) {
    contents.Attributes = deserializeAws_restJson1_1ListOf__string(
      output.Attributes,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1BaiduChannelResponse = (
  output: any,
  context: __SerdeContext
): BaiduChannelResponse => {
  let contents: any = {
    __type: "BaiduChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    Credential: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Platform: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Credential !== undefined && output.Credential !== null) {
    contents.Credential = output.Credential;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1BaseKpiResult = (
  output: any,
  context: __SerdeContext
): BaseKpiResult => {
  let contents: any = {
    __type: "BaseKpiResult",
    Rows: undefined
  };
  if (output.Rows !== undefined && output.Rows !== null) {
    contents.Rows = deserializeAws_restJson1_1ListOfResultRow(
      output.Rows,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1CampaignDateRangeKpiResponse = (
  output: any,
  context: __SerdeContext
): CampaignDateRangeKpiResponse => {
  let contents: any = {
    __type: "CampaignDateRangeKpiResponse",
    ApplicationId: undefined,
    CampaignId: undefined,
    EndTime: undefined,
    KpiName: undefined,
    KpiResult: undefined,
    NextToken: undefined,
    StartTime: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CampaignId !== undefined && output.CampaignId !== null) {
    contents.CampaignId = output.CampaignId;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(output.EndTime);
  }
  if (output.KpiName !== undefined && output.KpiName !== null) {
    contents.KpiName = output.KpiName;
  }
  if (output.KpiResult !== undefined && output.KpiResult !== null) {
    contents.KpiResult = deserializeAws_restJson1_1BaseKpiResult(
      output.KpiResult,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(output.StartTime);
  }
  return contents;
};

const deserializeAws_restJson1_1CampaignEmailMessage = (
  output: any,
  context: __SerdeContext
): CampaignEmailMessage => {
  let contents: any = {
    __type: "CampaignEmailMessage",
    Body: undefined,
    FromAddress: undefined,
    HtmlBody: undefined,
    Title: undefined
  };
  if (output.Body !== undefined && output.Body !== null) {
    contents.Body = output.Body;
  }
  if (output.FromAddress !== undefined && output.FromAddress !== null) {
    contents.FromAddress = output.FromAddress;
  }
  if (output.HtmlBody !== undefined && output.HtmlBody !== null) {
    contents.HtmlBody = output.HtmlBody;
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  return contents;
};

const deserializeAws_restJson1_1CampaignEventFilter = (
  output: any,
  context: __SerdeContext
): CampaignEventFilter => {
  let contents: any = {
    __type: "CampaignEventFilter",
    Dimensions: undefined,
    FilterType: undefined
  };
  if (output.Dimensions !== undefined && output.Dimensions !== null) {
    contents.Dimensions = deserializeAws_restJson1_1EventDimensions(
      output.Dimensions,
      context
    );
  }
  if (output.FilterType !== undefined && output.FilterType !== null) {
    contents.FilterType = output.FilterType;
  }
  return contents;
};

const deserializeAws_restJson1_1CampaignHook = (
  output: any,
  context: __SerdeContext
): CampaignHook => {
  let contents: any = {
    __type: "CampaignHook",
    LambdaFunctionName: undefined,
    Mode: undefined,
    WebUrl: undefined
  };
  if (
    output.LambdaFunctionName !== undefined &&
    output.LambdaFunctionName !== null
  ) {
    contents.LambdaFunctionName = output.LambdaFunctionName;
  }
  if (output.Mode !== undefined && output.Mode !== null) {
    contents.Mode = output.Mode;
  }
  if (output.WebUrl !== undefined && output.WebUrl !== null) {
    contents.WebUrl = output.WebUrl;
  }
  return contents;
};

const deserializeAws_restJson1_1CampaignLimits = (
  output: any,
  context: __SerdeContext
): CampaignLimits => {
  let contents: any = {
    __type: "CampaignLimits",
    Daily: undefined,
    MaximumDuration: undefined,
    MessagesPerSecond: undefined,
    Total: undefined
  };
  if (output.Daily !== undefined && output.Daily !== null) {
    contents.Daily = output.Daily;
  }
  if (output.MaximumDuration !== undefined && output.MaximumDuration !== null) {
    contents.MaximumDuration = output.MaximumDuration;
  }
  if (
    output.MessagesPerSecond !== undefined &&
    output.MessagesPerSecond !== null
  ) {
    contents.MessagesPerSecond = output.MessagesPerSecond;
  }
  if (output.Total !== undefined && output.Total !== null) {
    contents.Total = output.Total;
  }
  return contents;
};

const deserializeAws_restJson1_1CampaignResponse = (
  output: any,
  context: __SerdeContext
): CampaignResponse => {
  let contents: any = {
    __type: "CampaignResponse",
    AdditionalTreatments: undefined,
    ApplicationId: undefined,
    Arn: undefined,
    CreationDate: undefined,
    DefaultState: undefined,
    Description: undefined,
    HoldoutPercent: undefined,
    Hook: undefined,
    Id: undefined,
    IsPaused: undefined,
    LastModifiedDate: undefined,
    Limits: undefined,
    MessageConfiguration: undefined,
    Name: undefined,
    Schedule: undefined,
    SegmentId: undefined,
    SegmentVersion: undefined,
    State: undefined,
    TemplateConfiguration: undefined,
    TreatmentDescription: undefined,
    TreatmentName: undefined,
    Version: undefined,
    tags: undefined
  };
  if (
    output.AdditionalTreatments !== undefined &&
    output.AdditionalTreatments !== null
  ) {
    contents.AdditionalTreatments = deserializeAws_restJson1_1ListOfTreatmentResource(
      output.AdditionalTreatments,
      context
    );
  }
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.DefaultState !== undefined && output.DefaultState !== null) {
    contents.DefaultState = deserializeAws_restJson1_1CampaignState(
      output.DefaultState,
      context
    );
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.HoldoutPercent !== undefined && output.HoldoutPercent !== null) {
    contents.HoldoutPercent = output.HoldoutPercent;
  }
  if (output.Hook !== undefined && output.Hook !== null) {
    contents.Hook = deserializeAws_restJson1_1CampaignHook(
      output.Hook,
      context
    );
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsPaused !== undefined && output.IsPaused !== null) {
    contents.IsPaused = output.IsPaused;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Limits !== undefined && output.Limits !== null) {
    contents.Limits = deserializeAws_restJson1_1CampaignLimits(
      output.Limits,
      context
    );
  }
  if (
    output.MessageConfiguration !== undefined &&
    output.MessageConfiguration !== null
  ) {
    contents.MessageConfiguration = deserializeAws_restJson1_1MessageConfiguration(
      output.MessageConfiguration,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Schedule !== undefined && output.Schedule !== null) {
    contents.Schedule = deserializeAws_restJson1_1Schedule(
      output.Schedule,
      context
    );
  }
  if (output.SegmentId !== undefined && output.SegmentId !== null) {
    contents.SegmentId = output.SegmentId;
  }
  if (output.SegmentVersion !== undefined && output.SegmentVersion !== null) {
    contents.SegmentVersion = output.SegmentVersion;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = deserializeAws_restJson1_1CampaignState(
      output.State,
      context
    );
  }
  if (
    output.TemplateConfiguration !== undefined &&
    output.TemplateConfiguration !== null
  ) {
    contents.TemplateConfiguration = deserializeAws_restJson1_1TemplateConfiguration(
      output.TemplateConfiguration,
      context
    );
  }
  if (
    output.TreatmentDescription !== undefined &&
    output.TreatmentDescription !== null
  ) {
    contents.TreatmentDescription = output.TreatmentDescription;
  }
  if (output.TreatmentName !== undefined && output.TreatmentName !== null) {
    contents.TreatmentName = output.TreatmentName;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1CampaignSmsMessage = (
  output: any,
  context: __SerdeContext
): CampaignSmsMessage => {
  let contents: any = {
    __type: "CampaignSmsMessage",
    Body: undefined,
    MessageType: undefined,
    SenderId: undefined
  };
  if (output.Body !== undefined && output.Body !== null) {
    contents.Body = output.Body;
  }
  if (output.MessageType !== undefined && output.MessageType !== null) {
    contents.MessageType = output.MessageType;
  }
  if (output.SenderId !== undefined && output.SenderId !== null) {
    contents.SenderId = output.SenderId;
  }
  return contents;
};

const deserializeAws_restJson1_1CampaignState = (
  output: any,
  context: __SerdeContext
): CampaignState => {
  let contents: any = {
    __type: "CampaignState",
    CampaignStatus: undefined
  };
  if (output.CampaignStatus !== undefined && output.CampaignStatus !== null) {
    contents.CampaignStatus = output.CampaignStatus;
  }
  return contents;
};

const deserializeAws_restJson1_1CampaignsResponse = (
  output: any,
  context: __SerdeContext
): CampaignsResponse => {
  let contents: any = {
    __type: "CampaignsResponse",
    Item: undefined,
    NextToken: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfCampaignResponse(
      output.Item,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_restJson1_1ChannelResponse = (
  output: any,
  context: __SerdeContext
): ChannelResponse => {
  let contents: any = {
    __type: "ChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1ChannelsResponse = (
  output: any,
  context: __SerdeContext
): ChannelsResponse => {
  let contents: any = {
    __type: "ChannelsResponse",
    Channels: undefined
  };
  if (output.Channels !== undefined && output.Channels !== null) {
    contents.Channels = deserializeAws_restJson1_1MapOfChannelResponse(
      output.Channels,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Condition = (
  output: any,
  context: __SerdeContext
): Condition => {
  let contents: any = {
    __type: "Condition",
    Conditions: undefined,
    Operator: undefined
  };
  if (output.Conditions !== undefined && output.Conditions !== null) {
    contents.Conditions = deserializeAws_restJson1_1ListOfSimpleCondition(
      output.Conditions,
      context
    );
  }
  if (output.Operator !== undefined && output.Operator !== null) {
    contents.Operator = output.Operator;
  }
  return contents;
};

const deserializeAws_restJson1_1ConditionalSplitActivity = (
  output: any,
  context: __SerdeContext
): ConditionalSplitActivity => {
  let contents: any = {
    __type: "ConditionalSplitActivity",
    Condition: undefined,
    EvaluationWaitTime: undefined,
    FalseActivity: undefined,
    TrueActivity: undefined
  };
  if (output.Condition !== undefined && output.Condition !== null) {
    contents.Condition = deserializeAws_restJson1_1Condition(
      output.Condition,
      context
    );
  }
  if (
    output.EvaluationWaitTime !== undefined &&
    output.EvaluationWaitTime !== null
  ) {
    contents.EvaluationWaitTime = deserializeAws_restJson1_1WaitTime(
      output.EvaluationWaitTime,
      context
    );
  }
  if (output.FalseActivity !== undefined && output.FalseActivity !== null) {
    contents.FalseActivity = output.FalseActivity;
  }
  if (output.TrueActivity !== undefined && output.TrueActivity !== null) {
    contents.TrueActivity = output.TrueActivity;
  }
  return contents;
};

const deserializeAws_restJson1_1CreateTemplateMessageBody = (
  output: any,
  context: __SerdeContext
): CreateTemplateMessageBody => {
  let contents: any = {
    __type: "CreateTemplateMessageBody",
    Arn: undefined,
    Message: undefined,
    RequestID: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestID !== undefined && output.RequestID !== null) {
    contents.RequestID = output.RequestID;
  }
  return contents;
};

const deserializeAws_restJson1_1DefaultPushNotificationTemplate = (
  output: any,
  context: __SerdeContext
): DefaultPushNotificationTemplate => {
  let contents: any = {
    __type: "DefaultPushNotificationTemplate",
    Action: undefined,
    Body: undefined,
    Sound: undefined,
    Title: undefined,
    Url: undefined
  };
  if (output.Action !== undefined && output.Action !== null) {
    contents.Action = output.Action;
  }
  if (output.Body !== undefined && output.Body !== null) {
    contents.Body = output.Body;
  }
  if (output.Sound !== undefined && output.Sound !== null) {
    contents.Sound = output.Sound;
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  if (output.Url !== undefined && output.Url !== null) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_restJson1_1EmailChannelResponse = (
  output: any,
  context: __SerdeContext
): EmailChannelResponse => {
  let contents: any = {
    __type: "EmailChannelResponse",
    ApplicationId: undefined,
    ConfigurationSet: undefined,
    CreationDate: undefined,
    Enabled: undefined,
    FromAddress: undefined,
    HasCredential: undefined,
    Id: undefined,
    Identity: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    MessagesPerSecond: undefined,
    Platform: undefined,
    RoleArn: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (
    output.ConfigurationSet !== undefined &&
    output.ConfigurationSet !== null
  ) {
    contents.ConfigurationSet = output.ConfigurationSet;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.FromAddress !== undefined && output.FromAddress !== null) {
    contents.FromAddress = output.FromAddress;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Identity !== undefined && output.Identity !== null) {
    contents.Identity = output.Identity;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (
    output.MessagesPerSecond !== undefined &&
    output.MessagesPerSecond !== null
  ) {
    contents.MessagesPerSecond = output.MessagesPerSecond;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.RoleArn !== undefined && output.RoleArn !== null) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1EmailMessageActivity = (
  output: any,
  context: __SerdeContext
): EmailMessageActivity => {
  let contents: any = {
    __type: "EmailMessageActivity",
    MessageConfig: undefined,
    NextActivity: undefined,
    TemplateName: undefined,
    TemplateVersion: undefined
  };
  if (output.MessageConfig !== undefined && output.MessageConfig !== null) {
    contents.MessageConfig = deserializeAws_restJson1_1JourneyEmailMessage(
      output.MessageConfig,
      context
    );
  }
  if (output.NextActivity !== undefined && output.NextActivity !== null) {
    contents.NextActivity = output.NextActivity;
  }
  if (output.TemplateName !== undefined && output.TemplateName !== null) {
    contents.TemplateName = output.TemplateName;
  }
  if (output.TemplateVersion !== undefined && output.TemplateVersion !== null) {
    contents.TemplateVersion = output.TemplateVersion;
  }
  return contents;
};

const deserializeAws_restJson1_1EmailTemplateResponse = (
  output: any,
  context: __SerdeContext
): EmailTemplateResponse => {
  let contents: any = {
    __type: "EmailTemplateResponse",
    Arn: undefined,
    CreationDate: undefined,
    DefaultSubstitutions: undefined,
    HtmlPart: undefined,
    LastModifiedDate: undefined,
    Subject: undefined,
    TemplateDescription: undefined,
    TemplateName: undefined,
    TemplateType: undefined,
    TextPart: undefined,
    Version: undefined,
    tags: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (
    output.DefaultSubstitutions !== undefined &&
    output.DefaultSubstitutions !== null
  ) {
    contents.DefaultSubstitutions = output.DefaultSubstitutions;
  }
  if (output.HtmlPart !== undefined && output.HtmlPart !== null) {
    contents.HtmlPart = output.HtmlPart;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Subject !== undefined && output.Subject !== null) {
    contents.Subject = output.Subject;
  }
  if (
    output.TemplateDescription !== undefined &&
    output.TemplateDescription !== null
  ) {
    contents.TemplateDescription = output.TemplateDescription;
  }
  if (output.TemplateName !== undefined && output.TemplateName !== null) {
    contents.TemplateName = output.TemplateName;
  }
  if (output.TemplateType !== undefined && output.TemplateType !== null) {
    contents.TemplateType = output.TemplateType;
  }
  if (output.TextPart !== undefined && output.TextPart !== null) {
    contents.TextPart = output.TextPart;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1EndpointDemographic = (
  output: any,
  context: __SerdeContext
): EndpointDemographic => {
  let contents: any = {
    __type: "EndpointDemographic",
    AppVersion: undefined,
    Locale: undefined,
    Make: undefined,
    Model: undefined,
    ModelVersion: undefined,
    Platform: undefined,
    PlatformVersion: undefined,
    Timezone: undefined
  };
  if (output.AppVersion !== undefined && output.AppVersion !== null) {
    contents.AppVersion = output.AppVersion;
  }
  if (output.Locale !== undefined && output.Locale !== null) {
    contents.Locale = output.Locale;
  }
  if (output.Make !== undefined && output.Make !== null) {
    contents.Make = output.Make;
  }
  if (output.Model !== undefined && output.Model !== null) {
    contents.Model = output.Model;
  }
  if (output.ModelVersion !== undefined && output.ModelVersion !== null) {
    contents.ModelVersion = output.ModelVersion;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.PlatformVersion !== undefined && output.PlatformVersion !== null) {
    contents.PlatformVersion = output.PlatformVersion;
  }
  if (output.Timezone !== undefined && output.Timezone !== null) {
    contents.Timezone = output.Timezone;
  }
  return contents;
};

const deserializeAws_restJson1_1EndpointItemResponse = (
  output: any,
  context: __SerdeContext
): EndpointItemResponse => {
  let contents: any = {
    __type: "EndpointItemResponse",
    Message: undefined,
    StatusCode: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.StatusCode !== undefined && output.StatusCode !== null) {
    contents.StatusCode = output.StatusCode;
  }
  return contents;
};

const deserializeAws_restJson1_1EndpointLocation = (
  output: any,
  context: __SerdeContext
): EndpointLocation => {
  let contents: any = {
    __type: "EndpointLocation",
    City: undefined,
    Country: undefined,
    Latitude: undefined,
    Longitude: undefined,
    PostalCode: undefined,
    Region: undefined
  };
  if (output.City !== undefined && output.City !== null) {
    contents.City = output.City;
  }
  if (output.Country !== undefined && output.Country !== null) {
    contents.Country = output.Country;
  }
  if (output.Latitude !== undefined && output.Latitude !== null) {
    contents.Latitude = output.Latitude;
  }
  if (output.Longitude !== undefined && output.Longitude !== null) {
    contents.Longitude = output.Longitude;
  }
  if (output.PostalCode !== undefined && output.PostalCode !== null) {
    contents.PostalCode = output.PostalCode;
  }
  if (output.Region !== undefined && output.Region !== null) {
    contents.Region = output.Region;
  }
  return contents;
};

const deserializeAws_restJson1_1EndpointMessageResult = (
  output: any,
  context: __SerdeContext
): EndpointMessageResult => {
  let contents: any = {
    __type: "EndpointMessageResult",
    Address: undefined,
    DeliveryStatus: undefined,
    MessageId: undefined,
    StatusCode: undefined,
    StatusMessage: undefined,
    UpdatedToken: undefined
  };
  if (output.Address !== undefined && output.Address !== null) {
    contents.Address = output.Address;
  }
  if (output.DeliveryStatus !== undefined && output.DeliveryStatus !== null) {
    contents.DeliveryStatus = output.DeliveryStatus;
  }
  if (output.MessageId !== undefined && output.MessageId !== null) {
    contents.MessageId = output.MessageId;
  }
  if (output.StatusCode !== undefined && output.StatusCode !== null) {
    contents.StatusCode = output.StatusCode;
  }
  if (output.StatusMessage !== undefined && output.StatusMessage !== null) {
    contents.StatusMessage = output.StatusMessage;
  }
  if (output.UpdatedToken !== undefined && output.UpdatedToken !== null) {
    contents.UpdatedToken = output.UpdatedToken;
  }
  return contents;
};

const deserializeAws_restJson1_1EndpointResponse = (
  output: any,
  context: __SerdeContext
): EndpointResponse => {
  let contents: any = {
    __type: "EndpointResponse",
    Address: undefined,
    ApplicationId: undefined,
    Attributes: undefined,
    ChannelType: undefined,
    CohortId: undefined,
    CreationDate: undefined,
    Demographic: undefined,
    EffectiveDate: undefined,
    EndpointStatus: undefined,
    Id: undefined,
    Location: undefined,
    Metrics: undefined,
    OptOut: undefined,
    RequestId: undefined,
    User: undefined
  };
  if (output.Address !== undefined && output.Address !== null) {
    contents.Address = output.Address;
  }
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.Attributes !== undefined && output.Attributes !== null) {
    contents.Attributes = deserializeAws_restJson1_1MapOfListOf__string(
      output.Attributes,
      context
    );
  }
  if (output.ChannelType !== undefined && output.ChannelType !== null) {
    contents.ChannelType = output.ChannelType;
  }
  if (output.CohortId !== undefined && output.CohortId !== null) {
    contents.CohortId = output.CohortId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Demographic !== undefined && output.Demographic !== null) {
    contents.Demographic = deserializeAws_restJson1_1EndpointDemographic(
      output.Demographic,
      context
    );
  }
  if (output.EffectiveDate !== undefined && output.EffectiveDate !== null) {
    contents.EffectiveDate = output.EffectiveDate;
  }
  if (output.EndpointStatus !== undefined && output.EndpointStatus !== null) {
    contents.EndpointStatus = output.EndpointStatus;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Location !== undefined && output.Location !== null) {
    contents.Location = deserializeAws_restJson1_1EndpointLocation(
      output.Location,
      context
    );
  }
  if (output.Metrics !== undefined && output.Metrics !== null) {
    contents.Metrics = deserializeAws_restJson1_1MapOf__double(
      output.Metrics,
      context
    );
  }
  if (output.OptOut !== undefined && output.OptOut !== null) {
    contents.OptOut = output.OptOut;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  if (output.User !== undefined && output.User !== null) {
    contents.User = deserializeAws_restJson1_1EndpointUser(
      output.User,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1EndpointUser = (
  output: any,
  context: __SerdeContext
): EndpointUser => {
  let contents: any = {
    __type: "EndpointUser",
    UserAttributes: undefined,
    UserId: undefined
  };
  if (output.UserAttributes !== undefined && output.UserAttributes !== null) {
    contents.UserAttributes = deserializeAws_restJson1_1MapOfListOf__string(
      output.UserAttributes,
      context
    );
  }
  if (output.UserId !== undefined && output.UserId !== null) {
    contents.UserId = output.UserId;
  }
  return contents;
};

const deserializeAws_restJson1_1EndpointsResponse = (
  output: any,
  context: __SerdeContext
): EndpointsResponse => {
  let contents: any = {
    __type: "EndpointsResponse",
    Item: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfEndpointResponse(
      output.Item,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1EventCondition = (
  output: any,
  context: __SerdeContext
): EventCondition => {
  let contents: any = {
    __type: "EventCondition",
    Dimensions: undefined,
    MessageActivity: undefined
  };
  if (output.Dimensions !== undefined && output.Dimensions !== null) {
    contents.Dimensions = deserializeAws_restJson1_1EventDimensions(
      output.Dimensions,
      context
    );
  }
  if (output.MessageActivity !== undefined && output.MessageActivity !== null) {
    contents.MessageActivity = output.MessageActivity;
  }
  return contents;
};

const deserializeAws_restJson1_1EventDimensions = (
  output: any,
  context: __SerdeContext
): EventDimensions => {
  let contents: any = {
    __type: "EventDimensions",
    Attributes: undefined,
    EventType: undefined,
    Metrics: undefined
  };
  if (output.Attributes !== undefined && output.Attributes !== null) {
    contents.Attributes = deserializeAws_restJson1_1MapOfAttributeDimension(
      output.Attributes,
      context
    );
  }
  if (output.EventType !== undefined && output.EventType !== null) {
    contents.EventType = deserializeAws_restJson1_1SetDimension(
      output.EventType,
      context
    );
  }
  if (output.Metrics !== undefined && output.Metrics !== null) {
    contents.Metrics = deserializeAws_restJson1_1MapOfMetricDimension(
      output.Metrics,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1EventItemResponse = (
  output: any,
  context: __SerdeContext
): EventItemResponse => {
  let contents: any = {
    __type: "EventItemResponse",
    Message: undefined,
    StatusCode: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.StatusCode !== undefined && output.StatusCode !== null) {
    contents.StatusCode = output.StatusCode;
  }
  return contents;
};

const deserializeAws_restJson1_1EventStream = (
  output: any,
  context: __SerdeContext
): EventStream => {
  let contents: any = {
    __type: "EventStream",
    ApplicationId: undefined,
    DestinationStreamArn: undefined,
    ExternalId: undefined,
    LastModifiedDate: undefined,
    LastUpdatedBy: undefined,
    RoleArn: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (
    output.DestinationStreamArn !== undefined &&
    output.DestinationStreamArn !== null
  ) {
    contents.DestinationStreamArn = output.DestinationStreamArn;
  }
  if (output.ExternalId !== undefined && output.ExternalId !== null) {
    contents.ExternalId = output.ExternalId;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.LastUpdatedBy !== undefined && output.LastUpdatedBy !== null) {
    contents.LastUpdatedBy = output.LastUpdatedBy;
  }
  if (output.RoleArn !== undefined && output.RoleArn !== null) {
    contents.RoleArn = output.RoleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1EventsResponse = (
  output: any,
  context: __SerdeContext
): EventsResponse => {
  let contents: any = {
    __type: "EventsResponse",
    Results: undefined
  };
  if (output.Results !== undefined && output.Results !== null) {
    contents.Results = deserializeAws_restJson1_1MapOfItemResponse(
      output.Results,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ExportJobResource = (
  output: any,
  context: __SerdeContext
): ExportJobResource => {
  let contents: any = {
    __type: "ExportJobResource",
    RoleArn: undefined,
    S3UrlPrefix: undefined,
    SegmentId: undefined,
    SegmentVersion: undefined
  };
  if (output.RoleArn !== undefined && output.RoleArn !== null) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.S3UrlPrefix !== undefined && output.S3UrlPrefix !== null) {
    contents.S3UrlPrefix = output.S3UrlPrefix;
  }
  if (output.SegmentId !== undefined && output.SegmentId !== null) {
    contents.SegmentId = output.SegmentId;
  }
  if (output.SegmentVersion !== undefined && output.SegmentVersion !== null) {
    contents.SegmentVersion = output.SegmentVersion;
  }
  return contents;
};

const deserializeAws_restJson1_1ExportJobResponse = (
  output: any,
  context: __SerdeContext
): ExportJobResponse => {
  let contents: any = {
    __type: "ExportJobResponse",
    ApplicationId: undefined,
    CompletedPieces: undefined,
    CompletionDate: undefined,
    CreationDate: undefined,
    Definition: undefined,
    FailedPieces: undefined,
    Failures: undefined,
    Id: undefined,
    JobStatus: undefined,
    TotalFailures: undefined,
    TotalPieces: undefined,
    TotalProcessed: undefined,
    Type: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CompletedPieces !== undefined && output.CompletedPieces !== null) {
    contents.CompletedPieces = output.CompletedPieces;
  }
  if (output.CompletionDate !== undefined && output.CompletionDate !== null) {
    contents.CompletionDate = output.CompletionDate;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Definition !== undefined && output.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1ExportJobResource(
      output.Definition,
      context
    );
  }
  if (output.FailedPieces !== undefined && output.FailedPieces !== null) {
    contents.FailedPieces = output.FailedPieces;
  }
  if (output.Failures !== undefined && output.Failures !== null) {
    contents.Failures = deserializeAws_restJson1_1ListOf__string(
      output.Failures,
      context
    );
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.TotalFailures !== undefined && output.TotalFailures !== null) {
    contents.TotalFailures = output.TotalFailures;
  }
  if (output.TotalPieces !== undefined && output.TotalPieces !== null) {
    contents.TotalPieces = output.TotalPieces;
  }
  if (output.TotalProcessed !== undefined && output.TotalProcessed !== null) {
    contents.TotalProcessed = output.TotalProcessed;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1ExportJobsResponse = (
  output: any,
  context: __SerdeContext
): ExportJobsResponse => {
  let contents: any = {
    __type: "ExportJobsResponse",
    Item: undefined,
    NextToken: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfExportJobResponse(
      output.Item,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_restJson1_1GCMChannelResponse = (
  output: any,
  context: __SerdeContext
): GCMChannelResponse => {
  let contents: any = {
    __type: "GCMChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    Credential: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Platform: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Credential !== undefined && output.Credential !== null) {
    contents.Credential = output.Credential;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1GPSCoordinates = (
  output: any,
  context: __SerdeContext
): GPSCoordinates => {
  let contents: any = {
    __type: "GPSCoordinates",
    Latitude: undefined,
    Longitude: undefined
  };
  if (output.Latitude !== undefined && output.Latitude !== null) {
    contents.Latitude = output.Latitude;
  }
  if (output.Longitude !== undefined && output.Longitude !== null) {
    contents.Longitude = output.Longitude;
  }
  return contents;
};

const deserializeAws_restJson1_1GPSPointDimension = (
  output: any,
  context: __SerdeContext
): GPSPointDimension => {
  let contents: any = {
    __type: "GPSPointDimension",
    Coordinates: undefined,
    RangeInKilometers: undefined
  };
  if (output.Coordinates !== undefined && output.Coordinates !== null) {
    contents.Coordinates = deserializeAws_restJson1_1GPSCoordinates(
      output.Coordinates,
      context
    );
  }
  if (
    output.RangeInKilometers !== undefined &&
    output.RangeInKilometers !== null
  ) {
    contents.RangeInKilometers = output.RangeInKilometers;
  }
  return contents;
};

const deserializeAws_restJson1_1HoldoutActivity = (
  output: any,
  context: __SerdeContext
): HoldoutActivity => {
  let contents: any = {
    __type: "HoldoutActivity",
    NextActivity: undefined,
    Percentage: undefined
  };
  if (output.NextActivity !== undefined && output.NextActivity !== null) {
    contents.NextActivity = output.NextActivity;
  }
  if (output.Percentage !== undefined && output.Percentage !== null) {
    contents.Percentage = output.Percentage;
  }
  return contents;
};

const deserializeAws_restJson1_1ImportJobResource = (
  output: any,
  context: __SerdeContext
): ImportJobResource => {
  let contents: any = {
    __type: "ImportJobResource",
    DefineSegment: undefined,
    ExternalId: undefined,
    Format: undefined,
    RegisterEndpoints: undefined,
    RoleArn: undefined,
    S3Url: undefined,
    SegmentId: undefined,
    SegmentName: undefined
  };
  if (output.DefineSegment !== undefined && output.DefineSegment !== null) {
    contents.DefineSegment = output.DefineSegment;
  }
  if (output.ExternalId !== undefined && output.ExternalId !== null) {
    contents.ExternalId = output.ExternalId;
  }
  if (output.Format !== undefined && output.Format !== null) {
    contents.Format = output.Format;
  }
  if (
    output.RegisterEndpoints !== undefined &&
    output.RegisterEndpoints !== null
  ) {
    contents.RegisterEndpoints = output.RegisterEndpoints;
  }
  if (output.RoleArn !== undefined && output.RoleArn !== null) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.S3Url !== undefined && output.S3Url !== null) {
    contents.S3Url = output.S3Url;
  }
  if (output.SegmentId !== undefined && output.SegmentId !== null) {
    contents.SegmentId = output.SegmentId;
  }
  if (output.SegmentName !== undefined && output.SegmentName !== null) {
    contents.SegmentName = output.SegmentName;
  }
  return contents;
};

const deserializeAws_restJson1_1ImportJobResponse = (
  output: any,
  context: __SerdeContext
): ImportJobResponse => {
  let contents: any = {
    __type: "ImportJobResponse",
    ApplicationId: undefined,
    CompletedPieces: undefined,
    CompletionDate: undefined,
    CreationDate: undefined,
    Definition: undefined,
    FailedPieces: undefined,
    Failures: undefined,
    Id: undefined,
    JobStatus: undefined,
    TotalFailures: undefined,
    TotalPieces: undefined,
    TotalProcessed: undefined,
    Type: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CompletedPieces !== undefined && output.CompletedPieces !== null) {
    contents.CompletedPieces = output.CompletedPieces;
  }
  if (output.CompletionDate !== undefined && output.CompletionDate !== null) {
    contents.CompletionDate = output.CompletionDate;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Definition !== undefined && output.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1ImportJobResource(
      output.Definition,
      context
    );
  }
  if (output.FailedPieces !== undefined && output.FailedPieces !== null) {
    contents.FailedPieces = output.FailedPieces;
  }
  if (output.Failures !== undefined && output.Failures !== null) {
    contents.Failures = deserializeAws_restJson1_1ListOf__string(
      output.Failures,
      context
    );
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.TotalFailures !== undefined && output.TotalFailures !== null) {
    contents.TotalFailures = output.TotalFailures;
  }
  if (output.TotalPieces !== undefined && output.TotalPieces !== null) {
    contents.TotalPieces = output.TotalPieces;
  }
  if (output.TotalProcessed !== undefined && output.TotalProcessed !== null) {
    contents.TotalProcessed = output.TotalProcessed;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1ImportJobsResponse = (
  output: any,
  context: __SerdeContext
): ImportJobsResponse => {
  let contents: any = {
    __type: "ImportJobsResponse",
    Item: undefined,
    NextToken: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfImportJobResponse(
      output.Item,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_restJson1_1ItemResponse = (
  output: any,
  context: __SerdeContext
): ItemResponse => {
  let contents: any = {
    __type: "ItemResponse",
    EndpointItemResponse: undefined,
    EventsItemResponse: undefined
  };
  if (
    output.EndpointItemResponse !== undefined &&
    output.EndpointItemResponse !== null
  ) {
    contents.EndpointItemResponse = deserializeAws_restJson1_1EndpointItemResponse(
      output.EndpointItemResponse,
      context
    );
  }
  if (
    output.EventsItemResponse !== undefined &&
    output.EventsItemResponse !== null
  ) {
    contents.EventsItemResponse = deserializeAws_restJson1_1MapOfEventItemResponse(
      output.EventsItemResponse,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1JourneyDateRangeKpiResponse = (
  output: any,
  context: __SerdeContext
): JourneyDateRangeKpiResponse => {
  let contents: any = {
    __type: "JourneyDateRangeKpiResponse",
    ApplicationId: undefined,
    EndTime: undefined,
    JourneyId: undefined,
    KpiName: undefined,
    KpiResult: undefined,
    NextToken: undefined,
    StartTime: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(output.EndTime);
  }
  if (output.JourneyId !== undefined && output.JourneyId !== null) {
    contents.JourneyId = output.JourneyId;
  }
  if (output.KpiName !== undefined && output.KpiName !== null) {
    contents.KpiName = output.KpiName;
  }
  if (output.KpiResult !== undefined && output.KpiResult !== null) {
    contents.KpiResult = deserializeAws_restJson1_1BaseKpiResult(
      output.KpiResult,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(output.StartTime);
  }
  return contents;
};

const deserializeAws_restJson1_1JourneyEmailMessage = (
  output: any,
  context: __SerdeContext
): JourneyEmailMessage => {
  let contents: any = {
    __type: "JourneyEmailMessage",
    FromAddress: undefined
  };
  if (output.FromAddress !== undefined && output.FromAddress !== null) {
    contents.FromAddress = output.FromAddress;
  }
  return contents;
};

const deserializeAws_restJson1_1JourneyExecutionActivityMetricsResponse = (
  output: any,
  context: __SerdeContext
): JourneyExecutionActivityMetricsResponse => {
  let contents: any = {
    __type: "JourneyExecutionActivityMetricsResponse",
    ActivityType: undefined,
    ApplicationId: undefined,
    JourneyActivityId: undefined,
    JourneyId: undefined,
    LastEvaluatedTime: undefined,
    Metrics: undefined
  };
  if (output.ActivityType !== undefined && output.ActivityType !== null) {
    contents.ActivityType = output.ActivityType;
  }
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (
    output.JourneyActivityId !== undefined &&
    output.JourneyActivityId !== null
  ) {
    contents.JourneyActivityId = output.JourneyActivityId;
  }
  if (output.JourneyId !== undefined && output.JourneyId !== null) {
    contents.JourneyId = output.JourneyId;
  }
  if (
    output.LastEvaluatedTime !== undefined &&
    output.LastEvaluatedTime !== null
  ) {
    contents.LastEvaluatedTime = output.LastEvaluatedTime;
  }
  if (output.Metrics !== undefined && output.Metrics !== null) {
    contents.Metrics = deserializeAws_restJson1_1MapOf__string(
      output.Metrics,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1JourneyExecutionMetricsResponse = (
  output: any,
  context: __SerdeContext
): JourneyExecutionMetricsResponse => {
  let contents: any = {
    __type: "JourneyExecutionMetricsResponse",
    ApplicationId: undefined,
    JourneyId: undefined,
    LastEvaluatedTime: undefined,
    Metrics: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.JourneyId !== undefined && output.JourneyId !== null) {
    contents.JourneyId = output.JourneyId;
  }
  if (
    output.LastEvaluatedTime !== undefined &&
    output.LastEvaluatedTime !== null
  ) {
    contents.LastEvaluatedTime = output.LastEvaluatedTime;
  }
  if (output.Metrics !== undefined && output.Metrics !== null) {
    contents.Metrics = deserializeAws_restJson1_1MapOf__string(
      output.Metrics,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1JourneyLimits = (
  output: any,
  context: __SerdeContext
): JourneyLimits => {
  let contents: any = {
    __type: "JourneyLimits",
    DailyCap: undefined,
    EndpointReentryCap: undefined,
    MessagesPerSecond: undefined
  };
  if (output.DailyCap !== undefined && output.DailyCap !== null) {
    contents.DailyCap = output.DailyCap;
  }
  if (
    output.EndpointReentryCap !== undefined &&
    output.EndpointReentryCap !== null
  ) {
    contents.EndpointReentryCap = output.EndpointReentryCap;
  }
  if (
    output.MessagesPerSecond !== undefined &&
    output.MessagesPerSecond !== null
  ) {
    contents.MessagesPerSecond = output.MessagesPerSecond;
  }
  return contents;
};

const deserializeAws_restJson1_1JourneyResponse = (
  output: any,
  context: __SerdeContext
): JourneyResponse => {
  let contents: any = {
    __type: "JourneyResponse",
    Activities: undefined,
    ApplicationId: undefined,
    CreationDate: undefined,
    Id: undefined,
    LastModifiedDate: undefined,
    Limits: undefined,
    LocalTime: undefined,
    Name: undefined,
    QuietTime: undefined,
    RefreshFrequency: undefined,
    Schedule: undefined,
    StartActivity: undefined,
    StartCondition: undefined,
    State: undefined,
    tags: undefined
  };
  if (output.Activities !== undefined && output.Activities !== null) {
    contents.Activities = deserializeAws_restJson1_1MapOfActivity(
      output.Activities,
      context
    );
  }
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Limits !== undefined && output.Limits !== null) {
    contents.Limits = deserializeAws_restJson1_1JourneyLimits(
      output.Limits,
      context
    );
  }
  if (output.LocalTime !== undefined && output.LocalTime !== null) {
    contents.LocalTime = output.LocalTime;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.QuietTime !== undefined && output.QuietTime !== null) {
    contents.QuietTime = deserializeAws_restJson1_1QuietTime(
      output.QuietTime,
      context
    );
  }
  if (
    output.RefreshFrequency !== undefined &&
    output.RefreshFrequency !== null
  ) {
    contents.RefreshFrequency = output.RefreshFrequency;
  }
  if (output.Schedule !== undefined && output.Schedule !== null) {
    contents.Schedule = deserializeAws_restJson1_1JourneySchedule(
      output.Schedule,
      context
    );
  }
  if (output.StartActivity !== undefined && output.StartActivity !== null) {
    contents.StartActivity = output.StartActivity;
  }
  if (output.StartCondition !== undefined && output.StartCondition !== null) {
    contents.StartCondition = deserializeAws_restJson1_1StartCondition(
      output.StartCondition,
      context
    );
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = output.State;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1JourneySchedule = (
  output: any,
  context: __SerdeContext
): JourneySchedule => {
  let contents: any = {
    __type: "JourneySchedule",
    EndTime: undefined,
    StartTime: undefined,
    Timezone: undefined
  };
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(output.EndTime);
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(output.StartTime);
  }
  if (output.Timezone !== undefined && output.Timezone !== null) {
    contents.Timezone = output.Timezone;
  }
  return contents;
};

const deserializeAws_restJson1_1JourneysResponse = (
  output: any,
  context: __SerdeContext
): JourneysResponse => {
  let contents: any = {
    __type: "JourneysResponse",
    Item: undefined,
    NextToken: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfJourneyResponse(
      output.Item,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_restJson1_1ListOfActivityResponse = (
  output: any,
  context: __SerdeContext
): Array<ActivityResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ActivityResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfApplicationResponse = (
  output: any,
  context: __SerdeContext
): Array<ApplicationResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ApplicationResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfCampaignResponse = (
  output: any,
  context: __SerdeContext
): Array<CampaignResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1CampaignResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfEndpointResponse = (
  output: any,
  context: __SerdeContext
): Array<EndpointResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1EndpointResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfExportJobResponse = (
  output: any,
  context: __SerdeContext
): Array<ExportJobResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ExportJobResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfImportJobResponse = (
  output: any,
  context: __SerdeContext
): Array<ImportJobResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ImportJobResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfJourneyResponse = (
  output: any,
  context: __SerdeContext
): Array<JourneyResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1JourneyResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfMultiConditionalBranch = (
  output: any,
  context: __SerdeContext
): Array<MultiConditionalBranch> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1MultiConditionalBranch(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfRandomSplitEntry = (
  output: any,
  context: __SerdeContext
): Array<RandomSplitEntry> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1RandomSplitEntry(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfResultRow = (
  output: any,
  context: __SerdeContext
): Array<ResultRow> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ResultRow(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfResultRowValue = (
  output: any,
  context: __SerdeContext
): Array<ResultRowValue> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ResultRowValue(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfSegmentDimensions = (
  output: any,
  context: __SerdeContext
): Array<SegmentDimensions> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SegmentDimensions(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfSegmentGroup = (
  output: any,
  context: __SerdeContext
): Array<SegmentGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SegmentGroup(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfSegmentReference = (
  output: any,
  context: __SerdeContext
): Array<SegmentReference> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SegmentReference(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfSegmentResponse = (
  output: any,
  context: __SerdeContext
): Array<SegmentResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SegmentResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfSimpleCondition = (
  output: any,
  context: __SerdeContext
): Array<SimpleCondition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SimpleCondition(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfTemplateResponse = (
  output: any,
  context: __SerdeContext
): Array<TemplateResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TemplateResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfTemplateVersionResponse = (
  output: any,
  context: __SerdeContext
): Array<TemplateVersionResponse> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TemplateVersionResponse(entry, context)
  );
};

const deserializeAws_restJson1_1ListOfTreatmentResource = (
  output: any,
  context: __SerdeContext
): Array<TreatmentResource> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TreatmentResource(entry, context)
  );
};

const deserializeAws_restJson1_1ListOf__string = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1MapOfActivity = (
  output: any,
  context: __SerdeContext
): { [key: string]: Activity } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1Activity(output[key], context);
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOfAttributeDimension = (
  output: any,
  context: __SerdeContext
): { [key: string]: AttributeDimension } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1AttributeDimension(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOfChannelResponse = (
  output: any,
  context: __SerdeContext
): { [key: string]: ChannelResponse } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1ChannelResponse(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOfEndpointMessageResult = (
  output: any,
  context: __SerdeContext
): { [key: string]: EndpointMessageResult } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1EndpointMessageResult(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOfEventItemResponse = (
  output: any,
  context: __SerdeContext
): { [key: string]: EventItemResponse } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1EventItemResponse(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOfItemResponse = (
  output: any,
  context: __SerdeContext
): { [key: string]: ItemResponse } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1ItemResponse(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOfListOf__string = (
  output: any,
  context: __SerdeContext
): { [key: string]: Array<string> } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1ListOf__string(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOfMapOfEndpointMessageResult = (
  output: any,
  context: __SerdeContext
): { [key: string]: { [key: string]: EndpointMessageResult } } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1MapOfEndpointMessageResult(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOfMessageResult = (
  output: any,
  context: __SerdeContext
): { [key: string]: MessageResult } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1MessageResult(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOfMetricDimension = (
  output: any,
  context: __SerdeContext
): { [key: string]: MetricDimension } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1MetricDimension(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOf__double = (
  output: any,
  context: __SerdeContext
): { [key: string]: number } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOf__integer = (
  output: any,
  context: __SerdeContext
): { [key: string]: number } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1MapOf__string = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1Message = (
  output: any,
  context: __SerdeContext
): Message => {
  let contents: any = {
    __type: "Message",
    Action: undefined,
    Body: undefined,
    ImageIconUrl: undefined,
    ImageSmallIconUrl: undefined,
    ImageUrl: undefined,
    JsonBody: undefined,
    MediaUrl: undefined,
    RawContent: undefined,
    SilentPush: undefined,
    TimeToLive: undefined,
    Title: undefined,
    Url: undefined
  };
  if (output.Action !== undefined && output.Action !== null) {
    contents.Action = output.Action;
  }
  if (output.Body !== undefined && output.Body !== null) {
    contents.Body = output.Body;
  }
  if (output.ImageIconUrl !== undefined && output.ImageIconUrl !== null) {
    contents.ImageIconUrl = output.ImageIconUrl;
  }
  if (
    output.ImageSmallIconUrl !== undefined &&
    output.ImageSmallIconUrl !== null
  ) {
    contents.ImageSmallIconUrl = output.ImageSmallIconUrl;
  }
  if (output.ImageUrl !== undefined && output.ImageUrl !== null) {
    contents.ImageUrl = output.ImageUrl;
  }
  if (output.JsonBody !== undefined && output.JsonBody !== null) {
    contents.JsonBody = output.JsonBody;
  }
  if (output.MediaUrl !== undefined && output.MediaUrl !== null) {
    contents.MediaUrl = output.MediaUrl;
  }
  if (output.RawContent !== undefined && output.RawContent !== null) {
    contents.RawContent = output.RawContent;
  }
  if (output.SilentPush !== undefined && output.SilentPush !== null) {
    contents.SilentPush = output.SilentPush;
  }
  if (output.TimeToLive !== undefined && output.TimeToLive !== null) {
    contents.TimeToLive = output.TimeToLive;
  }
  if (output.Title !== undefined && output.Title !== null) {
    contents.Title = output.Title;
  }
  if (output.Url !== undefined && output.Url !== null) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_restJson1_1MessageBody = (
  output: any,
  context: __SerdeContext
): MessageBody => {
  let contents: any = {
    __type: "MessageBody",
    Message: undefined,
    RequestID: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.RequestID !== undefined && output.RequestID !== null) {
    contents.RequestID = output.RequestID;
  }
  return contents;
};

const deserializeAws_restJson1_1MessageConfiguration = (
  output: any,
  context: __SerdeContext
): MessageConfiguration => {
  let contents: any = {
    __type: "MessageConfiguration",
    ADMMessage: undefined,
    APNSMessage: undefined,
    BaiduMessage: undefined,
    DefaultMessage: undefined,
    EmailMessage: undefined,
    GCMMessage: undefined,
    SMSMessage: undefined
  };
  if (output.ADMMessage !== undefined && output.ADMMessage !== null) {
    contents.ADMMessage = deserializeAws_restJson1_1Message(
      output.ADMMessage,
      context
    );
  }
  if (output.APNSMessage !== undefined && output.APNSMessage !== null) {
    contents.APNSMessage = deserializeAws_restJson1_1Message(
      output.APNSMessage,
      context
    );
  }
  if (output.BaiduMessage !== undefined && output.BaiduMessage !== null) {
    contents.BaiduMessage = deserializeAws_restJson1_1Message(
      output.BaiduMessage,
      context
    );
  }
  if (output.DefaultMessage !== undefined && output.DefaultMessage !== null) {
    contents.DefaultMessage = deserializeAws_restJson1_1Message(
      output.DefaultMessage,
      context
    );
  }
  if (output.EmailMessage !== undefined && output.EmailMessage !== null) {
    contents.EmailMessage = deserializeAws_restJson1_1CampaignEmailMessage(
      output.EmailMessage,
      context
    );
  }
  if (output.GCMMessage !== undefined && output.GCMMessage !== null) {
    contents.GCMMessage = deserializeAws_restJson1_1Message(
      output.GCMMessage,
      context
    );
  }
  if (output.SMSMessage !== undefined && output.SMSMessage !== null) {
    contents.SMSMessage = deserializeAws_restJson1_1CampaignSmsMessage(
      output.SMSMessage,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1MessageResponse = (
  output: any,
  context: __SerdeContext
): MessageResponse => {
  let contents: any = {
    __type: "MessageResponse",
    ApplicationId: undefined,
    EndpointResult: undefined,
    RequestId: undefined,
    Result: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.EndpointResult !== undefined && output.EndpointResult !== null) {
    contents.EndpointResult = deserializeAws_restJson1_1MapOfEndpointMessageResult(
      output.EndpointResult,
      context
    );
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  if (output.Result !== undefined && output.Result !== null) {
    contents.Result = deserializeAws_restJson1_1MapOfMessageResult(
      output.Result,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1MessageResult = (
  output: any,
  context: __SerdeContext
): MessageResult => {
  let contents: any = {
    __type: "MessageResult",
    DeliveryStatus: undefined,
    MessageId: undefined,
    StatusCode: undefined,
    StatusMessage: undefined,
    UpdatedToken: undefined
  };
  if (output.DeliveryStatus !== undefined && output.DeliveryStatus !== null) {
    contents.DeliveryStatus = output.DeliveryStatus;
  }
  if (output.MessageId !== undefined && output.MessageId !== null) {
    contents.MessageId = output.MessageId;
  }
  if (output.StatusCode !== undefined && output.StatusCode !== null) {
    contents.StatusCode = output.StatusCode;
  }
  if (output.StatusMessage !== undefined && output.StatusMessage !== null) {
    contents.StatusMessage = output.StatusMessage;
  }
  if (output.UpdatedToken !== undefined && output.UpdatedToken !== null) {
    contents.UpdatedToken = output.UpdatedToken;
  }
  return contents;
};

const deserializeAws_restJson1_1MetricDimension = (
  output: any,
  context: __SerdeContext
): MetricDimension => {
  let contents: any = {
    __type: "MetricDimension",
    ComparisonOperator: undefined,
    Value: undefined
  };
  if (
    output.ComparisonOperator !== undefined &&
    output.ComparisonOperator !== null
  ) {
    contents.ComparisonOperator = output.ComparisonOperator;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_restJson1_1MultiConditionalBranch = (
  output: any,
  context: __SerdeContext
): MultiConditionalBranch => {
  let contents: any = {
    __type: "MultiConditionalBranch",
    Condition: undefined,
    NextActivity: undefined
  };
  if (output.Condition !== undefined && output.Condition !== null) {
    contents.Condition = deserializeAws_restJson1_1SimpleCondition(
      output.Condition,
      context
    );
  }
  if (output.NextActivity !== undefined && output.NextActivity !== null) {
    contents.NextActivity = output.NextActivity;
  }
  return contents;
};

const deserializeAws_restJson1_1MultiConditionalSplitActivity = (
  output: any,
  context: __SerdeContext
): MultiConditionalSplitActivity => {
  let contents: any = {
    __type: "MultiConditionalSplitActivity",
    Branches: undefined,
    DefaultActivity: undefined,
    EvaluationWaitTime: undefined
  };
  if (output.Branches !== undefined && output.Branches !== null) {
    contents.Branches = deserializeAws_restJson1_1ListOfMultiConditionalBranch(
      output.Branches,
      context
    );
  }
  if (output.DefaultActivity !== undefined && output.DefaultActivity !== null) {
    contents.DefaultActivity = output.DefaultActivity;
  }
  if (
    output.EvaluationWaitTime !== undefined &&
    output.EvaluationWaitTime !== null
  ) {
    contents.EvaluationWaitTime = deserializeAws_restJson1_1WaitTime(
      output.EvaluationWaitTime,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1NumberValidateResponse = (
  output: any,
  context: __SerdeContext
): NumberValidateResponse => {
  let contents: any = {
    __type: "NumberValidateResponse",
    Carrier: undefined,
    City: undefined,
    CleansedPhoneNumberE164: undefined,
    CleansedPhoneNumberNational: undefined,
    Country: undefined,
    CountryCodeIso2: undefined,
    CountryCodeNumeric: undefined,
    County: undefined,
    OriginalCountryCodeIso2: undefined,
    OriginalPhoneNumber: undefined,
    PhoneType: undefined,
    PhoneTypeCode: undefined,
    Timezone: undefined,
    ZipCode: undefined
  };
  if (output.Carrier !== undefined && output.Carrier !== null) {
    contents.Carrier = output.Carrier;
  }
  if (output.City !== undefined && output.City !== null) {
    contents.City = output.City;
  }
  if (
    output.CleansedPhoneNumberE164 !== undefined &&
    output.CleansedPhoneNumberE164 !== null
  ) {
    contents.CleansedPhoneNumberE164 = output.CleansedPhoneNumberE164;
  }
  if (
    output.CleansedPhoneNumberNational !== undefined &&
    output.CleansedPhoneNumberNational !== null
  ) {
    contents.CleansedPhoneNumberNational = output.CleansedPhoneNumberNational;
  }
  if (output.Country !== undefined && output.Country !== null) {
    contents.Country = output.Country;
  }
  if (output.CountryCodeIso2 !== undefined && output.CountryCodeIso2 !== null) {
    contents.CountryCodeIso2 = output.CountryCodeIso2;
  }
  if (
    output.CountryCodeNumeric !== undefined &&
    output.CountryCodeNumeric !== null
  ) {
    contents.CountryCodeNumeric = output.CountryCodeNumeric;
  }
  if (output.County !== undefined && output.County !== null) {
    contents.County = output.County;
  }
  if (
    output.OriginalCountryCodeIso2 !== undefined &&
    output.OriginalCountryCodeIso2 !== null
  ) {
    contents.OriginalCountryCodeIso2 = output.OriginalCountryCodeIso2;
  }
  if (
    output.OriginalPhoneNumber !== undefined &&
    output.OriginalPhoneNumber !== null
  ) {
    contents.OriginalPhoneNumber = output.OriginalPhoneNumber;
  }
  if (output.PhoneType !== undefined && output.PhoneType !== null) {
    contents.PhoneType = output.PhoneType;
  }
  if (output.PhoneTypeCode !== undefined && output.PhoneTypeCode !== null) {
    contents.PhoneTypeCode = output.PhoneTypeCode;
  }
  if (output.Timezone !== undefined && output.Timezone !== null) {
    contents.Timezone = output.Timezone;
  }
  if (output.ZipCode !== undefined && output.ZipCode !== null) {
    contents.ZipCode = output.ZipCode;
  }
  return contents;
};

const deserializeAws_restJson1_1PushNotificationTemplateResponse = (
  output: any,
  context: __SerdeContext
): PushNotificationTemplateResponse => {
  let contents: any = {
    __type: "PushNotificationTemplateResponse",
    ADM: undefined,
    APNS: undefined,
    Arn: undefined,
    Baidu: undefined,
    CreationDate: undefined,
    Default: undefined,
    DefaultSubstitutions: undefined,
    GCM: undefined,
    LastModifiedDate: undefined,
    TemplateDescription: undefined,
    TemplateName: undefined,
    TemplateType: undefined,
    Version: undefined,
    tags: undefined
  };
  if (output.ADM !== undefined && output.ADM !== null) {
    contents.ADM = deserializeAws_restJson1_1AndroidPushNotificationTemplate(
      output.ADM,
      context
    );
  }
  if (output.APNS !== undefined && output.APNS !== null) {
    contents.APNS = deserializeAws_restJson1_1APNSPushNotificationTemplate(
      output.APNS,
      context
    );
  }
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Baidu !== undefined && output.Baidu !== null) {
    contents.Baidu = deserializeAws_restJson1_1AndroidPushNotificationTemplate(
      output.Baidu,
      context
    );
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Default !== undefined && output.Default !== null) {
    contents.Default = deserializeAws_restJson1_1DefaultPushNotificationTemplate(
      output.Default,
      context
    );
  }
  if (
    output.DefaultSubstitutions !== undefined &&
    output.DefaultSubstitutions !== null
  ) {
    contents.DefaultSubstitutions = output.DefaultSubstitutions;
  }
  if (output.GCM !== undefined && output.GCM !== null) {
    contents.GCM = deserializeAws_restJson1_1AndroidPushNotificationTemplate(
      output.GCM,
      context
    );
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (
    output.TemplateDescription !== undefined &&
    output.TemplateDescription !== null
  ) {
    contents.TemplateDescription = output.TemplateDescription;
  }
  if (output.TemplateName !== undefined && output.TemplateName !== null) {
    contents.TemplateName = output.TemplateName;
  }
  if (output.TemplateType !== undefined && output.TemplateType !== null) {
    contents.TemplateType = output.TemplateType;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1QuietTime = (
  output: any,
  context: __SerdeContext
): QuietTime => {
  let contents: any = {
    __type: "QuietTime",
    End: undefined,
    Start: undefined
  };
  if (output.End !== undefined && output.End !== null) {
    contents.End = output.End;
  }
  if (output.Start !== undefined && output.Start !== null) {
    contents.Start = output.Start;
  }
  return contents;
};

const deserializeAws_restJson1_1RandomSplitActivity = (
  output: any,
  context: __SerdeContext
): RandomSplitActivity => {
  let contents: any = {
    __type: "RandomSplitActivity",
    Branches: undefined
  };
  if (output.Branches !== undefined && output.Branches !== null) {
    contents.Branches = deserializeAws_restJson1_1ListOfRandomSplitEntry(
      output.Branches,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1RandomSplitEntry = (
  output: any,
  context: __SerdeContext
): RandomSplitEntry => {
  let contents: any = {
    __type: "RandomSplitEntry",
    NextActivity: undefined,
    Percentage: undefined
  };
  if (output.NextActivity !== undefined && output.NextActivity !== null) {
    contents.NextActivity = output.NextActivity;
  }
  if (output.Percentage !== undefined && output.Percentage !== null) {
    contents.Percentage = output.Percentage;
  }
  return contents;
};

const deserializeAws_restJson1_1RecencyDimension = (
  output: any,
  context: __SerdeContext
): RecencyDimension => {
  let contents: any = {
    __type: "RecencyDimension",
    Duration: undefined,
    RecencyType: undefined
  };
  if (output.Duration !== undefined && output.Duration !== null) {
    contents.Duration = output.Duration;
  }
  if (output.RecencyType !== undefined && output.RecencyType !== null) {
    contents.RecencyType = output.RecencyType;
  }
  return contents;
};

const deserializeAws_restJson1_1ResultRow = (
  output: any,
  context: __SerdeContext
): ResultRow => {
  let contents: any = {
    __type: "ResultRow",
    GroupedBys: undefined,
    Values: undefined
  };
  if (output.GroupedBys !== undefined && output.GroupedBys !== null) {
    contents.GroupedBys = deserializeAws_restJson1_1ListOfResultRowValue(
      output.GroupedBys,
      context
    );
  }
  if (output.Values !== undefined && output.Values !== null) {
    contents.Values = deserializeAws_restJson1_1ListOfResultRowValue(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ResultRowValue = (
  output: any,
  context: __SerdeContext
): ResultRowValue => {
  let contents: any = {
    __type: "ResultRowValue",
    Key: undefined,
    Type: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_restJson1_1SMSChannelResponse = (
  output: any,
  context: __SerdeContext
): SMSChannelResponse => {
  let contents: any = {
    __type: "SMSChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Platform: undefined,
    PromotionalMessagesPerSecond: undefined,
    SenderId: undefined,
    ShortCode: undefined,
    TransactionalMessagesPerSecond: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (
    output.PromotionalMessagesPerSecond !== undefined &&
    output.PromotionalMessagesPerSecond !== null
  ) {
    contents.PromotionalMessagesPerSecond = output.PromotionalMessagesPerSecond;
  }
  if (output.SenderId !== undefined && output.SenderId !== null) {
    contents.SenderId = output.SenderId;
  }
  if (output.ShortCode !== undefined && output.ShortCode !== null) {
    contents.ShortCode = output.ShortCode;
  }
  if (
    output.TransactionalMessagesPerSecond !== undefined &&
    output.TransactionalMessagesPerSecond !== null
  ) {
    contents.TransactionalMessagesPerSecond =
      output.TransactionalMessagesPerSecond;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1SMSTemplateResponse = (
  output: any,
  context: __SerdeContext
): SMSTemplateResponse => {
  let contents: any = {
    __type: "SMSTemplateResponse",
    Arn: undefined,
    Body: undefined,
    CreationDate: undefined,
    DefaultSubstitutions: undefined,
    LastModifiedDate: undefined,
    TemplateDescription: undefined,
    TemplateName: undefined,
    TemplateType: undefined,
    Version: undefined,
    tags: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Body !== undefined && output.Body !== null) {
    contents.Body = output.Body;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (
    output.DefaultSubstitutions !== undefined &&
    output.DefaultSubstitutions !== null
  ) {
    contents.DefaultSubstitutions = output.DefaultSubstitutions;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (
    output.TemplateDescription !== undefined &&
    output.TemplateDescription !== null
  ) {
    contents.TemplateDescription = output.TemplateDescription;
  }
  if (output.TemplateName !== undefined && output.TemplateName !== null) {
    contents.TemplateName = output.TemplateName;
  }
  if (output.TemplateType !== undefined && output.TemplateType !== null) {
    contents.TemplateType = output.TemplateType;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Schedule = (
  output: any,
  context: __SerdeContext
): Schedule => {
  let contents: any = {
    __type: "Schedule",
    EndTime: undefined,
    EventFilter: undefined,
    Frequency: undefined,
    IsLocalTime: undefined,
    QuietTime: undefined,
    StartTime: undefined,
    Timezone: undefined
  };
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = output.EndTime;
  }
  if (output.EventFilter !== undefined && output.EventFilter !== null) {
    contents.EventFilter = deserializeAws_restJson1_1CampaignEventFilter(
      output.EventFilter,
      context
    );
  }
  if (output.Frequency !== undefined && output.Frequency !== null) {
    contents.Frequency = output.Frequency;
  }
  if (output.IsLocalTime !== undefined && output.IsLocalTime !== null) {
    contents.IsLocalTime = output.IsLocalTime;
  }
  if (output.QuietTime !== undefined && output.QuietTime !== null) {
    contents.QuietTime = deserializeAws_restJson1_1QuietTime(
      output.QuietTime,
      context
    );
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = output.StartTime;
  }
  if (output.Timezone !== undefined && output.Timezone !== null) {
    contents.Timezone = output.Timezone;
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentBehaviors = (
  output: any,
  context: __SerdeContext
): SegmentBehaviors => {
  let contents: any = {
    __type: "SegmentBehaviors",
    Recency: undefined
  };
  if (output.Recency !== undefined && output.Recency !== null) {
    contents.Recency = deserializeAws_restJson1_1RecencyDimension(
      output.Recency,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentCondition = (
  output: any,
  context: __SerdeContext
): SegmentCondition => {
  let contents: any = {
    __type: "SegmentCondition",
    SegmentId: undefined
  };
  if (output.SegmentId !== undefined && output.SegmentId !== null) {
    contents.SegmentId = output.SegmentId;
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentDemographics = (
  output: any,
  context: __SerdeContext
): SegmentDemographics => {
  let contents: any = {
    __type: "SegmentDemographics",
    AppVersion: undefined,
    Channel: undefined,
    DeviceType: undefined,
    Make: undefined,
    Model: undefined,
    Platform: undefined
  };
  if (output.AppVersion !== undefined && output.AppVersion !== null) {
    contents.AppVersion = deserializeAws_restJson1_1SetDimension(
      output.AppVersion,
      context
    );
  }
  if (output.Channel !== undefined && output.Channel !== null) {
    contents.Channel = deserializeAws_restJson1_1SetDimension(
      output.Channel,
      context
    );
  }
  if (output.DeviceType !== undefined && output.DeviceType !== null) {
    contents.DeviceType = deserializeAws_restJson1_1SetDimension(
      output.DeviceType,
      context
    );
  }
  if (output.Make !== undefined && output.Make !== null) {
    contents.Make = deserializeAws_restJson1_1SetDimension(
      output.Make,
      context
    );
  }
  if (output.Model !== undefined && output.Model !== null) {
    contents.Model = deserializeAws_restJson1_1SetDimension(
      output.Model,
      context
    );
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = deserializeAws_restJson1_1SetDimension(
      output.Platform,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentDimensions = (
  output: any,
  context: __SerdeContext
): SegmentDimensions => {
  let contents: any = {
    __type: "SegmentDimensions",
    Attributes: undefined,
    Behavior: undefined,
    Demographic: undefined,
    Location: undefined,
    Metrics: undefined,
    UserAttributes: undefined
  };
  if (output.Attributes !== undefined && output.Attributes !== null) {
    contents.Attributes = deserializeAws_restJson1_1MapOfAttributeDimension(
      output.Attributes,
      context
    );
  }
  if (output.Behavior !== undefined && output.Behavior !== null) {
    contents.Behavior = deserializeAws_restJson1_1SegmentBehaviors(
      output.Behavior,
      context
    );
  }
  if (output.Demographic !== undefined && output.Demographic !== null) {
    contents.Demographic = deserializeAws_restJson1_1SegmentDemographics(
      output.Demographic,
      context
    );
  }
  if (output.Location !== undefined && output.Location !== null) {
    contents.Location = deserializeAws_restJson1_1SegmentLocation(
      output.Location,
      context
    );
  }
  if (output.Metrics !== undefined && output.Metrics !== null) {
    contents.Metrics = deserializeAws_restJson1_1MapOfMetricDimension(
      output.Metrics,
      context
    );
  }
  if (output.UserAttributes !== undefined && output.UserAttributes !== null) {
    contents.UserAttributes = deserializeAws_restJson1_1MapOfAttributeDimension(
      output.UserAttributes,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentGroup = (
  output: any,
  context: __SerdeContext
): SegmentGroup => {
  let contents: any = {
    __type: "SegmentGroup",
    Dimensions: undefined,
    SourceSegments: undefined,
    SourceType: undefined,
    Type: undefined
  };
  if (output.Dimensions !== undefined && output.Dimensions !== null) {
    contents.Dimensions = deserializeAws_restJson1_1ListOfSegmentDimensions(
      output.Dimensions,
      context
    );
  }
  if (output.SourceSegments !== undefined && output.SourceSegments !== null) {
    contents.SourceSegments = deserializeAws_restJson1_1ListOfSegmentReference(
      output.SourceSegments,
      context
    );
  }
  if (output.SourceType !== undefined && output.SourceType !== null) {
    contents.SourceType = output.SourceType;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentGroupList = (
  output: any,
  context: __SerdeContext
): SegmentGroupList => {
  let contents: any = {
    __type: "SegmentGroupList",
    Groups: undefined,
    Include: undefined
  };
  if (output.Groups !== undefined && output.Groups !== null) {
    contents.Groups = deserializeAws_restJson1_1ListOfSegmentGroup(
      output.Groups,
      context
    );
  }
  if (output.Include !== undefined && output.Include !== null) {
    contents.Include = output.Include;
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentImportResource = (
  output: any,
  context: __SerdeContext
): SegmentImportResource => {
  let contents: any = {
    __type: "SegmentImportResource",
    ChannelCounts: undefined,
    ExternalId: undefined,
    Format: undefined,
    RoleArn: undefined,
    S3Url: undefined,
    Size: undefined
  };
  if (output.ChannelCounts !== undefined && output.ChannelCounts !== null) {
    contents.ChannelCounts = deserializeAws_restJson1_1MapOf__integer(
      output.ChannelCounts,
      context
    );
  }
  if (output.ExternalId !== undefined && output.ExternalId !== null) {
    contents.ExternalId = output.ExternalId;
  }
  if (output.Format !== undefined && output.Format !== null) {
    contents.Format = output.Format;
  }
  if (output.RoleArn !== undefined && output.RoleArn !== null) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.S3Url !== undefined && output.S3Url !== null) {
    contents.S3Url = output.S3Url;
  }
  if (output.Size !== undefined && output.Size !== null) {
    contents.Size = output.Size;
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentLocation = (
  output: any,
  context: __SerdeContext
): SegmentLocation => {
  let contents: any = {
    __type: "SegmentLocation",
    Country: undefined,
    GPSPoint: undefined
  };
  if (output.Country !== undefined && output.Country !== null) {
    contents.Country = deserializeAws_restJson1_1SetDimension(
      output.Country,
      context
    );
  }
  if (output.GPSPoint !== undefined && output.GPSPoint !== null) {
    contents.GPSPoint = deserializeAws_restJson1_1GPSPointDimension(
      output.GPSPoint,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentReference = (
  output: any,
  context: __SerdeContext
): SegmentReference => {
  let contents: any = {
    __type: "SegmentReference",
    Id: undefined,
    Version: undefined
  };
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentResponse = (
  output: any,
  context: __SerdeContext
): SegmentResponse => {
  let contents: any = {
    __type: "SegmentResponse",
    ApplicationId: undefined,
    Arn: undefined,
    CreationDate: undefined,
    Dimensions: undefined,
    Id: undefined,
    ImportDefinition: undefined,
    LastModifiedDate: undefined,
    Name: undefined,
    SegmentGroups: undefined,
    SegmentType: undefined,
    Version: undefined,
    tags: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Dimensions !== undefined && output.Dimensions !== null) {
    contents.Dimensions = deserializeAws_restJson1_1SegmentDimensions(
      output.Dimensions,
      context
    );
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (
    output.ImportDefinition !== undefined &&
    output.ImportDefinition !== null
  ) {
    contents.ImportDefinition = deserializeAws_restJson1_1SegmentImportResource(
      output.ImportDefinition,
      context
    );
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.SegmentGroups !== undefined && output.SegmentGroups !== null) {
    contents.SegmentGroups = deserializeAws_restJson1_1SegmentGroupList(
      output.SegmentGroups,
      context
    );
  }
  if (output.SegmentType !== undefined && output.SegmentType !== null) {
    contents.SegmentType = output.SegmentType;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1SegmentsResponse = (
  output: any,
  context: __SerdeContext
): SegmentsResponse => {
  let contents: any = {
    __type: "SegmentsResponse",
    Item: undefined,
    NextToken: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfSegmentResponse(
      output.Item,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_restJson1_1SendUsersMessageResponse = (
  output: any,
  context: __SerdeContext
): SendUsersMessageResponse => {
  let contents: any = {
    __type: "SendUsersMessageResponse",
    ApplicationId: undefined,
    RequestId: undefined,
    Result: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.RequestId !== undefined && output.RequestId !== null) {
    contents.RequestId = output.RequestId;
  }
  if (output.Result !== undefined && output.Result !== null) {
    contents.Result = deserializeAws_restJson1_1MapOfMapOfEndpointMessageResult(
      output.Result,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1SetDimension = (
  output: any,
  context: __SerdeContext
): SetDimension => {
  let contents: any = {
    __type: "SetDimension",
    DimensionType: undefined,
    Values: undefined
  };
  if (output.DimensionType !== undefined && output.DimensionType !== null) {
    contents.DimensionType = output.DimensionType;
  }
  if (output.Values !== undefined && output.Values !== null) {
    contents.Values = deserializeAws_restJson1_1ListOf__string(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1SimpleCondition = (
  output: any,
  context: __SerdeContext
): SimpleCondition => {
  let contents: any = {
    __type: "SimpleCondition",
    EventCondition: undefined,
    SegmentCondition: undefined,
    SegmentDimensions: undefined
  };
  if (output.EventCondition !== undefined && output.EventCondition !== null) {
    contents.EventCondition = deserializeAws_restJson1_1EventCondition(
      output.EventCondition,
      context
    );
  }
  if (
    output.SegmentCondition !== undefined &&
    output.SegmentCondition !== null
  ) {
    contents.SegmentCondition = deserializeAws_restJson1_1SegmentCondition(
      output.SegmentCondition,
      context
    );
  }
  if (
    output.segmentDimensions !== undefined &&
    output.segmentDimensions !== null
  ) {
    contents.SegmentDimensions = deserializeAws_restJson1_1SegmentDimensions(
      output.segmentDimensions,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1StartCondition = (
  output: any,
  context: __SerdeContext
): StartCondition => {
  let contents: any = {
    __type: "StartCondition",
    Description: undefined,
    SegmentStartCondition: undefined
  };
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (
    output.SegmentStartCondition !== undefined &&
    output.SegmentStartCondition !== null
  ) {
    contents.SegmentStartCondition = deserializeAws_restJson1_1SegmentCondition(
      output.SegmentStartCondition,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1TagsModel = (
  output: any,
  context: __SerdeContext
): TagsModel => {
  let contents: any = {
    __type: "TagsModel",
    tags: undefined
  };
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Template = (
  output: any,
  context: __SerdeContext
): Template => {
  let contents: any = {
    __type: "Template",
    Name: undefined,
    Version: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateConfiguration = (
  output: any,
  context: __SerdeContext
): TemplateConfiguration => {
  let contents: any = {
    __type: "TemplateConfiguration",
    EmailTemplate: undefined,
    PushTemplate: undefined,
    SMSTemplate: undefined,
    VoiceTemplate: undefined
  };
  if (output.EmailTemplate !== undefined && output.EmailTemplate !== null) {
    contents.EmailTemplate = deserializeAws_restJson1_1Template(
      output.EmailTemplate,
      context
    );
  }
  if (output.PushTemplate !== undefined && output.PushTemplate !== null) {
    contents.PushTemplate = deserializeAws_restJson1_1Template(
      output.PushTemplate,
      context
    );
  }
  if (output.SMSTemplate !== undefined && output.SMSTemplate !== null) {
    contents.SMSTemplate = deserializeAws_restJson1_1Template(
      output.SMSTemplate,
      context
    );
  }
  if (output.VoiceTemplate !== undefined && output.VoiceTemplate !== null) {
    contents.VoiceTemplate = deserializeAws_restJson1_1Template(
      output.VoiceTemplate,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateResponse = (
  output: any,
  context: __SerdeContext
): TemplateResponse => {
  let contents: any = {
    __type: "TemplateResponse",
    Arn: undefined,
    CreationDate: undefined,
    DefaultSubstitutions: undefined,
    LastModifiedDate: undefined,
    TemplateDescription: undefined,
    TemplateName: undefined,
    TemplateType: undefined,
    Version: undefined,
    tags: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (
    output.DefaultSubstitutions !== undefined &&
    output.DefaultSubstitutions !== null
  ) {
    contents.DefaultSubstitutions = output.DefaultSubstitutions;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (
    output.TemplateDescription !== undefined &&
    output.TemplateDescription !== null
  ) {
    contents.TemplateDescription = output.TemplateDescription;
  }
  if (output.TemplateName !== undefined && output.TemplateName !== null) {
    contents.TemplateName = output.TemplateName;
  }
  if (output.TemplateType !== undefined && output.TemplateType !== null) {
    contents.TemplateType = output.TemplateType;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateVersionResponse = (
  output: any,
  context: __SerdeContext
): TemplateVersionResponse => {
  let contents: any = {
    __type: "TemplateVersionResponse",
    CreationDate: undefined,
    DefaultSubstitutions: undefined,
    LastModifiedDate: undefined,
    TemplateDescription: undefined,
    TemplateName: undefined,
    TemplateType: undefined,
    Version: undefined
  };
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (
    output.DefaultSubstitutions !== undefined &&
    output.DefaultSubstitutions !== null
  ) {
    contents.DefaultSubstitutions = output.DefaultSubstitutions;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (
    output.TemplateDescription !== undefined &&
    output.TemplateDescription !== null
  ) {
    contents.TemplateDescription = output.TemplateDescription;
  }
  if (output.TemplateName !== undefined && output.TemplateName !== null) {
    contents.TemplateName = output.TemplateName;
  }
  if (output.TemplateType !== undefined && output.TemplateType !== null) {
    contents.TemplateType = output.TemplateType;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateVersionsResponse = (
  output: any,
  context: __SerdeContext
): TemplateVersionsResponse => {
  let contents: any = {
    __type: "TemplateVersionsResponse",
    Item: undefined,
    Message: undefined,
    NextToken: undefined,
    RequestID: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfTemplateVersionResponse(
      output.Item,
      context
    );
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.RequestID !== undefined && output.RequestID !== null) {
    contents.RequestID = output.RequestID;
  }
  return contents;
};

const deserializeAws_restJson1_1TemplatesResponse = (
  output: any,
  context: __SerdeContext
): TemplatesResponse => {
  let contents: any = {
    __type: "TemplatesResponse",
    Item: undefined,
    NextToken: undefined
  };
  if (output.Item !== undefined && output.Item !== null) {
    contents.Item = deserializeAws_restJson1_1ListOfTemplateResponse(
      output.Item,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_restJson1_1TreatmentResource = (
  output: any,
  context: __SerdeContext
): TreatmentResource => {
  let contents: any = {
    __type: "TreatmentResource",
    Id: undefined,
    MessageConfiguration: undefined,
    Schedule: undefined,
    SizePercent: undefined,
    State: undefined,
    TemplateConfiguration: undefined,
    TreatmentDescription: undefined,
    TreatmentName: undefined
  };
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (
    output.MessageConfiguration !== undefined &&
    output.MessageConfiguration !== null
  ) {
    contents.MessageConfiguration = deserializeAws_restJson1_1MessageConfiguration(
      output.MessageConfiguration,
      context
    );
  }
  if (output.Schedule !== undefined && output.Schedule !== null) {
    contents.Schedule = deserializeAws_restJson1_1Schedule(
      output.Schedule,
      context
    );
  }
  if (output.SizePercent !== undefined && output.SizePercent !== null) {
    contents.SizePercent = output.SizePercent;
  }
  if (output.State !== undefined && output.State !== null) {
    contents.State = deserializeAws_restJson1_1CampaignState(
      output.State,
      context
    );
  }
  if (
    output.TemplateConfiguration !== undefined &&
    output.TemplateConfiguration !== null
  ) {
    contents.TemplateConfiguration = deserializeAws_restJson1_1TemplateConfiguration(
      output.TemplateConfiguration,
      context
    );
  }
  if (
    output.TreatmentDescription !== undefined &&
    output.TreatmentDescription !== null
  ) {
    contents.TreatmentDescription = output.TreatmentDescription;
  }
  if (output.TreatmentName !== undefined && output.TreatmentName !== null) {
    contents.TreatmentName = output.TreatmentName;
  }
  return contents;
};

const deserializeAws_restJson1_1VoiceChannelResponse = (
  output: any,
  context: __SerdeContext
): VoiceChannelResponse => {
  let contents: any = {
    __type: "VoiceChannelResponse",
    ApplicationId: undefined,
    CreationDate: undefined,
    Enabled: undefined,
    HasCredential: undefined,
    Id: undefined,
    IsArchived: undefined,
    LastModifiedBy: undefined,
    LastModifiedDate: undefined,
    Platform: undefined,
    Version: undefined
  };
  if (output.ApplicationId !== undefined && output.ApplicationId !== null) {
    contents.ApplicationId = output.ApplicationId;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (output.HasCredential !== undefined && output.HasCredential !== null) {
    contents.HasCredential = output.HasCredential;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.IsArchived !== undefined && output.IsArchived !== null) {
    contents.IsArchived = output.IsArchived;
  }
  if (output.LastModifiedBy !== undefined && output.LastModifiedBy !== null) {
    contents.LastModifiedBy = output.LastModifiedBy;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (output.Platform !== undefined && output.Platform !== null) {
    contents.Platform = output.Platform;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1VoiceTemplateResponse = (
  output: any,
  context: __SerdeContext
): VoiceTemplateResponse => {
  let contents: any = {
    __type: "VoiceTemplateResponse",
    Arn: undefined,
    Body: undefined,
    CreationDate: undefined,
    DefaultSubstitutions: undefined,
    LanguageCode: undefined,
    LastModifiedDate: undefined,
    TemplateDescription: undefined,
    TemplateName: undefined,
    TemplateType: undefined,
    Version: undefined,
    VoiceId: undefined,
    tags: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Body !== undefined && output.Body !== null) {
    contents.Body = output.Body;
  }
  if (output.CreationDate !== undefined && output.CreationDate !== null) {
    contents.CreationDate = output.CreationDate;
  }
  if (
    output.DefaultSubstitutions !== undefined &&
    output.DefaultSubstitutions !== null
  ) {
    contents.DefaultSubstitutions = output.DefaultSubstitutions;
  }
  if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (
    output.LastModifiedDate !== undefined &&
    output.LastModifiedDate !== null
  ) {
    contents.LastModifiedDate = output.LastModifiedDate;
  }
  if (
    output.TemplateDescription !== undefined &&
    output.TemplateDescription !== null
  ) {
    contents.TemplateDescription = output.TemplateDescription;
  }
  if (output.TemplateName !== undefined && output.TemplateName !== null) {
    contents.TemplateName = output.TemplateName;
  }
  if (output.TemplateType !== undefined && output.TemplateType !== null) {
    contents.TemplateType = output.TemplateType;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  if (output.VoiceId !== undefined && output.VoiceId !== null) {
    contents.VoiceId = output.VoiceId;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_restJson1_1MapOf__string(
      output.tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1WaitActivity = (
  output: any,
  context: __SerdeContext
): WaitActivity => {
  let contents: any = {
    __type: "WaitActivity",
    NextActivity: undefined,
    WaitTime: undefined
  };
  if (output.NextActivity !== undefined && output.NextActivity !== null) {
    contents.NextActivity = output.NextActivity;
  }
  if (output.WaitTime !== undefined && output.WaitTime !== null) {
    contents.WaitTime = deserializeAws_restJson1_1WaitTime(
      output.WaitTime,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1WaitTime = (
  output: any,
  context: __SerdeContext
): WaitTime => {
  let contents: any = {
    __type: "WaitTime",
    WaitFor: undefined,
    WaitUntil: undefined
  };
  if (output.WaitFor !== undefined && output.WaitFor !== null) {
    contents.WaitFor = output.WaitFor;
  }
  if (output.WaitUntil !== undefined && output.WaitUntil !== null) {
    contents.WaitUntil = output.WaitUntil;
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};

/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output: __HttpResponse, data: any): string => {
  const findKey = (object: any, key: string) =>
    Object.keys(object).find(k => k.toLowerCase() === key.toLowerCase());

  const sanitizeErrorCode = (rawValue: string): string => {
    let cleanValue = rawValue;
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };

  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== undefined) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }

  if (data.code !== undefined) {
    return sanitizeErrorCode(data.code);
  }

  if (data["__type"] !== undefined) {
    return sanitizeErrorCode(data["__type"]);
  }

  return "";
};
