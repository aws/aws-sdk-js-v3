import {
  BatchDetectDominantLanguageCommandInput,
  BatchDetectDominantLanguageCommandOutput
} from "../commands/BatchDetectDominantLanguageCommand";
import {
  BatchDetectEntitiesCommandInput,
  BatchDetectEntitiesCommandOutput
} from "../commands/BatchDetectEntitiesCommand";
import {
  BatchDetectKeyPhrasesCommandInput,
  BatchDetectKeyPhrasesCommandOutput
} from "../commands/BatchDetectKeyPhrasesCommand";
import {
  BatchDetectSentimentCommandInput,
  BatchDetectSentimentCommandOutput
} from "../commands/BatchDetectSentimentCommand";
import {
  BatchDetectSyntaxCommandInput,
  BatchDetectSyntaxCommandOutput
} from "../commands/BatchDetectSyntaxCommand";
import {
  ClassifyDocumentCommandInput,
  ClassifyDocumentCommandOutput
} from "../commands/ClassifyDocumentCommand";
import {
  CreateDocumentClassifierCommandInput,
  CreateDocumentClassifierCommandOutput
} from "../commands/CreateDocumentClassifierCommand";
import {
  CreateEndpointCommandInput,
  CreateEndpointCommandOutput
} from "../commands/CreateEndpointCommand";
import {
  CreateEntityRecognizerCommandInput,
  CreateEntityRecognizerCommandOutput
} from "../commands/CreateEntityRecognizerCommand";
import {
  DeleteDocumentClassifierCommandInput,
  DeleteDocumentClassifierCommandOutput
} from "../commands/DeleteDocumentClassifierCommand";
import {
  DeleteEndpointCommandInput,
  DeleteEndpointCommandOutput
} from "../commands/DeleteEndpointCommand";
import {
  DeleteEntityRecognizerCommandInput,
  DeleteEntityRecognizerCommandOutput
} from "../commands/DeleteEntityRecognizerCommand";
import {
  DescribeDocumentClassificationJobCommandInput,
  DescribeDocumentClassificationJobCommandOutput
} from "../commands/DescribeDocumentClassificationJobCommand";
import {
  DescribeDocumentClassifierCommandInput,
  DescribeDocumentClassifierCommandOutput
} from "../commands/DescribeDocumentClassifierCommand";
import {
  DescribeDominantLanguageDetectionJobCommandInput,
  DescribeDominantLanguageDetectionJobCommandOutput
} from "../commands/DescribeDominantLanguageDetectionJobCommand";
import {
  DescribeEndpointCommandInput,
  DescribeEndpointCommandOutput
} from "../commands/DescribeEndpointCommand";
import {
  DescribeEntitiesDetectionJobCommandInput,
  DescribeEntitiesDetectionJobCommandOutput
} from "../commands/DescribeEntitiesDetectionJobCommand";
import {
  DescribeEntityRecognizerCommandInput,
  DescribeEntityRecognizerCommandOutput
} from "../commands/DescribeEntityRecognizerCommand";
import {
  DescribeKeyPhrasesDetectionJobCommandInput,
  DescribeKeyPhrasesDetectionJobCommandOutput
} from "../commands/DescribeKeyPhrasesDetectionJobCommand";
import {
  DescribeSentimentDetectionJobCommandInput,
  DescribeSentimentDetectionJobCommandOutput
} from "../commands/DescribeSentimentDetectionJobCommand";
import {
  DescribeTopicsDetectionJobCommandInput,
  DescribeTopicsDetectionJobCommandOutput
} from "../commands/DescribeTopicsDetectionJobCommand";
import {
  DetectDominantLanguageCommandInput,
  DetectDominantLanguageCommandOutput
} from "../commands/DetectDominantLanguageCommand";
import {
  DetectEntitiesCommandInput,
  DetectEntitiesCommandOutput
} from "../commands/DetectEntitiesCommand";
import {
  DetectKeyPhrasesCommandInput,
  DetectKeyPhrasesCommandOutput
} from "../commands/DetectKeyPhrasesCommand";
import {
  DetectSentimentCommandInput,
  DetectSentimentCommandOutput
} from "../commands/DetectSentimentCommand";
import {
  DetectSyntaxCommandInput,
  DetectSyntaxCommandOutput
} from "../commands/DetectSyntaxCommand";
import {
  ListDocumentClassificationJobsCommandInput,
  ListDocumentClassificationJobsCommandOutput
} from "../commands/ListDocumentClassificationJobsCommand";
import {
  ListDocumentClassifiersCommandInput,
  ListDocumentClassifiersCommandOutput
} from "../commands/ListDocumentClassifiersCommand";
import {
  ListDominantLanguageDetectionJobsCommandInput,
  ListDominantLanguageDetectionJobsCommandOutput
} from "../commands/ListDominantLanguageDetectionJobsCommand";
import {
  ListEndpointsCommandInput,
  ListEndpointsCommandOutput
} from "../commands/ListEndpointsCommand";
import {
  ListEntitiesDetectionJobsCommandInput,
  ListEntitiesDetectionJobsCommandOutput
} from "../commands/ListEntitiesDetectionJobsCommand";
import {
  ListEntityRecognizersCommandInput,
  ListEntityRecognizersCommandOutput
} from "../commands/ListEntityRecognizersCommand";
import {
  ListKeyPhrasesDetectionJobsCommandInput,
  ListKeyPhrasesDetectionJobsCommandOutput
} from "../commands/ListKeyPhrasesDetectionJobsCommand";
import {
  ListSentimentDetectionJobsCommandInput,
  ListSentimentDetectionJobsCommandOutput
} from "../commands/ListSentimentDetectionJobsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ListTopicsDetectionJobsCommandInput,
  ListTopicsDetectionJobsCommandOutput
} from "../commands/ListTopicsDetectionJobsCommand";
import {
  StartDocumentClassificationJobCommandInput,
  StartDocumentClassificationJobCommandOutput
} from "../commands/StartDocumentClassificationJobCommand";
import {
  StartDominantLanguageDetectionJobCommandInput,
  StartDominantLanguageDetectionJobCommandOutput
} from "../commands/StartDominantLanguageDetectionJobCommand";
import {
  StartEntitiesDetectionJobCommandInput,
  StartEntitiesDetectionJobCommandOutput
} from "../commands/StartEntitiesDetectionJobCommand";
import {
  StartKeyPhrasesDetectionJobCommandInput,
  StartKeyPhrasesDetectionJobCommandOutput
} from "../commands/StartKeyPhrasesDetectionJobCommand";
import {
  StartSentimentDetectionJobCommandInput,
  StartSentimentDetectionJobCommandOutput
} from "../commands/StartSentimentDetectionJobCommand";
import {
  StartTopicsDetectionJobCommandInput,
  StartTopicsDetectionJobCommandOutput
} from "../commands/StartTopicsDetectionJobCommand";
import {
  StopDominantLanguageDetectionJobCommandInput,
  StopDominantLanguageDetectionJobCommandOutput
} from "../commands/StopDominantLanguageDetectionJobCommand";
import {
  StopEntitiesDetectionJobCommandInput,
  StopEntitiesDetectionJobCommandOutput
} from "../commands/StopEntitiesDetectionJobCommand";
import {
  StopKeyPhrasesDetectionJobCommandInput,
  StopKeyPhrasesDetectionJobCommandOutput
} from "../commands/StopKeyPhrasesDetectionJobCommand";
import {
  StopSentimentDetectionJobCommandInput,
  StopSentimentDetectionJobCommandOutput
} from "../commands/StopSentimentDetectionJobCommand";
import {
  StopTrainingDocumentClassifierCommandInput,
  StopTrainingDocumentClassifierCommandOutput
} from "../commands/StopTrainingDocumentClassifierCommand";
import {
  StopTrainingEntityRecognizerCommandInput,
  StopTrainingEntityRecognizerCommandOutput
} from "../commands/StopTrainingEntityRecognizerCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateEndpointCommandInput,
  UpdateEndpointCommandOutput
} from "../commands/UpdateEndpointCommand";
import {
  BatchDetectDominantLanguageItemResult,
  BatchDetectDominantLanguageRequest,
  BatchDetectDominantLanguageResponse,
  BatchDetectEntitiesItemResult,
  BatchDetectEntitiesRequest,
  BatchDetectEntitiesResponse,
  BatchDetectKeyPhrasesItemResult,
  BatchDetectKeyPhrasesRequest,
  BatchDetectKeyPhrasesResponse,
  BatchDetectSentimentItemResult,
  BatchDetectSentimentRequest,
  BatchDetectSentimentResponse,
  BatchDetectSyntaxItemResult,
  BatchDetectSyntaxRequest,
  BatchDetectSyntaxResponse,
  BatchItemError,
  BatchSizeLimitExceededException,
  ClassifierEvaluationMetrics,
  ClassifierMetadata,
  ClassifyDocumentRequest,
  ClassifyDocumentResponse,
  ConcurrentModificationException,
  CreateDocumentClassifierRequest,
  CreateDocumentClassifierResponse,
  CreateEndpointRequest,
  CreateEndpointResponse,
  CreateEntityRecognizerRequest,
  CreateEntityRecognizerResponse,
  DeleteDocumentClassifierRequest,
  DeleteDocumentClassifierResponse,
  DeleteEndpointRequest,
  DeleteEndpointResponse,
  DeleteEntityRecognizerRequest,
  DeleteEntityRecognizerResponse,
  DescribeDocumentClassificationJobRequest,
  DescribeDocumentClassificationJobResponse,
  DescribeDocumentClassifierRequest,
  DescribeDocumentClassifierResponse,
  DescribeDominantLanguageDetectionJobRequest,
  DescribeDominantLanguageDetectionJobResponse,
  DescribeEndpointRequest,
  DescribeEndpointResponse,
  DescribeEntitiesDetectionJobRequest,
  DescribeEntitiesDetectionJobResponse,
  DescribeEntityRecognizerRequest,
  DescribeEntityRecognizerResponse,
  DescribeKeyPhrasesDetectionJobRequest,
  DescribeKeyPhrasesDetectionJobResponse,
  DescribeSentimentDetectionJobRequest,
  DescribeSentimentDetectionJobResponse,
  DescribeTopicsDetectionJobRequest,
  DescribeTopicsDetectionJobResponse,
  DetectDominantLanguageRequest,
  DetectDominantLanguageResponse,
  DetectEntitiesRequest,
  DetectEntitiesResponse,
  DetectKeyPhrasesRequest,
  DetectKeyPhrasesResponse,
  DetectSentimentRequest,
  DetectSentimentResponse,
  DetectSyntaxRequest,
  DetectSyntaxResponse,
  DocumentClass,
  DocumentClassificationJobFilter,
  DocumentClassificationJobProperties,
  DocumentClassifierFilter,
  DocumentClassifierInputDataConfig,
  DocumentClassifierOutputDataConfig,
  DocumentClassifierProperties,
  DominantLanguage,
  DominantLanguageDetectionJobFilter,
  DominantLanguageDetectionJobProperties,
  EndpointFilter,
  EndpointProperties,
  EntitiesDetectionJobFilter,
  EntitiesDetectionJobProperties,
  Entity,
  EntityRecognizerAnnotations,
  EntityRecognizerDocuments,
  EntityRecognizerEntityList,
  EntityRecognizerEvaluationMetrics,
  EntityRecognizerFilter,
  EntityRecognizerInputDataConfig,
  EntityRecognizerMetadata,
  EntityRecognizerMetadataEntityTypesListItem,
  EntityRecognizerProperties,
  EntityTypesEvaluationMetrics,
  EntityTypesListItem,
  InputDataConfig,
  InternalServerException,
  InvalidFilterException,
  InvalidRequestException,
  JobNotFoundException,
  KeyPhrase,
  KeyPhrasesDetectionJobFilter,
  KeyPhrasesDetectionJobProperties,
  KmsKeyValidationException,
  ListDocumentClassificationJobsRequest,
  ListDocumentClassificationJobsResponse,
  ListDocumentClassifiersRequest,
  ListDocumentClassifiersResponse,
  ListDominantLanguageDetectionJobsRequest,
  ListDominantLanguageDetectionJobsResponse,
  ListEndpointsRequest,
  ListEndpointsResponse,
  ListEntitiesDetectionJobsRequest,
  ListEntitiesDetectionJobsResponse,
  ListEntityRecognizersRequest,
  ListEntityRecognizersResponse,
  ListKeyPhrasesDetectionJobsRequest,
  ListKeyPhrasesDetectionJobsResponse,
  ListSentimentDetectionJobsRequest,
  ListSentimentDetectionJobsResponse,
  ListTagsForResourceRequest,
  ListTagsForResourceResponse,
  ListTopicsDetectionJobsRequest,
  ListTopicsDetectionJobsResponse,
  OutputDataConfig,
  PartOfSpeechTag,
  ResourceInUseException,
  ResourceLimitExceededException,
  ResourceNotFoundException,
  ResourceUnavailableException,
  SentimentDetectionJobFilter,
  SentimentDetectionJobProperties,
  SentimentScore,
  StartDocumentClassificationJobRequest,
  StartDocumentClassificationJobResponse,
  StartDominantLanguageDetectionJobRequest,
  StartDominantLanguageDetectionJobResponse,
  StartEntitiesDetectionJobRequest,
  StartEntitiesDetectionJobResponse,
  StartKeyPhrasesDetectionJobRequest,
  StartKeyPhrasesDetectionJobResponse,
  StartSentimentDetectionJobRequest,
  StartSentimentDetectionJobResponse,
  StartTopicsDetectionJobRequest,
  StartTopicsDetectionJobResponse,
  StopDominantLanguageDetectionJobRequest,
  StopDominantLanguageDetectionJobResponse,
  StopEntitiesDetectionJobRequest,
  StopEntitiesDetectionJobResponse,
  StopKeyPhrasesDetectionJobRequest,
  StopKeyPhrasesDetectionJobResponse,
  StopSentimentDetectionJobRequest,
  StopSentimentDetectionJobResponse,
  StopTrainingDocumentClassifierRequest,
  StopTrainingDocumentClassifierResponse,
  StopTrainingEntityRecognizerRequest,
  StopTrainingEntityRecognizerResponse,
  SyntaxToken,
  Tag,
  TagResourceRequest,
  TagResourceResponse,
  TextSizeLimitExceededException,
  TooManyRequestsException,
  TooManyTagKeysException,
  TooManyTagsException,
  TopicsDetectionJobFilter,
  TopicsDetectionJobProperties,
  UnsupportedLanguageException,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateEndpointRequest,
  UpdateEndpointResponse,
  VpcConfig
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_json1_1BatchDetectDominantLanguageCommand(
  input: BatchDetectDominantLanguageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectDominantLanguage";
  let body: any = {};
  const wrappedBody: any = {
    BatchDetectDominantLanguageRequest: serializeAws_json1_1BatchDetectDominantLanguageRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/BatchDetectDominantLanguage",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1BatchDetectEntitiesCommand(
  input: BatchDetectEntitiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectEntities";
  let body: any = {};
  const wrappedBody: any = {
    BatchDetectEntitiesRequest: serializeAws_json1_1BatchDetectEntitiesRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/BatchDetectEntities",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1BatchDetectKeyPhrasesCommand(
  input: BatchDetectKeyPhrasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectKeyPhrases";
  let body: any = {};
  const wrappedBody: any = {
    BatchDetectKeyPhrasesRequest: serializeAws_json1_1BatchDetectKeyPhrasesRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/BatchDetectKeyPhrases",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1BatchDetectSentimentCommand(
  input: BatchDetectSentimentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectSentiment";
  let body: any = {};
  const wrappedBody: any = {
    BatchDetectSentimentRequest: serializeAws_json1_1BatchDetectSentimentRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/BatchDetectSentiment",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1BatchDetectSyntaxCommand(
  input: BatchDetectSyntaxCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectSyntax";
  let body: any = {};
  const wrappedBody: any = {
    BatchDetectSyntaxRequest: serializeAws_json1_1BatchDetectSyntaxRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/BatchDetectSyntax",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ClassifyDocumentCommand(
  input: ClassifyDocumentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ClassifyDocument";
  let body: any = {};
  const wrappedBody: any = {
    ClassifyDocumentRequest: serializeAws_json1_1ClassifyDocumentRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ClassifyDocument",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateDocumentClassifierCommand(
  input: CreateDocumentClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.CreateDocumentClassifier";
  let body: any = {};
  const wrappedBody: any = {
    CreateDocumentClassifierRequest: serializeAws_json1_1CreateDocumentClassifierRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/CreateDocumentClassifier",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateEndpointCommand(
  input: CreateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.CreateEndpoint";
  let body: any = {};
  const wrappedBody: any = {
    CreateEndpointRequest: serializeAws_json1_1CreateEndpointRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/CreateEndpoint",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateEntityRecognizerCommand(
  input: CreateEntityRecognizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.CreateEntityRecognizer";
  let body: any = {};
  const wrappedBody: any = {
    CreateEntityRecognizerRequest: serializeAws_json1_1CreateEntityRecognizerRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/CreateEntityRecognizer",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteDocumentClassifierCommand(
  input: DeleteDocumentClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DeleteDocumentClassifier";
  let body: any = {};
  const wrappedBody: any = {
    DeleteDocumentClassifierRequest: serializeAws_json1_1DeleteDocumentClassifierRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteDocumentClassifier",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteEndpointCommand(
  input: DeleteEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DeleteEndpoint";
  let body: any = {};
  const wrappedBody: any = {
    DeleteEndpointRequest: serializeAws_json1_1DeleteEndpointRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteEndpoint",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteEntityRecognizerCommand(
  input: DeleteEntityRecognizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DeleteEntityRecognizer";
  let body: any = {};
  const wrappedBody: any = {
    DeleteEntityRecognizerRequest: serializeAws_json1_1DeleteEntityRecognizerRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteEntityRecognizer",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeDocumentClassificationJobCommand(
  input: DescribeDocumentClassificationJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.DescribeDocumentClassificationJob";
  let body: any = {};
  const wrappedBody: any = {
    DescribeDocumentClassificationJobRequest: serializeAws_json1_1DescribeDocumentClassificationJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeDocumentClassificationJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeDocumentClassifierCommand(
  input: DescribeDocumentClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeDocumentClassifier";
  let body: any = {};
  const wrappedBody: any = {
    DescribeDocumentClassifierRequest: serializeAws_json1_1DescribeDocumentClassifierRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeDocumentClassifier",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeDominantLanguageDetectionJobCommand(
  input: DescribeDominantLanguageDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.DescribeDominantLanguageDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    DescribeDominantLanguageDetectionJobRequest: serializeAws_json1_1DescribeDominantLanguageDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeDominantLanguageDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEndpointCommand(
  input: DescribeEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeEndpoint";
  let body: any = {};
  const wrappedBody: any = {
    DescribeEndpointRequest: serializeAws_json1_1DescribeEndpointRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeEndpoint",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEntitiesDetectionJobCommand(
  input: DescribeEntitiesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeEntitiesDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    DescribeEntitiesDetectionJobRequest: serializeAws_json1_1DescribeEntitiesDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeEntitiesDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEntityRecognizerCommand(
  input: DescribeEntityRecognizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeEntityRecognizer";
  let body: any = {};
  const wrappedBody: any = {
    DescribeEntityRecognizerRequest: serializeAws_json1_1DescribeEntityRecognizerRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeEntityRecognizer",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeKeyPhrasesDetectionJobCommand(
  input: DescribeKeyPhrasesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.DescribeKeyPhrasesDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    DescribeKeyPhrasesDetectionJobRequest: serializeAws_json1_1DescribeKeyPhrasesDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeKeyPhrasesDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeSentimentDetectionJobCommand(
  input: DescribeSentimentDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeSentimentDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    DescribeSentimentDetectionJobRequest: serializeAws_json1_1DescribeSentimentDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeSentimentDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeTopicsDetectionJobCommand(
  input: DescribeTopicsDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeTopicsDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    DescribeTopicsDetectionJobRequest: serializeAws_json1_1DescribeTopicsDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeTopicsDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DetectDominantLanguageCommand(
  input: DetectDominantLanguageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectDominantLanguage";
  let body: any = {};
  const wrappedBody: any = {
    DetectDominantLanguageRequest: serializeAws_json1_1DetectDominantLanguageRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DetectDominantLanguage",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DetectEntitiesCommand(
  input: DetectEntitiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectEntities";
  let body: any = {};
  const wrappedBody: any = {
    DetectEntitiesRequest: serializeAws_json1_1DetectEntitiesRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DetectEntities",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DetectKeyPhrasesCommand(
  input: DetectKeyPhrasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectKeyPhrases";
  let body: any = {};
  const wrappedBody: any = {
    DetectKeyPhrasesRequest: serializeAws_json1_1DetectKeyPhrasesRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DetectKeyPhrases",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DetectSentimentCommand(
  input: DetectSentimentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectSentiment";
  let body: any = {};
  const wrappedBody: any = {
    DetectSentimentRequest: serializeAws_json1_1DetectSentimentRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DetectSentiment",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DetectSyntaxCommand(
  input: DetectSyntaxCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectSyntax";
  let body: any = {};
  const wrappedBody: any = {
    DetectSyntaxRequest: serializeAws_json1_1DetectSyntaxRequest(input, context)
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DetectSyntax",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListDocumentClassificationJobsCommand(
  input: ListDocumentClassificationJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.ListDocumentClassificationJobs";
  let body: any = {};
  const wrappedBody: any = {
    ListDocumentClassificationJobsRequest: serializeAws_json1_1ListDocumentClassificationJobsRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListDocumentClassificationJobs",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListDocumentClassifiersCommand(
  input: ListDocumentClassifiersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListDocumentClassifiers";
  let body: any = {};
  const wrappedBody: any = {
    ListDocumentClassifiersRequest: serializeAws_json1_1ListDocumentClassifiersRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListDocumentClassifiers",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListDominantLanguageDetectionJobsCommand(
  input: ListDominantLanguageDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.ListDominantLanguageDetectionJobs";
  let body: any = {};
  const wrappedBody: any = {
    ListDominantLanguageDetectionJobsRequest: serializeAws_json1_1ListDominantLanguageDetectionJobsRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListDominantLanguageDetectionJobs",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListEndpointsCommand(
  input: ListEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListEndpoints";
  let body: any = {};
  const wrappedBody: any = {
    ListEndpointsRequest: serializeAws_json1_1ListEndpointsRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListEndpoints",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListEntitiesDetectionJobsCommand(
  input: ListEntitiesDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListEntitiesDetectionJobs";
  let body: any = {};
  const wrappedBody: any = {
    ListEntitiesDetectionJobsRequest: serializeAws_json1_1ListEntitiesDetectionJobsRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListEntitiesDetectionJobs",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListEntityRecognizersCommand(
  input: ListEntityRecognizersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListEntityRecognizers";
  let body: any = {};
  const wrappedBody: any = {
    ListEntityRecognizersRequest: serializeAws_json1_1ListEntityRecognizersRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListEntityRecognizers",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListKeyPhrasesDetectionJobsCommand(
  input: ListKeyPhrasesDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListKeyPhrasesDetectionJobs";
  let body: any = {};
  const wrappedBody: any = {
    ListKeyPhrasesDetectionJobsRequest: serializeAws_json1_1ListKeyPhrasesDetectionJobsRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListKeyPhrasesDetectionJobs",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListSentimentDetectionJobsCommand(
  input: ListSentimentDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListSentimentDetectionJobs";
  let body: any = {};
  const wrappedBody: any = {
    ListSentimentDetectionJobsRequest: serializeAws_json1_1ListSentimentDetectionJobsRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListSentimentDetectionJobs",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListTagsForResource";
  let body: any = {};
  const wrappedBody: any = {
    ListTagsForResourceRequest: serializeAws_json1_1ListTagsForResourceRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListTagsForResource",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTopicsDetectionJobsCommand(
  input: ListTopicsDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListTopicsDetectionJobs";
  let body: any = {};
  const wrappedBody: any = {
    ListTopicsDetectionJobsRequest: serializeAws_json1_1ListTopicsDetectionJobsRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListTopicsDetectionJobs",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartDocumentClassificationJobCommand(
  input: StartDocumentClassificationJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.StartDocumentClassificationJob";
  let body: any = {};
  const wrappedBody: any = {
    StartDocumentClassificationJobRequest: serializeAws_json1_1StartDocumentClassificationJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StartDocumentClassificationJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartDominantLanguageDetectionJobCommand(
  input: StartDominantLanguageDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.StartDominantLanguageDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    StartDominantLanguageDetectionJobRequest: serializeAws_json1_1StartDominantLanguageDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StartDominantLanguageDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartEntitiesDetectionJobCommand(
  input: StartEntitiesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StartEntitiesDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    StartEntitiesDetectionJobRequest: serializeAws_json1_1StartEntitiesDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StartEntitiesDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartKeyPhrasesDetectionJobCommand(
  input: StartKeyPhrasesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StartKeyPhrasesDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    StartKeyPhrasesDetectionJobRequest: serializeAws_json1_1StartKeyPhrasesDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StartKeyPhrasesDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartSentimentDetectionJobCommand(
  input: StartSentimentDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StartSentimentDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    StartSentimentDetectionJobRequest: serializeAws_json1_1StartSentimentDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StartSentimentDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartTopicsDetectionJobCommand(
  input: StartTopicsDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StartTopicsDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    StartTopicsDetectionJobRequest: serializeAws_json1_1StartTopicsDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StartTopicsDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopDominantLanguageDetectionJobCommand(
  input: StopDominantLanguageDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.StopDominantLanguageDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    StopDominantLanguageDetectionJobRequest: serializeAws_json1_1StopDominantLanguageDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StopDominantLanguageDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopEntitiesDetectionJobCommand(
  input: StopEntitiesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StopEntitiesDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    StopEntitiesDetectionJobRequest: serializeAws_json1_1StopEntitiesDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StopEntitiesDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopKeyPhrasesDetectionJobCommand(
  input: StopKeyPhrasesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StopKeyPhrasesDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    StopKeyPhrasesDetectionJobRequest: serializeAws_json1_1StopKeyPhrasesDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StopKeyPhrasesDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopSentimentDetectionJobCommand(
  input: StopSentimentDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StopSentimentDetectionJob";
  let body: any = {};
  const wrappedBody: any = {
    StopSentimentDetectionJobRequest: serializeAws_json1_1StopSentimentDetectionJobRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StopSentimentDetectionJob",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopTrainingDocumentClassifierCommand(
  input: StopTrainingDocumentClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.StopTrainingDocumentClassifier";
  let body: any = {};
  const wrappedBody: any = {
    StopTrainingDocumentClassifierRequest: serializeAws_json1_1StopTrainingDocumentClassifierRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StopTrainingDocumentClassifier",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopTrainingEntityRecognizerCommand(
  input: StopTrainingEntityRecognizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StopTrainingEntityRecognizer";
  let body: any = {};
  const wrappedBody: any = {
    StopTrainingEntityRecognizerRequest: serializeAws_json1_1StopTrainingEntityRecognizerRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StopTrainingEntityRecognizer",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.TagResource";
  let body: any = {};
  const wrappedBody: any = {
    TagResourceRequest: serializeAws_json1_1TagResourceRequest(input, context)
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/TagResource",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.UntagResource";
  let body: any = {};
  const wrappedBody: any = {
    UntagResourceRequest: serializeAws_json1_1UntagResourceRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/UntagResource",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateEndpointCommand(
  input: UpdateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.UpdateEndpoint";
  let body: any = {};
  const wrappedBody: any = {
    UpdateEndpointRequest: serializeAws_json1_1UpdateEndpointRequest(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/UpdateEndpoint",
    headers: headers,
    body: body
  });
}

export async function deserializeAws_json1_1BatchDetectDominantLanguageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectDominantLanguageCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectDominantLanguageCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectDominantLanguageResponse(
    data.BatchDetectDominantLanguageResponse,
    context
  );
  const response: BatchDetectDominantLanguageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectDominantLanguageResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectDominantLanguageCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectDominantLanguageCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1BatchDetectEntitiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectEntitiesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectEntitiesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectEntitiesResponse(
    data.BatchDetectEntitiesResponse,
    context
  );
  const response: BatchDetectEntitiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectEntitiesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectEntitiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectEntitiesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1BatchDetectKeyPhrasesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectKeyPhrasesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectKeyPhrasesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectKeyPhrasesResponse(
    data.BatchDetectKeyPhrasesResponse,
    context
  );
  const response: BatchDetectKeyPhrasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectKeyPhrasesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectKeyPhrasesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectKeyPhrasesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1BatchDetectSentimentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectSentimentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectSentimentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectSentimentResponse(
    data.BatchDetectSentimentResponse,
    context
  );
  const response: BatchDetectSentimentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectSentimentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectSentimentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectSentimentCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1BatchDetectSyntaxCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectSyntaxCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectSyntaxCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectSyntaxResponse(
    data.BatchDetectSyntaxResponse,
    context
  );
  const response: BatchDetectSyntaxCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectSyntaxResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectSyntaxCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectSyntaxCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ClassifyDocumentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ClassifyDocumentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ClassifyDocumentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ClassifyDocumentResponse(
    data.ClassifyDocumentResponse,
    context
  );
  const response: ClassifyDocumentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClassifyDocumentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ClassifyDocumentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ClassifyDocumentCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1CreateDocumentClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDocumentClassifierCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDocumentClassifierResponse(
    data.CreateDocumentClassifierResponse,
    context
  );
  const response: CreateDocumentClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDocumentClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDocumentClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentClassifierCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = await deserializeAws_json1_1ResourceInUseExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.comprehend#ResourceLimitExceededException":
      response = await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyTagsException":
    case "com.amazonaws.comprehend#TooManyTagsException":
      response = await deserializeAws_json1_1TooManyTagsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1CreateEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEndpointResponse(
    data.CreateEndpointResponse,
    context
  );
  const response: CreateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = await deserializeAws_json1_1ResourceInUseExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.comprehend#ResourceLimitExceededException":
      response = await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyTagsException":
    case "com.amazonaws.comprehend#TooManyTagsException":
      response = await deserializeAws_json1_1TooManyTagsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1CreateEntityRecognizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEntityRecognizerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEntityRecognizerCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEntityRecognizerResponse(
    data.CreateEntityRecognizerResponse,
    context
  );
  const response: CreateEntityRecognizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEntityRecognizerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEntityRecognizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEntityRecognizerCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = await deserializeAws_json1_1ResourceInUseExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.comprehend#ResourceLimitExceededException":
      response = await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyTagsException":
    case "com.amazonaws.comprehend#TooManyTagsException":
      response = await deserializeAws_json1_1TooManyTagsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteDocumentClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDocumentClassifierCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDocumentClassifierResponse(
    data.DeleteDocumentClassifierResponse,
    context
  );
  const response: DeleteDocumentClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDocumentClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDocumentClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentClassifierCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = await deserializeAws_json1_1ResourceInUseExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEndpointResponse(
    data.DeleteEndpointResponse,
    context
  );
  const response: DeleteEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = await deserializeAws_json1_1ResourceInUseExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteEntityRecognizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEntityRecognizerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEntityRecognizerCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEntityRecognizerResponse(
    data.DeleteEntityRecognizerResponse,
    context
  );
  const response: DeleteEntityRecognizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEntityRecognizerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEntityRecognizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEntityRecognizerCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = await deserializeAws_json1_1ResourceInUseExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeDocumentClassificationJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentClassificationJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDocumentClassificationJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDocumentClassificationJobResponse(
    data.DescribeDocumentClassificationJobResponse,
    context
  );
  const response: DescribeDocumentClassificationJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDocumentClassificationJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDocumentClassificationJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentClassificationJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeDocumentClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDocumentClassifierCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDocumentClassifierResponse(
    data.DescribeDocumentClassifierResponse,
    context
  );
  const response: DescribeDocumentClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDocumentClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDocumentClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentClassifierCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDominantLanguageDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDominantLanguageDetectionJobResponse(
    data.DescribeDominantLanguageDetectionJobResponse,
    context
  );
  const response: DescribeDominantLanguageDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDominantLanguageDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDominantLanguageDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointResponse(
    data.DescribeEndpointResponse,
    context
  );
  const response: DescribeEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeEntitiesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEntitiesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEntitiesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEntitiesDetectionJobResponse(
    data.DescribeEntitiesDetectionJobResponse,
    context
  );
  const response: DescribeEntitiesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEntitiesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEntitiesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEntitiesDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeEntityRecognizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEntityRecognizerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEntityRecognizerCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEntityRecognizerResponse(
    data.DescribeEntityRecognizerResponse,
    context
  );
  const response: DescribeEntityRecognizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEntityRecognizerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEntityRecognizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEntityRecognizerCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeKeyPhrasesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeKeyPhrasesDetectionJobResponse(
    data.DescribeKeyPhrasesDetectionJobResponse,
    context
  );
  const response: DescribeKeyPhrasesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeKeyPhrasesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeKeyPhrasesDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeSentimentDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSentimentDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeSentimentDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeSentimentDetectionJobResponse(
    data.DescribeSentimentDetectionJobResponse,
    context
  );
  const response: DescribeSentimentDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSentimentDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeSentimentDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSentimentDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeTopicsDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTopicsDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTopicsDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTopicsDetectionJobResponse(
    data.DescribeTopicsDetectionJobResponse,
    context
  );
  const response: DescribeTopicsDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTopicsDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTopicsDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTopicsDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DetectDominantLanguageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectDominantLanguageCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectDominantLanguageCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectDominantLanguageResponse(
    data.DetectDominantLanguageResponse,
    context
  );
  const response: DetectDominantLanguageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectDominantLanguageResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectDominantLanguageCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectDominantLanguageCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DetectEntitiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectEntitiesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectEntitiesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectEntitiesResponse(
    data.DetectEntitiesResponse,
    context
  );
  const response: DetectEntitiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectEntitiesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectEntitiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectEntitiesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DetectKeyPhrasesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectKeyPhrasesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectKeyPhrasesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectKeyPhrasesResponse(
    data.DetectKeyPhrasesResponse,
    context
  );
  const response: DetectKeyPhrasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectKeyPhrasesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectKeyPhrasesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectKeyPhrasesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DetectSentimentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectSentimentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectSentimentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectSentimentResponse(
    data.DetectSentimentResponse,
    context
  );
  const response: DetectSentimentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectSentimentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectSentimentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectSentimentCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DetectSyntaxCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectSyntaxCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectSyntaxCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectSyntaxResponse(
    data.DetectSyntaxResponse,
    context
  );
  const response: DetectSyntaxCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectSyntaxResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectSyntaxCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectSyntaxCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListDocumentClassificationJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentClassificationJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDocumentClassificationJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDocumentClassificationJobsResponse(
    data.ListDocumentClassificationJobsResponse,
    context
  );
  const response: ListDocumentClassificationJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDocumentClassificationJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDocumentClassificationJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentClassificationJobsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = await deserializeAws_json1_1InvalidFilterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListDocumentClassifiersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentClassifiersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDocumentClassifiersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDocumentClassifiersResponse(
    data.ListDocumentClassifiersResponse,
    context
  );
  const response: ListDocumentClassifiersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDocumentClassifiersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDocumentClassifiersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentClassifiersCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = await deserializeAws_json1_1InvalidFilterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListDominantLanguageDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDominantLanguageDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDominantLanguageDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDominantLanguageDetectionJobsResponse(
    data.ListDominantLanguageDetectionJobsResponse,
    context
  );
  const response: ListDominantLanguageDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDominantLanguageDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDominantLanguageDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDominantLanguageDetectionJobsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = await deserializeAws_json1_1InvalidFilterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEndpointsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListEndpointsResponse(
    data.ListEndpointsResponse,
    context
  );
  const response: ListEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListEndpointsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEndpointsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListEntitiesDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEntitiesDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListEntitiesDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListEntitiesDetectionJobsResponse(
    data.ListEntitiesDetectionJobsResponse,
    context
  );
  const response: ListEntitiesDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListEntitiesDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListEntitiesDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEntitiesDetectionJobsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = await deserializeAws_json1_1InvalidFilterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListEntityRecognizersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEntityRecognizersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListEntityRecognizersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListEntityRecognizersResponse(
    data.ListEntityRecognizersResponse,
    context
  );
  const response: ListEntityRecognizersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListEntityRecognizersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListEntityRecognizersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEntityRecognizersCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = await deserializeAws_json1_1InvalidFilterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListKeyPhrasesDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListKeyPhrasesDetectionJobsResponse(
    data.ListKeyPhrasesDetectionJobsResponse,
    context
  );
  const response: ListKeyPhrasesDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListKeyPhrasesDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListKeyPhrasesDetectionJobsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = await deserializeAws_json1_1InvalidFilterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListSentimentDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSentimentDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSentimentDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSentimentDetectionJobsResponse(
    data.ListSentimentDetectionJobsResponse,
    context
  );
  const response: ListSentimentDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSentimentDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSentimentDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSentimentDetectionJobsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = await deserializeAws_json1_1InvalidFilterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResponse(
    data.ListTagsForResourceResponse,
    context
  );
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListTopicsDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicsDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTopicsDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTopicsDetectionJobsResponse(
    data.ListTopicsDetectionJobsResponse,
    context
  );
  const response: ListTopicsDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTopicsDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTopicsDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicsDetectionJobsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = await deserializeAws_json1_1InvalidFilterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StartDocumentClassificationJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDocumentClassificationJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartDocumentClassificationJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartDocumentClassificationJobResponse(
    data.StartDocumentClassificationJobResponse,
    context
  );
  const response: StartDocumentClassificationJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartDocumentClassificationJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartDocumentClassificationJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDocumentClassificationJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StartDominantLanguageDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDominantLanguageDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartDominantLanguageDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartDominantLanguageDetectionJobResponse(
    data.StartDominantLanguageDetectionJobResponse,
    context
  );
  const response: StartDominantLanguageDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartDominantLanguageDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartDominantLanguageDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDominantLanguageDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StartEntitiesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartEntitiesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartEntitiesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartEntitiesDetectionJobResponse(
    data.StartEntitiesDetectionJobResponse,
    context
  );
  const response: StartEntitiesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartEntitiesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartEntitiesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartEntitiesDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StartKeyPhrasesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartKeyPhrasesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartKeyPhrasesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartKeyPhrasesDetectionJobResponse(
    data.StartKeyPhrasesDetectionJobResponse,
    context
  );
  const response: StartKeyPhrasesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartKeyPhrasesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartKeyPhrasesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartKeyPhrasesDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StartSentimentDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSentimentDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartSentimentDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartSentimentDetectionJobResponse(
    data.StartSentimentDetectionJobResponse,
    context
  );
  const response: StartSentimentDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartSentimentDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartSentimentDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSentimentDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StartTopicsDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTopicsDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartTopicsDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartTopicsDetectionJobResponse(
    data.StartTopicsDetectionJobResponse,
    context
  );
  const response: StartTopicsDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartTopicsDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartTopicsDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTopicsDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StopDominantLanguageDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopDominantLanguageDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopDominantLanguageDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopDominantLanguageDetectionJobResponse(
    data.StopDominantLanguageDetectionJobResponse,
    context
  );
  const response: StopDominantLanguageDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopDominantLanguageDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopDominantLanguageDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopDominantLanguageDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StopEntitiesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopEntitiesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopEntitiesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopEntitiesDetectionJobResponse(
    data.StopEntitiesDetectionJobResponse,
    context
  );
  const response: StopEntitiesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopEntitiesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopEntitiesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopEntitiesDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StopKeyPhrasesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopKeyPhrasesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopKeyPhrasesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopKeyPhrasesDetectionJobResponse(
    data.StopKeyPhrasesDetectionJobResponse,
    context
  );
  const response: StopKeyPhrasesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopKeyPhrasesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopKeyPhrasesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopKeyPhrasesDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StopSentimentDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopSentimentDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopSentimentDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopSentimentDetectionJobResponse(
    data.StopSentimentDetectionJobResponse,
    context
  );
  const response: StopSentimentDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopSentimentDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopSentimentDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopSentimentDetectionJobCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = await deserializeAws_json1_1JobNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StopTrainingDocumentClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingDocumentClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopTrainingDocumentClassifierCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopTrainingDocumentClassifierResponse(
    data.StopTrainingDocumentClassifierResponse,
    context
  );
  const response: StopTrainingDocumentClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopTrainingDocumentClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopTrainingDocumentClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingDocumentClassifierCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StopTrainingEntityRecognizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingEntityRecognizerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopTrainingEntityRecognizerCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopTrainingEntityRecognizerResponse(
    data.StopTrainingEntityRecognizerResponse,
    context
  );
  const response: StopTrainingEntityRecognizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopTrainingEntityRecognizerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopTrainingEntityRecognizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingEntityRecognizerCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(
    data.TagResourceResponse,
    context
  );
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.comprehend#ConcurrentModificationException":
      response = await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyTagsException":
    case "com.amazonaws.comprehend#TooManyTagsException":
      response = await deserializeAws_json1_1TooManyTagsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(
    data.UntagResourceResponse,
    context
  );
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.comprehend#ConcurrentModificationException":
      response = await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyTagKeysException":
    case "com.amazonaws.comprehend#TooManyTagKeysException":
      response = await deserializeAws_json1_1TooManyTagKeysExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1UpdateEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateEndpointResponse(
    data.UpdateEndpointResponse,
    context
  );
  const response: UpdateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = await deserializeAws_json1_1InternalServerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = await deserializeAws_json1_1InvalidRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = await deserializeAws_json1_1ResourceInUseExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.comprehend#ResourceLimitExceededException":
      response = await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = await deserializeAws_json1_1TooManyRequestsExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.comprehend#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

const deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<BatchSizeLimitExceededException> => {
  const deserialized: any = deserializeAws_json1_1BatchSizeLimitExceededException(
    output.body,
    context
  );
  const contents: BatchSizeLimitExceededException = {
    __type: "BatchSizeLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ConcurrentModificationExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ConcurrentModificationException> => {
  const deserialized: any = deserializeAws_json1_1ConcurrentModificationException(
    output.body,
    context
  );
  const contents: ConcurrentModificationException = {
    __type: "ConcurrentModificationException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InternalServerExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InternalServerException> => {
  const deserialized: any = deserializeAws_json1_1InternalServerException(
    output.body,
    context
  );
  const contents: InternalServerException = {
    __type: "InternalServerException",
    $fault: "server",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFilterExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidFilterException> => {
  const deserialized: any = deserializeAws_json1_1InvalidFilterException(
    output.body,
    context
  );
  const contents: InvalidFilterException = {
    __type: "InvalidFilterException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRequestExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidRequestException> => {
  const deserialized: any = deserializeAws_json1_1InvalidRequestException(
    output.body,
    context
  );
  const contents: InvalidRequestException = {
    __type: "InvalidRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1JobNotFoundExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<JobNotFoundException> => {
  const deserialized: any = deserializeAws_json1_1JobNotFoundException(
    output.body,
    context
  );
  const contents: JobNotFoundException = {
    __type: "JobNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KmsKeyValidationExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<KmsKeyValidationException> => {
  const deserialized: any = deserializeAws_json1_1KmsKeyValidationException(
    output.body,
    context
  );
  const contents: KmsKeyValidationException = {
    __type: "KmsKeyValidationException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceInUseExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceInUseException> => {
  const deserialized: any = deserializeAws_json1_1ResourceInUseException(
    output.body,
    context
  );
  const contents: ResourceInUseException = {
    __type: "ResourceInUseException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceLimitExceededExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceLimitExceededException> => {
  const deserialized: any = deserializeAws_json1_1ResourceLimitExceededException(
    output.body,
    context
  );
  const contents: ResourceLimitExceededException = {
    __type: "ResourceLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceNotFoundException> => {
  const deserialized: any = deserializeAws_json1_1ResourceNotFoundException(
    output.body,
    context
  );
  const contents: ResourceNotFoundException = {
    __type: "ResourceNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceUnavailableExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceUnavailableException> => {
  const deserialized: any = deserializeAws_json1_1ResourceUnavailableException(
    output.body,
    context
  );
  const contents: ResourceUnavailableException = {
    __type: "ResourceUnavailableException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TextSizeLimitExceededExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<TextSizeLimitExceededException> => {
  const deserialized: any = deserializeAws_json1_1TextSizeLimitExceededException(
    output.body,
    context
  );
  const contents: TextSizeLimitExceededException = {
    __type: "TextSizeLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyRequestsExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<TooManyRequestsException> => {
  const deserialized: any = deserializeAws_json1_1TooManyRequestsException(
    output.body,
    context
  );
  const contents: TooManyRequestsException = {
    __type: "TooManyRequestsException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyTagKeysExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<TooManyTagKeysException> => {
  const deserialized: any = deserializeAws_json1_1TooManyTagKeysException(
    output.body,
    context
  );
  const contents: TooManyTagKeysException = {
    __type: "TooManyTagKeysException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyTagsExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<TooManyTagsException> => {
  const deserialized: any = deserializeAws_json1_1TooManyTagsException(
    output.body,
    context
  );
  const contents: TooManyTagsException = {
    __type: "TooManyTagsException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedLanguageExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<UnsupportedLanguageException> => {
  const deserialized: any = deserializeAws_json1_1UnsupportedLanguageException(
    output.body,
    context
  );
  const contents: UnsupportedLanguageException = {
    __type: "UnsupportedLanguageException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1BatchDetectDominantLanguageRequest = (
  input: BatchDetectDominantLanguageRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDetectEntitiesRequest = (
  input: BatchDetectEntitiesRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDetectKeyPhrasesRequest = (
  input: BatchDetectKeyPhrasesRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDetectSentimentRequest = (
  input: BatchDetectSentimentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDetectSyntaxRequest = (
  input: BatchDetectSyntaxRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ClassifyDocumentRequest = (
  input: ClassifyDocumentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDocumentClassifierRequest = (
  input: CreateDocumentClassifierRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.DocumentClassifierName !== undefined) {
    bodyParams["DocumentClassifierName"] = input.DocumentClassifierName;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams[
      "InputDataConfig"
    ] = serializeAws_json1_1DocumentClassifierInputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams[
      "OutputDataConfig"
    ] = serializeAws_json1_1DocumentClassifierOutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEndpointRequest = (
  input: CreateEndpointRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DesiredInferenceUnits !== undefined) {
    bodyParams["DesiredInferenceUnits"] = input.DesiredInferenceUnits;
  }
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  if (input.ModelArn !== undefined) {
    bodyParams["ModelArn"] = input.ModelArn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEntityRecognizerRequest = (
  input: CreateEntityRecognizerRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams[
      "InputDataConfig"
    ] = serializeAws_json1_1EntityRecognizerInputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.RecognizerName !== undefined) {
    bodyParams["RecognizerName"] = input.RecognizerName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDocumentClassifierRequest = (
  input: DeleteDocumentClassifierRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DocumentClassifierArn !== undefined) {
    bodyParams["DocumentClassifierArn"] = input.DocumentClassifierArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEndpointRequest = (
  input: DeleteEndpointRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEntityRecognizerRequest = (
  input: DeleteEntityRecognizerRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EntityRecognizerArn !== undefined) {
    bodyParams["EntityRecognizerArn"] = input.EntityRecognizerArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDocumentClassificationJobRequest = (
  input: DescribeDocumentClassificationJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDocumentClassifierRequest = (
  input: DescribeDocumentClassifierRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DocumentClassifierArn !== undefined) {
    bodyParams["DocumentClassifierArn"] = input.DocumentClassifierArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDominantLanguageDetectionJobRequest = (
  input: DescribeDominantLanguageDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEndpointRequest = (
  input: DescribeEndpointRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEntitiesDetectionJobRequest = (
  input: DescribeEntitiesDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEntityRecognizerRequest = (
  input: DescribeEntityRecognizerRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EntityRecognizerArn !== undefined) {
    bodyParams["EntityRecognizerArn"] = input.EntityRecognizerArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeKeyPhrasesDetectionJobRequest = (
  input: DescribeKeyPhrasesDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeSentimentDetectionJobRequest = (
  input: DescribeSentimentDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTopicsDetectionJobRequest = (
  input: DescribeTopicsDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectDominantLanguageRequest = (
  input: DetectDominantLanguageRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectEntitiesRequest = (
  input: DetectEntitiesRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectKeyPhrasesRequest = (
  input: DetectKeyPhrasesRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectSentimentRequest = (
  input: DetectSentimentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectSyntaxRequest = (
  input: DetectSyntaxRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentClassificationJobFilter = (
  input: DocumentClassificationJobFilter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentClassifierFilter = (
  input: DocumentClassifierFilter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentClassifierInputDataConfig = (
  input: DocumentClassifierInputDataConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentClassifierOutputDataConfig = (
  input: DocumentClassifierOutputDataConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1DominantLanguageDetectionJobFilter = (
  input: DominantLanguageDetectionJobFilter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1EndpointFilter = (
  input: EndpointFilter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.ModelArn !== undefined) {
    bodyParams["ModelArn"] = input.ModelArn;
  }
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  return bodyParams;
};

const serializeAws_json1_1EntitiesDetectionJobFilter = (
  input: EntitiesDetectionJobFilter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerAnnotations = (
  input: EntityRecognizerAnnotations,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerDocuments = (
  input: EntityRecognizerDocuments,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerEntityList = (
  input: EntityRecognizerEntityList,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerFilter = (
  input: EntityRecognizerFilter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerInputDataConfig = (
  input: EntityRecognizerInputDataConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Annotations !== undefined) {
    bodyParams["Annotations"] = serializeAws_json1_1EntityRecognizerAnnotations(
      input.Annotations,
      context
    );
  }
  if (input.Documents !== undefined) {
    bodyParams["Documents"] = serializeAws_json1_1EntityRecognizerDocuments(
      input.Documents,
      context
    );
  }
  if (input.EntityList !== undefined) {
    bodyParams["EntityList"] = serializeAws_json1_1EntityRecognizerEntityList(
      input.EntityList,
      context
    );
  }
  if (input.EntityTypes !== undefined) {
    bodyParams["EntityTypes"] = serializeAws_json1_1EntityTypesList(
      input.EntityTypes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1EntityTypesList = (
  input: Array<EntityTypesListItem>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1EntityTypesListItem(entry, context)
  );
};

const serializeAws_json1_1EntityTypesListItem = (
  input: EntityTypesListItem,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1InputDataConfig = (
  input: InputDataConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.InputFormat !== undefined) {
    bodyParams["InputFormat"] = input.InputFormat;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1KeyPhrasesDetectionJobFilter = (
  input: KeyPhrasesDetectionJobFilter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ListDocumentClassificationJobsRequest = (
  input: ListDocumentClassificationJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1DocumentClassificationJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListDocumentClassifiersRequest = (
  input: ListDocumentClassifiersRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1DocumentClassifierFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListDominantLanguageDetectionJobsRequest = (
  input: ListDominantLanguageDetectionJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams[
      "Filter"
    ] = serializeAws_json1_1DominantLanguageDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListEndpointsRequest = (
  input: ListEndpointsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1EndpointFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListEntitiesDetectionJobsRequest = (
  input: ListEntitiesDetectionJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1EntitiesDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListEntityRecognizersRequest = (
  input: ListEntityRecognizersRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1EntityRecognizerFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListKeyPhrasesDetectionJobsRequest = (
  input: ListKeyPhrasesDetectionJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1KeyPhrasesDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSentimentDetectionJobsRequest = (
  input: ListSentimentDetectionJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1SentimentDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsForResourceRequest = (
  input: ListTagsForResourceRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTopicsDetectionJobsRequest = (
  input: ListTopicsDetectionJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1TopicsDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1OutputDataConfig = (
  input: OutputDataConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1SecurityGroupIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1SentimentDetectionJobFilter = (
  input: SentimentDetectionJobFilter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartDocumentClassificationJobRequest = (
  input: StartDocumentClassificationJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.DocumentClassifierArn !== undefined) {
    bodyParams["DocumentClassifierArn"] = input.DocumentClassifierArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartDominantLanguageDetectionJobRequest = (
  input: StartDominantLanguageDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartEntitiesDetectionJobRequest = (
  input: StartEntitiesDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.EntityRecognizerArn !== undefined) {
    bodyParams["EntityRecognizerArn"] = input.EntityRecognizerArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartKeyPhrasesDetectionJobRequest = (
  input: StartKeyPhrasesDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartSentimentDetectionJobRequest = (
  input: StartSentimentDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartTopicsDetectionJobRequest = (
  input: StartTopicsDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.NumberOfTopics !== undefined) {
    bodyParams["NumberOfTopics"] = input.NumberOfTopics;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StopDominantLanguageDetectionJobRequest = (
  input: StopDominantLanguageDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopEntitiesDetectionJobRequest = (
  input: StopEntitiesDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopKeyPhrasesDetectionJobRequest = (
  input: StopKeyPhrasesDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopSentimentDetectionJobRequest = (
  input: StopSentimentDetectionJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopTrainingDocumentClassifierRequest = (
  input: StopTrainingDocumentClassifierRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DocumentClassifierArn !== undefined) {
    bodyParams["DocumentClassifierArn"] = input.DocumentClassifierArn;
  }
  return bodyParams;
};

const serializeAws_json1_1StopTrainingEntityRecognizerRequest = (
  input: StopTrainingEntityRecognizerRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EntityRecognizerArn !== undefined) {
    bodyParams["EntityRecognizerArn"] = input.EntityRecognizerArn;
  }
  return bodyParams;
};

const serializeAws_json1_1StringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1Subnets = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  let bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => serializeAws_json1_1Tag(entry, context));
};

const serializeAws_json1_1TagResourceRequest = (
  input: TagResourceRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1TopicsDetectionJobFilter = (
  input: TopicsDetectionJobFilter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UntagResourceRequest = (
  input: UntagResourceRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1TagKeyList(
      input.TagKeys,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateEndpointRequest = (
  input: UpdateEndpointRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DesiredInferenceUnits !== undefined) {
    bodyParams["DesiredInferenceUnits"] = input.DesiredInferenceUnits;
  }
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1VpcConfig = (
  input: VpcConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.SecurityGroupIds !== undefined) {
    bodyParams["SecurityGroupIds"] = serializeAws_json1_1SecurityGroupIds(
      input.SecurityGroupIds,
      context
    );
  }
  if (input.Subnets !== undefined) {
    bodyParams["Subnets"] = serializeAws_json1_1Subnets(input.Subnets, context);
  }
  return bodyParams;
};

const deserializeAws_json1_1BatchDetectDominantLanguageItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectDominantLanguageItemResult => {
  let contents: any = {
    __type: "BatchDetectDominantLanguageItemResult",
    Index: undefined,
    Languages: undefined
  };
  if (output.Index !== undefined) {
    contents.Index = output.Index;
  }
  if (output.Languages !== undefined) {
    contents.Languages = deserializeAws_json1_1ListOfDominantLanguages(
      output.Languages,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectDominantLanguageResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectDominantLanguageResponse => {
  let contents: any = {
    __type: "BatchDetectDominantLanguageResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectDominantLanguageResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectEntitiesItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectEntitiesItemResult => {
  let contents: any = {
    __type: "BatchDetectEntitiesItemResult",
    Entities: undefined,
    Index: undefined
  };
  if (output.Entities !== undefined) {
    contents.Entities = deserializeAws_json1_1ListOfEntities(
      output.Entities,
      context
    );
  }
  if (output.Index !== undefined) {
    contents.Index = output.Index;
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectEntitiesResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectEntitiesResponse => {
  let contents: any = {
    __type: "BatchDetectEntitiesResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectEntitiesResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectKeyPhrasesItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectKeyPhrasesItemResult => {
  let contents: any = {
    __type: "BatchDetectKeyPhrasesItemResult",
    Index: undefined,
    KeyPhrases: undefined
  };
  if (output.Index !== undefined) {
    contents.Index = output.Index;
  }
  if (output.KeyPhrases !== undefined) {
    contents.KeyPhrases = deserializeAws_json1_1ListOfKeyPhrases(
      output.KeyPhrases,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectKeyPhrasesResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectKeyPhrasesResponse => {
  let contents: any = {
    __type: "BatchDetectKeyPhrasesResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectKeyPhrasesResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectSentimentItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectSentimentItemResult => {
  let contents: any = {
    __type: "BatchDetectSentimentItemResult",
    Index: undefined,
    Sentiment: undefined,
    SentimentScore: undefined
  };
  if (output.Index !== undefined) {
    contents.Index = output.Index;
  }
  if (output.Sentiment !== undefined) {
    contents.Sentiment = output.Sentiment;
  }
  if (output.SentimentScore !== undefined) {
    contents.SentimentScore = deserializeAws_json1_1SentimentScore(
      output.SentimentScore,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectSentimentResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectSentimentResponse => {
  let contents: any = {
    __type: "BatchDetectSentimentResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectSentimentResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectSyntaxItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectSyntaxItemResult => {
  let contents: any = {
    __type: "BatchDetectSyntaxItemResult",
    Index: undefined,
    SyntaxTokens: undefined
  };
  if (output.Index !== undefined) {
    contents.Index = output.Index;
  }
  if (output.SyntaxTokens !== undefined) {
    contents.SyntaxTokens = deserializeAws_json1_1ListOfSyntaxTokens(
      output.SyntaxTokens,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectSyntaxResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectSyntaxResponse => {
  let contents: any = {
    __type: "BatchDetectSyntaxResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectSyntaxResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchItemError = (
  output: any,
  context: __SerdeContext
): BatchItemError => {
  let contents: any = {
    __type: "BatchItemError",
    ErrorCode: undefined,
    ErrorMessage: undefined,
    Index: undefined
  };
  if (output.ErrorCode !== undefined) {
    contents.ErrorCode = output.ErrorCode;
  }
  if (output.ErrorMessage !== undefined) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.Index !== undefined) {
    contents.Index = output.Index;
  }
  return contents;
};

const deserializeAws_json1_1BatchItemErrorList = (
  output: any,
  context: __SerdeContext
): Array<BatchItemError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchItemError(entry, context)
  );
};

const deserializeAws_json1_1BatchSizeLimitExceededException = (
  output: any,
  context: __SerdeContext
): BatchSizeLimitExceededException => {
  let contents: any = {
    __type: "BatchSizeLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ClassifierEvaluationMetrics = (
  output: any,
  context: __SerdeContext
): ClassifierEvaluationMetrics => {
  let contents: any = {
    __type: "ClassifierEvaluationMetrics",
    Accuracy: undefined,
    F1Score: undefined,
    Precision: undefined,
    Recall: undefined
  };
  if (output.Accuracy !== undefined) {
    contents.Accuracy = output.Accuracy;
  }
  if (output.F1Score !== undefined) {
    contents.F1Score = output.F1Score;
  }
  if (output.Precision !== undefined) {
    contents.Precision = output.Precision;
  }
  if (output.Recall !== undefined) {
    contents.Recall = output.Recall;
  }
  return contents;
};

const deserializeAws_json1_1ClassifierMetadata = (
  output: any,
  context: __SerdeContext
): ClassifierMetadata => {
  let contents: any = {
    __type: "ClassifierMetadata",
    EvaluationMetrics: undefined,
    NumberOfLabels: undefined,
    NumberOfTestDocuments: undefined,
    NumberOfTrainedDocuments: undefined
  };
  if (output.EvaluationMetrics !== undefined) {
    contents.EvaluationMetrics = deserializeAws_json1_1ClassifierEvaluationMetrics(
      output.EvaluationMetrics,
      context
    );
  }
  if (output.NumberOfLabels !== undefined) {
    contents.NumberOfLabels = output.NumberOfLabels;
  }
  if (output.NumberOfTestDocuments !== undefined) {
    contents.NumberOfTestDocuments = output.NumberOfTestDocuments;
  }
  if (output.NumberOfTrainedDocuments !== undefined) {
    contents.NumberOfTrainedDocuments = output.NumberOfTrainedDocuments;
  }
  return contents;
};

const deserializeAws_json1_1ClassifyDocumentResponse = (
  output: any,
  context: __SerdeContext
): ClassifyDocumentResponse => {
  let contents: any = {
    __type: "ClassifyDocumentResponse",
    Classes: undefined
  };
  if (output.Classes !== undefined) {
    contents.Classes = deserializeAws_json1_1ListOfClasses(
      output.Classes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ConcurrentModificationException = (
  output: any,
  context: __SerdeContext
): ConcurrentModificationException => {
  let contents: any = {
    __type: "ConcurrentModificationException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1CreateDocumentClassifierResponse = (
  output: any,
  context: __SerdeContext
): CreateDocumentClassifierResponse => {
  let contents: any = {
    __type: "CreateDocumentClassifierResponse",
    DocumentClassifierArn: undefined
  };
  if (output.DocumentClassifierArn !== undefined) {
    contents.DocumentClassifierArn = output.DocumentClassifierArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateEndpointResponse = (
  output: any,
  context: __SerdeContext
): CreateEndpointResponse => {
  let contents: any = {
    __type: "CreateEndpointResponse",
    EndpointArn: undefined
  };
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateEntityRecognizerResponse = (
  output: any,
  context: __SerdeContext
): CreateEntityRecognizerResponse => {
  let contents: any = {
    __type: "CreateEntityRecognizerResponse",
    EntityRecognizerArn: undefined
  };
  if (output.EntityRecognizerArn !== undefined) {
    contents.EntityRecognizerArn = output.EntityRecognizerArn;
  }
  return contents;
};

const deserializeAws_json1_1DeleteDocumentClassifierResponse = (
  output: any,
  context: __SerdeContext
): DeleteDocumentClassifierResponse => {
  let contents: any = {
    __type: "DeleteDocumentClassifierResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteEndpointResponse = (
  output: any,
  context: __SerdeContext
): DeleteEndpointResponse => {
  let contents: any = {
    __type: "DeleteEndpointResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteEntityRecognizerResponse = (
  output: any,
  context: __SerdeContext
): DeleteEntityRecognizerResponse => {
  let contents: any = {
    __type: "DeleteEntityRecognizerResponse"
  };
  return contents;
};

const deserializeAws_json1_1DescribeDocumentClassificationJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeDocumentClassificationJobResponse => {
  let contents: any = {
    __type: "DescribeDocumentClassificationJobResponse",
    DocumentClassificationJobProperties: undefined
  };
  if (output.DocumentClassificationJobProperties !== undefined) {
    contents.DocumentClassificationJobProperties = deserializeAws_json1_1DocumentClassificationJobProperties(
      output.DocumentClassificationJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeDocumentClassifierResponse = (
  output: any,
  context: __SerdeContext
): DescribeDocumentClassifierResponse => {
  let contents: any = {
    __type: "DescribeDocumentClassifierResponse",
    DocumentClassifierProperties: undefined
  };
  if (output.DocumentClassifierProperties !== undefined) {
    contents.DocumentClassifierProperties = deserializeAws_json1_1DocumentClassifierProperties(
      output.DocumentClassifierProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeDominantLanguageDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeDominantLanguageDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeDominantLanguageDetectionJobResponse",
    DominantLanguageDetectionJobProperties: undefined
  };
  if (output.DominantLanguageDetectionJobProperties !== undefined) {
    contents.DominantLanguageDetectionJobProperties = deserializeAws_json1_1DominantLanguageDetectionJobProperties(
      output.DominantLanguageDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEndpointResponse = (
  output: any,
  context: __SerdeContext
): DescribeEndpointResponse => {
  let contents: any = {
    __type: "DescribeEndpointResponse",
    EndpointProperties: undefined
  };
  if (output.EndpointProperties !== undefined) {
    contents.EndpointProperties = deserializeAws_json1_1EndpointProperties(
      output.EndpointProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEntitiesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeEntitiesDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeEntitiesDetectionJobResponse",
    EntitiesDetectionJobProperties: undefined
  };
  if (output.EntitiesDetectionJobProperties !== undefined) {
    contents.EntitiesDetectionJobProperties = deserializeAws_json1_1EntitiesDetectionJobProperties(
      output.EntitiesDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEntityRecognizerResponse = (
  output: any,
  context: __SerdeContext
): DescribeEntityRecognizerResponse => {
  let contents: any = {
    __type: "DescribeEntityRecognizerResponse",
    EntityRecognizerProperties: undefined
  };
  if (output.EntityRecognizerProperties !== undefined) {
    contents.EntityRecognizerProperties = deserializeAws_json1_1EntityRecognizerProperties(
      output.EntityRecognizerProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeKeyPhrasesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeKeyPhrasesDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeKeyPhrasesDetectionJobResponse",
    KeyPhrasesDetectionJobProperties: undefined
  };
  if (output.KeyPhrasesDetectionJobProperties !== undefined) {
    contents.KeyPhrasesDetectionJobProperties = deserializeAws_json1_1KeyPhrasesDetectionJobProperties(
      output.KeyPhrasesDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeSentimentDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeSentimentDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeSentimentDetectionJobResponse",
    SentimentDetectionJobProperties: undefined
  };
  if (output.SentimentDetectionJobProperties !== undefined) {
    contents.SentimentDetectionJobProperties = deserializeAws_json1_1SentimentDetectionJobProperties(
      output.SentimentDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeTopicsDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeTopicsDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeTopicsDetectionJobResponse",
    TopicsDetectionJobProperties: undefined
  };
  if (output.TopicsDetectionJobProperties !== undefined) {
    contents.TopicsDetectionJobProperties = deserializeAws_json1_1TopicsDetectionJobProperties(
      output.TopicsDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectDominantLanguageResponse = (
  output: any,
  context: __SerdeContext
): DetectDominantLanguageResponse => {
  let contents: any = {
    __type: "DetectDominantLanguageResponse",
    Languages: undefined
  };
  if (output.Languages !== undefined) {
    contents.Languages = deserializeAws_json1_1ListOfDominantLanguages(
      output.Languages,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectEntitiesResponse = (
  output: any,
  context: __SerdeContext
): DetectEntitiesResponse => {
  let contents: any = {
    __type: "DetectEntitiesResponse",
    Entities: undefined
  };
  if (output.Entities !== undefined) {
    contents.Entities = deserializeAws_json1_1ListOfEntities(
      output.Entities,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectKeyPhrasesResponse = (
  output: any,
  context: __SerdeContext
): DetectKeyPhrasesResponse => {
  let contents: any = {
    __type: "DetectKeyPhrasesResponse",
    KeyPhrases: undefined
  };
  if (output.KeyPhrases !== undefined) {
    contents.KeyPhrases = deserializeAws_json1_1ListOfKeyPhrases(
      output.KeyPhrases,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectSentimentResponse = (
  output: any,
  context: __SerdeContext
): DetectSentimentResponse => {
  let contents: any = {
    __type: "DetectSentimentResponse",
    Sentiment: undefined,
    SentimentScore: undefined
  };
  if (output.Sentiment !== undefined) {
    contents.Sentiment = output.Sentiment;
  }
  if (output.SentimentScore !== undefined) {
    contents.SentimentScore = deserializeAws_json1_1SentimentScore(
      output.SentimentScore,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectSyntaxResponse = (
  output: any,
  context: __SerdeContext
): DetectSyntaxResponse => {
  let contents: any = {
    __type: "DetectSyntaxResponse",
    SyntaxTokens: undefined
  };
  if (output.SyntaxTokens !== undefined) {
    contents.SyntaxTokens = deserializeAws_json1_1ListOfSyntaxTokens(
      output.SyntaxTokens,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DocumentClass = (
  output: any,
  context: __SerdeContext
): DocumentClass => {
  let contents: any = {
    __type: "DocumentClass",
    Name: undefined,
    Score: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.Score !== undefined) {
    contents.Score = output.Score;
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassificationJobProperties = (
  output: any,
  context: __SerdeContext
): DocumentClassificationJobProperties => {
  let contents: any = {
    __type: "DocumentClassificationJobProperties",
    DataAccessRoleArn: undefined,
    DocumentClassifierArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (output.DataAccessRoleArn !== undefined) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.DocumentClassifierArn !== undefined) {
    contents.DocumentClassifierArn = output.DocumentClassifierArn;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(
      output.EndTime % 1 != 0
        ? Math.round(output.EndTime * 1000)
        : output.EndTime
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined) {
    contents.SubmitTime = new Date(
      output.SubmitTime % 1 != 0
        ? Math.round(output.SubmitTime * 1000)
        : output.SubmitTime
    );
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassificationJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<DocumentClassificationJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentClassificationJobProperties(entry, context)
  );
};

const deserializeAws_json1_1DocumentClassifierInputDataConfig = (
  output: any,
  context: __SerdeContext
): DocumentClassifierInputDataConfig => {
  let contents: any = {
    __type: "DocumentClassifierInputDataConfig",
    S3Uri: undefined
  };
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassifierOutputDataConfig = (
  output: any,
  context: __SerdeContext
): DocumentClassifierOutputDataConfig => {
  let contents: any = {
    __type: "DocumentClassifierOutputDataConfig",
    KmsKeyId: undefined,
    S3Uri: undefined
  };
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassifierProperties = (
  output: any,
  context: __SerdeContext
): DocumentClassifierProperties => {
  let contents: any = {
    __type: "DocumentClassifierProperties",
    ClassifierMetadata: undefined,
    DataAccessRoleArn: undefined,
    DocumentClassifierArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    LanguageCode: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    Status: undefined,
    SubmitTime: undefined,
    TrainingEndTime: undefined,
    TrainingStartTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (output.ClassifierMetadata !== undefined) {
    contents.ClassifierMetadata = deserializeAws_json1_1ClassifierMetadata(
      output.ClassifierMetadata,
      context
    );
  }
  if (output.DataAccessRoleArn !== undefined) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.DocumentClassifierArn !== undefined) {
    contents.DocumentClassifierArn = output.DocumentClassifierArn;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(
      output.EndTime % 1 != 0
        ? Math.round(output.EndTime * 1000)
        : output.EndTime
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1DocumentClassifierInputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.LanguageCode !== undefined) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1DocumentClassifierOutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.SubmitTime !== undefined) {
    contents.SubmitTime = new Date(
      output.SubmitTime % 1 != 0
        ? Math.round(output.SubmitTime * 1000)
        : output.SubmitTime
    );
  }
  if (output.TrainingEndTime !== undefined) {
    contents.TrainingEndTime = new Date(
      output.TrainingEndTime % 1 != 0
        ? Math.round(output.TrainingEndTime * 1000)
        : output.TrainingEndTime
    );
  }
  if (output.TrainingStartTime !== undefined) {
    contents.TrainingStartTime = new Date(
      output.TrainingStartTime % 1 != 0
        ? Math.round(output.TrainingStartTime * 1000)
        : output.TrainingStartTime
    );
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassifierPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<DocumentClassifierProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentClassifierProperties(entry, context)
  );
};

const deserializeAws_json1_1DominantLanguage = (
  output: any,
  context: __SerdeContext
): DominantLanguage => {
  let contents: any = {
    __type: "DominantLanguage",
    LanguageCode: undefined,
    Score: undefined
  };
  if (output.LanguageCode !== undefined) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Score !== undefined) {
    contents.Score = output.Score;
  }
  return contents;
};

const deserializeAws_json1_1DominantLanguageDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): DominantLanguageDetectionJobProperties => {
  let contents: any = {
    __type: "DominantLanguageDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (output.DataAccessRoleArn !== undefined) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(
      output.EndTime % 1 != 0
        ? Math.round(output.EndTime * 1000)
        : output.EndTime
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined) {
    contents.SubmitTime = new Date(
      output.SubmitTime % 1 != 0
        ? Math.round(output.SubmitTime * 1000)
        : output.SubmitTime
    );
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DominantLanguageDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<DominantLanguageDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DominantLanguageDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1EndpointProperties = (
  output: any,
  context: __SerdeContext
): EndpointProperties => {
  let contents: any = {
    __type: "EndpointProperties",
    CreationTime: undefined,
    CurrentInferenceUnits: undefined,
    DesiredInferenceUnits: undefined,
    EndpointArn: undefined,
    LastModifiedTime: undefined,
    Message: undefined,
    ModelArn: undefined,
    Status: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(
      output.CreationTime % 1 != 0
        ? Math.round(output.CreationTime * 1000)
        : output.CreationTime
    );
  }
  if (output.CurrentInferenceUnits !== undefined) {
    contents.CurrentInferenceUnits = output.CurrentInferenceUnits;
  }
  if (output.DesiredInferenceUnits !== undefined) {
    contents.DesiredInferenceUnits = output.DesiredInferenceUnits;
  }
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      output.LastModifiedTime % 1 != 0
        ? Math.round(output.LastModifiedTime * 1000)
        : output.LastModifiedTime
    );
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.ModelArn !== undefined) {
    contents.ModelArn = output.ModelArn;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1EndpointPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<EndpointProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EndpointProperties(entry, context)
  );
};

const deserializeAws_json1_1EntitiesDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): EntitiesDetectionJobProperties => {
  let contents: any = {
    __type: "EntitiesDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    EntityRecognizerArn: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    LanguageCode: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (output.DataAccessRoleArn !== undefined) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(
      output.EndTime % 1 != 0
        ? Math.round(output.EndTime * 1000)
        : output.EndTime
    );
  }
  if (output.EntityRecognizerArn !== undefined) {
    contents.EntityRecognizerArn = output.EntityRecognizerArn;
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.LanguageCode !== undefined) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined) {
    contents.SubmitTime = new Date(
      output.SubmitTime % 1 != 0
        ? Math.round(output.SubmitTime * 1000)
        : output.SubmitTime
    );
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1EntitiesDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<EntitiesDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EntitiesDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1Entity = (
  output: any,
  context: __SerdeContext
): Entity => {
  let contents: any = {
    __type: "Entity",
    BeginOffset: undefined,
    EndOffset: undefined,
    Score: undefined,
    Text: undefined,
    Type: undefined
  };
  if (output.BeginOffset !== undefined) {
    contents.BeginOffset = output.BeginOffset;
  }
  if (output.EndOffset !== undefined) {
    contents.EndOffset = output.EndOffset;
  }
  if (output.Score !== undefined) {
    contents.Score = output.Score;
  }
  if (output.Text !== undefined) {
    contents.Text = output.Text;
  }
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerAnnotations = (
  output: any,
  context: __SerdeContext
): EntityRecognizerAnnotations => {
  let contents: any = {
    __type: "EntityRecognizerAnnotations",
    S3Uri: undefined
  };
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerDocuments = (
  output: any,
  context: __SerdeContext
): EntityRecognizerDocuments => {
  let contents: any = {
    __type: "EntityRecognizerDocuments",
    S3Uri: undefined
  };
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerEntityList = (
  output: any,
  context: __SerdeContext
): EntityRecognizerEntityList => {
  let contents: any = {
    __type: "EntityRecognizerEntityList",
    S3Uri: undefined
  };
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerEvaluationMetrics = (
  output: any,
  context: __SerdeContext
): EntityRecognizerEvaluationMetrics => {
  let contents: any = {
    __type: "EntityRecognizerEvaluationMetrics",
    F1Score: undefined,
    Precision: undefined,
    Recall: undefined
  };
  if (output.F1Score !== undefined) {
    contents.F1Score = output.F1Score;
  }
  if (output.Precision !== undefined) {
    contents.Precision = output.Precision;
  }
  if (output.Recall !== undefined) {
    contents.Recall = output.Recall;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerInputDataConfig = (
  output: any,
  context: __SerdeContext
): EntityRecognizerInputDataConfig => {
  let contents: any = {
    __type: "EntityRecognizerInputDataConfig",
    Annotations: undefined,
    Documents: undefined,
    EntityList: undefined,
    EntityTypes: undefined
  };
  if (output.Annotations !== undefined) {
    contents.Annotations = deserializeAws_json1_1EntityRecognizerAnnotations(
      output.Annotations,
      context
    );
  }
  if (output.Documents !== undefined) {
    contents.Documents = deserializeAws_json1_1EntityRecognizerDocuments(
      output.Documents,
      context
    );
  }
  if (output.EntityList !== undefined) {
    contents.EntityList = deserializeAws_json1_1EntityRecognizerEntityList(
      output.EntityList,
      context
    );
  }
  if (output.EntityTypes !== undefined) {
    contents.EntityTypes = deserializeAws_json1_1EntityTypesList(
      output.EntityTypes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerMetadata = (
  output: any,
  context: __SerdeContext
): EntityRecognizerMetadata => {
  let contents: any = {
    __type: "EntityRecognizerMetadata",
    EntityTypes: undefined,
    EvaluationMetrics: undefined,
    NumberOfTestDocuments: undefined,
    NumberOfTrainedDocuments: undefined
  };
  if (output.EntityTypes !== undefined) {
    contents.EntityTypes = deserializeAws_json1_1EntityRecognizerMetadataEntityTypesList(
      output.EntityTypes,
      context
    );
  }
  if (output.EvaluationMetrics !== undefined) {
    contents.EvaluationMetrics = deserializeAws_json1_1EntityRecognizerEvaluationMetrics(
      output.EvaluationMetrics,
      context
    );
  }
  if (output.NumberOfTestDocuments !== undefined) {
    contents.NumberOfTestDocuments = output.NumberOfTestDocuments;
  }
  if (output.NumberOfTrainedDocuments !== undefined) {
    contents.NumberOfTrainedDocuments = output.NumberOfTrainedDocuments;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerMetadataEntityTypesList = (
  output: any,
  context: __SerdeContext
): Array<EntityRecognizerMetadataEntityTypesListItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EntityRecognizerMetadataEntityTypesListItem(
      entry,
      context
    )
  );
};

const deserializeAws_json1_1EntityRecognizerMetadataEntityTypesListItem = (
  output: any,
  context: __SerdeContext
): EntityRecognizerMetadataEntityTypesListItem => {
  let contents: any = {
    __type: "EntityRecognizerMetadataEntityTypesListItem",
    EvaluationMetrics: undefined,
    NumberOfTrainMentions: undefined,
    Type: undefined
  };
  if (output.EvaluationMetrics !== undefined) {
    contents.EvaluationMetrics = deserializeAws_json1_1EntityTypesEvaluationMetrics(
      output.EvaluationMetrics,
      context
    );
  }
  if (output.NumberOfTrainMentions !== undefined) {
    contents.NumberOfTrainMentions = output.NumberOfTrainMentions;
  }
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerProperties = (
  output: any,
  context: __SerdeContext
): EntityRecognizerProperties => {
  let contents: any = {
    __type: "EntityRecognizerProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    EntityRecognizerArn: undefined,
    InputDataConfig: undefined,
    LanguageCode: undefined,
    Message: undefined,
    RecognizerMetadata: undefined,
    Status: undefined,
    SubmitTime: undefined,
    TrainingEndTime: undefined,
    TrainingStartTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (output.DataAccessRoleArn !== undefined) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(
      output.EndTime % 1 != 0
        ? Math.round(output.EndTime * 1000)
        : output.EndTime
    );
  }
  if (output.EntityRecognizerArn !== undefined) {
    contents.EntityRecognizerArn = output.EntityRecognizerArn;
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1EntityRecognizerInputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.LanguageCode !== undefined) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.RecognizerMetadata !== undefined) {
    contents.RecognizerMetadata = deserializeAws_json1_1EntityRecognizerMetadata(
      output.RecognizerMetadata,
      context
    );
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.SubmitTime !== undefined) {
    contents.SubmitTime = new Date(
      output.SubmitTime % 1 != 0
        ? Math.round(output.SubmitTime * 1000)
        : output.SubmitTime
    );
  }
  if (output.TrainingEndTime !== undefined) {
    contents.TrainingEndTime = new Date(
      output.TrainingEndTime % 1 != 0
        ? Math.round(output.TrainingEndTime * 1000)
        : output.TrainingEndTime
    );
  }
  if (output.TrainingStartTime !== undefined) {
    contents.TrainingStartTime = new Date(
      output.TrainingStartTime % 1 != 0
        ? Math.round(output.TrainingStartTime * 1000)
        : output.TrainingStartTime
    );
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<EntityRecognizerProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EntityRecognizerProperties(entry, context)
  );
};

const deserializeAws_json1_1EntityTypesEvaluationMetrics = (
  output: any,
  context: __SerdeContext
): EntityTypesEvaluationMetrics => {
  let contents: any = {
    __type: "EntityTypesEvaluationMetrics",
    F1Score: undefined,
    Precision: undefined,
    Recall: undefined
  };
  if (output.F1Score !== undefined) {
    contents.F1Score = output.F1Score;
  }
  if (output.Precision !== undefined) {
    contents.Precision = output.Precision;
  }
  if (output.Recall !== undefined) {
    contents.Recall = output.Recall;
  }
  return contents;
};

const deserializeAws_json1_1EntityTypesList = (
  output: any,
  context: __SerdeContext
): Array<EntityTypesListItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EntityTypesListItem(entry, context)
  );
};

const deserializeAws_json1_1EntityTypesListItem = (
  output: any,
  context: __SerdeContext
): EntityTypesListItem => {
  let contents: any = {
    __type: "EntityTypesListItem",
    Type: undefined
  };
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1InputDataConfig = (
  output: any,
  context: __SerdeContext
): InputDataConfig => {
  let contents: any = {
    __type: "InputDataConfig",
    InputFormat: undefined,
    S3Uri: undefined
  };
  if (output.InputFormat !== undefined) {
    contents.InputFormat = output.InputFormat;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1InternalServerException = (
  output: any,
  context: __SerdeContext
): InternalServerException => {
  let contents: any = {
    __type: "InternalServerException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidFilterException = (
  output: any,
  context: __SerdeContext
): InvalidFilterException => {
  let contents: any = {
    __type: "InvalidFilterException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRequestException = (
  output: any,
  context: __SerdeContext
): InvalidRequestException => {
  let contents: any = {
    __type: "InvalidRequestException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1JobNotFoundException = (
  output: any,
  context: __SerdeContext
): JobNotFoundException => {
  let contents: any = {
    __type: "JobNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1KeyPhrase = (
  output: any,
  context: __SerdeContext
): KeyPhrase => {
  let contents: any = {
    __type: "KeyPhrase",
    BeginOffset: undefined,
    EndOffset: undefined,
    Score: undefined,
    Text: undefined
  };
  if (output.BeginOffset !== undefined) {
    contents.BeginOffset = output.BeginOffset;
  }
  if (output.EndOffset !== undefined) {
    contents.EndOffset = output.EndOffset;
  }
  if (output.Score !== undefined) {
    contents.Score = output.Score;
  }
  if (output.Text !== undefined) {
    contents.Text = output.Text;
  }
  return contents;
};

const deserializeAws_json1_1KeyPhrasesDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): KeyPhrasesDetectionJobProperties => {
  let contents: any = {
    __type: "KeyPhrasesDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    LanguageCode: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (output.DataAccessRoleArn !== undefined) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(
      output.EndTime % 1 != 0
        ? Math.round(output.EndTime * 1000)
        : output.EndTime
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.LanguageCode !== undefined) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined) {
    contents.SubmitTime = new Date(
      output.SubmitTime % 1 != 0
        ? Math.round(output.SubmitTime * 1000)
        : output.SubmitTime
    );
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1KeyPhrasesDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<KeyPhrasesDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1KeyPhrasesDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1KmsKeyValidationException = (
  output: any,
  context: __SerdeContext
): KmsKeyValidationException => {
  let contents: any = {
    __type: "KmsKeyValidationException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ListDocumentClassificationJobsResponse = (
  output: any,
  context: __SerdeContext
): ListDocumentClassificationJobsResponse => {
  let contents: any = {
    __type: "ListDocumentClassificationJobsResponse",
    DocumentClassificationJobPropertiesList: undefined,
    NextToken: undefined
  };
  if (output.DocumentClassificationJobPropertiesList !== undefined) {
    contents.DocumentClassificationJobPropertiesList = deserializeAws_json1_1DocumentClassificationJobPropertiesList(
      output.DocumentClassificationJobPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListDocumentClassifiersResponse = (
  output: any,
  context: __SerdeContext
): ListDocumentClassifiersResponse => {
  let contents: any = {
    __type: "ListDocumentClassifiersResponse",
    DocumentClassifierPropertiesList: undefined,
    NextToken: undefined
  };
  if (output.DocumentClassifierPropertiesList !== undefined) {
    contents.DocumentClassifierPropertiesList = deserializeAws_json1_1DocumentClassifierPropertiesList(
      output.DocumentClassifierPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListDominantLanguageDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListDominantLanguageDetectionJobsResponse => {
  let contents: any = {
    __type: "ListDominantLanguageDetectionJobsResponse",
    DominantLanguageDetectionJobPropertiesList: undefined,
    NextToken: undefined
  };
  if (output.DominantLanguageDetectionJobPropertiesList !== undefined) {
    contents.DominantLanguageDetectionJobPropertiesList = deserializeAws_json1_1DominantLanguageDetectionJobPropertiesList(
      output.DominantLanguageDetectionJobPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListEndpointsResponse = (
  output: any,
  context: __SerdeContext
): ListEndpointsResponse => {
  let contents: any = {
    __type: "ListEndpointsResponse",
    EndpointPropertiesList: undefined,
    NextToken: undefined
  };
  if (output.EndpointPropertiesList !== undefined) {
    contents.EndpointPropertiesList = deserializeAws_json1_1EndpointPropertiesList(
      output.EndpointPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListEntitiesDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListEntitiesDetectionJobsResponse => {
  let contents: any = {
    __type: "ListEntitiesDetectionJobsResponse",
    EntitiesDetectionJobPropertiesList: undefined,
    NextToken: undefined
  };
  if (output.EntitiesDetectionJobPropertiesList !== undefined) {
    contents.EntitiesDetectionJobPropertiesList = deserializeAws_json1_1EntitiesDetectionJobPropertiesList(
      output.EntitiesDetectionJobPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListEntityRecognizersResponse = (
  output: any,
  context: __SerdeContext
): ListEntityRecognizersResponse => {
  let contents: any = {
    __type: "ListEntityRecognizersResponse",
    EntityRecognizerPropertiesList: undefined,
    NextToken: undefined
  };
  if (output.EntityRecognizerPropertiesList !== undefined) {
    contents.EntityRecognizerPropertiesList = deserializeAws_json1_1EntityRecognizerPropertiesList(
      output.EntityRecognizerPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListKeyPhrasesDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListKeyPhrasesDetectionJobsResponse => {
  let contents: any = {
    __type: "ListKeyPhrasesDetectionJobsResponse",
    KeyPhrasesDetectionJobPropertiesList: undefined,
    NextToken: undefined
  };
  if (output.KeyPhrasesDetectionJobPropertiesList !== undefined) {
    contents.KeyPhrasesDetectionJobPropertiesList = deserializeAws_json1_1KeyPhrasesDetectionJobPropertiesList(
      output.KeyPhrasesDetectionJobPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListOfClasses = (
  output: any,
  context: __SerdeContext
): Array<DocumentClass> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentClass(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectDominantLanguageResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectDominantLanguageItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectDominantLanguageItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectEntitiesResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectEntitiesItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectEntitiesItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectKeyPhrasesResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectKeyPhrasesItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectKeyPhrasesItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectSentimentResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectSentimentItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectSentimentItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectSyntaxResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectSyntaxItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectSyntaxItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDominantLanguages = (
  output: any,
  context: __SerdeContext
): Array<DominantLanguage> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DominantLanguage(entry, context)
  );
};

const deserializeAws_json1_1ListOfEntities = (
  output: any,
  context: __SerdeContext
): Array<Entity> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Entity(entry, context)
  );
};

const deserializeAws_json1_1ListOfKeyPhrases = (
  output: any,
  context: __SerdeContext
): Array<KeyPhrase> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1KeyPhrase(entry, context)
  );
};

const deserializeAws_json1_1ListOfSyntaxTokens = (
  output: any,
  context: __SerdeContext
): Array<SyntaxToken> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SyntaxToken(entry, context)
  );
};

const deserializeAws_json1_1ListSentimentDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListSentimentDetectionJobsResponse => {
  let contents: any = {
    __type: "ListSentimentDetectionJobsResponse",
    NextToken: undefined,
    SentimentDetectionJobPropertiesList: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.SentimentDetectionJobPropertiesList !== undefined) {
    contents.SentimentDetectionJobPropertiesList = deserializeAws_json1_1SentimentDetectionJobPropertiesList(
      output.SentimentDetectionJobPropertiesList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTagsForResourceResponse = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResponse => {
  let contents: any = {
    __type: "ListTagsForResourceResponse",
    ResourceArn: undefined,
    Tags: undefined
  };
  if (output.ResourceArn !== undefined) {
    contents.ResourceArn = output.ResourceArn;
  }
  if (output.Tags !== undefined) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1ListTopicsDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListTopicsDetectionJobsResponse => {
  let contents: any = {
    __type: "ListTopicsDetectionJobsResponse",
    NextToken: undefined,
    TopicsDetectionJobPropertiesList: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.TopicsDetectionJobPropertiesList !== undefined) {
    contents.TopicsDetectionJobPropertiesList = deserializeAws_json1_1TopicsDetectionJobPropertiesList(
      output.TopicsDetectionJobPropertiesList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1OutputDataConfig = (
  output: any,
  context: __SerdeContext
): OutputDataConfig => {
  let contents: any = {
    __type: "OutputDataConfig",
    KmsKeyId: undefined,
    S3Uri: undefined
  };
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1PartOfSpeechTag = (
  output: any,
  context: __SerdeContext
): PartOfSpeechTag => {
  let contents: any = {
    __type: "PartOfSpeechTag",
    Score: undefined,
    Tag: undefined
  };
  if (output.Score !== undefined) {
    contents.Score = output.Score;
  }
  if (output.Tag !== undefined) {
    contents.Tag = output.Tag;
  }
  return contents;
};

const deserializeAws_json1_1ResourceInUseException = (
  output: any,
  context: __SerdeContext
): ResourceInUseException => {
  let contents: any = {
    __type: "ResourceInUseException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceLimitExceededException = (
  output: any,
  context: __SerdeContext
): ResourceLimitExceededException => {
  let contents: any = {
    __type: "ResourceLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundException = (
  output: any,
  context: __SerdeContext
): ResourceNotFoundException => {
  let contents: any = {
    __type: "ResourceNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceUnavailableException = (
  output: any,
  context: __SerdeContext
): ResourceUnavailableException => {
  let contents: any = {
    __type: "ResourceUnavailableException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1SecurityGroupIds = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SentimentDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): SentimentDetectionJobProperties => {
  let contents: any = {
    __type: "SentimentDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    LanguageCode: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (output.DataAccessRoleArn !== undefined) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(
      output.EndTime % 1 != 0
        ? Math.round(output.EndTime * 1000)
        : output.EndTime
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.LanguageCode !== undefined) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined) {
    contents.SubmitTime = new Date(
      output.SubmitTime % 1 != 0
        ? Math.round(output.SubmitTime * 1000)
        : output.SubmitTime
    );
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1SentimentDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<SentimentDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SentimentDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1SentimentScore = (
  output: any,
  context: __SerdeContext
): SentimentScore => {
  let contents: any = {
    __type: "SentimentScore",
    Mixed: undefined,
    Negative: undefined,
    Neutral: undefined,
    Positive: undefined
  };
  if (output.Mixed !== undefined) {
    contents.Mixed = output.Mixed;
  }
  if (output.Negative !== undefined) {
    contents.Negative = output.Negative;
  }
  if (output.Neutral !== undefined) {
    contents.Neutral = output.Neutral;
  }
  if (output.Positive !== undefined) {
    contents.Positive = output.Positive;
  }
  return contents;
};

const deserializeAws_json1_1StartDocumentClassificationJobResponse = (
  output: any,
  context: __SerdeContext
): StartDocumentClassificationJobResponse => {
  let contents: any = {
    __type: "StartDocumentClassificationJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartDominantLanguageDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartDominantLanguageDetectionJobResponse => {
  let contents: any = {
    __type: "StartDominantLanguageDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartEntitiesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartEntitiesDetectionJobResponse => {
  let contents: any = {
    __type: "StartEntitiesDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartKeyPhrasesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartKeyPhrasesDetectionJobResponse => {
  let contents: any = {
    __type: "StartKeyPhrasesDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartSentimentDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartSentimentDetectionJobResponse => {
  let contents: any = {
    __type: "StartSentimentDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartTopicsDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartTopicsDetectionJobResponse => {
  let contents: any = {
    __type: "StartTopicsDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopDominantLanguageDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StopDominantLanguageDetectionJobResponse => {
  let contents: any = {
    __type: "StopDominantLanguageDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopEntitiesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StopEntitiesDetectionJobResponse => {
  let contents: any = {
    __type: "StopEntitiesDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopKeyPhrasesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StopKeyPhrasesDetectionJobResponse => {
  let contents: any = {
    __type: "StopKeyPhrasesDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopSentimentDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StopSentimentDetectionJobResponse => {
  let contents: any = {
    __type: "StopSentimentDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopTrainingDocumentClassifierResponse = (
  output: any,
  context: __SerdeContext
): StopTrainingDocumentClassifierResponse => {
  let contents: any = {
    __type: "StopTrainingDocumentClassifierResponse"
  };
  return contents;
};

const deserializeAws_json1_1StopTrainingEntityRecognizerResponse = (
  output: any,
  context: __SerdeContext
): StopTrainingEntityRecognizerResponse => {
  let contents: any = {
    __type: "StopTrainingEntityRecognizerResponse"
  };
  return contents;
};

const deserializeAws_json1_1Subnets = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SyntaxToken = (
  output: any,
  context: __SerdeContext
): SyntaxToken => {
  let contents: any = {
    __type: "SyntaxToken",
    BeginOffset: undefined,
    EndOffset: undefined,
    PartOfSpeech: undefined,
    Text: undefined,
    TokenId: undefined
  };
  if (output.BeginOffset !== undefined) {
    contents.BeginOffset = output.BeginOffset;
  }
  if (output.EndOffset !== undefined) {
    contents.EndOffset = output.EndOffset;
  }
  if (output.PartOfSpeech !== undefined) {
    contents.PartOfSpeech = deserializeAws_json1_1PartOfSpeechTag(
      output.PartOfSpeech,
      context
    );
  }
  if (output.Text !== undefined) {
    contents.Text = output.Text;
  }
  if (output.TokenId !== undefined) {
    contents.TokenId = output.TokenId;
  }
  return contents;
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TagResourceResponse = (
  output: any,
  context: __SerdeContext
): TagResourceResponse => {
  let contents: any = {
    __type: "TagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1TextSizeLimitExceededException = (
  output: any,
  context: __SerdeContext
): TextSizeLimitExceededException => {
  let contents: any = {
    __type: "TextSizeLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TooManyRequestsException = (
  output: any,
  context: __SerdeContext
): TooManyRequestsException => {
  let contents: any = {
    __type: "TooManyRequestsException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TooManyTagKeysException = (
  output: any,
  context: __SerdeContext
): TooManyTagKeysException => {
  let contents: any = {
    __type: "TooManyTagKeysException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TooManyTagsException = (
  output: any,
  context: __SerdeContext
): TooManyTagsException => {
  let contents: any = {
    __type: "TooManyTagsException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TopicsDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): TopicsDetectionJobProperties => {
  let contents: any = {
    __type: "TopicsDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    Message: undefined,
    NumberOfTopics: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (output.DataAccessRoleArn !== undefined) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(
      output.EndTime % 1 != 0
        ? Math.round(output.EndTime * 1000)
        : output.EndTime
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.NumberOfTopics !== undefined) {
    contents.NumberOfTopics = output.NumberOfTopics;
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined) {
    contents.SubmitTime = new Date(
      output.SubmitTime % 1 != 0
        ? Math.round(output.SubmitTime * 1000)
        : output.SubmitTime
    );
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TopicsDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<TopicsDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TopicsDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1UnsupportedLanguageException = (
  output: any,
  context: __SerdeContext
): UnsupportedLanguageException => {
  let contents: any = {
    __type: "UnsupportedLanguageException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UntagResourceResponse = (
  output: any,
  context: __SerdeContext
): UntagResourceResponse => {
  let contents: any = {
    __type: "UntagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateEndpointResponse = (
  output: any,
  context: __SerdeContext
): UpdateEndpointResponse => {
  let contents: any = {
    __type: "UpdateEndpointResponse"
  };
  return contents;
};

const deserializeAws_json1_1VpcConfig = (
  output: any,
  context: __SerdeContext
): VpcConfig => {
  let contents: any = {
    __type: "VpcConfig",
    SecurityGroupIds: undefined,
    Subnets: undefined
  };
  if (output.SecurityGroupIds !== undefined) {
    contents.SecurityGroupIds = deserializeAws_json1_1SecurityGroupIds(
      output.SecurityGroupIds,
      context
    );
  }
  if (output.Subnets !== undefined) {
    contents.Subnets = deserializeAws_json1_1Subnets(output.Subnets, context);
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return context.streamCollector(streamBody).then((body: any) => {
    const encoded = context.utf8Encoder(body);
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
