import {
  BatchDetectDominantLanguageCommandInput,
  BatchDetectDominantLanguageCommandOutput
} from "../commands/BatchDetectDominantLanguageCommand";
import {
  BatchDetectEntitiesCommandInput,
  BatchDetectEntitiesCommandOutput
} from "../commands/BatchDetectEntitiesCommand";
import {
  BatchDetectKeyPhrasesCommandInput,
  BatchDetectKeyPhrasesCommandOutput
} from "../commands/BatchDetectKeyPhrasesCommand";
import {
  BatchDetectSentimentCommandInput,
  BatchDetectSentimentCommandOutput
} from "../commands/BatchDetectSentimentCommand";
import {
  BatchDetectSyntaxCommandInput,
  BatchDetectSyntaxCommandOutput
} from "../commands/BatchDetectSyntaxCommand";
import {
  ClassifyDocumentCommandInput,
  ClassifyDocumentCommandOutput
} from "../commands/ClassifyDocumentCommand";
import {
  CreateDocumentClassifierCommandInput,
  CreateDocumentClassifierCommandOutput
} from "../commands/CreateDocumentClassifierCommand";
import {
  CreateEndpointCommandInput,
  CreateEndpointCommandOutput
} from "../commands/CreateEndpointCommand";
import {
  CreateEntityRecognizerCommandInput,
  CreateEntityRecognizerCommandOutput
} from "../commands/CreateEntityRecognizerCommand";
import {
  DeleteDocumentClassifierCommandInput,
  DeleteDocumentClassifierCommandOutput
} from "../commands/DeleteDocumentClassifierCommand";
import {
  DeleteEndpointCommandInput,
  DeleteEndpointCommandOutput
} from "../commands/DeleteEndpointCommand";
import {
  DeleteEntityRecognizerCommandInput,
  DeleteEntityRecognizerCommandOutput
} from "../commands/DeleteEntityRecognizerCommand";
import {
  DescribeDocumentClassificationJobCommandInput,
  DescribeDocumentClassificationJobCommandOutput
} from "../commands/DescribeDocumentClassificationJobCommand";
import {
  DescribeDocumentClassifierCommandInput,
  DescribeDocumentClassifierCommandOutput
} from "../commands/DescribeDocumentClassifierCommand";
import {
  DescribeDominantLanguageDetectionJobCommandInput,
  DescribeDominantLanguageDetectionJobCommandOutput
} from "../commands/DescribeDominantLanguageDetectionJobCommand";
import {
  DescribeEndpointCommandInput,
  DescribeEndpointCommandOutput
} from "../commands/DescribeEndpointCommand";
import {
  DescribeEntitiesDetectionJobCommandInput,
  DescribeEntitiesDetectionJobCommandOutput
} from "../commands/DescribeEntitiesDetectionJobCommand";
import {
  DescribeEntityRecognizerCommandInput,
  DescribeEntityRecognizerCommandOutput
} from "../commands/DescribeEntityRecognizerCommand";
import {
  DescribeKeyPhrasesDetectionJobCommandInput,
  DescribeKeyPhrasesDetectionJobCommandOutput
} from "../commands/DescribeKeyPhrasesDetectionJobCommand";
import {
  DescribeSentimentDetectionJobCommandInput,
  DescribeSentimentDetectionJobCommandOutput
} from "../commands/DescribeSentimentDetectionJobCommand";
import {
  DescribeTopicsDetectionJobCommandInput,
  DescribeTopicsDetectionJobCommandOutput
} from "../commands/DescribeTopicsDetectionJobCommand";
import {
  DetectDominantLanguageCommandInput,
  DetectDominantLanguageCommandOutput
} from "../commands/DetectDominantLanguageCommand";
import {
  DetectEntitiesCommandInput,
  DetectEntitiesCommandOutput
} from "../commands/DetectEntitiesCommand";
import {
  DetectKeyPhrasesCommandInput,
  DetectKeyPhrasesCommandOutput
} from "../commands/DetectKeyPhrasesCommand";
import {
  DetectSentimentCommandInput,
  DetectSentimentCommandOutput
} from "../commands/DetectSentimentCommand";
import {
  DetectSyntaxCommandInput,
  DetectSyntaxCommandOutput
} from "../commands/DetectSyntaxCommand";
import {
  ListDocumentClassificationJobsCommandInput,
  ListDocumentClassificationJobsCommandOutput
} from "../commands/ListDocumentClassificationJobsCommand";
import {
  ListDocumentClassifiersCommandInput,
  ListDocumentClassifiersCommandOutput
} from "../commands/ListDocumentClassifiersCommand";
import {
  ListDominantLanguageDetectionJobsCommandInput,
  ListDominantLanguageDetectionJobsCommandOutput
} from "../commands/ListDominantLanguageDetectionJobsCommand";
import {
  ListEndpointsCommandInput,
  ListEndpointsCommandOutput
} from "../commands/ListEndpointsCommand";
import {
  ListEntitiesDetectionJobsCommandInput,
  ListEntitiesDetectionJobsCommandOutput
} from "../commands/ListEntitiesDetectionJobsCommand";
import {
  ListEntityRecognizersCommandInput,
  ListEntityRecognizersCommandOutput
} from "../commands/ListEntityRecognizersCommand";
import {
  ListKeyPhrasesDetectionJobsCommandInput,
  ListKeyPhrasesDetectionJobsCommandOutput
} from "../commands/ListKeyPhrasesDetectionJobsCommand";
import {
  ListSentimentDetectionJobsCommandInput,
  ListSentimentDetectionJobsCommandOutput
} from "../commands/ListSentimentDetectionJobsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ListTopicsDetectionJobsCommandInput,
  ListTopicsDetectionJobsCommandOutput
} from "../commands/ListTopicsDetectionJobsCommand";
import {
  StartDocumentClassificationJobCommandInput,
  StartDocumentClassificationJobCommandOutput
} from "../commands/StartDocumentClassificationJobCommand";
import {
  StartDominantLanguageDetectionJobCommandInput,
  StartDominantLanguageDetectionJobCommandOutput
} from "../commands/StartDominantLanguageDetectionJobCommand";
import {
  StartEntitiesDetectionJobCommandInput,
  StartEntitiesDetectionJobCommandOutput
} from "../commands/StartEntitiesDetectionJobCommand";
import {
  StartKeyPhrasesDetectionJobCommandInput,
  StartKeyPhrasesDetectionJobCommandOutput
} from "../commands/StartKeyPhrasesDetectionJobCommand";
import {
  StartSentimentDetectionJobCommandInput,
  StartSentimentDetectionJobCommandOutput
} from "../commands/StartSentimentDetectionJobCommand";
import {
  StartTopicsDetectionJobCommandInput,
  StartTopicsDetectionJobCommandOutput
} from "../commands/StartTopicsDetectionJobCommand";
import {
  StopDominantLanguageDetectionJobCommandInput,
  StopDominantLanguageDetectionJobCommandOutput
} from "../commands/StopDominantLanguageDetectionJobCommand";
import {
  StopEntitiesDetectionJobCommandInput,
  StopEntitiesDetectionJobCommandOutput
} from "../commands/StopEntitiesDetectionJobCommand";
import {
  StopKeyPhrasesDetectionJobCommandInput,
  StopKeyPhrasesDetectionJobCommandOutput
} from "../commands/StopKeyPhrasesDetectionJobCommand";
import {
  StopSentimentDetectionJobCommandInput,
  StopSentimentDetectionJobCommandOutput
} from "../commands/StopSentimentDetectionJobCommand";
import {
  StopTrainingDocumentClassifierCommandInput,
  StopTrainingDocumentClassifierCommandOutput
} from "../commands/StopTrainingDocumentClassifierCommand";
import {
  StopTrainingEntityRecognizerCommandInput,
  StopTrainingEntityRecognizerCommandOutput
} from "../commands/StopTrainingEntityRecognizerCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateEndpointCommandInput,
  UpdateEndpointCommandOutput
} from "../commands/UpdateEndpointCommand";
import {
  BatchDetectDominantLanguageItemResult,
  BatchDetectDominantLanguageRequest,
  BatchDetectDominantLanguageResponse,
  BatchDetectEntitiesItemResult,
  BatchDetectEntitiesRequest,
  BatchDetectEntitiesResponse,
  BatchDetectKeyPhrasesItemResult,
  BatchDetectKeyPhrasesRequest,
  BatchDetectKeyPhrasesResponse,
  BatchDetectSentimentItemResult,
  BatchDetectSentimentRequest,
  BatchDetectSentimentResponse,
  BatchDetectSyntaxItemResult,
  BatchDetectSyntaxRequest,
  BatchDetectSyntaxResponse,
  BatchItemError,
  BatchSizeLimitExceededException,
  ClassifierEvaluationMetrics,
  ClassifierMetadata,
  ClassifyDocumentRequest,
  ClassifyDocumentResponse,
  ConcurrentModificationException,
  CreateDocumentClassifierRequest,
  CreateDocumentClassifierResponse,
  CreateEndpointRequest,
  CreateEndpointResponse,
  CreateEntityRecognizerRequest,
  CreateEntityRecognizerResponse,
  DeleteDocumentClassifierRequest,
  DeleteDocumentClassifierResponse,
  DeleteEndpointRequest,
  DeleteEndpointResponse,
  DeleteEntityRecognizerRequest,
  DeleteEntityRecognizerResponse,
  DescribeDocumentClassificationJobRequest,
  DescribeDocumentClassificationJobResponse,
  DescribeDocumentClassifierRequest,
  DescribeDocumentClassifierResponse,
  DescribeDominantLanguageDetectionJobRequest,
  DescribeDominantLanguageDetectionJobResponse,
  DescribeEndpointRequest,
  DescribeEndpointResponse,
  DescribeEntitiesDetectionJobRequest,
  DescribeEntitiesDetectionJobResponse,
  DescribeEntityRecognizerRequest,
  DescribeEntityRecognizerResponse,
  DescribeKeyPhrasesDetectionJobRequest,
  DescribeKeyPhrasesDetectionJobResponse,
  DescribeSentimentDetectionJobRequest,
  DescribeSentimentDetectionJobResponse,
  DescribeTopicsDetectionJobRequest,
  DescribeTopicsDetectionJobResponse,
  DetectDominantLanguageRequest,
  DetectDominantLanguageResponse,
  DetectEntitiesRequest,
  DetectEntitiesResponse,
  DetectKeyPhrasesRequest,
  DetectKeyPhrasesResponse,
  DetectSentimentRequest,
  DetectSentimentResponse,
  DetectSyntaxRequest,
  DetectSyntaxResponse,
  DocumentClass,
  DocumentClassificationJobFilter,
  DocumentClassificationJobProperties,
  DocumentClassifierFilter,
  DocumentClassifierInputDataConfig,
  DocumentClassifierOutputDataConfig,
  DocumentClassifierProperties,
  DocumentLabel,
  DominantLanguage,
  DominantLanguageDetectionJobFilter,
  DominantLanguageDetectionJobProperties,
  EndpointFilter,
  EndpointProperties,
  EntitiesDetectionJobFilter,
  EntitiesDetectionJobProperties,
  Entity,
  EntityRecognizerAnnotations,
  EntityRecognizerDocuments,
  EntityRecognizerEntityList,
  EntityRecognizerEvaluationMetrics,
  EntityRecognizerFilter,
  EntityRecognizerInputDataConfig,
  EntityRecognizerMetadata,
  EntityRecognizerMetadataEntityTypesListItem,
  EntityRecognizerProperties,
  EntityTypesEvaluationMetrics,
  EntityTypesListItem,
  InputDataConfig,
  InternalServerException,
  InvalidFilterException,
  InvalidRequestException,
  JobNotFoundException,
  KeyPhrase,
  KeyPhrasesDetectionJobFilter,
  KeyPhrasesDetectionJobProperties,
  KmsKeyValidationException,
  ListDocumentClassificationJobsRequest,
  ListDocumentClassificationJobsResponse,
  ListDocumentClassifiersRequest,
  ListDocumentClassifiersResponse,
  ListDominantLanguageDetectionJobsRequest,
  ListDominantLanguageDetectionJobsResponse,
  ListEndpointsRequest,
  ListEndpointsResponse,
  ListEntitiesDetectionJobsRequest,
  ListEntitiesDetectionJobsResponse,
  ListEntityRecognizersRequest,
  ListEntityRecognizersResponse,
  ListKeyPhrasesDetectionJobsRequest,
  ListKeyPhrasesDetectionJobsResponse,
  ListSentimentDetectionJobsRequest,
  ListSentimentDetectionJobsResponse,
  ListTagsForResourceRequest,
  ListTagsForResourceResponse,
  ListTopicsDetectionJobsRequest,
  ListTopicsDetectionJobsResponse,
  OutputDataConfig,
  PartOfSpeechTag,
  ResourceInUseException,
  ResourceLimitExceededException,
  ResourceNotFoundException,
  ResourceUnavailableException,
  SentimentDetectionJobFilter,
  SentimentDetectionJobProperties,
  SentimentScore,
  StartDocumentClassificationJobRequest,
  StartDocumentClassificationJobResponse,
  StartDominantLanguageDetectionJobRequest,
  StartDominantLanguageDetectionJobResponse,
  StartEntitiesDetectionJobRequest,
  StartEntitiesDetectionJobResponse,
  StartKeyPhrasesDetectionJobRequest,
  StartKeyPhrasesDetectionJobResponse,
  StartSentimentDetectionJobRequest,
  StartSentimentDetectionJobResponse,
  StartTopicsDetectionJobRequest,
  StartTopicsDetectionJobResponse,
  StopDominantLanguageDetectionJobRequest,
  StopDominantLanguageDetectionJobResponse,
  StopEntitiesDetectionJobRequest,
  StopEntitiesDetectionJobResponse,
  StopKeyPhrasesDetectionJobRequest,
  StopKeyPhrasesDetectionJobResponse,
  StopSentimentDetectionJobRequest,
  StopSentimentDetectionJobResponse,
  StopTrainingDocumentClassifierRequest,
  StopTrainingDocumentClassifierResponse,
  StopTrainingEntityRecognizerRequest,
  StopTrainingEntityRecognizerResponse,
  SyntaxToken,
  Tag,
  TagResourceRequest,
  TagResourceResponse,
  TextSizeLimitExceededException,
  TooManyRequestsException,
  TooManyTagKeysException,
  TooManyTagsException,
  TopicsDetectionJobFilter,
  TopicsDetectionJobProperties,
  UnsupportedLanguageException,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateEndpointRequest,
  UpdateEndpointResponse,
  VpcConfig
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import { v4 as generateIdempotencyToken } from "uuid";

export async function serializeAws_json1_1BatchDetectDominantLanguageCommand(
  input: BatchDetectDominantLanguageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectDominantLanguage";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDetectDominantLanguageRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDetectEntitiesCommand(
  input: BatchDetectEntitiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectEntities";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDetectEntitiesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDetectKeyPhrasesCommand(
  input: BatchDetectKeyPhrasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectKeyPhrases";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDetectKeyPhrasesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDetectSentimentCommand(
  input: BatchDetectSentimentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectSentiment";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDetectSentimentRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1BatchDetectSyntaxCommand(
  input: BatchDetectSyntaxCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.BatchDetectSyntax";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1BatchDetectSyntaxRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ClassifyDocumentCommand(
  input: ClassifyDocumentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ClassifyDocument";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ClassifyDocumentRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateDocumentClassifierCommand(
  input: CreateDocumentClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.CreateDocumentClassifier";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateDocumentClassifierRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateEndpointCommand(
  input: CreateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.CreateEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateEndpointRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateEntityRecognizerCommand(
  input: CreateEntityRecognizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.CreateEntityRecognizer";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateEntityRecognizerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDocumentClassifierCommand(
  input: DeleteDocumentClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DeleteDocumentClassifier";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDocumentClassifierRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteEndpointCommand(
  input: DeleteEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DeleteEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteEndpointRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteEntityRecognizerCommand(
  input: DeleteEntityRecognizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DeleteEntityRecognizer";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteEntityRecognizerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDocumentClassificationJobCommand(
  input: DescribeDocumentClassificationJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.DescribeDocumentClassificationJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDocumentClassificationJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDocumentClassifierCommand(
  input: DescribeDocumentClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeDocumentClassifier";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDocumentClassifierRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDominantLanguageDetectionJobCommand(
  input: DescribeDominantLanguageDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.DescribeDominantLanguageDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDominantLanguageDetectionJobRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEndpointCommand(
  input: DescribeEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEndpointRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEntitiesDetectionJobCommand(
  input: DescribeEntitiesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeEntitiesDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEntitiesDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEntityRecognizerCommand(
  input: DescribeEntityRecognizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeEntityRecognizer";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEntityRecognizerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeKeyPhrasesDetectionJobCommand(
  input: DescribeKeyPhrasesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.DescribeKeyPhrasesDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeKeyPhrasesDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeSentimentDetectionJobCommand(
  input: DescribeSentimentDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeSentimentDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeSentimentDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeTopicsDetectionJobCommand(
  input: DescribeTopicsDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DescribeTopicsDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeTopicsDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DetectDominantLanguageCommand(
  input: DetectDominantLanguageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectDominantLanguage";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DetectDominantLanguageRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DetectEntitiesCommand(
  input: DetectEntitiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectEntities";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DetectEntitiesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DetectKeyPhrasesCommand(
  input: DetectKeyPhrasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectKeyPhrases";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DetectKeyPhrasesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DetectSentimentCommand(
  input: DetectSentimentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectSentiment";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DetectSentimentRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DetectSyntaxCommand(
  input: DetectSyntaxCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.DetectSyntax";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DetectSyntaxRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListDocumentClassificationJobsCommand(
  input: ListDocumentClassificationJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.ListDocumentClassificationJobs";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListDocumentClassificationJobsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListDocumentClassifiersCommand(
  input: ListDocumentClassifiersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListDocumentClassifiers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListDocumentClassifiersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListDominantLanguageDetectionJobsCommand(
  input: ListDominantLanguageDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.ListDominantLanguageDetectionJobs";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListDominantLanguageDetectionJobsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListEndpointsCommand(
  input: ListEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListEndpoints";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListEndpointsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListEntitiesDetectionJobsCommand(
  input: ListEntitiesDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListEntitiesDetectionJobs";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListEntitiesDetectionJobsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListEntityRecognizersCommand(
  input: ListEntityRecognizersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListEntityRecognizers";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListEntityRecognizersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListKeyPhrasesDetectionJobsCommand(
  input: ListKeyPhrasesDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListKeyPhrasesDetectionJobs";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListKeyPhrasesDetectionJobsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListSentimentDetectionJobsCommand(
  input: ListSentimentDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListSentimentDetectionJobs";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListSentimentDetectionJobsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListTagsForResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListTagsForResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListTopicsDetectionJobsCommand(
  input: ListTopicsDetectionJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.ListTopicsDetectionJobs";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListTopicsDetectionJobsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartDocumentClassificationJobCommand(
  input: StartDocumentClassificationJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.StartDocumentClassificationJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartDocumentClassificationJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartDominantLanguageDetectionJobCommand(
  input: StartDominantLanguageDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.StartDominantLanguageDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartDominantLanguageDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartEntitiesDetectionJobCommand(
  input: StartEntitiesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StartEntitiesDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartEntitiesDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartKeyPhrasesDetectionJobCommand(
  input: StartKeyPhrasesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StartKeyPhrasesDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartKeyPhrasesDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartSentimentDetectionJobCommand(
  input: StartSentimentDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StartSentimentDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartSentimentDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartTopicsDetectionJobCommand(
  input: StartTopicsDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StartTopicsDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartTopicsDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopDominantLanguageDetectionJobCommand(
  input: StopDominantLanguageDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.StopDominantLanguageDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopDominantLanguageDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopEntitiesDetectionJobCommand(
  input: StopEntitiesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StopEntitiesDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopEntitiesDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopKeyPhrasesDetectionJobCommand(
  input: StopKeyPhrasesDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StopKeyPhrasesDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopKeyPhrasesDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopSentimentDetectionJobCommand(
  input: StopSentimentDetectionJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StopSentimentDetectionJob";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopSentimentDetectionJobRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopTrainingDocumentClassifierCommand(
  input: StopTrainingDocumentClassifierCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "Comprehend_20171127.StopTrainingDocumentClassifier";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopTrainingDocumentClassifierRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopTrainingEntityRecognizerCommand(
  input: StopTrainingEntityRecognizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.StopTrainingEntityRecognizer";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopTrainingEntityRecognizerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.TagResource";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.UntagResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UntagResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateEndpointCommand(
  input: UpdateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "Comprehend_20171127.UpdateEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateEndpointRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_json1_1BatchDetectDominantLanguageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectDominantLanguageCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectDominantLanguageCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectDominantLanguageResponse(
    data,
    context
  );
  const response: BatchDetectDominantLanguageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectDominantLanguageResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectDominantLanguageCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectDominantLanguageCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDetectEntitiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectEntitiesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectEntitiesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectEntitiesResponse(data, context);
  const response: BatchDetectEntitiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectEntitiesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectEntitiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectEntitiesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDetectKeyPhrasesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectKeyPhrasesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectKeyPhrasesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectKeyPhrasesResponse(data, context);
  const response: BatchDetectKeyPhrasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectKeyPhrasesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectKeyPhrasesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectKeyPhrasesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDetectSentimentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectSentimentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectSentimentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectSentimentResponse(data, context);
  const response: BatchDetectSentimentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectSentimentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectSentimentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectSentimentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1BatchDetectSyntaxCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectSyntaxCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1BatchDetectSyntaxCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1BatchDetectSyntaxResponse(data, context);
  const response: BatchDetectSyntaxCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDetectSyntaxResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1BatchDetectSyntaxCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDetectSyntaxCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "BatchSizeLimitExceededException":
    case "com.amazonaws.comprehend#BatchSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ClassifyDocumentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ClassifyDocumentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ClassifyDocumentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ClassifyDocumentResponse(data, context);
  const response: ClassifyDocumentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClassifyDocumentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ClassifyDocumentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ClassifyDocumentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateDocumentClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDocumentClassifierCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDocumentClassifierResponse(
    data,
    context
  );
  const response: CreateDocumentClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDocumentClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDocumentClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDocumentClassifierCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = {
        ...(await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.comprehend#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.comprehend#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEndpointResponse(data, context);
  const response: CreateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.comprehend#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.comprehend#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateEntityRecognizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEntityRecognizerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEntityRecognizerCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEntityRecognizerResponse(
    data,
    context
  );
  const response: CreateEntityRecognizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEntityRecognizerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEntityRecognizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEntityRecognizerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = {
        ...(await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.comprehend#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.comprehend#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDocumentClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDocumentClassifierCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDocumentClassifierResponse(
    data,
    context
  );
  const response: DeleteDocumentClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDocumentClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDocumentClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDocumentClassifierCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEndpointResponse(data, context);
  const response: DeleteEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteEntityRecognizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEntityRecognizerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEntityRecognizerCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEntityRecognizerResponse(
    data,
    context
  );
  const response: DeleteEntityRecognizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEntityRecognizerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEntityRecognizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEntityRecognizerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDocumentClassificationJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentClassificationJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDocumentClassificationJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDocumentClassificationJobResponse(
    data,
    context
  );
  const response: DescribeDocumentClassificationJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDocumentClassificationJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDocumentClassificationJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentClassificationJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDocumentClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDocumentClassifierCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDocumentClassifierResponse(
    data,
    context
  );
  const response: DescribeDocumentClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDocumentClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDocumentClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDocumentClassifierCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDominantLanguageDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDominantLanguageDetectionJobResponse(
    data,
    context
  );
  const response: DescribeDominantLanguageDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDominantLanguageDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDominantLanguageDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDominantLanguageDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointResponse(data, context);
  const response: DescribeEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEntitiesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEntitiesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEntitiesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEntitiesDetectionJobResponse(
    data,
    context
  );
  const response: DescribeEntitiesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEntitiesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEntitiesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEntitiesDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEntityRecognizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEntityRecognizerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEntityRecognizerCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEntityRecognizerResponse(
    data,
    context
  );
  const response: DescribeEntityRecognizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEntityRecognizerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEntityRecognizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEntityRecognizerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeKeyPhrasesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeKeyPhrasesDetectionJobResponse(
    data,
    context
  );
  const response: DescribeKeyPhrasesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeKeyPhrasesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeKeyPhrasesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeKeyPhrasesDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeSentimentDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSentimentDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeSentimentDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeSentimentDetectionJobResponse(
    data,
    context
  );
  const response: DescribeSentimentDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSentimentDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeSentimentDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSentimentDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeTopicsDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTopicsDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTopicsDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTopicsDetectionJobResponse(
    data,
    context
  );
  const response: DescribeTopicsDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTopicsDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTopicsDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTopicsDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DetectDominantLanguageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectDominantLanguageCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectDominantLanguageCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectDominantLanguageResponse(
    data,
    context
  );
  const response: DetectDominantLanguageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectDominantLanguageResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectDominantLanguageCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectDominantLanguageCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DetectEntitiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectEntitiesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectEntitiesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectEntitiesResponse(data, context);
  const response: DetectEntitiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectEntitiesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectEntitiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectEntitiesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DetectKeyPhrasesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectKeyPhrasesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectKeyPhrasesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectKeyPhrasesResponse(data, context);
  const response: DetectKeyPhrasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectKeyPhrasesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectKeyPhrasesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectKeyPhrasesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DetectSentimentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectSentimentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectSentimentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectSentimentResponse(data, context);
  const response: DetectSentimentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectSentimentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectSentimentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectSentimentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DetectSyntaxCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectSyntaxCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetectSyntaxCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DetectSyntaxResponse(data, context);
  const response: DetectSyntaxCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetectSyntaxResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DetectSyntaxCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetectSyntaxCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TextSizeLimitExceededException":
    case "com.amazonaws.comprehend#TextSizeLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1TextSizeLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedLanguageException":
    case "com.amazonaws.comprehend#UnsupportedLanguageException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedLanguageExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListDocumentClassificationJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentClassificationJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDocumentClassificationJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDocumentClassificationJobsResponse(
    data,
    context
  );
  const response: ListDocumentClassificationJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDocumentClassificationJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDocumentClassificationJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentClassificationJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListDocumentClassifiersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentClassifiersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDocumentClassifiersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDocumentClassifiersResponse(
    data,
    context
  );
  const response: ListDocumentClassifiersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDocumentClassifiersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDocumentClassifiersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDocumentClassifiersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListDominantLanguageDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDominantLanguageDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDominantLanguageDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDominantLanguageDetectionJobsResponse(
    data,
    context
  );
  const response: ListDominantLanguageDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDominantLanguageDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDominantLanguageDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDominantLanguageDetectionJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEndpointsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListEndpointsResponse(data, context);
  const response: ListEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListEndpointsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEndpointsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListEntitiesDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEntitiesDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListEntitiesDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListEntitiesDetectionJobsResponse(
    data,
    context
  );
  const response: ListEntitiesDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListEntitiesDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListEntitiesDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEntitiesDetectionJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListEntityRecognizersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEntityRecognizersCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListEntityRecognizersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListEntityRecognizersResponse(data, context);
  const response: ListEntityRecognizersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListEntityRecognizersResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListEntityRecognizersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEntityRecognizersCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListKeyPhrasesDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListKeyPhrasesDetectionJobsResponse(
    data,
    context
  );
  const response: ListKeyPhrasesDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListKeyPhrasesDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListKeyPhrasesDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListKeyPhrasesDetectionJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSentimentDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSentimentDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSentimentDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSentimentDetectionJobsResponse(
    data,
    context
  );
  const response: ListSentimentDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSentimentDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSentimentDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSentimentDetectionJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTopicsDetectionJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicsDetectionJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTopicsDetectionJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTopicsDetectionJobsResponse(
    data,
    context
  );
  const response: ListTopicsDetectionJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTopicsDetectionJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTopicsDetectionJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicsDetectionJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFilterException":
    case "com.amazonaws.comprehend#InvalidFilterException":
      response = {
        ...(await deserializeAws_json1_1InvalidFilterExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartDocumentClassificationJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDocumentClassificationJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartDocumentClassificationJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartDocumentClassificationJobResponse(
    data,
    context
  );
  const response: StartDocumentClassificationJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartDocumentClassificationJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartDocumentClassificationJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDocumentClassificationJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = {
        ...(await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartDominantLanguageDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDominantLanguageDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartDominantLanguageDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartDominantLanguageDetectionJobResponse(
    data,
    context
  );
  const response: StartDominantLanguageDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartDominantLanguageDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartDominantLanguageDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDominantLanguageDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = {
        ...(await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartEntitiesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartEntitiesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartEntitiesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartEntitiesDetectionJobResponse(
    data,
    context
  );
  const response: StartEntitiesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartEntitiesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartEntitiesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartEntitiesDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = {
        ...(await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartKeyPhrasesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartKeyPhrasesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartKeyPhrasesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartKeyPhrasesDetectionJobResponse(
    data,
    context
  );
  const response: StartKeyPhrasesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartKeyPhrasesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartKeyPhrasesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartKeyPhrasesDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = {
        ...(await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartSentimentDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSentimentDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartSentimentDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartSentimentDetectionJobResponse(
    data,
    context
  );
  const response: StartSentimentDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartSentimentDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartSentimentDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartSentimentDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = {
        ...(await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartTopicsDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTopicsDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartTopicsDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartTopicsDetectionJobResponse(
    data,
    context
  );
  const response: StartTopicsDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartTopicsDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartTopicsDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartTopicsDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KmsKeyValidationException":
    case "com.amazonaws.comprehend#KmsKeyValidationException":
      response = {
        ...(await deserializeAws_json1_1KmsKeyValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopDominantLanguageDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopDominantLanguageDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopDominantLanguageDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopDominantLanguageDetectionJobResponse(
    data,
    context
  );
  const response: StopDominantLanguageDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopDominantLanguageDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopDominantLanguageDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopDominantLanguageDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopEntitiesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopEntitiesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopEntitiesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopEntitiesDetectionJobResponse(
    data,
    context
  );
  const response: StopEntitiesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopEntitiesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopEntitiesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopEntitiesDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopKeyPhrasesDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopKeyPhrasesDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopKeyPhrasesDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopKeyPhrasesDetectionJobResponse(
    data,
    context
  );
  const response: StopKeyPhrasesDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopKeyPhrasesDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopKeyPhrasesDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopKeyPhrasesDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopSentimentDetectionJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopSentimentDetectionJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopSentimentDetectionJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopSentimentDetectionJobResponse(
    data,
    context
  );
  const response: StopSentimentDetectionJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopSentimentDetectionJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopSentimentDetectionJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopSentimentDetectionJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "JobNotFoundException":
    case "com.amazonaws.comprehend#JobNotFoundException":
      response = {
        ...(await deserializeAws_json1_1JobNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopTrainingDocumentClassifierCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingDocumentClassifierCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopTrainingDocumentClassifierCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopTrainingDocumentClassifierResponse(
    data,
    context
  );
  const response: StopTrainingDocumentClassifierCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopTrainingDocumentClassifierResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopTrainingDocumentClassifierCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingDocumentClassifierCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopTrainingEntityRecognizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingEntityRecognizerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopTrainingEntityRecognizerCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopTrainingEntityRecognizerResponse(
    data,
    context
  );
  const response: StopTrainingEntityRecognizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopTrainingEntityRecognizerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopTrainingEntityRecognizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingEntityRecognizerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.comprehend#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.comprehend#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConcurrentModificationException":
    case "com.amazonaws.comprehend#ConcurrentModificationException":
      response = {
        ...(await deserializeAws_json1_1ConcurrentModificationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagKeysException":
    case "com.amazonaws.comprehend#TooManyTagKeysException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateEndpointResponse(data, context);
  const response: UpdateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServerException":
    case "com.amazonaws.comprehend#InternalServerException":
      response = {
        ...(await deserializeAws_json1_1InternalServerExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.comprehend#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceInUseException":
    case "com.amazonaws.comprehend#ResourceInUseException":
      response = {
        ...(await deserializeAws_json1_1ResourceInUseExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.comprehend#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_json1_1ResourceLimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.comprehend#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.comprehend#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_json1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyRequestsException":
    case "com.amazonaws.comprehend#TooManyRequestsException":
      response = {
        ...(await deserializeAws_json1_1TooManyRequestsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1BatchSizeLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BatchSizeLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1BatchSizeLimitExceededException(
    body,
    context
  );
  const contents: BatchSizeLimitExceededException = {
    name: "BatchSizeLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ConcurrentModificationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentModificationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConcurrentModificationException(
    body,
    context
  );
  const contents: ConcurrentModificationException = {
    name: "ConcurrentModificationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InternalServerExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalServerException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InternalServerException(
    body,
    context
  );
  const contents: InternalServerException = {
    name: "InternalServerException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFilterExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidFilterException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidFilterException(
    body,
    context
  );
  const contents: InvalidFilterException = {
    name: "InvalidFilterException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRequestException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRequestException(
    body,
    context
  );
  const contents: InvalidRequestException = {
    name: "InvalidRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1JobNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<JobNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1JobNotFoundException(
    body,
    context
  );
  const contents: JobNotFoundException = {
    name: "JobNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KmsKeyValidationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KmsKeyValidationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KmsKeyValidationException(
    body,
    context
  );
  const contents: KmsKeyValidationException = {
    name: "KmsKeyValidationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceInUseExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceInUseException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceInUseException(
    body,
    context
  );
  const contents: ResourceInUseException = {
    name: "ResourceInUseException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceLimitExceededException(
    body,
    context
  );
  const contents: ResourceLimitExceededException = {
    name: "ResourceLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceNotFoundException(
    body,
    context
  );
  const contents: ResourceNotFoundException = {
    name: "ResourceNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceUnavailableExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceUnavailableException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceUnavailableException(
    body,
    context
  );
  const contents: ResourceUnavailableException = {
    name: "ResourceUnavailableException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TextSizeLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TextSizeLimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TextSizeLimitExceededException(
    body,
    context
  );
  const contents: TextSizeLimitExceededException = {
    name: "TextSizeLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyRequestsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyRequestsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TooManyRequestsException(
    body,
    context
  );
  const contents: TooManyRequestsException = {
    name: "TooManyRequestsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyTagKeysExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTagKeysException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TooManyTagKeysException(
    body,
    context
  );
  const contents: TooManyTagKeysException = {
    name: "TooManyTagKeysException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyTagsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTagsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TooManyTagsException(
    body,
    context
  );
  const contents: TooManyTagsException = {
    name: "TooManyTagsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedLanguageExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedLanguageException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedLanguageException(
    body,
    context
  );
  const contents: UnsupportedLanguageException = {
    name: "UnsupportedLanguageException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1BatchDetectDominantLanguageRequest = (
  input: BatchDetectDominantLanguageRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDetectEntitiesRequest = (
  input: BatchDetectEntitiesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDetectKeyPhrasesRequest = (
  input: BatchDetectKeyPhrasesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDetectSentimentRequest = (
  input: BatchDetectSentimentRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1BatchDetectSyntaxRequest = (
  input: BatchDetectSyntaxRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.TextList !== undefined) {
    bodyParams["TextList"] = serializeAws_json1_1StringList(
      input.TextList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ClassifyDocumentRequest = (
  input: ClassifyDocumentRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDocumentClassifierRequest = (
  input: CreateDocumentClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.DocumentClassifierName !== undefined) {
    bodyParams["DocumentClassifierName"] = input.DocumentClassifierName;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams[
      "InputDataConfig"
    ] = serializeAws_json1_1DocumentClassifierInputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.Mode !== undefined) {
    bodyParams["Mode"] = input.Mode;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams[
      "OutputDataConfig"
    ] = serializeAws_json1_1DocumentClassifierOutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEndpointRequest = (
  input: CreateEndpointRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DesiredInferenceUnits !== undefined) {
    bodyParams["DesiredInferenceUnits"] = input.DesiredInferenceUnits;
  }
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  if (input.ModelArn !== undefined) {
    bodyParams["ModelArn"] = input.ModelArn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEntityRecognizerRequest = (
  input: CreateEntityRecognizerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams[
      "InputDataConfig"
    ] = serializeAws_json1_1EntityRecognizerInputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.RecognizerName !== undefined) {
    bodyParams["RecognizerName"] = input.RecognizerName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDocumentClassifierRequest = (
  input: DeleteDocumentClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentClassifierArn !== undefined) {
    bodyParams["DocumentClassifierArn"] = input.DocumentClassifierArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEndpointRequest = (
  input: DeleteEndpointRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEntityRecognizerRequest = (
  input: DeleteEntityRecognizerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EntityRecognizerArn !== undefined) {
    bodyParams["EntityRecognizerArn"] = input.EntityRecognizerArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDocumentClassificationJobRequest = (
  input: DescribeDocumentClassificationJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDocumentClassifierRequest = (
  input: DescribeDocumentClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentClassifierArn !== undefined) {
    bodyParams["DocumentClassifierArn"] = input.DocumentClassifierArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDominantLanguageDetectionJobRequest = (
  input: DescribeDominantLanguageDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEndpointRequest = (
  input: DescribeEndpointRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEntitiesDetectionJobRequest = (
  input: DescribeEntitiesDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEntityRecognizerRequest = (
  input: DescribeEntityRecognizerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EntityRecognizerArn !== undefined) {
    bodyParams["EntityRecognizerArn"] = input.EntityRecognizerArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeKeyPhrasesDetectionJobRequest = (
  input: DescribeKeyPhrasesDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeSentimentDetectionJobRequest = (
  input: DescribeSentimentDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTopicsDetectionJobRequest = (
  input: DescribeTopicsDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectDominantLanguageRequest = (
  input: DetectDominantLanguageRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectEntitiesRequest = (
  input: DetectEntitiesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectKeyPhrasesRequest = (
  input: DetectKeyPhrasesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectSentimentRequest = (
  input: DetectSentimentRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DetectSyntaxRequest = (
  input: DetectSyntaxRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.Text !== undefined) {
    bodyParams["Text"] = input.Text;
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentClassificationJobFilter = (
  input: DocumentClassificationJobFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentClassifierFilter = (
  input: DocumentClassifierFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentClassifierInputDataConfig = (
  input: DocumentClassifierInputDataConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LabelDelimiter !== undefined) {
    bodyParams["LabelDelimiter"] = input.LabelDelimiter;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1DocumentClassifierOutputDataConfig = (
  input: DocumentClassifierOutputDataConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1DominantLanguageDetectionJobFilter = (
  input: DominantLanguageDetectionJobFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1EndpointFilter = (
  input: EndpointFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.ModelArn !== undefined) {
    bodyParams["ModelArn"] = input.ModelArn;
  }
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  return bodyParams;
};

const serializeAws_json1_1EntitiesDetectionJobFilter = (
  input: EntitiesDetectionJobFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerAnnotations = (
  input: EntityRecognizerAnnotations,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerDocuments = (
  input: EntityRecognizerDocuments,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerEntityList = (
  input: EntityRecognizerEntityList,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerFilter = (
  input: EntityRecognizerFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1EntityRecognizerInputDataConfig = (
  input: EntityRecognizerInputDataConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Annotations !== undefined) {
    bodyParams["Annotations"] = serializeAws_json1_1EntityRecognizerAnnotations(
      input.Annotations,
      context
    );
  }
  if (input.Documents !== undefined) {
    bodyParams["Documents"] = serializeAws_json1_1EntityRecognizerDocuments(
      input.Documents,
      context
    );
  }
  if (input.EntityList !== undefined) {
    bodyParams["EntityList"] = serializeAws_json1_1EntityRecognizerEntityList(
      input.EntityList,
      context
    );
  }
  if (input.EntityTypes !== undefined) {
    bodyParams["EntityTypes"] = serializeAws_json1_1EntityTypesList(
      input.EntityTypes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1EntityTypesList = (
  input: Array<EntityTypesListItem>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1EntityTypesListItem(entry, context));
  }
  return contents;
};

const serializeAws_json1_1EntityTypesListItem = (
  input: EntityTypesListItem,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1InputDataConfig = (
  input: InputDataConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InputFormat !== undefined) {
    bodyParams["InputFormat"] = input.InputFormat;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1KeyPhrasesDetectionJobFilter = (
  input: KeyPhrasesDetectionJobFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ListDocumentClassificationJobsRequest = (
  input: ListDocumentClassificationJobsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1DocumentClassificationJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListDocumentClassifiersRequest = (
  input: ListDocumentClassifiersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1DocumentClassifierFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListDominantLanguageDetectionJobsRequest = (
  input: ListDominantLanguageDetectionJobsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams[
      "Filter"
    ] = serializeAws_json1_1DominantLanguageDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListEndpointsRequest = (
  input: ListEndpointsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1EndpointFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListEntitiesDetectionJobsRequest = (
  input: ListEntitiesDetectionJobsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1EntitiesDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListEntityRecognizersRequest = (
  input: ListEntityRecognizersRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1EntityRecognizerFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListKeyPhrasesDetectionJobsRequest = (
  input: ListKeyPhrasesDetectionJobsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1KeyPhrasesDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSentimentDetectionJobsRequest = (
  input: ListSentimentDetectionJobsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1SentimentDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsForResourceRequest = (
  input: ListTagsForResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTopicsDetectionJobsRequest = (
  input: ListTopicsDetectionJobsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filter !== undefined) {
    bodyParams["Filter"] = serializeAws_json1_1TopicsDetectionJobFilter(
      input.Filter,
      context
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1OutputDataConfig = (
  input: OutputDataConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1SecurityGroupIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1SentimentDetectionJobFilter = (
  input: SentimentDetectionJobFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartDocumentClassificationJobRequest = (
  input: StartDocumentClassificationJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.DocumentClassifierArn !== undefined) {
    bodyParams["DocumentClassifierArn"] = input.DocumentClassifierArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartDominantLanguageDetectionJobRequest = (
  input: StartDominantLanguageDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartEntitiesDetectionJobRequest = (
  input: StartEntitiesDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.EntityRecognizerArn !== undefined) {
    bodyParams["EntityRecognizerArn"] = input.EntityRecognizerArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartKeyPhrasesDetectionJobRequest = (
  input: StartKeyPhrasesDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartSentimentDetectionJobRequest = (
  input: StartSentimentDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.LanguageCode !== undefined) {
    bodyParams["LanguageCode"] = input.LanguageCode;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartTopicsDetectionJobRequest = (
  input: StartTopicsDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.DataAccessRoleArn !== undefined) {
    bodyParams["DataAccessRoleArn"] = input.DataAccessRoleArn;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.NumberOfTopics !== undefined) {
    bodyParams["NumberOfTopics"] = input.NumberOfTopics;
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StopDominantLanguageDetectionJobRequest = (
  input: StopDominantLanguageDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopEntitiesDetectionJobRequest = (
  input: StopEntitiesDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopKeyPhrasesDetectionJobRequest = (
  input: StopKeyPhrasesDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopSentimentDetectionJobRequest = (
  input: StopSentimentDetectionJobRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobId !== undefined) {
    bodyParams["JobId"] = input.JobId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopTrainingDocumentClassifierRequest = (
  input: StopTrainingDocumentClassifierRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DocumentClassifierArn !== undefined) {
    bodyParams["DocumentClassifierArn"] = input.DocumentClassifierArn;
  }
  return bodyParams;
};

const serializeAws_json1_1StopTrainingEntityRecognizerRequest = (
  input: StopTrainingEntityRecognizerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EntityRecognizerArn !== undefined) {
    bodyParams["EntityRecognizerArn"] = input.EntityRecognizerArn;
  }
  return bodyParams;
};

const serializeAws_json1_1StringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Subnets = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Tag(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TagResourceRequest = (
  input: TagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1TopicsDetectionJobFilter = (
  input: TopicsDetectionJobFilter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JobName !== undefined) {
    bodyParams["JobName"] = input.JobName;
  }
  if (input.JobStatus !== undefined) {
    bodyParams["JobStatus"] = input.JobStatus;
  }
  if (input.SubmitTimeAfter !== undefined) {
    bodyParams["SubmitTimeAfter"] = Math.round(
      input.SubmitTimeAfter.getTime() / 1000
    );
  }
  if (input.SubmitTimeBefore !== undefined) {
    bodyParams["SubmitTimeBefore"] = Math.round(
      input.SubmitTimeBefore.getTime() / 1000
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UntagResourceRequest = (
  input: UntagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1TagKeyList(
      input.TagKeys,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateEndpointRequest = (
  input: UpdateEndpointRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DesiredInferenceUnits !== undefined) {
    bodyParams["DesiredInferenceUnits"] = input.DesiredInferenceUnits;
  }
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1VpcConfig = (
  input: VpcConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SecurityGroupIds !== undefined) {
    bodyParams["SecurityGroupIds"] = serializeAws_json1_1SecurityGroupIds(
      input.SecurityGroupIds,
      context
    );
  }
  if (input.Subnets !== undefined) {
    bodyParams["Subnets"] = serializeAws_json1_1Subnets(input.Subnets, context);
  }
  return bodyParams;
};

const deserializeAws_json1_1BatchDetectDominantLanguageItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectDominantLanguageItemResult => {
  let contents: any = {
    __type: "BatchDetectDominantLanguageItemResult",
    Index: undefined,
    Languages: undefined
  };
  if (output.Index !== undefined && output.Index !== null) {
    contents.Index = output.Index;
  }
  if (output.Languages !== undefined && output.Languages !== null) {
    contents.Languages = deserializeAws_json1_1ListOfDominantLanguages(
      output.Languages,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectDominantLanguageResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectDominantLanguageResponse => {
  let contents: any = {
    __type: "BatchDetectDominantLanguageResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined && output.ErrorList !== null) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined && output.ResultList !== null) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectDominantLanguageResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectEntitiesItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectEntitiesItemResult => {
  let contents: any = {
    __type: "BatchDetectEntitiesItemResult",
    Entities: undefined,
    Index: undefined
  };
  if (output.Entities !== undefined && output.Entities !== null) {
    contents.Entities = deserializeAws_json1_1ListOfEntities(
      output.Entities,
      context
    );
  }
  if (output.Index !== undefined && output.Index !== null) {
    contents.Index = output.Index;
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectEntitiesResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectEntitiesResponse => {
  let contents: any = {
    __type: "BatchDetectEntitiesResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined && output.ErrorList !== null) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined && output.ResultList !== null) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectEntitiesResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectKeyPhrasesItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectKeyPhrasesItemResult => {
  let contents: any = {
    __type: "BatchDetectKeyPhrasesItemResult",
    Index: undefined,
    KeyPhrases: undefined
  };
  if (output.Index !== undefined && output.Index !== null) {
    contents.Index = output.Index;
  }
  if (output.KeyPhrases !== undefined && output.KeyPhrases !== null) {
    contents.KeyPhrases = deserializeAws_json1_1ListOfKeyPhrases(
      output.KeyPhrases,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectKeyPhrasesResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectKeyPhrasesResponse => {
  let contents: any = {
    __type: "BatchDetectKeyPhrasesResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined && output.ErrorList !== null) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined && output.ResultList !== null) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectKeyPhrasesResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectSentimentItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectSentimentItemResult => {
  let contents: any = {
    __type: "BatchDetectSentimentItemResult",
    Index: undefined,
    Sentiment: undefined,
    SentimentScore: undefined
  };
  if (output.Index !== undefined && output.Index !== null) {
    contents.Index = output.Index;
  }
  if (output.Sentiment !== undefined && output.Sentiment !== null) {
    contents.Sentiment = output.Sentiment;
  }
  if (output.SentimentScore !== undefined && output.SentimentScore !== null) {
    contents.SentimentScore = deserializeAws_json1_1SentimentScore(
      output.SentimentScore,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectSentimentResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectSentimentResponse => {
  let contents: any = {
    __type: "BatchDetectSentimentResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined && output.ErrorList !== null) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined && output.ResultList !== null) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectSentimentResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectSyntaxItemResult = (
  output: any,
  context: __SerdeContext
): BatchDetectSyntaxItemResult => {
  let contents: any = {
    __type: "BatchDetectSyntaxItemResult",
    Index: undefined,
    SyntaxTokens: undefined
  };
  if (output.Index !== undefined && output.Index !== null) {
    contents.Index = output.Index;
  }
  if (output.SyntaxTokens !== undefined && output.SyntaxTokens !== null) {
    contents.SyntaxTokens = deserializeAws_json1_1ListOfSyntaxTokens(
      output.SyntaxTokens,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchDetectSyntaxResponse = (
  output: any,
  context: __SerdeContext
): BatchDetectSyntaxResponse => {
  let contents: any = {
    __type: "BatchDetectSyntaxResponse",
    ErrorList: undefined,
    ResultList: undefined
  };
  if (output.ErrorList !== undefined && output.ErrorList !== null) {
    contents.ErrorList = deserializeAws_json1_1BatchItemErrorList(
      output.ErrorList,
      context
    );
  }
  if (output.ResultList !== undefined && output.ResultList !== null) {
    contents.ResultList = deserializeAws_json1_1ListOfDetectSyntaxResult(
      output.ResultList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1BatchItemError = (
  output: any,
  context: __SerdeContext
): BatchItemError => {
  let contents: any = {
    __type: "BatchItemError",
    ErrorCode: undefined,
    ErrorMessage: undefined,
    Index: undefined
  };
  if (output.ErrorCode !== undefined && output.ErrorCode !== null) {
    contents.ErrorCode = output.ErrorCode;
  }
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.Index !== undefined && output.Index !== null) {
    contents.Index = output.Index;
  }
  return contents;
};

const deserializeAws_json1_1BatchItemErrorList = (
  output: any,
  context: __SerdeContext
): Array<BatchItemError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchItemError(entry, context)
  );
};

const deserializeAws_json1_1BatchSizeLimitExceededException = (
  output: any,
  context: __SerdeContext
): BatchSizeLimitExceededException => {
  let contents: any = {
    __type: "BatchSizeLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ClassifierEvaluationMetrics = (
  output: any,
  context: __SerdeContext
): ClassifierEvaluationMetrics => {
  let contents: any = {
    __type: "ClassifierEvaluationMetrics",
    Accuracy: undefined,
    F1Score: undefined,
    HammingLoss: undefined,
    MicroF1Score: undefined,
    MicroPrecision: undefined,
    MicroRecall: undefined,
    Precision: undefined,
    Recall: undefined
  };
  if (output.Accuracy !== undefined && output.Accuracy !== null) {
    contents.Accuracy = output.Accuracy;
  }
  if (output.F1Score !== undefined && output.F1Score !== null) {
    contents.F1Score = output.F1Score;
  }
  if (output.HammingLoss !== undefined && output.HammingLoss !== null) {
    contents.HammingLoss = output.HammingLoss;
  }
  if (output.MicroF1Score !== undefined && output.MicroF1Score !== null) {
    contents.MicroF1Score = output.MicroF1Score;
  }
  if (output.MicroPrecision !== undefined && output.MicroPrecision !== null) {
    contents.MicroPrecision = output.MicroPrecision;
  }
  if (output.MicroRecall !== undefined && output.MicroRecall !== null) {
    contents.MicroRecall = output.MicroRecall;
  }
  if (output.Precision !== undefined && output.Precision !== null) {
    contents.Precision = output.Precision;
  }
  if (output.Recall !== undefined && output.Recall !== null) {
    contents.Recall = output.Recall;
  }
  return contents;
};

const deserializeAws_json1_1ClassifierMetadata = (
  output: any,
  context: __SerdeContext
): ClassifierMetadata => {
  let contents: any = {
    __type: "ClassifierMetadata",
    EvaluationMetrics: undefined,
    NumberOfLabels: undefined,
    NumberOfTestDocuments: undefined,
    NumberOfTrainedDocuments: undefined
  };
  if (
    output.EvaluationMetrics !== undefined &&
    output.EvaluationMetrics !== null
  ) {
    contents.EvaluationMetrics = deserializeAws_json1_1ClassifierEvaluationMetrics(
      output.EvaluationMetrics,
      context
    );
  }
  if (output.NumberOfLabels !== undefined && output.NumberOfLabels !== null) {
    contents.NumberOfLabels = output.NumberOfLabels;
  }
  if (
    output.NumberOfTestDocuments !== undefined &&
    output.NumberOfTestDocuments !== null
  ) {
    contents.NumberOfTestDocuments = output.NumberOfTestDocuments;
  }
  if (
    output.NumberOfTrainedDocuments !== undefined &&
    output.NumberOfTrainedDocuments !== null
  ) {
    contents.NumberOfTrainedDocuments = output.NumberOfTrainedDocuments;
  }
  return contents;
};

const deserializeAws_json1_1ClassifyDocumentResponse = (
  output: any,
  context: __SerdeContext
): ClassifyDocumentResponse => {
  let contents: any = {
    __type: "ClassifyDocumentResponse",
    Classes: undefined,
    Labels: undefined
  };
  if (output.Classes !== undefined && output.Classes !== null) {
    contents.Classes = deserializeAws_json1_1ListOfClasses(
      output.Classes,
      context
    );
  }
  if (output.Labels !== undefined && output.Labels !== null) {
    contents.Labels = deserializeAws_json1_1ListOfLabels(
      output.Labels,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ConcurrentModificationException = (
  output: any,
  context: __SerdeContext
): ConcurrentModificationException => {
  let contents: any = {
    __type: "ConcurrentModificationException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1CreateDocumentClassifierResponse = (
  output: any,
  context: __SerdeContext
): CreateDocumentClassifierResponse => {
  let contents: any = {
    __type: "CreateDocumentClassifierResponse",
    DocumentClassifierArn: undefined
  };
  if (
    output.DocumentClassifierArn !== undefined &&
    output.DocumentClassifierArn !== null
  ) {
    contents.DocumentClassifierArn = output.DocumentClassifierArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateEndpointResponse = (
  output: any,
  context: __SerdeContext
): CreateEndpointResponse => {
  let contents: any = {
    __type: "CreateEndpointResponse",
    EndpointArn: undefined
  };
  if (output.EndpointArn !== undefined && output.EndpointArn !== null) {
    contents.EndpointArn = output.EndpointArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateEntityRecognizerResponse = (
  output: any,
  context: __SerdeContext
): CreateEntityRecognizerResponse => {
  let contents: any = {
    __type: "CreateEntityRecognizerResponse",
    EntityRecognizerArn: undefined
  };
  if (
    output.EntityRecognizerArn !== undefined &&
    output.EntityRecognizerArn !== null
  ) {
    contents.EntityRecognizerArn = output.EntityRecognizerArn;
  }
  return contents;
};

const deserializeAws_json1_1DeleteDocumentClassifierResponse = (
  output: any,
  context: __SerdeContext
): DeleteDocumentClassifierResponse => {
  let contents: any = {
    __type: "DeleteDocumentClassifierResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteEndpointResponse = (
  output: any,
  context: __SerdeContext
): DeleteEndpointResponse => {
  let contents: any = {
    __type: "DeleteEndpointResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteEntityRecognizerResponse = (
  output: any,
  context: __SerdeContext
): DeleteEntityRecognizerResponse => {
  let contents: any = {
    __type: "DeleteEntityRecognizerResponse"
  };
  return contents;
};

const deserializeAws_json1_1DescribeDocumentClassificationJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeDocumentClassificationJobResponse => {
  let contents: any = {
    __type: "DescribeDocumentClassificationJobResponse",
    DocumentClassificationJobProperties: undefined
  };
  if (
    output.DocumentClassificationJobProperties !== undefined &&
    output.DocumentClassificationJobProperties !== null
  ) {
    contents.DocumentClassificationJobProperties = deserializeAws_json1_1DocumentClassificationJobProperties(
      output.DocumentClassificationJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeDocumentClassifierResponse = (
  output: any,
  context: __SerdeContext
): DescribeDocumentClassifierResponse => {
  let contents: any = {
    __type: "DescribeDocumentClassifierResponse",
    DocumentClassifierProperties: undefined
  };
  if (
    output.DocumentClassifierProperties !== undefined &&
    output.DocumentClassifierProperties !== null
  ) {
    contents.DocumentClassifierProperties = deserializeAws_json1_1DocumentClassifierProperties(
      output.DocumentClassifierProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeDominantLanguageDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeDominantLanguageDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeDominantLanguageDetectionJobResponse",
    DominantLanguageDetectionJobProperties: undefined
  };
  if (
    output.DominantLanguageDetectionJobProperties !== undefined &&
    output.DominantLanguageDetectionJobProperties !== null
  ) {
    contents.DominantLanguageDetectionJobProperties = deserializeAws_json1_1DominantLanguageDetectionJobProperties(
      output.DominantLanguageDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEndpointResponse = (
  output: any,
  context: __SerdeContext
): DescribeEndpointResponse => {
  let contents: any = {
    __type: "DescribeEndpointResponse",
    EndpointProperties: undefined
  };
  if (
    output.EndpointProperties !== undefined &&
    output.EndpointProperties !== null
  ) {
    contents.EndpointProperties = deserializeAws_json1_1EndpointProperties(
      output.EndpointProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEntitiesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeEntitiesDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeEntitiesDetectionJobResponse",
    EntitiesDetectionJobProperties: undefined
  };
  if (
    output.EntitiesDetectionJobProperties !== undefined &&
    output.EntitiesDetectionJobProperties !== null
  ) {
    contents.EntitiesDetectionJobProperties = deserializeAws_json1_1EntitiesDetectionJobProperties(
      output.EntitiesDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEntityRecognizerResponse = (
  output: any,
  context: __SerdeContext
): DescribeEntityRecognizerResponse => {
  let contents: any = {
    __type: "DescribeEntityRecognizerResponse",
    EntityRecognizerProperties: undefined
  };
  if (
    output.EntityRecognizerProperties !== undefined &&
    output.EntityRecognizerProperties !== null
  ) {
    contents.EntityRecognizerProperties = deserializeAws_json1_1EntityRecognizerProperties(
      output.EntityRecognizerProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeKeyPhrasesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeKeyPhrasesDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeKeyPhrasesDetectionJobResponse",
    KeyPhrasesDetectionJobProperties: undefined
  };
  if (
    output.KeyPhrasesDetectionJobProperties !== undefined &&
    output.KeyPhrasesDetectionJobProperties !== null
  ) {
    contents.KeyPhrasesDetectionJobProperties = deserializeAws_json1_1KeyPhrasesDetectionJobProperties(
      output.KeyPhrasesDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeSentimentDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeSentimentDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeSentimentDetectionJobResponse",
    SentimentDetectionJobProperties: undefined
  };
  if (
    output.SentimentDetectionJobProperties !== undefined &&
    output.SentimentDetectionJobProperties !== null
  ) {
    contents.SentimentDetectionJobProperties = deserializeAws_json1_1SentimentDetectionJobProperties(
      output.SentimentDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeTopicsDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeTopicsDetectionJobResponse => {
  let contents: any = {
    __type: "DescribeTopicsDetectionJobResponse",
    TopicsDetectionJobProperties: undefined
  };
  if (
    output.TopicsDetectionJobProperties !== undefined &&
    output.TopicsDetectionJobProperties !== null
  ) {
    contents.TopicsDetectionJobProperties = deserializeAws_json1_1TopicsDetectionJobProperties(
      output.TopicsDetectionJobProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectDominantLanguageResponse = (
  output: any,
  context: __SerdeContext
): DetectDominantLanguageResponse => {
  let contents: any = {
    __type: "DetectDominantLanguageResponse",
    Languages: undefined
  };
  if (output.Languages !== undefined && output.Languages !== null) {
    contents.Languages = deserializeAws_json1_1ListOfDominantLanguages(
      output.Languages,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectEntitiesResponse = (
  output: any,
  context: __SerdeContext
): DetectEntitiesResponse => {
  let contents: any = {
    __type: "DetectEntitiesResponse",
    Entities: undefined
  };
  if (output.Entities !== undefined && output.Entities !== null) {
    contents.Entities = deserializeAws_json1_1ListOfEntities(
      output.Entities,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectKeyPhrasesResponse = (
  output: any,
  context: __SerdeContext
): DetectKeyPhrasesResponse => {
  let contents: any = {
    __type: "DetectKeyPhrasesResponse",
    KeyPhrases: undefined
  };
  if (output.KeyPhrases !== undefined && output.KeyPhrases !== null) {
    contents.KeyPhrases = deserializeAws_json1_1ListOfKeyPhrases(
      output.KeyPhrases,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectSentimentResponse = (
  output: any,
  context: __SerdeContext
): DetectSentimentResponse => {
  let contents: any = {
    __type: "DetectSentimentResponse",
    Sentiment: undefined,
    SentimentScore: undefined
  };
  if (output.Sentiment !== undefined && output.Sentiment !== null) {
    contents.Sentiment = output.Sentiment;
  }
  if (output.SentimentScore !== undefined && output.SentimentScore !== null) {
    contents.SentimentScore = deserializeAws_json1_1SentimentScore(
      output.SentimentScore,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DetectSyntaxResponse = (
  output: any,
  context: __SerdeContext
): DetectSyntaxResponse => {
  let contents: any = {
    __type: "DetectSyntaxResponse",
    SyntaxTokens: undefined
  };
  if (output.SyntaxTokens !== undefined && output.SyntaxTokens !== null) {
    contents.SyntaxTokens = deserializeAws_json1_1ListOfSyntaxTokens(
      output.SyntaxTokens,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DocumentClass = (
  output: any,
  context: __SerdeContext
): DocumentClass => {
  let contents: any = {
    __type: "DocumentClass",
    Name: undefined,
    Score: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Score !== undefined && output.Score !== null) {
    contents.Score = output.Score;
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassificationJobProperties = (
  output: any,
  context: __SerdeContext
): DocumentClassificationJobProperties => {
  let contents: any = {
    __type: "DocumentClassificationJobProperties",
    DataAccessRoleArn: undefined,
    DocumentClassifierArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (
    output.DataAccessRoleArn !== undefined &&
    output.DataAccessRoleArn !== null
  ) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (
    output.DocumentClassifierArn !== undefined &&
    output.DocumentClassifierArn !== null
  ) {
    contents.DocumentClassifierArn = output.DocumentClassifierArn;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.InputDataConfig !== undefined && output.InputDataConfig !== null) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (
    output.OutputDataConfig !== undefined &&
    output.OutputDataConfig !== null
  ) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined && output.SubmitTime !== null) {
    contents.SubmitTime = new Date(Math.round(output.SubmitTime * 1000));
  }
  if (output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined && output.VpcConfig !== null) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassificationJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<DocumentClassificationJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentClassificationJobProperties(entry, context)
  );
};

const deserializeAws_json1_1DocumentClassifierInputDataConfig = (
  output: any,
  context: __SerdeContext
): DocumentClassifierInputDataConfig => {
  let contents: any = {
    __type: "DocumentClassifierInputDataConfig",
    LabelDelimiter: undefined,
    S3Uri: undefined
  };
  if (output.LabelDelimiter !== undefined && output.LabelDelimiter !== null) {
    contents.LabelDelimiter = output.LabelDelimiter;
  }
  if (output.S3Uri !== undefined && output.S3Uri !== null) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassifierOutputDataConfig = (
  output: any,
  context: __SerdeContext
): DocumentClassifierOutputDataConfig => {
  let contents: any = {
    __type: "DocumentClassifierOutputDataConfig",
    KmsKeyId: undefined,
    S3Uri: undefined
  };
  if (output.KmsKeyId !== undefined && output.KmsKeyId !== null) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.S3Uri !== undefined && output.S3Uri !== null) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassifierProperties = (
  output: any,
  context: __SerdeContext
): DocumentClassifierProperties => {
  let contents: any = {
    __type: "DocumentClassifierProperties",
    ClassifierMetadata: undefined,
    DataAccessRoleArn: undefined,
    DocumentClassifierArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    LanguageCode: undefined,
    Message: undefined,
    Mode: undefined,
    OutputDataConfig: undefined,
    Status: undefined,
    SubmitTime: undefined,
    TrainingEndTime: undefined,
    TrainingStartTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (
    output.ClassifierMetadata !== undefined &&
    output.ClassifierMetadata !== null
  ) {
    contents.ClassifierMetadata = deserializeAws_json1_1ClassifierMetadata(
      output.ClassifierMetadata,
      context
    );
  }
  if (
    output.DataAccessRoleArn !== undefined &&
    output.DataAccessRoleArn !== null
  ) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (
    output.DocumentClassifierArn !== undefined &&
    output.DocumentClassifierArn !== null
  ) {
    contents.DocumentClassifierArn = output.DocumentClassifierArn;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.InputDataConfig !== undefined && output.InputDataConfig !== null) {
    contents.InputDataConfig = deserializeAws_json1_1DocumentClassifierInputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.Mode !== undefined && output.Mode !== null) {
    contents.Mode = output.Mode;
  }
  if (
    output.OutputDataConfig !== undefined &&
    output.OutputDataConfig !== null
  ) {
    contents.OutputDataConfig = deserializeAws_json1_1DocumentClassifierOutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.SubmitTime !== undefined && output.SubmitTime !== null) {
    contents.SubmitTime = new Date(Math.round(output.SubmitTime * 1000));
  }
  if (output.TrainingEndTime !== undefined && output.TrainingEndTime !== null) {
    contents.TrainingEndTime = new Date(
      Math.round(output.TrainingEndTime * 1000)
    );
  }
  if (
    output.TrainingStartTime !== undefined &&
    output.TrainingStartTime !== null
  ) {
    contents.TrainingStartTime = new Date(
      Math.round(output.TrainingStartTime * 1000)
    );
  }
  if (output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined && output.VpcConfig !== null) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DocumentClassifierPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<DocumentClassifierProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentClassifierProperties(entry, context)
  );
};

const deserializeAws_json1_1DocumentLabel = (
  output: any,
  context: __SerdeContext
): DocumentLabel => {
  let contents: any = {
    __type: "DocumentLabel",
    Name: undefined,
    Score: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Score !== undefined && output.Score !== null) {
    contents.Score = output.Score;
  }
  return contents;
};

const deserializeAws_json1_1DominantLanguage = (
  output: any,
  context: __SerdeContext
): DominantLanguage => {
  let contents: any = {
    __type: "DominantLanguage",
    LanguageCode: undefined,
    Score: undefined
  };
  if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Score !== undefined && output.Score !== null) {
    contents.Score = output.Score;
  }
  return contents;
};

const deserializeAws_json1_1DominantLanguageDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): DominantLanguageDetectionJobProperties => {
  let contents: any = {
    __type: "DominantLanguageDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (
    output.DataAccessRoleArn !== undefined &&
    output.DataAccessRoleArn !== null
  ) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.InputDataConfig !== undefined && output.InputDataConfig !== null) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (
    output.OutputDataConfig !== undefined &&
    output.OutputDataConfig !== null
  ) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined && output.SubmitTime !== null) {
    contents.SubmitTime = new Date(Math.round(output.SubmitTime * 1000));
  }
  if (output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined && output.VpcConfig !== null) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DominantLanguageDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<DominantLanguageDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DominantLanguageDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1EndpointProperties = (
  output: any,
  context: __SerdeContext
): EndpointProperties => {
  let contents: any = {
    __type: "EndpointProperties",
    CreationTime: undefined,
    CurrentInferenceUnits: undefined,
    DesiredInferenceUnits: undefined,
    EndpointArn: undefined,
    LastModifiedTime: undefined,
    Message: undefined,
    ModelArn: undefined,
    Status: undefined
  };
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (
    output.CurrentInferenceUnits !== undefined &&
    output.CurrentInferenceUnits !== null
  ) {
    contents.CurrentInferenceUnits = output.CurrentInferenceUnits;
  }
  if (
    output.DesiredInferenceUnits !== undefined &&
    output.DesiredInferenceUnits !== null
  ) {
    contents.DesiredInferenceUnits = output.DesiredInferenceUnits;
  }
  if (output.EndpointArn !== undefined && output.EndpointArn !== null) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (
    output.LastModifiedTime !== undefined &&
    output.LastModifiedTime !== null
  ) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.ModelArn !== undefined && output.ModelArn !== null) {
    contents.ModelArn = output.ModelArn;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1EndpointPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<EndpointProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EndpointProperties(entry, context)
  );
};

const deserializeAws_json1_1EntitiesDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): EntitiesDetectionJobProperties => {
  let contents: any = {
    __type: "EntitiesDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    EntityRecognizerArn: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    LanguageCode: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (
    output.DataAccessRoleArn !== undefined &&
    output.DataAccessRoleArn !== null
  ) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (
    output.EntityRecognizerArn !== undefined &&
    output.EntityRecognizerArn !== null
  ) {
    contents.EntityRecognizerArn = output.EntityRecognizerArn;
  }
  if (output.InputDataConfig !== undefined && output.InputDataConfig !== null) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (
    output.OutputDataConfig !== undefined &&
    output.OutputDataConfig !== null
  ) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined && output.SubmitTime !== null) {
    contents.SubmitTime = new Date(Math.round(output.SubmitTime * 1000));
  }
  if (output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined && output.VpcConfig !== null) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1EntitiesDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<EntitiesDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EntitiesDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1Entity = (
  output: any,
  context: __SerdeContext
): Entity => {
  let contents: any = {
    __type: "Entity",
    BeginOffset: undefined,
    EndOffset: undefined,
    Score: undefined,
    Text: undefined,
    Type: undefined
  };
  if (output.BeginOffset !== undefined && output.BeginOffset !== null) {
    contents.BeginOffset = output.BeginOffset;
  }
  if (output.EndOffset !== undefined && output.EndOffset !== null) {
    contents.EndOffset = output.EndOffset;
  }
  if (output.Score !== undefined && output.Score !== null) {
    contents.Score = output.Score;
  }
  if (output.Text !== undefined && output.Text !== null) {
    contents.Text = output.Text;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerAnnotations = (
  output: any,
  context: __SerdeContext
): EntityRecognizerAnnotations => {
  let contents: any = {
    __type: "EntityRecognizerAnnotations",
    S3Uri: undefined
  };
  if (output.S3Uri !== undefined && output.S3Uri !== null) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerDocuments = (
  output: any,
  context: __SerdeContext
): EntityRecognizerDocuments => {
  let contents: any = {
    __type: "EntityRecognizerDocuments",
    S3Uri: undefined
  };
  if (output.S3Uri !== undefined && output.S3Uri !== null) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerEntityList = (
  output: any,
  context: __SerdeContext
): EntityRecognizerEntityList => {
  let contents: any = {
    __type: "EntityRecognizerEntityList",
    S3Uri: undefined
  };
  if (output.S3Uri !== undefined && output.S3Uri !== null) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerEvaluationMetrics = (
  output: any,
  context: __SerdeContext
): EntityRecognizerEvaluationMetrics => {
  let contents: any = {
    __type: "EntityRecognizerEvaluationMetrics",
    F1Score: undefined,
    Precision: undefined,
    Recall: undefined
  };
  if (output.F1Score !== undefined && output.F1Score !== null) {
    contents.F1Score = output.F1Score;
  }
  if (output.Precision !== undefined && output.Precision !== null) {
    contents.Precision = output.Precision;
  }
  if (output.Recall !== undefined && output.Recall !== null) {
    contents.Recall = output.Recall;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerInputDataConfig = (
  output: any,
  context: __SerdeContext
): EntityRecognizerInputDataConfig => {
  let contents: any = {
    __type: "EntityRecognizerInputDataConfig",
    Annotations: undefined,
    Documents: undefined,
    EntityList: undefined,
    EntityTypes: undefined
  };
  if (output.Annotations !== undefined && output.Annotations !== null) {
    contents.Annotations = deserializeAws_json1_1EntityRecognizerAnnotations(
      output.Annotations,
      context
    );
  }
  if (output.Documents !== undefined && output.Documents !== null) {
    contents.Documents = deserializeAws_json1_1EntityRecognizerDocuments(
      output.Documents,
      context
    );
  }
  if (output.EntityList !== undefined && output.EntityList !== null) {
    contents.EntityList = deserializeAws_json1_1EntityRecognizerEntityList(
      output.EntityList,
      context
    );
  }
  if (output.EntityTypes !== undefined && output.EntityTypes !== null) {
    contents.EntityTypes = deserializeAws_json1_1EntityTypesList(
      output.EntityTypes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerMetadata = (
  output: any,
  context: __SerdeContext
): EntityRecognizerMetadata => {
  let contents: any = {
    __type: "EntityRecognizerMetadata",
    EntityTypes: undefined,
    EvaluationMetrics: undefined,
    NumberOfTestDocuments: undefined,
    NumberOfTrainedDocuments: undefined
  };
  if (output.EntityTypes !== undefined && output.EntityTypes !== null) {
    contents.EntityTypes = deserializeAws_json1_1EntityRecognizerMetadataEntityTypesList(
      output.EntityTypes,
      context
    );
  }
  if (
    output.EvaluationMetrics !== undefined &&
    output.EvaluationMetrics !== null
  ) {
    contents.EvaluationMetrics = deserializeAws_json1_1EntityRecognizerEvaluationMetrics(
      output.EvaluationMetrics,
      context
    );
  }
  if (
    output.NumberOfTestDocuments !== undefined &&
    output.NumberOfTestDocuments !== null
  ) {
    contents.NumberOfTestDocuments = output.NumberOfTestDocuments;
  }
  if (
    output.NumberOfTrainedDocuments !== undefined &&
    output.NumberOfTrainedDocuments !== null
  ) {
    contents.NumberOfTrainedDocuments = output.NumberOfTrainedDocuments;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerMetadataEntityTypesList = (
  output: any,
  context: __SerdeContext
): Array<EntityRecognizerMetadataEntityTypesListItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EntityRecognizerMetadataEntityTypesListItem(
      entry,
      context
    )
  );
};

const deserializeAws_json1_1EntityRecognizerMetadataEntityTypesListItem = (
  output: any,
  context: __SerdeContext
): EntityRecognizerMetadataEntityTypesListItem => {
  let contents: any = {
    __type: "EntityRecognizerMetadataEntityTypesListItem",
    EvaluationMetrics: undefined,
    NumberOfTrainMentions: undefined,
    Type: undefined
  };
  if (
    output.EvaluationMetrics !== undefined &&
    output.EvaluationMetrics !== null
  ) {
    contents.EvaluationMetrics = deserializeAws_json1_1EntityTypesEvaluationMetrics(
      output.EvaluationMetrics,
      context
    );
  }
  if (
    output.NumberOfTrainMentions !== undefined &&
    output.NumberOfTrainMentions !== null
  ) {
    contents.NumberOfTrainMentions = output.NumberOfTrainMentions;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerProperties = (
  output: any,
  context: __SerdeContext
): EntityRecognizerProperties => {
  let contents: any = {
    __type: "EntityRecognizerProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    EntityRecognizerArn: undefined,
    InputDataConfig: undefined,
    LanguageCode: undefined,
    Message: undefined,
    RecognizerMetadata: undefined,
    Status: undefined,
    SubmitTime: undefined,
    TrainingEndTime: undefined,
    TrainingStartTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (
    output.DataAccessRoleArn !== undefined &&
    output.DataAccessRoleArn !== null
  ) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (
    output.EntityRecognizerArn !== undefined &&
    output.EntityRecognizerArn !== null
  ) {
    contents.EntityRecognizerArn = output.EntityRecognizerArn;
  }
  if (output.InputDataConfig !== undefined && output.InputDataConfig !== null) {
    contents.InputDataConfig = deserializeAws_json1_1EntityRecognizerInputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (
    output.RecognizerMetadata !== undefined &&
    output.RecognizerMetadata !== null
  ) {
    contents.RecognizerMetadata = deserializeAws_json1_1EntityRecognizerMetadata(
      output.RecognizerMetadata,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.SubmitTime !== undefined && output.SubmitTime !== null) {
    contents.SubmitTime = new Date(Math.round(output.SubmitTime * 1000));
  }
  if (output.TrainingEndTime !== undefined && output.TrainingEndTime !== null) {
    contents.TrainingEndTime = new Date(
      Math.round(output.TrainingEndTime * 1000)
    );
  }
  if (
    output.TrainingStartTime !== undefined &&
    output.TrainingStartTime !== null
  ) {
    contents.TrainingStartTime = new Date(
      Math.round(output.TrainingStartTime * 1000)
    );
  }
  if (output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined && output.VpcConfig !== null) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1EntityRecognizerPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<EntityRecognizerProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EntityRecognizerProperties(entry, context)
  );
};

const deserializeAws_json1_1EntityTypesEvaluationMetrics = (
  output: any,
  context: __SerdeContext
): EntityTypesEvaluationMetrics => {
  let contents: any = {
    __type: "EntityTypesEvaluationMetrics",
    F1Score: undefined,
    Precision: undefined,
    Recall: undefined
  };
  if (output.F1Score !== undefined && output.F1Score !== null) {
    contents.F1Score = output.F1Score;
  }
  if (output.Precision !== undefined && output.Precision !== null) {
    contents.Precision = output.Precision;
  }
  if (output.Recall !== undefined && output.Recall !== null) {
    contents.Recall = output.Recall;
  }
  return contents;
};

const deserializeAws_json1_1EntityTypesList = (
  output: any,
  context: __SerdeContext
): Array<EntityTypesListItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EntityTypesListItem(entry, context)
  );
};

const deserializeAws_json1_1EntityTypesListItem = (
  output: any,
  context: __SerdeContext
): EntityTypesListItem => {
  let contents: any = {
    __type: "EntityTypesListItem",
    Type: undefined
  };
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1InputDataConfig = (
  output: any,
  context: __SerdeContext
): InputDataConfig => {
  let contents: any = {
    __type: "InputDataConfig",
    InputFormat: undefined,
    S3Uri: undefined
  };
  if (output.InputFormat !== undefined && output.InputFormat !== null) {
    contents.InputFormat = output.InputFormat;
  }
  if (output.S3Uri !== undefined && output.S3Uri !== null) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1InternalServerException = (
  output: any,
  context: __SerdeContext
): InternalServerException => {
  let contents: any = {
    __type: "InternalServerException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidFilterException = (
  output: any,
  context: __SerdeContext
): InvalidFilterException => {
  let contents: any = {
    __type: "InvalidFilterException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRequestException = (
  output: any,
  context: __SerdeContext
): InvalidRequestException => {
  let contents: any = {
    __type: "InvalidRequestException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1JobNotFoundException = (
  output: any,
  context: __SerdeContext
): JobNotFoundException => {
  let contents: any = {
    __type: "JobNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1KeyPhrase = (
  output: any,
  context: __SerdeContext
): KeyPhrase => {
  let contents: any = {
    __type: "KeyPhrase",
    BeginOffset: undefined,
    EndOffset: undefined,
    Score: undefined,
    Text: undefined
  };
  if (output.BeginOffset !== undefined && output.BeginOffset !== null) {
    contents.BeginOffset = output.BeginOffset;
  }
  if (output.EndOffset !== undefined && output.EndOffset !== null) {
    contents.EndOffset = output.EndOffset;
  }
  if (output.Score !== undefined && output.Score !== null) {
    contents.Score = output.Score;
  }
  if (output.Text !== undefined && output.Text !== null) {
    contents.Text = output.Text;
  }
  return contents;
};

const deserializeAws_json1_1KeyPhrasesDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): KeyPhrasesDetectionJobProperties => {
  let contents: any = {
    __type: "KeyPhrasesDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    LanguageCode: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (
    output.DataAccessRoleArn !== undefined &&
    output.DataAccessRoleArn !== null
  ) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.InputDataConfig !== undefined && output.InputDataConfig !== null) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (
    output.OutputDataConfig !== undefined &&
    output.OutputDataConfig !== null
  ) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined && output.SubmitTime !== null) {
    contents.SubmitTime = new Date(Math.round(output.SubmitTime * 1000));
  }
  if (output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined && output.VpcConfig !== null) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1KeyPhrasesDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<KeyPhrasesDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1KeyPhrasesDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1KmsKeyValidationException = (
  output: any,
  context: __SerdeContext
): KmsKeyValidationException => {
  let contents: any = {
    __type: "KmsKeyValidationException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ListDocumentClassificationJobsResponse = (
  output: any,
  context: __SerdeContext
): ListDocumentClassificationJobsResponse => {
  let contents: any = {
    __type: "ListDocumentClassificationJobsResponse",
    DocumentClassificationJobPropertiesList: undefined,
    NextToken: undefined
  };
  if (
    output.DocumentClassificationJobPropertiesList !== undefined &&
    output.DocumentClassificationJobPropertiesList !== null
  ) {
    contents.DocumentClassificationJobPropertiesList = deserializeAws_json1_1DocumentClassificationJobPropertiesList(
      output.DocumentClassificationJobPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListDocumentClassifiersResponse = (
  output: any,
  context: __SerdeContext
): ListDocumentClassifiersResponse => {
  let contents: any = {
    __type: "ListDocumentClassifiersResponse",
    DocumentClassifierPropertiesList: undefined,
    NextToken: undefined
  };
  if (
    output.DocumentClassifierPropertiesList !== undefined &&
    output.DocumentClassifierPropertiesList !== null
  ) {
    contents.DocumentClassifierPropertiesList = deserializeAws_json1_1DocumentClassifierPropertiesList(
      output.DocumentClassifierPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListDominantLanguageDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListDominantLanguageDetectionJobsResponse => {
  let contents: any = {
    __type: "ListDominantLanguageDetectionJobsResponse",
    DominantLanguageDetectionJobPropertiesList: undefined,
    NextToken: undefined
  };
  if (
    output.DominantLanguageDetectionJobPropertiesList !== undefined &&
    output.DominantLanguageDetectionJobPropertiesList !== null
  ) {
    contents.DominantLanguageDetectionJobPropertiesList = deserializeAws_json1_1DominantLanguageDetectionJobPropertiesList(
      output.DominantLanguageDetectionJobPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListEndpointsResponse = (
  output: any,
  context: __SerdeContext
): ListEndpointsResponse => {
  let contents: any = {
    __type: "ListEndpointsResponse",
    EndpointPropertiesList: undefined,
    NextToken: undefined
  };
  if (
    output.EndpointPropertiesList !== undefined &&
    output.EndpointPropertiesList !== null
  ) {
    contents.EndpointPropertiesList = deserializeAws_json1_1EndpointPropertiesList(
      output.EndpointPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListEntitiesDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListEntitiesDetectionJobsResponse => {
  let contents: any = {
    __type: "ListEntitiesDetectionJobsResponse",
    EntitiesDetectionJobPropertiesList: undefined,
    NextToken: undefined
  };
  if (
    output.EntitiesDetectionJobPropertiesList !== undefined &&
    output.EntitiesDetectionJobPropertiesList !== null
  ) {
    contents.EntitiesDetectionJobPropertiesList = deserializeAws_json1_1EntitiesDetectionJobPropertiesList(
      output.EntitiesDetectionJobPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListEntityRecognizersResponse = (
  output: any,
  context: __SerdeContext
): ListEntityRecognizersResponse => {
  let contents: any = {
    __type: "ListEntityRecognizersResponse",
    EntityRecognizerPropertiesList: undefined,
    NextToken: undefined
  };
  if (
    output.EntityRecognizerPropertiesList !== undefined &&
    output.EntityRecognizerPropertiesList !== null
  ) {
    contents.EntityRecognizerPropertiesList = deserializeAws_json1_1EntityRecognizerPropertiesList(
      output.EntityRecognizerPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListKeyPhrasesDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListKeyPhrasesDetectionJobsResponse => {
  let contents: any = {
    __type: "ListKeyPhrasesDetectionJobsResponse",
    KeyPhrasesDetectionJobPropertiesList: undefined,
    NextToken: undefined
  };
  if (
    output.KeyPhrasesDetectionJobPropertiesList !== undefined &&
    output.KeyPhrasesDetectionJobPropertiesList !== null
  ) {
    contents.KeyPhrasesDetectionJobPropertiesList = deserializeAws_json1_1KeyPhrasesDetectionJobPropertiesList(
      output.KeyPhrasesDetectionJobPropertiesList,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListOfClasses = (
  output: any,
  context: __SerdeContext
): Array<DocumentClass> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentClass(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectDominantLanguageResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectDominantLanguageItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectDominantLanguageItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectEntitiesResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectEntitiesItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectEntitiesItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectKeyPhrasesResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectKeyPhrasesItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectKeyPhrasesItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectSentimentResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectSentimentItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectSentimentItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDetectSyntaxResult = (
  output: any,
  context: __SerdeContext
): Array<BatchDetectSyntaxItemResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BatchDetectSyntaxItemResult(entry, context)
  );
};

const deserializeAws_json1_1ListOfDominantLanguages = (
  output: any,
  context: __SerdeContext
): Array<DominantLanguage> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DominantLanguage(entry, context)
  );
};

const deserializeAws_json1_1ListOfEntities = (
  output: any,
  context: __SerdeContext
): Array<Entity> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Entity(entry, context)
  );
};

const deserializeAws_json1_1ListOfKeyPhrases = (
  output: any,
  context: __SerdeContext
): Array<KeyPhrase> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1KeyPhrase(entry, context)
  );
};

const deserializeAws_json1_1ListOfLabels = (
  output: any,
  context: __SerdeContext
): Array<DocumentLabel> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DocumentLabel(entry, context)
  );
};

const deserializeAws_json1_1ListOfSyntaxTokens = (
  output: any,
  context: __SerdeContext
): Array<SyntaxToken> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SyntaxToken(entry, context)
  );
};

const deserializeAws_json1_1ListSentimentDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListSentimentDetectionJobsResponse => {
  let contents: any = {
    __type: "ListSentimentDetectionJobsResponse",
    NextToken: undefined,
    SentimentDetectionJobPropertiesList: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.SentimentDetectionJobPropertiesList !== undefined &&
    output.SentimentDetectionJobPropertiesList !== null
  ) {
    contents.SentimentDetectionJobPropertiesList = deserializeAws_json1_1SentimentDetectionJobPropertiesList(
      output.SentimentDetectionJobPropertiesList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTagsForResourceResponse = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResponse => {
  let contents: any = {
    __type: "ListTagsForResourceResponse",
    ResourceArn: undefined,
    Tags: undefined
  };
  if (output.ResourceArn !== undefined && output.ResourceArn !== null) {
    contents.ResourceArn = output.ResourceArn;
  }
  if (output.Tags !== undefined && output.Tags !== null) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1ListTopicsDetectionJobsResponse = (
  output: any,
  context: __SerdeContext
): ListTopicsDetectionJobsResponse => {
  let contents: any = {
    __type: "ListTopicsDetectionJobsResponse",
    NextToken: undefined,
    TopicsDetectionJobPropertiesList: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (
    output.TopicsDetectionJobPropertiesList !== undefined &&
    output.TopicsDetectionJobPropertiesList !== null
  ) {
    contents.TopicsDetectionJobPropertiesList = deserializeAws_json1_1TopicsDetectionJobPropertiesList(
      output.TopicsDetectionJobPropertiesList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1OutputDataConfig = (
  output: any,
  context: __SerdeContext
): OutputDataConfig => {
  let contents: any = {
    __type: "OutputDataConfig",
    KmsKeyId: undefined,
    S3Uri: undefined
  };
  if (output.KmsKeyId !== undefined && output.KmsKeyId !== null) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.S3Uri !== undefined && output.S3Uri !== null) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1PartOfSpeechTag = (
  output: any,
  context: __SerdeContext
): PartOfSpeechTag => {
  let contents: any = {
    __type: "PartOfSpeechTag",
    Score: undefined,
    Tag: undefined
  };
  if (output.Score !== undefined && output.Score !== null) {
    contents.Score = output.Score;
  }
  if (output.Tag !== undefined && output.Tag !== null) {
    contents.Tag = output.Tag;
  }
  return contents;
};

const deserializeAws_json1_1ResourceInUseException = (
  output: any,
  context: __SerdeContext
): ResourceInUseException => {
  let contents: any = {
    __type: "ResourceInUseException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceLimitExceededException = (
  output: any,
  context: __SerdeContext
): ResourceLimitExceededException => {
  let contents: any = {
    __type: "ResourceLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundException = (
  output: any,
  context: __SerdeContext
): ResourceNotFoundException => {
  let contents: any = {
    __type: "ResourceNotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceUnavailableException = (
  output: any,
  context: __SerdeContext
): ResourceUnavailableException => {
  let contents: any = {
    __type: "ResourceUnavailableException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1SecurityGroupIds = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SentimentDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): SentimentDetectionJobProperties => {
  let contents: any = {
    __type: "SentimentDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    LanguageCode: undefined,
    Message: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (
    output.DataAccessRoleArn !== undefined &&
    output.DataAccessRoleArn !== null
  ) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.InputDataConfig !== undefined && output.InputDataConfig !== null) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.LanguageCode !== undefined && output.LanguageCode !== null) {
    contents.LanguageCode = output.LanguageCode;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (
    output.OutputDataConfig !== undefined &&
    output.OutputDataConfig !== null
  ) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined && output.SubmitTime !== null) {
    contents.SubmitTime = new Date(Math.round(output.SubmitTime * 1000));
  }
  if (output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined && output.VpcConfig !== null) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1SentimentDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<SentimentDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SentimentDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1SentimentScore = (
  output: any,
  context: __SerdeContext
): SentimentScore => {
  let contents: any = {
    __type: "SentimentScore",
    Mixed: undefined,
    Negative: undefined,
    Neutral: undefined,
    Positive: undefined
  };
  if (output.Mixed !== undefined && output.Mixed !== null) {
    contents.Mixed = output.Mixed;
  }
  if (output.Negative !== undefined && output.Negative !== null) {
    contents.Negative = output.Negative;
  }
  if (output.Neutral !== undefined && output.Neutral !== null) {
    contents.Neutral = output.Neutral;
  }
  if (output.Positive !== undefined && output.Positive !== null) {
    contents.Positive = output.Positive;
  }
  return contents;
};

const deserializeAws_json1_1StartDocumentClassificationJobResponse = (
  output: any,
  context: __SerdeContext
): StartDocumentClassificationJobResponse => {
  let contents: any = {
    __type: "StartDocumentClassificationJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartDominantLanguageDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartDominantLanguageDetectionJobResponse => {
  let contents: any = {
    __type: "StartDominantLanguageDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartEntitiesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartEntitiesDetectionJobResponse => {
  let contents: any = {
    __type: "StartEntitiesDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartKeyPhrasesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartKeyPhrasesDetectionJobResponse => {
  let contents: any = {
    __type: "StartKeyPhrasesDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartSentimentDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartSentimentDetectionJobResponse => {
  let contents: any = {
    __type: "StartSentimentDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StartTopicsDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StartTopicsDetectionJobResponse => {
  let contents: any = {
    __type: "StartTopicsDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopDominantLanguageDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StopDominantLanguageDetectionJobResponse => {
  let contents: any = {
    __type: "StopDominantLanguageDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopEntitiesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StopEntitiesDetectionJobResponse => {
  let contents: any = {
    __type: "StopEntitiesDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopKeyPhrasesDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StopKeyPhrasesDetectionJobResponse => {
  let contents: any = {
    __type: "StopKeyPhrasesDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopSentimentDetectionJobResponse = (
  output: any,
  context: __SerdeContext
): StopSentimentDetectionJobResponse => {
  let contents: any = {
    __type: "StopSentimentDetectionJobResponse",
    JobId: undefined,
    JobStatus: undefined
  };
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  return contents;
};

const deserializeAws_json1_1StopTrainingDocumentClassifierResponse = (
  output: any,
  context: __SerdeContext
): StopTrainingDocumentClassifierResponse => {
  let contents: any = {
    __type: "StopTrainingDocumentClassifierResponse"
  };
  return contents;
};

const deserializeAws_json1_1StopTrainingEntityRecognizerResponse = (
  output: any,
  context: __SerdeContext
): StopTrainingEntityRecognizerResponse => {
  let contents: any = {
    __type: "StopTrainingEntityRecognizerResponse"
  };
  return contents;
};

const deserializeAws_json1_1Subnets = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SyntaxToken = (
  output: any,
  context: __SerdeContext
): SyntaxToken => {
  let contents: any = {
    __type: "SyntaxToken",
    BeginOffset: undefined,
    EndOffset: undefined,
    PartOfSpeech: undefined,
    Text: undefined,
    TokenId: undefined
  };
  if (output.BeginOffset !== undefined && output.BeginOffset !== null) {
    contents.BeginOffset = output.BeginOffset;
  }
  if (output.EndOffset !== undefined && output.EndOffset !== null) {
    contents.EndOffset = output.EndOffset;
  }
  if (output.PartOfSpeech !== undefined && output.PartOfSpeech !== null) {
    contents.PartOfSpeech = deserializeAws_json1_1PartOfSpeechTag(
      output.PartOfSpeech,
      context
    );
  }
  if (output.Text !== undefined && output.Text !== null) {
    contents.Text = output.Text;
  }
  if (output.TokenId !== undefined && output.TokenId !== null) {
    contents.TokenId = output.TokenId;
  }
  return contents;
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TagResourceResponse = (
  output: any,
  context: __SerdeContext
): TagResourceResponse => {
  let contents: any = {
    __type: "TagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1TextSizeLimitExceededException = (
  output: any,
  context: __SerdeContext
): TextSizeLimitExceededException => {
  let contents: any = {
    __type: "TextSizeLimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TooManyRequestsException = (
  output: any,
  context: __SerdeContext
): TooManyRequestsException => {
  let contents: any = {
    __type: "TooManyRequestsException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TooManyTagKeysException = (
  output: any,
  context: __SerdeContext
): TooManyTagKeysException => {
  let contents: any = {
    __type: "TooManyTagKeysException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TooManyTagsException = (
  output: any,
  context: __SerdeContext
): TooManyTagsException => {
  let contents: any = {
    __type: "TooManyTagsException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TopicsDetectionJobProperties = (
  output: any,
  context: __SerdeContext
): TopicsDetectionJobProperties => {
  let contents: any = {
    __type: "TopicsDetectionJobProperties",
    DataAccessRoleArn: undefined,
    EndTime: undefined,
    InputDataConfig: undefined,
    JobId: undefined,
    JobName: undefined,
    JobStatus: undefined,
    Message: undefined,
    NumberOfTopics: undefined,
    OutputDataConfig: undefined,
    SubmitTime: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (
    output.DataAccessRoleArn !== undefined &&
    output.DataAccessRoleArn !== null
  ) {
    contents.DataAccessRoleArn = output.DataAccessRoleArn;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.InputDataConfig !== undefined && output.InputDataConfig !== null) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.JobId !== undefined && output.JobId !== null) {
    contents.JobId = output.JobId;
  }
  if (output.JobName !== undefined && output.JobName !== null) {
    contents.JobName = output.JobName;
  }
  if (output.JobStatus !== undefined && output.JobStatus !== null) {
    contents.JobStatus = output.JobStatus;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.NumberOfTopics !== undefined && output.NumberOfTopics !== null) {
    contents.NumberOfTopics = output.NumberOfTopics;
  }
  if (
    output.OutputDataConfig !== undefined &&
    output.OutputDataConfig !== null
  ) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.SubmitTime !== undefined && output.SubmitTime !== null) {
    contents.SubmitTime = new Date(Math.round(output.SubmitTime * 1000));
  }
  if (output.VolumeKmsKeyId !== undefined && output.VolumeKmsKeyId !== null) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined && output.VpcConfig !== null) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TopicsDetectionJobPropertiesList = (
  output: any,
  context: __SerdeContext
): Array<TopicsDetectionJobProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TopicsDetectionJobProperties(entry, context)
  );
};

const deserializeAws_json1_1UnsupportedLanguageException = (
  output: any,
  context: __SerdeContext
): UnsupportedLanguageException => {
  let contents: any = {
    __type: "UnsupportedLanguageException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UntagResourceResponse = (
  output: any,
  context: __SerdeContext
): UntagResourceResponse => {
  let contents: any = {
    __type: "UntagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateEndpointResponse = (
  output: any,
  context: __SerdeContext
): UpdateEndpointResponse => {
  let contents: any = {
    __type: "UpdateEndpointResponse"
  };
  return contents;
};

const deserializeAws_json1_1VpcConfig = (
  output: any,
  context: __SerdeContext
): VpcConfig => {
  let contents: any = {
    __type: "VpcConfig",
    SecurityGroupIds: undefined,
    Subnets: undefined
  };
  if (
    output.SecurityGroupIds !== undefined &&
    output.SecurityGroupIds !== null
  ) {
    contents.SecurityGroupIds = deserializeAws_json1_1SecurityGroupIds(
      output.SecurityGroupIds,
      context
    );
  }
  if (output.Subnets !== undefined && output.Subnets !== null) {
    contents.Subnets = deserializeAws_json1_1Subnets(output.Subnets, context);
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
