// smithy-typescript generated code
import { ExceptionOptionType as __ExceptionOptionType, SENSITIVE_STRING } from "@smithy/smithy-client";

import { EKSAuthServiceException as __BaseException } from "./EKSAuthServiceException";

/**
 * @public
 * <p>You don't have permissions to perform the requested operation. The IAM principal
 *             making the request must have at least one IAM permissions policy attached
 *             that grants the required permissions. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html">Access
 *                 management</a> in the <i>IAM User Guide</i>. </p>
 */
export class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException" = "AccessDeniedException";
  readonly $fault: "client" = "client";
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, AccessDeniedException.prototype);
  }
}

/**
 * @public
 * <p>An object with the permanent IAM role identity and the temporary session
 *             name.</p>
 */
export interface AssumedRoleUser {
  /**
   * @public
   * <p>The ARN of the IAM role that the temporary credentials authenticate to.</p>
   */
  arn: string | undefined;

  /**
   * @public
   * <p>The session name of the temporary session requested to STS. The value
   *             is a unique identifier that contains the role ID, a colon (<code>:</code>), and the role
   *             session name of the role that is being assumed. The role ID is generated by IAM when
   *             the role is created. The role session name part of the value follows this format:
   *                     <code>eks-<i>clustername</i>-<i>podname</i>-<i>random
   *                     UUID</i>
   *             </code>
   *          </p>
   */
  assumeRoleId: string | undefined;
}

/**
 * @public
 */
export interface AssumeRoleForPodIdentityRequest {
  /**
   * @public
   * <p>The name of the cluster for the request.</p>
   */
  clusterName: string | undefined;

  /**
   * @public
   * <p>The token of the Kubernetes service account for the pod.</p>
   */
  token: string | undefined;
}

/**
 * @public
 * <p>The <i>Amazon Web Services Signature Version 4</i> type of temporary
 *             credentials.</p>
 */
export interface Credentials {
  /**
   * @public
   * <p>The token that applications inside the pods must pass to any service API to use the
   *             temporary credentials.</p>
   */
  sessionToken: string | undefined;

  /**
   * @public
   * <p>The secret access key that applications inside the pods use to sign requests.</p>
   */
  secretAccessKey: string | undefined;

  /**
   * @public
   * <p>The access key ID that identifies the temporary security credentials.</p>
   */
  accessKeyId: string | undefined;

  /**
   * @public
   * <p>The Unix epoch timestamp in seconds when the current credentials expire.</p>
   */
  expiration: Date | undefined;
}

/**
 * @public
 * <p>Amazon EKS Pod Identity associations provide the ability to manage credentials for your applications, similar to the way that Amazon EC2 instance profiles provide credentials to Amazon EC2 instances.</p>
 */
export interface PodIdentityAssociation {
  /**
   * @public
   * <p>The Amazon Resource Name (ARN) of the EKS Pod Identity association.</p>
   */
  associationArn: string | undefined;

  /**
   * @public
   * <p>The ID of the association.</p>
   */
  associationId: string | undefined;
}

/**
 * @public
 * <p>An object containing the name of the Kubernetes service account inside the cluster to
 *             associate the IAM credentials with.</p>
 */
export interface Subject {
  /**
   * @public
   * <p>The name of the Kubernetes namespace inside the cluster to create the association in. The
   *             service account and the pods that use the service account must be in this
   *             namespace.</p>
   */
  namespace: string | undefined;

  /**
   * @public
   * <p>The name of the Kubernetes service account inside the cluster to associate the IAM
   *             credentials with.</p>
   */
  serviceAccount: string | undefined;
}

/**
 * @public
 */
export interface AssumeRoleForPodIdentityResponse {
  /**
   * @public
   * <p>The name of the Kubernetes service account inside the cluster to associate the IAM
   *             credentials with.</p>
   */
  subject: Subject | undefined;

  /**
   * @public
   * <p>The identity that is allowed to use the credentials. This value is always
   *                 <code>pods.eks.amazonaws.com</code>.</p>
   */
  audience: string | undefined;

  /**
   * @public
   * <p>The Amazon Resource Name (ARN) and ID of the EKS Pod Identity association.</p>
   */
  podIdentityAssociation: PodIdentityAssociation | undefined;

  /**
   * @public
   * <p>An object with the permanent IAM role identity and the temporary session
   *             name.</p>
   *          <p>The ARN of the IAM role that the temporary credentials authenticate to.</p>
   *          <p>The session name of the temporary session requested to STS. The value
   *             is a unique identifier that contains the role ID, a colon (<code>:</code>), and the role
   *             session name of the role that is being assumed. The role ID is generated by IAM when
   *             the role is created. The role session name part of the value follows this format:
   *                     <code>eks-<i>clustername</i>-<i>podname</i>-<i>random
   *                     UUID</i>
   *             </code>
   *          </p>
   */
  assumedRoleUser: AssumedRoleUser | undefined;

  /**
   * @public
   * <p>The <i>Amazon Web Services Signature Version 4</i> type of temporary
   *             credentials.</p>
   */
  credentials: Credentials | undefined;
}

/**
 * @public
 * <p>The specified Kubernetes service account token is expired.</p>
 */
export class ExpiredTokenException extends __BaseException {
  readonly name: "ExpiredTokenException" = "ExpiredTokenException";
  readonly $fault: "client" = "client";
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<ExpiredTokenException, __BaseException>) {
    super({
      name: "ExpiredTokenException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, ExpiredTokenException.prototype);
  }
}

/**
 * @public
 * <p>These errors are usually caused by a server-side issue.</p>
 */
export class InternalServerException extends __BaseException {
  readonly name: "InternalServerException" = "InternalServerException";
  readonly $fault: "server" = "server";
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...opts,
    });
    Object.setPrototypeOf(this, InternalServerException.prototype);
  }
}

/**
 * @public
 * <p>The specified parameter is invalid. Review the available parameters for the API
 *             request.</p>
 */
export class InvalidParameterException extends __BaseException {
  readonly name: "InvalidParameterException" = "InvalidParameterException";
  readonly $fault: "client" = "client";
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<InvalidParameterException, __BaseException>) {
    super({
      name: "InvalidParameterException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, InvalidParameterException.prototype);
  }
}

/**
 * @public
 * <p>This exception is thrown if the request contains a semantic error. The precise meaning
 *             will depend on the API, and will be documented in the error message.</p>
 */
export class InvalidRequestException extends __BaseException {
  readonly name: "InvalidRequestException" = "InvalidRequestException";
  readonly $fault: "client" = "client";
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<InvalidRequestException, __BaseException>) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, InvalidRequestException.prototype);
  }
}

/**
 * @public
 * <p>The specified Kubernetes service account token is invalid.</p>
 */
export class InvalidTokenException extends __BaseException {
  readonly name: "InvalidTokenException" = "InvalidTokenException";
  readonly $fault: "client" = "client";
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<InvalidTokenException, __BaseException>) {
    super({
      name: "InvalidTokenException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, InvalidTokenException.prototype);
  }
}

/**
 * @public
 * <p>The specified resource could not be found.</p>
 */
export class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException" = "ResourceNotFoundException";
  readonly $fault: "client" = "client";
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
  }
}

/**
 * @public
 * <p>The service is unavailable. Back off and retry the operation.</p>
 */
export class ServiceUnavailableException extends __BaseException {
  readonly name: "ServiceUnavailableException" = "ServiceUnavailableException";
  readonly $fault: "server" = "server";
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>) {
    super({
      name: "ServiceUnavailableException",
      $fault: "server",
      ...opts,
    });
    Object.setPrototypeOf(this, ServiceUnavailableException.prototype);
  }
}

/**
 * @public
 * <p>The request was denied because your request rate is too high. Reduce the frequency of requests.</p>
 */
export class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException" = "ThrottlingException";
  readonly $fault: "client" = "client";
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>) {
    super({
      name: "ThrottlingException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, ThrottlingException.prototype);
  }
}

/**
 * @internal
 */
export const AssumeRoleForPodIdentityRequestFilterSensitiveLog = (obj: AssumeRoleForPodIdentityRequest): any => ({
  ...obj,
  ...(obj.token && { token: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const CredentialsFilterSensitiveLog = (obj: Credentials): any => ({
  ...obj,
});

/**
 * @internal
 */
export const AssumeRoleForPodIdentityResponseFilterSensitiveLog = (obj: AssumeRoleForPodIdentityResponse): any => ({
  ...obj,
  ...(obj.credentials && { credentials: SENSITIVE_STRING }),
});
