import {
  AcceptDirectConnectGatewayAssociationProposalCommandInput,
  AcceptDirectConnectGatewayAssociationProposalCommandOutput
} from "../commands/AcceptDirectConnectGatewayAssociationProposalCommand";
import {
  AllocateConnectionOnInterconnectCommandInput,
  AllocateConnectionOnInterconnectCommandOutput
} from "../commands/AllocateConnectionOnInterconnectCommand";
import {
  AllocateHostedConnectionCommandInput,
  AllocateHostedConnectionCommandOutput
} from "../commands/AllocateHostedConnectionCommand";
import {
  AllocatePrivateVirtualInterfaceCommandInput,
  AllocatePrivateVirtualInterfaceCommandOutput
} from "../commands/AllocatePrivateVirtualInterfaceCommand";
import {
  AllocatePublicVirtualInterfaceCommandInput,
  AllocatePublicVirtualInterfaceCommandOutput
} from "../commands/AllocatePublicVirtualInterfaceCommand";
import {
  AllocateTransitVirtualInterfaceCommandInput,
  AllocateTransitVirtualInterfaceCommandOutput
} from "../commands/AllocateTransitVirtualInterfaceCommand";
import {
  AssociateConnectionWithLagCommandInput,
  AssociateConnectionWithLagCommandOutput
} from "../commands/AssociateConnectionWithLagCommand";
import {
  AssociateHostedConnectionCommandInput,
  AssociateHostedConnectionCommandOutput
} from "../commands/AssociateHostedConnectionCommand";
import {
  AssociateVirtualInterfaceCommandInput,
  AssociateVirtualInterfaceCommandOutput
} from "../commands/AssociateVirtualInterfaceCommand";
import {
  ConfirmConnectionCommandInput,
  ConfirmConnectionCommandOutput
} from "../commands/ConfirmConnectionCommand";
import {
  ConfirmPrivateVirtualInterfaceCommandInput,
  ConfirmPrivateVirtualInterfaceCommandOutput
} from "../commands/ConfirmPrivateVirtualInterfaceCommand";
import {
  ConfirmPublicVirtualInterfaceCommandInput,
  ConfirmPublicVirtualInterfaceCommandOutput
} from "../commands/ConfirmPublicVirtualInterfaceCommand";
import {
  ConfirmTransitVirtualInterfaceCommandInput,
  ConfirmTransitVirtualInterfaceCommandOutput
} from "../commands/ConfirmTransitVirtualInterfaceCommand";
import {
  CreateBGPPeerCommandInput,
  CreateBGPPeerCommandOutput
} from "../commands/CreateBGPPeerCommand";
import {
  CreateConnectionCommandInput,
  CreateConnectionCommandOutput
} from "../commands/CreateConnectionCommand";
import {
  CreateDirectConnectGatewayAssociationCommandInput,
  CreateDirectConnectGatewayAssociationCommandOutput
} from "../commands/CreateDirectConnectGatewayAssociationCommand";
import {
  CreateDirectConnectGatewayAssociationProposalCommandInput,
  CreateDirectConnectGatewayAssociationProposalCommandOutput
} from "../commands/CreateDirectConnectGatewayAssociationProposalCommand";
import {
  CreateDirectConnectGatewayCommandInput,
  CreateDirectConnectGatewayCommandOutput
} from "../commands/CreateDirectConnectGatewayCommand";
import {
  CreateInterconnectCommandInput,
  CreateInterconnectCommandOutput
} from "../commands/CreateInterconnectCommand";
import {
  CreateLagCommandInput,
  CreateLagCommandOutput
} from "../commands/CreateLagCommand";
import {
  CreatePrivateVirtualInterfaceCommandInput,
  CreatePrivateVirtualInterfaceCommandOutput
} from "../commands/CreatePrivateVirtualInterfaceCommand";
import {
  CreatePublicVirtualInterfaceCommandInput,
  CreatePublicVirtualInterfaceCommandOutput
} from "../commands/CreatePublicVirtualInterfaceCommand";
import {
  CreateTransitVirtualInterfaceCommandInput,
  CreateTransitVirtualInterfaceCommandOutput
} from "../commands/CreateTransitVirtualInterfaceCommand";
import {
  DeleteBGPPeerCommandInput,
  DeleteBGPPeerCommandOutput
} from "../commands/DeleteBGPPeerCommand";
import {
  DeleteConnectionCommandInput,
  DeleteConnectionCommandOutput
} from "../commands/DeleteConnectionCommand";
import {
  DeleteDirectConnectGatewayAssociationCommandInput,
  DeleteDirectConnectGatewayAssociationCommandOutput
} from "../commands/DeleteDirectConnectGatewayAssociationCommand";
import {
  DeleteDirectConnectGatewayAssociationProposalCommandInput,
  DeleteDirectConnectGatewayAssociationProposalCommandOutput
} from "../commands/DeleteDirectConnectGatewayAssociationProposalCommand";
import {
  DeleteDirectConnectGatewayCommandInput,
  DeleteDirectConnectGatewayCommandOutput
} from "../commands/DeleteDirectConnectGatewayCommand";
import {
  DeleteInterconnectCommandInput,
  DeleteInterconnectCommandOutput
} from "../commands/DeleteInterconnectCommand";
import {
  DeleteLagCommandInput,
  DeleteLagCommandOutput
} from "../commands/DeleteLagCommand";
import {
  DeleteVirtualInterfaceCommandInput,
  DeleteVirtualInterfaceCommandOutput
} from "../commands/DeleteVirtualInterfaceCommand";
import {
  DescribeConnectionLoaCommandInput,
  DescribeConnectionLoaCommandOutput
} from "../commands/DescribeConnectionLoaCommand";
import {
  DescribeConnectionsCommandInput,
  DescribeConnectionsCommandOutput
} from "../commands/DescribeConnectionsCommand";
import {
  DescribeConnectionsOnInterconnectCommandInput,
  DescribeConnectionsOnInterconnectCommandOutput
} from "../commands/DescribeConnectionsOnInterconnectCommand";
import {
  DescribeDirectConnectGatewayAssociationProposalsCommandInput,
  DescribeDirectConnectGatewayAssociationProposalsCommandOutput
} from "../commands/DescribeDirectConnectGatewayAssociationProposalsCommand";
import {
  DescribeDirectConnectGatewayAssociationsCommandInput,
  DescribeDirectConnectGatewayAssociationsCommandOutput
} from "../commands/DescribeDirectConnectGatewayAssociationsCommand";
import {
  DescribeDirectConnectGatewayAttachmentsCommandInput,
  DescribeDirectConnectGatewayAttachmentsCommandOutput
} from "../commands/DescribeDirectConnectGatewayAttachmentsCommand";
import {
  DescribeDirectConnectGatewaysCommandInput,
  DescribeDirectConnectGatewaysCommandOutput
} from "../commands/DescribeDirectConnectGatewaysCommand";
import {
  DescribeHostedConnectionsCommandInput,
  DescribeHostedConnectionsCommandOutput
} from "../commands/DescribeHostedConnectionsCommand";
import {
  DescribeInterconnectLoaCommandInput,
  DescribeInterconnectLoaCommandOutput
} from "../commands/DescribeInterconnectLoaCommand";
import {
  DescribeInterconnectsCommandInput,
  DescribeInterconnectsCommandOutput
} from "../commands/DescribeInterconnectsCommand";
import {
  DescribeLagsCommandInput,
  DescribeLagsCommandOutput
} from "../commands/DescribeLagsCommand";
import {
  DescribeLoaCommandInput,
  DescribeLoaCommandOutput
} from "../commands/DescribeLoaCommand";
import {
  DescribeLocationsCommandInput,
  DescribeLocationsCommandOutput
} from "../commands/DescribeLocationsCommand";
import {
  DescribeTagsCommandInput,
  DescribeTagsCommandOutput
} from "../commands/DescribeTagsCommand";
import {
  DescribeVirtualGatewaysCommandInput,
  DescribeVirtualGatewaysCommandOutput
} from "../commands/DescribeVirtualGatewaysCommand";
import {
  DescribeVirtualInterfacesCommandInput,
  DescribeVirtualInterfacesCommandOutput
} from "../commands/DescribeVirtualInterfacesCommand";
import {
  DisassociateConnectionFromLagCommandInput,
  DisassociateConnectionFromLagCommandOutput
} from "../commands/DisassociateConnectionFromLagCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateDirectConnectGatewayAssociationCommandInput,
  UpdateDirectConnectGatewayAssociationCommandOutput
} from "../commands/UpdateDirectConnectGatewayAssociationCommand";
import {
  UpdateLagCommandInput,
  UpdateLagCommandOutput
} from "../commands/UpdateLagCommand";
import {
  UpdateVirtualInterfaceAttributesCommandInput,
  UpdateVirtualInterfaceAttributesCommandOutput
} from "../commands/UpdateVirtualInterfaceAttributesCommand";
import {
  AcceptDirectConnectGatewayAssociationProposalRequest,
  AcceptDirectConnectGatewayAssociationProposalResult,
  AllocateConnectionOnInterconnectRequest,
  AllocateHostedConnectionRequest,
  AllocatePrivateVirtualInterfaceRequest,
  AllocatePublicVirtualInterfaceRequest,
  AllocateTransitVirtualInterfaceRequest,
  AllocateTransitVirtualInterfaceResult,
  AssociateConnectionWithLagRequest,
  AssociateHostedConnectionRequest,
  AssociateVirtualInterfaceRequest,
  AssociatedGateway,
  BGPPeer,
  ConfirmConnectionRequest,
  ConfirmConnectionResponse,
  ConfirmPrivateVirtualInterfaceRequest,
  ConfirmPrivateVirtualInterfaceResponse,
  ConfirmPublicVirtualInterfaceRequest,
  ConfirmPublicVirtualInterfaceResponse,
  ConfirmTransitVirtualInterfaceRequest,
  ConfirmTransitVirtualInterfaceResponse,
  Connection,
  Connections,
  CreateBGPPeerRequest,
  CreateBGPPeerResponse,
  CreateConnectionRequest,
  CreateDirectConnectGatewayAssociationProposalRequest,
  CreateDirectConnectGatewayAssociationProposalResult,
  CreateDirectConnectGatewayAssociationRequest,
  CreateDirectConnectGatewayAssociationResult,
  CreateDirectConnectGatewayRequest,
  CreateDirectConnectGatewayResult,
  CreateInterconnectRequest,
  CreateLagRequest,
  CreatePrivateVirtualInterfaceRequest,
  CreatePublicVirtualInterfaceRequest,
  CreateTransitVirtualInterfaceRequest,
  CreateTransitVirtualInterfaceResult,
  DeleteBGPPeerRequest,
  DeleteBGPPeerResponse,
  DeleteConnectionRequest,
  DeleteDirectConnectGatewayAssociationProposalRequest,
  DeleteDirectConnectGatewayAssociationProposalResult,
  DeleteDirectConnectGatewayAssociationRequest,
  DeleteDirectConnectGatewayAssociationResult,
  DeleteDirectConnectGatewayRequest,
  DeleteDirectConnectGatewayResult,
  DeleteInterconnectRequest,
  DeleteInterconnectResponse,
  DeleteLagRequest,
  DeleteVirtualInterfaceRequest,
  DeleteVirtualInterfaceResponse,
  DescribeConnectionLoaRequest,
  DescribeConnectionLoaResponse,
  DescribeConnectionsOnInterconnectRequest,
  DescribeConnectionsRequest,
  DescribeDirectConnectGatewayAssociationProposalsRequest,
  DescribeDirectConnectGatewayAssociationProposalsResult,
  DescribeDirectConnectGatewayAssociationsRequest,
  DescribeDirectConnectGatewayAssociationsResult,
  DescribeDirectConnectGatewayAttachmentsRequest,
  DescribeDirectConnectGatewayAttachmentsResult,
  DescribeDirectConnectGatewaysRequest,
  DescribeDirectConnectGatewaysResult,
  DescribeHostedConnectionsRequest,
  DescribeInterconnectLoaRequest,
  DescribeInterconnectLoaResponse,
  DescribeInterconnectsRequest,
  DescribeLagsRequest,
  DescribeLoaRequest,
  DescribeTagsRequest,
  DescribeTagsResponse,
  DescribeVirtualInterfacesRequest,
  DirectConnectClientException,
  DirectConnectGateway,
  DirectConnectGatewayAssociation,
  DirectConnectGatewayAssociationProposal,
  DirectConnectGatewayAttachment,
  DirectConnectServerException,
  DisassociateConnectionFromLagRequest,
  DuplicateTagKeysException,
  Interconnect,
  Interconnects,
  Lag,
  Lags,
  Loa,
  Location,
  Locations,
  NewBGPPeer,
  NewPrivateVirtualInterface,
  NewPrivateVirtualInterfaceAllocation,
  NewPublicVirtualInterface,
  NewPublicVirtualInterfaceAllocation,
  NewTransitVirtualInterface,
  NewTransitVirtualInterfaceAllocation,
  ResourceTag,
  RouteFilterPrefix,
  Tag,
  TagResourceRequest,
  TagResourceResponse,
  TooManyTagsException,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateDirectConnectGatewayAssociationRequest,
  UpdateDirectConnectGatewayAssociationResult,
  UpdateLagRequest,
  UpdateVirtualInterfaceAttributesRequest,
  VirtualGateway,
  VirtualGateways,
  VirtualInterface,
  VirtualInterfaces
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalCommand(
  input: AcceptDirectConnectGatewayAssociationProposalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "OvertureService.AcceptDirectConnectGatewayAssociationProposal";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AllocateConnectionOnInterconnectCommand(
  input: AllocateConnectionOnInterconnectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.AllocateConnectionOnInterconnect";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AllocateConnectionOnInterconnectRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AllocateHostedConnectionCommand(
  input: AllocateHostedConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.AllocateHostedConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AllocateHostedConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AllocatePrivateVirtualInterfaceCommand(
  input: AllocatePrivateVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.AllocatePrivateVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AllocatePrivateVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AllocatePublicVirtualInterfaceCommand(
  input: AllocatePublicVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.AllocatePublicVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AllocatePublicVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AllocateTransitVirtualInterfaceCommand(
  input: AllocateTransitVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.AllocateTransitVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AllocateTransitVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AssociateConnectionWithLagCommand(
  input: AssociateConnectionWithLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.AssociateConnectionWithLag";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateConnectionWithLagRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AssociateHostedConnectionCommand(
  input: AssociateHostedConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.AssociateHostedConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateHostedConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1AssociateVirtualInterfaceCommand(
  input: AssociateVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.AssociateVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ConfirmConnectionCommand(
  input: ConfirmConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.ConfirmConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ConfirmConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ConfirmPrivateVirtualInterfaceCommand(
  input: ConfirmPrivateVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.ConfirmPrivateVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ConfirmPrivateVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ConfirmPublicVirtualInterfaceCommand(
  input: ConfirmPublicVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.ConfirmPublicVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ConfirmPublicVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ConfirmTransitVirtualInterfaceCommand(
  input: ConfirmTransitVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.ConfirmTransitVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ConfirmTransitVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateBGPPeerCommand(
  input: CreateBGPPeerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.CreateBGPPeer";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateBGPPeerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateConnectionCommand(
  input: CreateConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.CreateConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateDirectConnectGatewayCommand(
  input: CreateDirectConnectGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.CreateDirectConnectGateway";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateDirectConnectGatewayRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateDirectConnectGatewayAssociationCommand(
  input: CreateDirectConnectGatewayAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "OvertureService.CreateDirectConnectGatewayAssociation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateDirectConnectGatewayAssociationRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateDirectConnectGatewayAssociationProposalCommand(
  input: CreateDirectConnectGatewayAssociationProposalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "OvertureService.CreateDirectConnectGatewayAssociationProposal";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateDirectConnectGatewayAssociationProposalRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateInterconnectCommand(
  input: CreateInterconnectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.CreateInterconnect";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateInterconnectRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateLagCommand(
  input: CreateLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.CreateLag";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateLagRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreatePrivateVirtualInterfaceCommand(
  input: CreatePrivateVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.CreatePrivateVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreatePrivateVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreatePublicVirtualInterfaceCommand(
  input: CreatePublicVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.CreatePublicVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreatePublicVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateTransitVirtualInterfaceCommand(
  input: CreateTransitVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.CreateTransitVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateTransitVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteBGPPeerCommand(
  input: DeleteBGPPeerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DeleteBGPPeer";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteBGPPeerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteConnectionCommand(
  input: DeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DeleteConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteConnectionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDirectConnectGatewayCommand(
  input: DeleteDirectConnectGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DeleteDirectConnectGateway";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDirectConnectGatewayRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDirectConnectGatewayAssociationCommand(
  input: DeleteDirectConnectGatewayAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "OvertureService.DeleteDirectConnectGatewayAssociation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDirectConnectGatewayAssociationRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalCommand(
  input: DeleteDirectConnectGatewayAssociationProposalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "OvertureService.DeleteDirectConnectGatewayAssociationProposal";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteInterconnectCommand(
  input: DeleteInterconnectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DeleteInterconnect";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteInterconnectRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteLagCommand(
  input: DeleteLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DeleteLag";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteLagRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteVirtualInterfaceCommand(
  input: DeleteVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DeleteVirtualInterface";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteVirtualInterfaceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeConnectionLoaCommand(
  input: DescribeConnectionLoaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeConnectionLoa";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeConnectionLoaRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeConnectionsCommand(
  input: DescribeConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeConnections";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeConnectionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeConnectionsOnInterconnectCommand(
  input: DescribeConnectionsOnInterconnectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeConnectionsOnInterconnect";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeConnectionsOnInterconnectRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsCommand(
  input: DescribeDirectConnectGatewayAssociationProposalsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "OvertureService.DescribeDirectConnectGatewayAssociationProposals";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDirectConnectGatewayAssociationsCommand(
  input: DescribeDirectConnectGatewayAssociationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "OvertureService.DescribeDirectConnectGatewayAssociations";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDirectConnectGatewayAssociationsRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDirectConnectGatewayAttachmentsCommand(
  input: DescribeDirectConnectGatewayAttachmentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "OvertureService.DescribeDirectConnectGatewayAttachments";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDirectConnectGatewayAttachmentsRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeDirectConnectGatewaysCommand(
  input: DescribeDirectConnectGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeDirectConnectGateways";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDirectConnectGatewaysRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeHostedConnectionsCommand(
  input: DescribeHostedConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeHostedConnections";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeHostedConnectionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeInterconnectLoaCommand(
  input: DescribeInterconnectLoaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeInterconnectLoa";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInterconnectLoaRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeInterconnectsCommand(
  input: DescribeInterconnectsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeInterconnects";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInterconnectsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeLagsCommand(
  input: DescribeLagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeLags";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeLagsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeLoaCommand(
  input: DescribeLoaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeLoa";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeLoaRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeLocationsCommand(
  input: DescribeLocationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeLocations";
  return buildHttpRpcRequest(context, headers, "/", undefined, undefined);
}

export async function serializeAws_json1_1DescribeTagsCommand(
  input: DescribeTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeTags";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeTagsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeVirtualGatewaysCommand(
  input: DescribeVirtualGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeVirtualGateways";
  return buildHttpRpcRequest(context, headers, "/", undefined, undefined);
}

export async function serializeAws_json1_1DescribeVirtualInterfacesCommand(
  input: DescribeVirtualInterfacesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DescribeVirtualInterfaces";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeVirtualInterfacesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DisassociateConnectionFromLagCommand(
  input: DisassociateConnectionFromLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.DisassociateConnectionFromLag";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisassociateConnectionFromLagRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.TagResource";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.UntagResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UntagResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateDirectConnectGatewayAssociationCommand(
  input: UpdateDirectConnectGatewayAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "OvertureService.UpdateDirectConnectGatewayAssociation";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateDirectConnectGatewayAssociationRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateLagCommand(
  input: UpdateLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.UpdateLag";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateLagRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateVirtualInterfaceAttributesCommand(
  input: UpdateVirtualInterfaceAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "OvertureService.UpdateVirtualInterfaceAttributes";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateVirtualInterfaceAttributesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptDirectConnectGatewayAssociationProposalCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalResult(
    data,
    context
  );
  const response: AcceptDirectConnectGatewayAssociationProposalCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AcceptDirectConnectGatewayAssociationProposalResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptDirectConnectGatewayAssociationProposalCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AllocateConnectionOnInterconnectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateConnectionOnInterconnectCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AllocateConnectionOnInterconnectCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: AllocateConnectionOnInterconnectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connection",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AllocateConnectionOnInterconnectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateConnectionOnInterconnectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AllocateHostedConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateHostedConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AllocateHostedConnectionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: AllocateHostedConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connection",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AllocateHostedConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateHostedConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AllocatePrivateVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocatePrivateVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AllocatePrivateVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: AllocatePrivateVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VirtualInterface",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AllocatePrivateVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocatePrivateVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AllocatePublicVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocatePublicVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AllocatePublicVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: AllocatePublicVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VirtualInterface",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AllocatePublicVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocatePublicVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AllocateTransitVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateTransitVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AllocateTransitVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AllocateTransitVirtualInterfaceResult(
    data,
    context
  );
  const response: AllocateTransitVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AllocateTransitVirtualInterfaceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AllocateTransitVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateTransitVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateConnectionWithLagCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateConnectionWithLagCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateConnectionWithLagCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: AssociateConnectionWithLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connection",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateConnectionWithLagCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateConnectionWithLagCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateHostedConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateHostedConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateHostedConnectionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: AssociateHostedConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connection",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateHostedConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateHostedConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: AssociateVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VirtualInterface",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ConfirmConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ConfirmConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ConfirmConnectionResponse(data, context);
  const response: ConfirmConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ConfirmConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ConfirmConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ConfirmPrivateVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmPrivateVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ConfirmPrivateVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ConfirmPrivateVirtualInterfaceResponse(
    data,
    context
  );
  const response: ConfirmPrivateVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ConfirmPrivateVirtualInterfaceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ConfirmPrivateVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmPrivateVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ConfirmPublicVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmPublicVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ConfirmPublicVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ConfirmPublicVirtualInterfaceResponse(
    data,
    context
  );
  const response: ConfirmPublicVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ConfirmPublicVirtualInterfaceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ConfirmPublicVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmPublicVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ConfirmTransitVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmTransitVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ConfirmTransitVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ConfirmTransitVirtualInterfaceResponse(
    data,
    context
  );
  const response: ConfirmTransitVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ConfirmTransitVirtualInterfaceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ConfirmTransitVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmTransitVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateBGPPeerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBGPPeerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateBGPPeerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateBGPPeerResponse(data, context);
  const response: CreateBGPPeerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateBGPPeerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateBGPPeerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBGPPeerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: CreateConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connection",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateDirectConnectGatewayCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDirectConnectGatewayCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDirectConnectGatewayResult(
    data,
    context
  );
  const response: CreateDirectConnectGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDirectConnectGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDirectConnectGatewayCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateDirectConnectGatewayAssociationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayAssociationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDirectConnectGatewayAssociationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDirectConnectGatewayAssociationResult(
    data,
    context
  );
  const response: CreateDirectConnectGatewayAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDirectConnectGatewayAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDirectConnectGatewayAssociationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayAssociationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayAssociationProposalCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalResult(
    data,
    context
  );
  const response: CreateDirectConnectGatewayAssociationProposalCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDirectConnectGatewayAssociationProposalResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayAssociationProposalCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateInterconnectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInterconnectCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateInterconnectCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Interconnect(data, context);
  const response: CreateInterconnectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Interconnect",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateInterconnectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInterconnectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateLagCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLagCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateLagCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Lag(data, context);
  const response: CreateLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Lag",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateLagCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLagCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePrivateVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePrivateVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePrivateVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: CreatePrivateVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VirtualInterface",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePrivateVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePrivateVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePublicVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePublicVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePublicVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: CreatePublicVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VirtualInterface",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePublicVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePublicVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateTransitVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTransitVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTransitVirtualInterfaceResult(
    data,
    context
  );
  const response: CreateTransitVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTransitVirtualInterfaceResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateTransitVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteBGPPeerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBGPPeerCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteBGPPeerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteBGPPeerResponse(data, context);
  const response: DeleteBGPPeerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteBGPPeerResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteBGPPeerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBGPPeerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: DeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connection",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDirectConnectGatewayCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDirectConnectGatewayCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDirectConnectGatewayResult(
    data,
    context
  );
  const response: DeleteDirectConnectGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDirectConnectGatewayResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDirectConnectGatewayCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDirectConnectGatewayAssociationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayAssociationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDirectConnectGatewayAssociationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDirectConnectGatewayAssociationResult(
    data,
    context
  );
  const response: DeleteDirectConnectGatewayAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDirectConnectGatewayAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDirectConnectGatewayAssociationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayAssociationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayAssociationProposalCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalResult(
    data,
    context
  );
  const response: DeleteDirectConnectGatewayAssociationProposalCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDirectConnectGatewayAssociationProposalResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayAssociationProposalCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteInterconnectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInterconnectCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteInterconnectCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteInterconnectResponse(data, context);
  const response: DeleteInterconnectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteInterconnectResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteInterconnectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInterconnectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteLagCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLagCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteLagCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Lag(data, context);
  const response: DeleteLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Lag",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteLagCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLagCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteVirtualInterfaceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVirtualInterfaceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteVirtualInterfaceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteVirtualInterfaceResponse(
    data,
    context
  );
  const response: DeleteVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVirtualInterfaceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteVirtualInterfaceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVirtualInterfaceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeConnectionLoaCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionLoaCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeConnectionLoaCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeConnectionLoaResponse(data, context);
  const response: DescribeConnectionLoaCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeConnectionLoaResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeConnectionLoaCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionLoaCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeConnectionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connections(data, context);
  const response: DescribeConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connections",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeConnectionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeConnectionsOnInterconnectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsOnInterconnectCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeConnectionsOnInterconnectCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connections(data, context);
  const response: DescribeConnectionsOnInterconnectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connections",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeConnectionsOnInterconnectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsOnInterconnectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAssociationProposalsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsResult(
    data,
    context
  );
  const response: DescribeDirectConnectGatewayAssociationProposalsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDirectConnectGatewayAssociationProposalsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAssociationProposalsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAssociationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsResult(
    data,
    context
  );
  const response: DescribeDirectConnectGatewayAssociationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDirectConnectGatewayAssociationsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAssociationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAttachmentsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsResult(
    data,
    context
  );
  const response: DescribeDirectConnectGatewayAttachmentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDirectConnectGatewayAttachmentsResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAttachmentsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDirectConnectGatewaysCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewaysCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDirectConnectGatewaysCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDirectConnectGatewaysResult(
    data,
    context
  );
  const response: DescribeDirectConnectGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDirectConnectGatewaysResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDirectConnectGatewaysCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewaysCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeHostedConnectionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostedConnectionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeHostedConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connections(data, context);
  const response: DescribeHostedConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connections",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeHostedConnectionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostedConnectionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeInterconnectLoaCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInterconnectLoaCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInterconnectLoaCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInterconnectLoaResponse(
    data,
    context
  );
  const response: DescribeInterconnectLoaCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInterconnectLoaResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeInterconnectLoaCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInterconnectLoaCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeInterconnectsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInterconnectsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInterconnectsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Interconnects(data, context);
  const response: DescribeInterconnectsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Interconnects",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeInterconnectsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInterconnectsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeLagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeLagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Lags(data, context);
  const response: DescribeLagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Lags",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeLagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeLoaCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLoaCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeLoaCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Loa(data, context);
  const response: DescribeLoaCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Loa",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeLoaCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLoaCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeLocationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeLocationsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Locations(data, context);
  const response: DescribeLocationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Locations",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeLocationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTagsResponse(data, context);
  const response: DescribeTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTagsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeVirtualGatewaysCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVirtualGatewaysCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeVirtualGatewaysCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualGateways(data, context);
  const response: DescribeVirtualGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VirtualGateways",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeVirtualGatewaysCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVirtualGatewaysCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeVirtualInterfacesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVirtualInterfacesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeVirtualInterfacesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterfaces(data, context);
  const response: DescribeVirtualInterfacesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VirtualInterfaces",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeVirtualInterfacesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVirtualInterfacesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisassociateConnectionFromLagCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateConnectionFromLagCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisassociateConnectionFromLagCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: DisassociateConnectionFromLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Connection",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisassociateConnectionFromLagCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateConnectionFromLagCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazon.awsdx.overture#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTagsException":
    case "com.amazon.awsdx.overture#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateDirectConnectGatewayAssociationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDirectConnectGatewayAssociationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDirectConnectGatewayAssociationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDirectConnectGatewayAssociationResult(
    data,
    context
  );
  const response: UpdateDirectConnectGatewayAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDirectConnectGatewayAssociationResult",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateDirectConnectGatewayAssociationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDirectConnectGatewayAssociationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateLagCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateLagCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateLagCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Lag(data, context);
  const response: UpdateLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "Lag",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateLagCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateLagCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateVirtualInterfaceAttributesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVirtualInterfaceAttributesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateVirtualInterfaceAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: UpdateVirtualInterfaceAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "VirtualInterface",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateVirtualInterfaceAttributesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVirtualInterfaceAttributesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazon.awsdx.overture#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DirectConnectServerException":
    case "com.amazon.awsdx.overture#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1DirectConnectClientExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectConnectClientException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectConnectClientException(
    body,
    context
  );
  const contents: DirectConnectClientException = {
    name: "DirectConnectClientException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DirectConnectServerExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectConnectServerException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectConnectServerException(
    body,
    context
  );
  const contents: DirectConnectServerException = {
    name: "DirectConnectServerException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1DuplicateTagKeysExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DuplicateTagKeysException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DuplicateTagKeysException(
    body,
    context
  );
  const contents: DuplicateTagKeysException = {
    name: "DuplicateTagKeysException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TooManyTagsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTagsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TooManyTagsException(
    body,
    context
  );
  const contents: TooManyTagsException = {
    name: "TooManyTagsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalRequest = (
  input: AcceptDirectConnectGatewayAssociationProposalRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.associatedGatewayOwnerAccount !== undefined) {
    bodyParams["associatedGatewayOwnerAccount"] =
      input.associatedGatewayOwnerAccount;
  }
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.overrideAllowedPrefixesToDirectConnectGateway !== undefined) {
    bodyParams[
      "overrideAllowedPrefixesToDirectConnectGateway"
    ] = serializeAws_json1_1RouteFilterPrefixList(
      input.overrideAllowedPrefixesToDirectConnectGateway,
      context
    );
  }
  if (input.proposalId !== undefined) {
    bodyParams["proposalId"] = input.proposalId;
  }
  return bodyParams;
};

const serializeAws_json1_1AllocateConnectionOnInterconnectRequest = (
  input: AllocateConnectionOnInterconnectRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.bandwidth !== undefined) {
    bodyParams["bandwidth"] = input.bandwidth;
  }
  if (input.connectionName !== undefined) {
    bodyParams["connectionName"] = input.connectionName;
  }
  if (input.interconnectId !== undefined) {
    bodyParams["interconnectId"] = input.interconnectId;
  }
  if (input.ownerAccount !== undefined) {
    bodyParams["ownerAccount"] = input.ownerAccount;
  }
  if (input.vlan !== undefined) {
    bodyParams["vlan"] = input.vlan;
  }
  return bodyParams;
};

const serializeAws_json1_1AllocateHostedConnectionRequest = (
  input: AllocateHostedConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.bandwidth !== undefined) {
    bodyParams["bandwidth"] = input.bandwidth;
  }
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.connectionName !== undefined) {
    bodyParams["connectionName"] = input.connectionName;
  }
  if (input.ownerAccount !== undefined) {
    bodyParams["ownerAccount"] = input.ownerAccount;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  if (input.vlan !== undefined) {
    bodyParams["vlan"] = input.vlan;
  }
  return bodyParams;
};

const serializeAws_json1_1AllocatePrivateVirtualInterfaceRequest = (
  input: AllocatePrivateVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.newPrivateVirtualInterfaceAllocation !== undefined) {
    bodyParams[
      "newPrivateVirtualInterfaceAllocation"
    ] = serializeAws_json1_1NewPrivateVirtualInterfaceAllocation(
      input.newPrivateVirtualInterfaceAllocation,
      context
    );
  }
  if (input.ownerAccount !== undefined) {
    bodyParams["ownerAccount"] = input.ownerAccount;
  }
  return bodyParams;
};

const serializeAws_json1_1AllocatePublicVirtualInterfaceRequest = (
  input: AllocatePublicVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.newPublicVirtualInterfaceAllocation !== undefined) {
    bodyParams[
      "newPublicVirtualInterfaceAllocation"
    ] = serializeAws_json1_1NewPublicVirtualInterfaceAllocation(
      input.newPublicVirtualInterfaceAllocation,
      context
    );
  }
  if (input.ownerAccount !== undefined) {
    bodyParams["ownerAccount"] = input.ownerAccount;
  }
  return bodyParams;
};

const serializeAws_json1_1AllocateTransitVirtualInterfaceRequest = (
  input: AllocateTransitVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.newTransitVirtualInterfaceAllocation !== undefined) {
    bodyParams[
      "newTransitVirtualInterfaceAllocation"
    ] = serializeAws_json1_1NewTransitVirtualInterfaceAllocation(
      input.newTransitVirtualInterfaceAllocation,
      context
    );
  }
  if (input.ownerAccount !== undefined) {
    bodyParams["ownerAccount"] = input.ownerAccount;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateConnectionWithLagRequest = (
  input: AssociateConnectionWithLagRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.lagId !== undefined) {
    bodyParams["lagId"] = input.lagId;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateHostedConnectionRequest = (
  input: AssociateHostedConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.parentConnectionId !== undefined) {
    bodyParams["parentConnectionId"] = input.parentConnectionId;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateVirtualInterfaceRequest = (
  input: AssociateVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const serializeAws_json1_1ConfirmConnectionRequest = (
  input: ConfirmConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  return bodyParams;
};

const serializeAws_json1_1ConfirmPrivateVirtualInterfaceRequest = (
  input: ConfirmPrivateVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.virtualGatewayId !== undefined) {
    bodyParams["virtualGatewayId"] = input.virtualGatewayId;
  }
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const serializeAws_json1_1ConfirmPublicVirtualInterfaceRequest = (
  input: ConfirmPublicVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const serializeAws_json1_1ConfirmTransitVirtualInterfaceRequest = (
  input: ConfirmTransitVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateBGPPeerRequest = (
  input: CreateBGPPeerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.newBGPPeer !== undefined) {
    bodyParams["newBGPPeer"] = serializeAws_json1_1NewBGPPeer(
      input.newBGPPeer,
      context
    );
  }
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateConnectionRequest = (
  input: CreateConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.bandwidth !== undefined) {
    bodyParams["bandwidth"] = input.bandwidth;
  }
  if (input.connectionName !== undefined) {
    bodyParams["connectionName"] = input.connectionName;
  }
  if (input.lagId !== undefined) {
    bodyParams["lagId"] = input.lagId;
  }
  if (input.location !== undefined) {
    bodyParams["location"] = input.location;
  }
  if (input.providerName !== undefined) {
    bodyParams["providerName"] = input.providerName;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDirectConnectGatewayAssociationProposalRequest = (
  input: CreateDirectConnectGatewayAssociationProposalRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addAllowedPrefixesToDirectConnectGateway !== undefined) {
    bodyParams[
      "addAllowedPrefixesToDirectConnectGateway"
    ] = serializeAws_json1_1RouteFilterPrefixList(
      input.addAllowedPrefixesToDirectConnectGateway,
      context
    );
  }
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.directConnectGatewayOwnerAccount !== undefined) {
    bodyParams["directConnectGatewayOwnerAccount"] =
      input.directConnectGatewayOwnerAccount;
  }
  if (input.gatewayId !== undefined) {
    bodyParams["gatewayId"] = input.gatewayId;
  }
  if (input.removeAllowedPrefixesToDirectConnectGateway !== undefined) {
    bodyParams[
      "removeAllowedPrefixesToDirectConnectGateway"
    ] = serializeAws_json1_1RouteFilterPrefixList(
      input.removeAllowedPrefixesToDirectConnectGateway,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDirectConnectGatewayAssociationRequest = (
  input: CreateDirectConnectGatewayAssociationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addAllowedPrefixesToDirectConnectGateway !== undefined) {
    bodyParams[
      "addAllowedPrefixesToDirectConnectGateway"
    ] = serializeAws_json1_1RouteFilterPrefixList(
      input.addAllowedPrefixesToDirectConnectGateway,
      context
    );
  }
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.gatewayId !== undefined) {
    bodyParams["gatewayId"] = input.gatewayId;
  }
  if (input.virtualGatewayId !== undefined) {
    bodyParams["virtualGatewayId"] = input.virtualGatewayId;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDirectConnectGatewayRequest = (
  input: CreateDirectConnectGatewayRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.amazonSideAsn !== undefined) {
    bodyParams["amazonSideAsn"] = input.amazonSideAsn;
  }
  if (input.directConnectGatewayName !== undefined) {
    bodyParams["directConnectGatewayName"] = input.directConnectGatewayName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateInterconnectRequest = (
  input: CreateInterconnectRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.bandwidth !== undefined) {
    bodyParams["bandwidth"] = input.bandwidth;
  }
  if (input.interconnectName !== undefined) {
    bodyParams["interconnectName"] = input.interconnectName;
  }
  if (input.lagId !== undefined) {
    bodyParams["lagId"] = input.lagId;
  }
  if (input.location !== undefined) {
    bodyParams["location"] = input.location;
  }
  if (input.providerName !== undefined) {
    bodyParams["providerName"] = input.providerName;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateLagRequest = (
  input: CreateLagRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.childConnectionTags !== undefined) {
    bodyParams["childConnectionTags"] = serializeAws_json1_1TagList(
      input.childConnectionTags,
      context
    );
  }
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.connectionsBandwidth !== undefined) {
    bodyParams["connectionsBandwidth"] = input.connectionsBandwidth;
  }
  if (input.lagName !== undefined) {
    bodyParams["lagName"] = input.lagName;
  }
  if (input.location !== undefined) {
    bodyParams["location"] = input.location;
  }
  if (input.numberOfConnections !== undefined) {
    bodyParams["numberOfConnections"] = input.numberOfConnections;
  }
  if (input.providerName !== undefined) {
    bodyParams["providerName"] = input.providerName;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePrivateVirtualInterfaceRequest = (
  input: CreatePrivateVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.newPrivateVirtualInterface !== undefined) {
    bodyParams[
      "newPrivateVirtualInterface"
    ] = serializeAws_json1_1NewPrivateVirtualInterface(
      input.newPrivateVirtualInterface,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePublicVirtualInterfaceRequest = (
  input: CreatePublicVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.newPublicVirtualInterface !== undefined) {
    bodyParams[
      "newPublicVirtualInterface"
    ] = serializeAws_json1_1NewPublicVirtualInterface(
      input.newPublicVirtualInterface,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateTransitVirtualInterfaceRequest = (
  input: CreateTransitVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.newTransitVirtualInterface !== undefined) {
    bodyParams[
      "newTransitVirtualInterface"
    ] = serializeAws_json1_1NewTransitVirtualInterface(
      input.newTransitVirtualInterface,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteBGPPeerRequest = (
  input: DeleteBGPPeerRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.asn !== undefined) {
    bodyParams["asn"] = input.asn;
  }
  if (input.bgpPeerId !== undefined) {
    bodyParams["bgpPeerId"] = input.bgpPeerId;
  }
  if (input.customerAddress !== undefined) {
    bodyParams["customerAddress"] = input.customerAddress;
  }
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteConnectionRequest = (
  input: DeleteConnectionRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalRequest = (
  input: DeleteDirectConnectGatewayAssociationProposalRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.proposalId !== undefined) {
    bodyParams["proposalId"] = input.proposalId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDirectConnectGatewayAssociationRequest = (
  input: DeleteDirectConnectGatewayAssociationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.associationId !== undefined) {
    bodyParams["associationId"] = input.associationId;
  }
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.virtualGatewayId !== undefined) {
    bodyParams["virtualGatewayId"] = input.virtualGatewayId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDirectConnectGatewayRequest = (
  input: DeleteDirectConnectGatewayRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteInterconnectRequest = (
  input: DeleteInterconnectRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.interconnectId !== undefined) {
    bodyParams["interconnectId"] = input.interconnectId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteLagRequest = (
  input: DeleteLagRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.lagId !== undefined) {
    bodyParams["lagId"] = input.lagId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteVirtualInterfaceRequest = (
  input: DeleteVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeConnectionLoaRequest = (
  input: DescribeConnectionLoaRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.loaContentType !== undefined) {
    bodyParams["loaContentType"] = input.loaContentType;
  }
  if (input.providerName !== undefined) {
    bodyParams["providerName"] = input.providerName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeConnectionsOnInterconnectRequest = (
  input: DescribeConnectionsOnInterconnectRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.interconnectId !== undefined) {
    bodyParams["interconnectId"] = input.interconnectId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeConnectionsRequest = (
  input: DescribeConnectionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsRequest = (
  input: DescribeDirectConnectGatewayAssociationProposalsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.associatedGatewayId !== undefined) {
    bodyParams["associatedGatewayId"] = input.associatedGatewayId;
  }
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.proposalId !== undefined) {
    bodyParams["proposalId"] = input.proposalId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDirectConnectGatewayAssociationsRequest = (
  input: DescribeDirectConnectGatewayAssociationsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.associatedGatewayId !== undefined) {
    bodyParams["associatedGatewayId"] = input.associatedGatewayId;
  }
  if (input.associationId !== undefined) {
    bodyParams["associationId"] = input.associationId;
  }
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.virtualGatewayId !== undefined) {
    bodyParams["virtualGatewayId"] = input.virtualGatewayId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDirectConnectGatewayAttachmentsRequest = (
  input: DescribeDirectConnectGatewayAttachmentsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDirectConnectGatewaysRequest = (
  input: DescribeDirectConnectGatewaysRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeHostedConnectionsRequest = (
  input: DescribeHostedConnectionsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeInterconnectLoaRequest = (
  input: DescribeInterconnectLoaRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.interconnectId !== undefined) {
    bodyParams["interconnectId"] = input.interconnectId;
  }
  if (input.loaContentType !== undefined) {
    bodyParams["loaContentType"] = input.loaContentType;
  }
  if (input.providerName !== undefined) {
    bodyParams["providerName"] = input.providerName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeInterconnectsRequest = (
  input: DescribeInterconnectsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.interconnectId !== undefined) {
    bodyParams["interconnectId"] = input.interconnectId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeLagsRequest = (
  input: DescribeLagsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.lagId !== undefined) {
    bodyParams["lagId"] = input.lagId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeLoaRequest = (
  input: DescribeLoaRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.loaContentType !== undefined) {
    bodyParams["loaContentType"] = input.loaContentType;
  }
  if (input.providerName !== undefined) {
    bodyParams["providerName"] = input.providerName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTagsRequest = (
  input: DescribeTagsRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.resourceArns !== undefined) {
    bodyParams["resourceArns"] = serializeAws_json1_1ResourceArnList(
      input.resourceArns,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeVirtualInterfacesRequest = (
  input: DescribeVirtualInterfacesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const serializeAws_json1_1DisassociateConnectionFromLagRequest = (
  input: DisassociateConnectionFromLagRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.connectionId !== undefined) {
    bodyParams["connectionId"] = input.connectionId;
  }
  if (input.lagId !== undefined) {
    bodyParams["lagId"] = input.lagId;
  }
  return bodyParams;
};

const serializeAws_json1_1NewBGPPeer = (
  input: NewBGPPeer,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addressFamily !== undefined) {
    bodyParams["addressFamily"] = input.addressFamily;
  }
  if (input.amazonAddress !== undefined) {
    bodyParams["amazonAddress"] = input.amazonAddress;
  }
  if (input.asn !== undefined) {
    bodyParams["asn"] = input.asn;
  }
  if (input.authKey !== undefined) {
    bodyParams["authKey"] = input.authKey;
  }
  if (input.customerAddress !== undefined) {
    bodyParams["customerAddress"] = input.customerAddress;
  }
  return bodyParams;
};

const serializeAws_json1_1NewPrivateVirtualInterface = (
  input: NewPrivateVirtualInterface,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addressFamily !== undefined) {
    bodyParams["addressFamily"] = input.addressFamily;
  }
  if (input.amazonAddress !== undefined) {
    bodyParams["amazonAddress"] = input.amazonAddress;
  }
  if (input.asn !== undefined) {
    bodyParams["asn"] = input.asn;
  }
  if (input.authKey !== undefined) {
    bodyParams["authKey"] = input.authKey;
  }
  if (input.customerAddress !== undefined) {
    bodyParams["customerAddress"] = input.customerAddress;
  }
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.mtu !== undefined) {
    bodyParams["mtu"] = input.mtu;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  if (input.virtualGatewayId !== undefined) {
    bodyParams["virtualGatewayId"] = input.virtualGatewayId;
  }
  if (input.virtualInterfaceName !== undefined) {
    bodyParams["virtualInterfaceName"] = input.virtualInterfaceName;
  }
  if (input.vlan !== undefined) {
    bodyParams["vlan"] = input.vlan;
  }
  return bodyParams;
};

const serializeAws_json1_1NewPrivateVirtualInterfaceAllocation = (
  input: NewPrivateVirtualInterfaceAllocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addressFamily !== undefined) {
    bodyParams["addressFamily"] = input.addressFamily;
  }
  if (input.amazonAddress !== undefined) {
    bodyParams["amazonAddress"] = input.amazonAddress;
  }
  if (input.asn !== undefined) {
    bodyParams["asn"] = input.asn;
  }
  if (input.authKey !== undefined) {
    bodyParams["authKey"] = input.authKey;
  }
  if (input.customerAddress !== undefined) {
    bodyParams["customerAddress"] = input.customerAddress;
  }
  if (input.mtu !== undefined) {
    bodyParams["mtu"] = input.mtu;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  if (input.virtualInterfaceName !== undefined) {
    bodyParams["virtualInterfaceName"] = input.virtualInterfaceName;
  }
  if (input.vlan !== undefined) {
    bodyParams["vlan"] = input.vlan;
  }
  return bodyParams;
};

const serializeAws_json1_1NewPublicVirtualInterface = (
  input: NewPublicVirtualInterface,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addressFamily !== undefined) {
    bodyParams["addressFamily"] = input.addressFamily;
  }
  if (input.amazonAddress !== undefined) {
    bodyParams["amazonAddress"] = input.amazonAddress;
  }
  if (input.asn !== undefined) {
    bodyParams["asn"] = input.asn;
  }
  if (input.authKey !== undefined) {
    bodyParams["authKey"] = input.authKey;
  }
  if (input.customerAddress !== undefined) {
    bodyParams["customerAddress"] = input.customerAddress;
  }
  if (input.routeFilterPrefixes !== undefined) {
    bodyParams[
      "routeFilterPrefixes"
    ] = serializeAws_json1_1RouteFilterPrefixList(
      input.routeFilterPrefixes,
      context
    );
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  if (input.virtualInterfaceName !== undefined) {
    bodyParams["virtualInterfaceName"] = input.virtualInterfaceName;
  }
  if (input.vlan !== undefined) {
    bodyParams["vlan"] = input.vlan;
  }
  return bodyParams;
};

const serializeAws_json1_1NewPublicVirtualInterfaceAllocation = (
  input: NewPublicVirtualInterfaceAllocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addressFamily !== undefined) {
    bodyParams["addressFamily"] = input.addressFamily;
  }
  if (input.amazonAddress !== undefined) {
    bodyParams["amazonAddress"] = input.amazonAddress;
  }
  if (input.asn !== undefined) {
    bodyParams["asn"] = input.asn;
  }
  if (input.authKey !== undefined) {
    bodyParams["authKey"] = input.authKey;
  }
  if (input.customerAddress !== undefined) {
    bodyParams["customerAddress"] = input.customerAddress;
  }
  if (input.routeFilterPrefixes !== undefined) {
    bodyParams[
      "routeFilterPrefixes"
    ] = serializeAws_json1_1RouteFilterPrefixList(
      input.routeFilterPrefixes,
      context
    );
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  if (input.virtualInterfaceName !== undefined) {
    bodyParams["virtualInterfaceName"] = input.virtualInterfaceName;
  }
  if (input.vlan !== undefined) {
    bodyParams["vlan"] = input.vlan;
  }
  return bodyParams;
};

const serializeAws_json1_1NewTransitVirtualInterface = (
  input: NewTransitVirtualInterface,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addressFamily !== undefined) {
    bodyParams["addressFamily"] = input.addressFamily;
  }
  if (input.amazonAddress !== undefined) {
    bodyParams["amazonAddress"] = input.amazonAddress;
  }
  if (input.asn !== undefined) {
    bodyParams["asn"] = input.asn;
  }
  if (input.authKey !== undefined) {
    bodyParams["authKey"] = input.authKey;
  }
  if (input.customerAddress !== undefined) {
    bodyParams["customerAddress"] = input.customerAddress;
  }
  if (input.directConnectGatewayId !== undefined) {
    bodyParams["directConnectGatewayId"] = input.directConnectGatewayId;
  }
  if (input.mtu !== undefined) {
    bodyParams["mtu"] = input.mtu;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  if (input.virtualInterfaceName !== undefined) {
    bodyParams["virtualInterfaceName"] = input.virtualInterfaceName;
  }
  if (input.vlan !== undefined) {
    bodyParams["vlan"] = input.vlan;
  }
  return bodyParams;
};

const serializeAws_json1_1NewTransitVirtualInterfaceAllocation = (
  input: NewTransitVirtualInterfaceAllocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addressFamily !== undefined) {
    bodyParams["addressFamily"] = input.addressFamily;
  }
  if (input.amazonAddress !== undefined) {
    bodyParams["amazonAddress"] = input.amazonAddress;
  }
  if (input.asn !== undefined) {
    bodyParams["asn"] = input.asn;
  }
  if (input.authKey !== undefined) {
    bodyParams["authKey"] = input.authKey;
  }
  if (input.customerAddress !== undefined) {
    bodyParams["customerAddress"] = input.customerAddress;
  }
  if (input.mtu !== undefined) {
    bodyParams["mtu"] = input.mtu;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  if (input.virtualInterfaceName !== undefined) {
    bodyParams["virtualInterfaceName"] = input.virtualInterfaceName;
  }
  if (input.vlan !== undefined) {
    bodyParams["vlan"] = input.vlan;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceArnList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1RouteFilterPrefix = (
  input: RouteFilterPrefix,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.cidr !== undefined) {
    bodyParams["cidr"] = input.cidr;
  }
  return bodyParams;
};

const serializeAws_json1_1RouteFilterPrefixList = (
  input: Array<RouteFilterPrefix>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1RouteFilterPrefix(entry, context));
  }
  return contents;
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  const bodyParams: any = {};
  if (input.key !== undefined) {
    bodyParams["key"] = input.key;
  }
  if (input.value !== undefined) {
    bodyParams["value"] = input.value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Tag(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TagResourceRequest = (
  input: TagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.resourceArn !== undefined) {
    bodyParams["resourceArn"] = input.resourceArn;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_json1_1TagList(input.tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1UntagResourceRequest = (
  input: UntagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.resourceArn !== undefined) {
    bodyParams["resourceArn"] = input.resourceArn;
  }
  if (input.tagKeys !== undefined) {
    bodyParams["tagKeys"] = serializeAws_json1_1TagKeyList(
      input.tagKeys,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateDirectConnectGatewayAssociationRequest = (
  input: UpdateDirectConnectGatewayAssociationRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addAllowedPrefixesToDirectConnectGateway !== undefined) {
    bodyParams[
      "addAllowedPrefixesToDirectConnectGateway"
    ] = serializeAws_json1_1RouteFilterPrefixList(
      input.addAllowedPrefixesToDirectConnectGateway,
      context
    );
  }
  if (input.associationId !== undefined) {
    bodyParams["associationId"] = input.associationId;
  }
  if (input.removeAllowedPrefixesToDirectConnectGateway !== undefined) {
    bodyParams[
      "removeAllowedPrefixesToDirectConnectGateway"
    ] = serializeAws_json1_1RouteFilterPrefixList(
      input.removeAllowedPrefixesToDirectConnectGateway,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateLagRequest = (
  input: UpdateLagRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.lagId !== undefined) {
    bodyParams["lagId"] = input.lagId;
  }
  if (input.lagName !== undefined) {
    bodyParams["lagName"] = input.lagName;
  }
  if (input.minimumLinks !== undefined) {
    bodyParams["minimumLinks"] = input.minimumLinks;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateVirtualInterfaceAttributesRequest = (
  input: UpdateVirtualInterfaceAttributesRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.mtu !== undefined) {
    bodyParams["mtu"] = input.mtu;
  }
  if (input.virtualInterfaceId !== undefined) {
    bodyParams["virtualInterfaceId"] = input.virtualInterfaceId;
  }
  return bodyParams;
};

const deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalResult = (
  output: any,
  context: __SerdeContext
): AcceptDirectConnectGatewayAssociationProposalResult => {
  let contents: any = {
    __type: "AcceptDirectConnectGatewayAssociationProposalResult",
    directConnectGatewayAssociation: undefined
  };
  if (
    output.directConnectGatewayAssociation !== undefined &&
    output.directConnectGatewayAssociation !== null
  ) {
    contents.directConnectGatewayAssociation = deserializeAws_json1_1DirectConnectGatewayAssociation(
      output.directConnectGatewayAssociation,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AllocateTransitVirtualInterfaceResult = (
  output: any,
  context: __SerdeContext
): AllocateTransitVirtualInterfaceResult => {
  let contents: any = {
    __type: "AllocateTransitVirtualInterfaceResult",
    virtualInterface: undefined
  };
  if (
    output.virtualInterface !== undefined &&
    output.virtualInterface !== null
  ) {
    contents.virtualInterface = deserializeAws_json1_1VirtualInterface(
      output.virtualInterface,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AssociatedGateway = (
  output: any,
  context: __SerdeContext
): AssociatedGateway => {
  let contents: any = {
    __type: "AssociatedGateway",
    id: undefined,
    ownerAccount: undefined,
    region: undefined,
    type: undefined
  };
  if (output.id !== undefined && output.id !== null) {
    contents.id = output.id;
  }
  if (output.ownerAccount !== undefined && output.ownerAccount !== null) {
    contents.ownerAccount = output.ownerAccount;
  }
  if (output.region !== undefined && output.region !== null) {
    contents.region = output.region;
  }
  if (output.type !== undefined && output.type !== null) {
    contents.type = output.type;
  }
  return contents;
};

const deserializeAws_json1_1AvailablePortSpeeds = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1BGPPeer = (
  output: any,
  context: __SerdeContext
): BGPPeer => {
  let contents: any = {
    __type: "BGPPeer",
    addressFamily: undefined,
    amazonAddress: undefined,
    asn: undefined,
    authKey: undefined,
    awsDeviceV2: undefined,
    bgpPeerId: undefined,
    bgpPeerState: undefined,
    bgpStatus: undefined,
    customerAddress: undefined
  };
  if (output.addressFamily !== undefined && output.addressFamily !== null) {
    contents.addressFamily = output.addressFamily;
  }
  if (output.amazonAddress !== undefined && output.amazonAddress !== null) {
    contents.amazonAddress = output.amazonAddress;
  }
  if (output.asn !== undefined && output.asn !== null) {
    contents.asn = output.asn;
  }
  if (output.authKey !== undefined && output.authKey !== null) {
    contents.authKey = output.authKey;
  }
  if (output.awsDeviceV2 !== undefined && output.awsDeviceV2 !== null) {
    contents.awsDeviceV2 = output.awsDeviceV2;
  }
  if (output.bgpPeerId !== undefined && output.bgpPeerId !== null) {
    contents.bgpPeerId = output.bgpPeerId;
  }
  if (output.bgpPeerState !== undefined && output.bgpPeerState !== null) {
    contents.bgpPeerState = output.bgpPeerState;
  }
  if (output.bgpStatus !== undefined && output.bgpStatus !== null) {
    contents.bgpStatus = output.bgpStatus;
  }
  if (output.customerAddress !== undefined && output.customerAddress !== null) {
    contents.customerAddress = output.customerAddress;
  }
  return contents;
};

const deserializeAws_json1_1BGPPeerList = (
  output: any,
  context: __SerdeContext
): Array<BGPPeer> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BGPPeer(entry, context)
  );
};

const deserializeAws_json1_1ConfirmConnectionResponse = (
  output: any,
  context: __SerdeContext
): ConfirmConnectionResponse => {
  let contents: any = {
    __type: "ConfirmConnectionResponse",
    connectionState: undefined
  };
  if (output.connectionState !== undefined && output.connectionState !== null) {
    contents.connectionState = output.connectionState;
  }
  return contents;
};

const deserializeAws_json1_1ConfirmPrivateVirtualInterfaceResponse = (
  output: any,
  context: __SerdeContext
): ConfirmPrivateVirtualInterfaceResponse => {
  let contents: any = {
    __type: "ConfirmPrivateVirtualInterfaceResponse",
    virtualInterfaceState: undefined
  };
  if (
    output.virtualInterfaceState !== undefined &&
    output.virtualInterfaceState !== null
  ) {
    contents.virtualInterfaceState = output.virtualInterfaceState;
  }
  return contents;
};

const deserializeAws_json1_1ConfirmPublicVirtualInterfaceResponse = (
  output: any,
  context: __SerdeContext
): ConfirmPublicVirtualInterfaceResponse => {
  let contents: any = {
    __type: "ConfirmPublicVirtualInterfaceResponse",
    virtualInterfaceState: undefined
  };
  if (
    output.virtualInterfaceState !== undefined &&
    output.virtualInterfaceState !== null
  ) {
    contents.virtualInterfaceState = output.virtualInterfaceState;
  }
  return contents;
};

const deserializeAws_json1_1ConfirmTransitVirtualInterfaceResponse = (
  output: any,
  context: __SerdeContext
): ConfirmTransitVirtualInterfaceResponse => {
  let contents: any = {
    __type: "ConfirmTransitVirtualInterfaceResponse",
    virtualInterfaceState: undefined
  };
  if (
    output.virtualInterfaceState !== undefined &&
    output.virtualInterfaceState !== null
  ) {
    contents.virtualInterfaceState = output.virtualInterfaceState;
  }
  return contents;
};

const deserializeAws_json1_1Connection = (
  output: any,
  context: __SerdeContext
): Connection => {
  let contents: any = {
    __type: "Connection",
    awsDevice: undefined,
    awsDeviceV2: undefined,
    bandwidth: undefined,
    connectionId: undefined,
    connectionName: undefined,
    connectionState: undefined,
    hasLogicalRedundancy: undefined,
    jumboFrameCapable: undefined,
    lagId: undefined,
    loaIssueTime: undefined,
    location: undefined,
    ownerAccount: undefined,
    partnerName: undefined,
    providerName: undefined,
    region: undefined,
    tags: undefined,
    vlan: undefined
  };
  if (output.awsDevice !== undefined && output.awsDevice !== null) {
    contents.awsDevice = output.awsDevice;
  }
  if (output.awsDeviceV2 !== undefined && output.awsDeviceV2 !== null) {
    contents.awsDeviceV2 = output.awsDeviceV2;
  }
  if (output.bandwidth !== undefined && output.bandwidth !== null) {
    contents.bandwidth = output.bandwidth;
  }
  if (output.connectionId !== undefined && output.connectionId !== null) {
    contents.connectionId = output.connectionId;
  }
  if (output.connectionName !== undefined && output.connectionName !== null) {
    contents.connectionName = output.connectionName;
  }
  if (output.connectionState !== undefined && output.connectionState !== null) {
    contents.connectionState = output.connectionState;
  }
  if (
    output.hasLogicalRedundancy !== undefined &&
    output.hasLogicalRedundancy !== null
  ) {
    contents.hasLogicalRedundancy = output.hasLogicalRedundancy;
  }
  if (
    output.jumboFrameCapable !== undefined &&
    output.jumboFrameCapable !== null
  ) {
    contents.jumboFrameCapable = output.jumboFrameCapable;
  }
  if (output.lagId !== undefined && output.lagId !== null) {
    contents.lagId = output.lagId;
  }
  if (output.loaIssueTime !== undefined && output.loaIssueTime !== null) {
    contents.loaIssueTime = new Date(Math.round(output.loaIssueTime * 1000));
  }
  if (output.location !== undefined && output.location !== null) {
    contents.location = output.location;
  }
  if (output.ownerAccount !== undefined && output.ownerAccount !== null) {
    contents.ownerAccount = output.ownerAccount;
  }
  if (output.partnerName !== undefined && output.partnerName !== null) {
    contents.partnerName = output.partnerName;
  }
  if (output.providerName !== undefined && output.providerName !== null) {
    contents.providerName = output.providerName;
  }
  if (output.region !== undefined && output.region !== null) {
    contents.region = output.region;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_json1_1TagList(output.tags, context);
  }
  if (output.vlan !== undefined && output.vlan !== null) {
    contents.vlan = output.vlan;
  }
  return contents;
};

const deserializeAws_json1_1ConnectionList = (
  output: any,
  context: __SerdeContext
): Array<Connection> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Connection(entry, context)
  );
};

const deserializeAws_json1_1Connections = (
  output: any,
  context: __SerdeContext
): Connections => {
  let contents: any = {
    __type: "Connections",
    connections: undefined
  };
  if (output.connections !== undefined && output.connections !== null) {
    contents.connections = deserializeAws_json1_1ConnectionList(
      output.connections,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateBGPPeerResponse = (
  output: any,
  context: __SerdeContext
): CreateBGPPeerResponse => {
  let contents: any = {
    __type: "CreateBGPPeerResponse",
    virtualInterface: undefined
  };
  if (
    output.virtualInterface !== undefined &&
    output.virtualInterface !== null
  ) {
    contents.virtualInterface = deserializeAws_json1_1VirtualInterface(
      output.virtualInterface,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalResult = (
  output: any,
  context: __SerdeContext
): CreateDirectConnectGatewayAssociationProposalResult => {
  let contents: any = {
    __type: "CreateDirectConnectGatewayAssociationProposalResult",
    directConnectGatewayAssociationProposal: undefined
  };
  if (
    output.directConnectGatewayAssociationProposal !== undefined &&
    output.directConnectGatewayAssociationProposal !== null
  ) {
    contents.directConnectGatewayAssociationProposal = deserializeAws_json1_1DirectConnectGatewayAssociationProposal(
      output.directConnectGatewayAssociationProposal,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateDirectConnectGatewayAssociationResult = (
  output: any,
  context: __SerdeContext
): CreateDirectConnectGatewayAssociationResult => {
  let contents: any = {
    __type: "CreateDirectConnectGatewayAssociationResult",
    directConnectGatewayAssociation: undefined
  };
  if (
    output.directConnectGatewayAssociation !== undefined &&
    output.directConnectGatewayAssociation !== null
  ) {
    contents.directConnectGatewayAssociation = deserializeAws_json1_1DirectConnectGatewayAssociation(
      output.directConnectGatewayAssociation,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateDirectConnectGatewayResult = (
  output: any,
  context: __SerdeContext
): CreateDirectConnectGatewayResult => {
  let contents: any = {
    __type: "CreateDirectConnectGatewayResult",
    directConnectGateway: undefined
  };
  if (
    output.directConnectGateway !== undefined &&
    output.directConnectGateway !== null
  ) {
    contents.directConnectGateway = deserializeAws_json1_1DirectConnectGateway(
      output.directConnectGateway,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateTransitVirtualInterfaceResult = (
  output: any,
  context: __SerdeContext
): CreateTransitVirtualInterfaceResult => {
  let contents: any = {
    __type: "CreateTransitVirtualInterfaceResult",
    virtualInterface: undefined
  };
  if (
    output.virtualInterface !== undefined &&
    output.virtualInterface !== null
  ) {
    contents.virtualInterface = deserializeAws_json1_1VirtualInterface(
      output.virtualInterface,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteBGPPeerResponse = (
  output: any,
  context: __SerdeContext
): DeleteBGPPeerResponse => {
  let contents: any = {
    __type: "DeleteBGPPeerResponse",
    virtualInterface: undefined
  };
  if (
    output.virtualInterface !== undefined &&
    output.virtualInterface !== null
  ) {
    contents.virtualInterface = deserializeAws_json1_1VirtualInterface(
      output.virtualInterface,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalResult = (
  output: any,
  context: __SerdeContext
): DeleteDirectConnectGatewayAssociationProposalResult => {
  let contents: any = {
    __type: "DeleteDirectConnectGatewayAssociationProposalResult",
    directConnectGatewayAssociationProposal: undefined
  };
  if (
    output.directConnectGatewayAssociationProposal !== undefined &&
    output.directConnectGatewayAssociationProposal !== null
  ) {
    contents.directConnectGatewayAssociationProposal = deserializeAws_json1_1DirectConnectGatewayAssociationProposal(
      output.directConnectGatewayAssociationProposal,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteDirectConnectGatewayAssociationResult = (
  output: any,
  context: __SerdeContext
): DeleteDirectConnectGatewayAssociationResult => {
  let contents: any = {
    __type: "DeleteDirectConnectGatewayAssociationResult",
    directConnectGatewayAssociation: undefined
  };
  if (
    output.directConnectGatewayAssociation !== undefined &&
    output.directConnectGatewayAssociation !== null
  ) {
    contents.directConnectGatewayAssociation = deserializeAws_json1_1DirectConnectGatewayAssociation(
      output.directConnectGatewayAssociation,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteDirectConnectGatewayResult = (
  output: any,
  context: __SerdeContext
): DeleteDirectConnectGatewayResult => {
  let contents: any = {
    __type: "DeleteDirectConnectGatewayResult",
    directConnectGateway: undefined
  };
  if (
    output.directConnectGateway !== undefined &&
    output.directConnectGateway !== null
  ) {
    contents.directConnectGateway = deserializeAws_json1_1DirectConnectGateway(
      output.directConnectGateway,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteInterconnectResponse = (
  output: any,
  context: __SerdeContext
): DeleteInterconnectResponse => {
  let contents: any = {
    __type: "DeleteInterconnectResponse",
    interconnectState: undefined
  };
  if (
    output.interconnectState !== undefined &&
    output.interconnectState !== null
  ) {
    contents.interconnectState = output.interconnectState;
  }
  return contents;
};

const deserializeAws_json1_1DeleteVirtualInterfaceResponse = (
  output: any,
  context: __SerdeContext
): DeleteVirtualInterfaceResponse => {
  let contents: any = {
    __type: "DeleteVirtualInterfaceResponse",
    virtualInterfaceState: undefined
  };
  if (
    output.virtualInterfaceState !== undefined &&
    output.virtualInterfaceState !== null
  ) {
    contents.virtualInterfaceState = output.virtualInterfaceState;
  }
  return contents;
};

const deserializeAws_json1_1DescribeConnectionLoaResponse = (
  output: any,
  context: __SerdeContext
): DescribeConnectionLoaResponse => {
  let contents: any = {
    __type: "DescribeConnectionLoaResponse",
    loa: undefined
  };
  if (output.loa !== undefined && output.loa !== null) {
    contents.loa = deserializeAws_json1_1Loa(output.loa, context);
  }
  return contents;
};

const deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsResult = (
  output: any,
  context: __SerdeContext
): DescribeDirectConnectGatewayAssociationProposalsResult => {
  let contents: any = {
    __type: "DescribeDirectConnectGatewayAssociationProposalsResult",
    directConnectGatewayAssociationProposals: undefined,
    nextToken: undefined
  };
  if (
    output.directConnectGatewayAssociationProposals !== undefined &&
    output.directConnectGatewayAssociationProposals !== null
  ) {
    contents.directConnectGatewayAssociationProposals = deserializeAws_json1_1DirectConnectGatewayAssociationProposalList(
      output.directConnectGatewayAssociationProposals,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsResult = (
  output: any,
  context: __SerdeContext
): DescribeDirectConnectGatewayAssociationsResult => {
  let contents: any = {
    __type: "DescribeDirectConnectGatewayAssociationsResult",
    directConnectGatewayAssociations: undefined,
    nextToken: undefined
  };
  if (
    output.directConnectGatewayAssociations !== undefined &&
    output.directConnectGatewayAssociations !== null
  ) {
    contents.directConnectGatewayAssociations = deserializeAws_json1_1DirectConnectGatewayAssociationList(
      output.directConnectGatewayAssociations,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsResult = (
  output: any,
  context: __SerdeContext
): DescribeDirectConnectGatewayAttachmentsResult => {
  let contents: any = {
    __type: "DescribeDirectConnectGatewayAttachmentsResult",
    directConnectGatewayAttachments: undefined,
    nextToken: undefined
  };
  if (
    output.directConnectGatewayAttachments !== undefined &&
    output.directConnectGatewayAttachments !== null
  ) {
    contents.directConnectGatewayAttachments = deserializeAws_json1_1DirectConnectGatewayAttachmentList(
      output.directConnectGatewayAttachments,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeDirectConnectGatewaysResult = (
  output: any,
  context: __SerdeContext
): DescribeDirectConnectGatewaysResult => {
  let contents: any = {
    __type: "DescribeDirectConnectGatewaysResult",
    directConnectGateways: undefined,
    nextToken: undefined
  };
  if (
    output.directConnectGateways !== undefined &&
    output.directConnectGateways !== null
  ) {
    contents.directConnectGateways = deserializeAws_json1_1DirectConnectGatewayList(
      output.directConnectGateways,
      context
    );
  }
  if (output.nextToken !== undefined && output.nextToken !== null) {
    contents.nextToken = output.nextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeInterconnectLoaResponse = (
  output: any,
  context: __SerdeContext
): DescribeInterconnectLoaResponse => {
  let contents: any = {
    __type: "DescribeInterconnectLoaResponse",
    loa: undefined
  };
  if (output.loa !== undefined && output.loa !== null) {
    contents.loa = deserializeAws_json1_1Loa(output.loa, context);
  }
  return contents;
};

const deserializeAws_json1_1DescribeTagsResponse = (
  output: any,
  context: __SerdeContext
): DescribeTagsResponse => {
  let contents: any = {
    __type: "DescribeTagsResponse",
    resourceTags: undefined
  };
  if (output.resourceTags !== undefined && output.resourceTags !== null) {
    contents.resourceTags = deserializeAws_json1_1ResourceTagList(
      output.resourceTags,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DirectConnectClientException = (
  output: any,
  context: __SerdeContext
): DirectConnectClientException => {
  let contents: any = {
    __type: "DirectConnectClientException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1DirectConnectGateway = (
  output: any,
  context: __SerdeContext
): DirectConnectGateway => {
  let contents: any = {
    __type: "DirectConnectGateway",
    amazonSideAsn: undefined,
    directConnectGatewayId: undefined,
    directConnectGatewayName: undefined,
    directConnectGatewayState: undefined,
    ownerAccount: undefined,
    stateChangeError: undefined
  };
  if (output.amazonSideAsn !== undefined && output.amazonSideAsn !== null) {
    contents.amazonSideAsn = output.amazonSideAsn;
  }
  if (
    output.directConnectGatewayId !== undefined &&
    output.directConnectGatewayId !== null
  ) {
    contents.directConnectGatewayId = output.directConnectGatewayId;
  }
  if (
    output.directConnectGatewayName !== undefined &&
    output.directConnectGatewayName !== null
  ) {
    contents.directConnectGatewayName = output.directConnectGatewayName;
  }
  if (
    output.directConnectGatewayState !== undefined &&
    output.directConnectGatewayState !== null
  ) {
    contents.directConnectGatewayState = output.directConnectGatewayState;
  }
  if (output.ownerAccount !== undefined && output.ownerAccount !== null) {
    contents.ownerAccount = output.ownerAccount;
  }
  if (
    output.stateChangeError !== undefined &&
    output.stateChangeError !== null
  ) {
    contents.stateChangeError = output.stateChangeError;
  }
  return contents;
};

const deserializeAws_json1_1DirectConnectGatewayAssociation = (
  output: any,
  context: __SerdeContext
): DirectConnectGatewayAssociation => {
  let contents: any = {
    __type: "DirectConnectGatewayAssociation",
    allowedPrefixesToDirectConnectGateway: undefined,
    associatedGateway: undefined,
    associationId: undefined,
    associationState: undefined,
    directConnectGatewayId: undefined,
    directConnectGatewayOwnerAccount: undefined,
    stateChangeError: undefined,
    virtualGatewayId: undefined,
    virtualGatewayOwnerAccount: undefined,
    virtualGatewayRegion: undefined
  };
  if (
    output.allowedPrefixesToDirectConnectGateway !== undefined &&
    output.allowedPrefixesToDirectConnectGateway !== null
  ) {
    contents.allowedPrefixesToDirectConnectGateway = deserializeAws_json1_1RouteFilterPrefixList(
      output.allowedPrefixesToDirectConnectGateway,
      context
    );
  }
  if (
    output.associatedGateway !== undefined &&
    output.associatedGateway !== null
  ) {
    contents.associatedGateway = deserializeAws_json1_1AssociatedGateway(
      output.associatedGateway,
      context
    );
  }
  if (output.associationId !== undefined && output.associationId !== null) {
    contents.associationId = output.associationId;
  }
  if (
    output.associationState !== undefined &&
    output.associationState !== null
  ) {
    contents.associationState = output.associationState;
  }
  if (
    output.directConnectGatewayId !== undefined &&
    output.directConnectGatewayId !== null
  ) {
    contents.directConnectGatewayId = output.directConnectGatewayId;
  }
  if (
    output.directConnectGatewayOwnerAccount !== undefined &&
    output.directConnectGatewayOwnerAccount !== null
  ) {
    contents.directConnectGatewayOwnerAccount =
      output.directConnectGatewayOwnerAccount;
  }
  if (
    output.stateChangeError !== undefined &&
    output.stateChangeError !== null
  ) {
    contents.stateChangeError = output.stateChangeError;
  }
  if (
    output.virtualGatewayId !== undefined &&
    output.virtualGatewayId !== null
  ) {
    contents.virtualGatewayId = output.virtualGatewayId;
  }
  if (
    output.virtualGatewayOwnerAccount !== undefined &&
    output.virtualGatewayOwnerAccount !== null
  ) {
    contents.virtualGatewayOwnerAccount = output.virtualGatewayOwnerAccount;
  }
  if (
    output.virtualGatewayRegion !== undefined &&
    output.virtualGatewayRegion !== null
  ) {
    contents.virtualGatewayRegion = output.virtualGatewayRegion;
  }
  return contents;
};

const deserializeAws_json1_1DirectConnectGatewayAssociationList = (
  output: any,
  context: __SerdeContext
): Array<DirectConnectGatewayAssociation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DirectConnectGatewayAssociation(entry, context)
  );
};

const deserializeAws_json1_1DirectConnectGatewayAssociationProposal = (
  output: any,
  context: __SerdeContext
): DirectConnectGatewayAssociationProposal => {
  let contents: any = {
    __type: "DirectConnectGatewayAssociationProposal",
    associatedGateway: undefined,
    directConnectGatewayId: undefined,
    directConnectGatewayOwnerAccount: undefined,
    existingAllowedPrefixesToDirectConnectGateway: undefined,
    proposalId: undefined,
    proposalState: undefined,
    requestedAllowedPrefixesToDirectConnectGateway: undefined
  };
  if (
    output.associatedGateway !== undefined &&
    output.associatedGateway !== null
  ) {
    contents.associatedGateway = deserializeAws_json1_1AssociatedGateway(
      output.associatedGateway,
      context
    );
  }
  if (
    output.directConnectGatewayId !== undefined &&
    output.directConnectGatewayId !== null
  ) {
    contents.directConnectGatewayId = output.directConnectGatewayId;
  }
  if (
    output.directConnectGatewayOwnerAccount !== undefined &&
    output.directConnectGatewayOwnerAccount !== null
  ) {
    contents.directConnectGatewayOwnerAccount =
      output.directConnectGatewayOwnerAccount;
  }
  if (
    output.existingAllowedPrefixesToDirectConnectGateway !== undefined &&
    output.existingAllowedPrefixesToDirectConnectGateway !== null
  ) {
    contents.existingAllowedPrefixesToDirectConnectGateway = deserializeAws_json1_1RouteFilterPrefixList(
      output.existingAllowedPrefixesToDirectConnectGateway,
      context
    );
  }
  if (output.proposalId !== undefined && output.proposalId !== null) {
    contents.proposalId = output.proposalId;
  }
  if (output.proposalState !== undefined && output.proposalState !== null) {
    contents.proposalState = output.proposalState;
  }
  if (
    output.requestedAllowedPrefixesToDirectConnectGateway !== undefined &&
    output.requestedAllowedPrefixesToDirectConnectGateway !== null
  ) {
    contents.requestedAllowedPrefixesToDirectConnectGateway = deserializeAws_json1_1RouteFilterPrefixList(
      output.requestedAllowedPrefixesToDirectConnectGateway,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DirectConnectGatewayAssociationProposalList = (
  output: any,
  context: __SerdeContext
): Array<DirectConnectGatewayAssociationProposal> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DirectConnectGatewayAssociationProposal(
      entry,
      context
    )
  );
};

const deserializeAws_json1_1DirectConnectGatewayAttachment = (
  output: any,
  context: __SerdeContext
): DirectConnectGatewayAttachment => {
  let contents: any = {
    __type: "DirectConnectGatewayAttachment",
    attachmentState: undefined,
    attachmentType: undefined,
    directConnectGatewayId: undefined,
    stateChangeError: undefined,
    virtualInterfaceId: undefined,
    virtualInterfaceOwnerAccount: undefined,
    virtualInterfaceRegion: undefined
  };
  if (output.attachmentState !== undefined && output.attachmentState !== null) {
    contents.attachmentState = output.attachmentState;
  }
  if (output.attachmentType !== undefined && output.attachmentType !== null) {
    contents.attachmentType = output.attachmentType;
  }
  if (
    output.directConnectGatewayId !== undefined &&
    output.directConnectGatewayId !== null
  ) {
    contents.directConnectGatewayId = output.directConnectGatewayId;
  }
  if (
    output.stateChangeError !== undefined &&
    output.stateChangeError !== null
  ) {
    contents.stateChangeError = output.stateChangeError;
  }
  if (
    output.virtualInterfaceId !== undefined &&
    output.virtualInterfaceId !== null
  ) {
    contents.virtualInterfaceId = output.virtualInterfaceId;
  }
  if (
    output.virtualInterfaceOwnerAccount !== undefined &&
    output.virtualInterfaceOwnerAccount !== null
  ) {
    contents.virtualInterfaceOwnerAccount = output.virtualInterfaceOwnerAccount;
  }
  if (
    output.virtualInterfaceRegion !== undefined &&
    output.virtualInterfaceRegion !== null
  ) {
    contents.virtualInterfaceRegion = output.virtualInterfaceRegion;
  }
  return contents;
};

const deserializeAws_json1_1DirectConnectGatewayAttachmentList = (
  output: any,
  context: __SerdeContext
): Array<DirectConnectGatewayAttachment> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DirectConnectGatewayAttachment(entry, context)
  );
};

const deserializeAws_json1_1DirectConnectGatewayList = (
  output: any,
  context: __SerdeContext
): Array<DirectConnectGateway> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DirectConnectGateway(entry, context)
  );
};

const deserializeAws_json1_1DirectConnectServerException = (
  output: any,
  context: __SerdeContext
): DirectConnectServerException => {
  let contents: any = {
    __type: "DirectConnectServerException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1DuplicateTagKeysException = (
  output: any,
  context: __SerdeContext
): DuplicateTagKeysException => {
  let contents: any = {
    __type: "DuplicateTagKeysException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1Interconnect = (
  output: any,
  context: __SerdeContext
): Interconnect => {
  let contents: any = {
    __type: "Interconnect",
    awsDevice: undefined,
    awsDeviceV2: undefined,
    bandwidth: undefined,
    hasLogicalRedundancy: undefined,
    interconnectId: undefined,
    interconnectName: undefined,
    interconnectState: undefined,
    jumboFrameCapable: undefined,
    lagId: undefined,
    loaIssueTime: undefined,
    location: undefined,
    providerName: undefined,
    region: undefined,
    tags: undefined
  };
  if (output.awsDevice !== undefined && output.awsDevice !== null) {
    contents.awsDevice = output.awsDevice;
  }
  if (output.awsDeviceV2 !== undefined && output.awsDeviceV2 !== null) {
    contents.awsDeviceV2 = output.awsDeviceV2;
  }
  if (output.bandwidth !== undefined && output.bandwidth !== null) {
    contents.bandwidth = output.bandwidth;
  }
  if (
    output.hasLogicalRedundancy !== undefined &&
    output.hasLogicalRedundancy !== null
  ) {
    contents.hasLogicalRedundancy = output.hasLogicalRedundancy;
  }
  if (output.interconnectId !== undefined && output.interconnectId !== null) {
    contents.interconnectId = output.interconnectId;
  }
  if (
    output.interconnectName !== undefined &&
    output.interconnectName !== null
  ) {
    contents.interconnectName = output.interconnectName;
  }
  if (
    output.interconnectState !== undefined &&
    output.interconnectState !== null
  ) {
    contents.interconnectState = output.interconnectState;
  }
  if (
    output.jumboFrameCapable !== undefined &&
    output.jumboFrameCapable !== null
  ) {
    contents.jumboFrameCapable = output.jumboFrameCapable;
  }
  if (output.lagId !== undefined && output.lagId !== null) {
    contents.lagId = output.lagId;
  }
  if (output.loaIssueTime !== undefined && output.loaIssueTime !== null) {
    contents.loaIssueTime = new Date(Math.round(output.loaIssueTime * 1000));
  }
  if (output.location !== undefined && output.location !== null) {
    contents.location = output.location;
  }
  if (output.providerName !== undefined && output.providerName !== null) {
    contents.providerName = output.providerName;
  }
  if (output.region !== undefined && output.region !== null) {
    contents.region = output.region;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_json1_1TagList(output.tags, context);
  }
  return contents;
};

const deserializeAws_json1_1InterconnectList = (
  output: any,
  context: __SerdeContext
): Array<Interconnect> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Interconnect(entry, context)
  );
};

const deserializeAws_json1_1Interconnects = (
  output: any,
  context: __SerdeContext
): Interconnects => {
  let contents: any = {
    __type: "Interconnects",
    interconnects: undefined
  };
  if (output.interconnects !== undefined && output.interconnects !== null) {
    contents.interconnects = deserializeAws_json1_1InterconnectList(
      output.interconnects,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1Lag = (
  output: any,
  context: __SerdeContext
): Lag => {
  let contents: any = {
    __type: "Lag",
    allowsHostedConnections: undefined,
    awsDevice: undefined,
    awsDeviceV2: undefined,
    connections: undefined,
    connectionsBandwidth: undefined,
    hasLogicalRedundancy: undefined,
    jumboFrameCapable: undefined,
    lagId: undefined,
    lagName: undefined,
    lagState: undefined,
    location: undefined,
    minimumLinks: undefined,
    numberOfConnections: undefined,
    ownerAccount: undefined,
    providerName: undefined,
    region: undefined,
    tags: undefined
  };
  if (
    output.allowsHostedConnections !== undefined &&
    output.allowsHostedConnections !== null
  ) {
    contents.allowsHostedConnections = output.allowsHostedConnections;
  }
  if (output.awsDevice !== undefined && output.awsDevice !== null) {
    contents.awsDevice = output.awsDevice;
  }
  if (output.awsDeviceV2 !== undefined && output.awsDeviceV2 !== null) {
    contents.awsDeviceV2 = output.awsDeviceV2;
  }
  if (output.connections !== undefined && output.connections !== null) {
    contents.connections = deserializeAws_json1_1ConnectionList(
      output.connections,
      context
    );
  }
  if (
    output.connectionsBandwidth !== undefined &&
    output.connectionsBandwidth !== null
  ) {
    contents.connectionsBandwidth = output.connectionsBandwidth;
  }
  if (
    output.hasLogicalRedundancy !== undefined &&
    output.hasLogicalRedundancy !== null
  ) {
    contents.hasLogicalRedundancy = output.hasLogicalRedundancy;
  }
  if (
    output.jumboFrameCapable !== undefined &&
    output.jumboFrameCapable !== null
  ) {
    contents.jumboFrameCapable = output.jumboFrameCapable;
  }
  if (output.lagId !== undefined && output.lagId !== null) {
    contents.lagId = output.lagId;
  }
  if (output.lagName !== undefined && output.lagName !== null) {
    contents.lagName = output.lagName;
  }
  if (output.lagState !== undefined && output.lagState !== null) {
    contents.lagState = output.lagState;
  }
  if (output.location !== undefined && output.location !== null) {
    contents.location = output.location;
  }
  if (output.minimumLinks !== undefined && output.minimumLinks !== null) {
    contents.minimumLinks = output.minimumLinks;
  }
  if (
    output.numberOfConnections !== undefined &&
    output.numberOfConnections !== null
  ) {
    contents.numberOfConnections = output.numberOfConnections;
  }
  if (output.ownerAccount !== undefined && output.ownerAccount !== null) {
    contents.ownerAccount = output.ownerAccount;
  }
  if (output.providerName !== undefined && output.providerName !== null) {
    contents.providerName = output.providerName;
  }
  if (output.region !== undefined && output.region !== null) {
    contents.region = output.region;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_json1_1TagList(output.tags, context);
  }
  return contents;
};

const deserializeAws_json1_1LagList = (
  output: any,
  context: __SerdeContext
): Array<Lag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Lag(entry, context)
  );
};

const deserializeAws_json1_1Lags = (
  output: any,
  context: __SerdeContext
): Lags => {
  let contents: any = {
    __type: "Lags",
    lags: undefined
  };
  if (output.lags !== undefined && output.lags !== null) {
    contents.lags = deserializeAws_json1_1LagList(output.lags, context);
  }
  return contents;
};

const deserializeAws_json1_1Loa = (
  output: any,
  context: __SerdeContext
): Loa => {
  let contents: any = {
    __type: "Loa",
    loaContent: undefined,
    loaContentType: undefined
  };
  if (output.loaContent !== undefined && output.loaContent !== null) {
    contents.loaContent = context.base64Decoder(output.loaContent);
  }
  if (output.loaContentType !== undefined && output.loaContentType !== null) {
    contents.loaContentType = output.loaContentType;
  }
  return contents;
};

const deserializeAws_json1_1Location = (
  output: any,
  context: __SerdeContext
): Location => {
  let contents: any = {
    __type: "Location",
    availablePortSpeeds: undefined,
    availableProviders: undefined,
    locationCode: undefined,
    locationName: undefined,
    region: undefined
  };
  if (
    output.availablePortSpeeds !== undefined &&
    output.availablePortSpeeds !== null
  ) {
    contents.availablePortSpeeds = deserializeAws_json1_1AvailablePortSpeeds(
      output.availablePortSpeeds,
      context
    );
  }
  if (
    output.availableProviders !== undefined &&
    output.availableProviders !== null
  ) {
    contents.availableProviders = deserializeAws_json1_1ProviderList(
      output.availableProviders,
      context
    );
  }
  if (output.locationCode !== undefined && output.locationCode !== null) {
    contents.locationCode = output.locationCode;
  }
  if (output.locationName !== undefined && output.locationName !== null) {
    contents.locationName = output.locationName;
  }
  if (output.region !== undefined && output.region !== null) {
    contents.region = output.region;
  }
  return contents;
};

const deserializeAws_json1_1LocationList = (
  output: any,
  context: __SerdeContext
): Array<Location> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Location(entry, context)
  );
};

const deserializeAws_json1_1Locations = (
  output: any,
  context: __SerdeContext
): Locations => {
  let contents: any = {
    __type: "Locations",
    locations: undefined
  };
  if (output.locations !== undefined && output.locations !== null) {
    contents.locations = deserializeAws_json1_1LocationList(
      output.locations,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ProviderList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ResourceTag = (
  output: any,
  context: __SerdeContext
): ResourceTag => {
  let contents: any = {
    __type: "ResourceTag",
    resourceArn: undefined,
    tags: undefined
  };
  if (output.resourceArn !== undefined && output.resourceArn !== null) {
    contents.resourceArn = output.resourceArn;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_json1_1TagList(output.tags, context);
  }
  return contents;
};

const deserializeAws_json1_1ResourceTagList = (
  output: any,
  context: __SerdeContext
): Array<ResourceTag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ResourceTag(entry, context)
  );
};

const deserializeAws_json1_1RouteFilterPrefix = (
  output: any,
  context: __SerdeContext
): RouteFilterPrefix => {
  let contents: any = {
    __type: "RouteFilterPrefix",
    cidr: undefined
  };
  if (output.cidr !== undefined && output.cidr !== null) {
    contents.cidr = output.cidr;
  }
  return contents;
};

const deserializeAws_json1_1RouteFilterPrefixList = (
  output: any,
  context: __SerdeContext
): Array<RouteFilterPrefix> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RouteFilterPrefix(entry, context)
  );
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    key: undefined,
    value: undefined
  };
  if (output.key !== undefined && output.key !== null) {
    contents.key = output.key;
  }
  if (output.value !== undefined && output.value !== null) {
    contents.value = output.value;
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TagResourceResponse = (
  output: any,
  context: __SerdeContext
): TagResourceResponse => {
  let contents: any = {
    __type: "TagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1TooManyTagsException = (
  output: any,
  context: __SerdeContext
): TooManyTagsException => {
  let contents: any = {
    __type: "TooManyTagsException",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1UntagResourceResponse = (
  output: any,
  context: __SerdeContext
): UntagResourceResponse => {
  let contents: any = {
    __type: "UntagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateDirectConnectGatewayAssociationResult = (
  output: any,
  context: __SerdeContext
): UpdateDirectConnectGatewayAssociationResult => {
  let contents: any = {
    __type: "UpdateDirectConnectGatewayAssociationResult",
    directConnectGatewayAssociation: undefined
  };
  if (
    output.directConnectGatewayAssociation !== undefined &&
    output.directConnectGatewayAssociation !== null
  ) {
    contents.directConnectGatewayAssociation = deserializeAws_json1_1DirectConnectGatewayAssociation(
      output.directConnectGatewayAssociation,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1VirtualGateway = (
  output: any,
  context: __SerdeContext
): VirtualGateway => {
  let contents: any = {
    __type: "VirtualGateway",
    virtualGatewayId: undefined,
    virtualGatewayState: undefined
  };
  if (
    output.virtualGatewayId !== undefined &&
    output.virtualGatewayId !== null
  ) {
    contents.virtualGatewayId = output.virtualGatewayId;
  }
  if (
    output.virtualGatewayState !== undefined &&
    output.virtualGatewayState !== null
  ) {
    contents.virtualGatewayState = output.virtualGatewayState;
  }
  return contents;
};

const deserializeAws_json1_1VirtualGatewayList = (
  output: any,
  context: __SerdeContext
): Array<VirtualGateway> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1VirtualGateway(entry, context)
  );
};

const deserializeAws_json1_1VirtualGateways = (
  output: any,
  context: __SerdeContext
): VirtualGateways => {
  let contents: any = {
    __type: "VirtualGateways",
    virtualGateways: undefined
  };
  if (output.virtualGateways !== undefined && output.virtualGateways !== null) {
    contents.virtualGateways = deserializeAws_json1_1VirtualGatewayList(
      output.virtualGateways,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1VirtualInterface = (
  output: any,
  context: __SerdeContext
): VirtualInterface => {
  let contents: any = {
    __type: "VirtualInterface",
    addressFamily: undefined,
    amazonAddress: undefined,
    amazonSideAsn: undefined,
    asn: undefined,
    authKey: undefined,
    awsDeviceV2: undefined,
    bgpPeers: undefined,
    connectionId: undefined,
    customerAddress: undefined,
    customerRouterConfig: undefined,
    directConnectGatewayId: undefined,
    jumboFrameCapable: undefined,
    location: undefined,
    mtu: undefined,
    ownerAccount: undefined,
    region: undefined,
    routeFilterPrefixes: undefined,
    tags: undefined,
    virtualGatewayId: undefined,
    virtualInterfaceId: undefined,
    virtualInterfaceName: undefined,
    virtualInterfaceState: undefined,
    virtualInterfaceType: undefined,
    vlan: undefined
  };
  if (output.addressFamily !== undefined && output.addressFamily !== null) {
    contents.addressFamily = output.addressFamily;
  }
  if (output.amazonAddress !== undefined && output.amazonAddress !== null) {
    contents.amazonAddress = output.amazonAddress;
  }
  if (output.amazonSideAsn !== undefined && output.amazonSideAsn !== null) {
    contents.amazonSideAsn = output.amazonSideAsn;
  }
  if (output.asn !== undefined && output.asn !== null) {
    contents.asn = output.asn;
  }
  if (output.authKey !== undefined && output.authKey !== null) {
    contents.authKey = output.authKey;
  }
  if (output.awsDeviceV2 !== undefined && output.awsDeviceV2 !== null) {
    contents.awsDeviceV2 = output.awsDeviceV2;
  }
  if (output.bgpPeers !== undefined && output.bgpPeers !== null) {
    contents.bgpPeers = deserializeAws_json1_1BGPPeerList(
      output.bgpPeers,
      context
    );
  }
  if (output.connectionId !== undefined && output.connectionId !== null) {
    contents.connectionId = output.connectionId;
  }
  if (output.customerAddress !== undefined && output.customerAddress !== null) {
    contents.customerAddress = output.customerAddress;
  }
  if (
    output.customerRouterConfig !== undefined &&
    output.customerRouterConfig !== null
  ) {
    contents.customerRouterConfig = output.customerRouterConfig;
  }
  if (
    output.directConnectGatewayId !== undefined &&
    output.directConnectGatewayId !== null
  ) {
    contents.directConnectGatewayId = output.directConnectGatewayId;
  }
  if (
    output.jumboFrameCapable !== undefined &&
    output.jumboFrameCapable !== null
  ) {
    contents.jumboFrameCapable = output.jumboFrameCapable;
  }
  if (output.location !== undefined && output.location !== null) {
    contents.location = output.location;
  }
  if (output.mtu !== undefined && output.mtu !== null) {
    contents.mtu = output.mtu;
  }
  if (output.ownerAccount !== undefined && output.ownerAccount !== null) {
    contents.ownerAccount = output.ownerAccount;
  }
  if (output.region !== undefined && output.region !== null) {
    contents.region = output.region;
  }
  if (
    output.routeFilterPrefixes !== undefined &&
    output.routeFilterPrefixes !== null
  ) {
    contents.routeFilterPrefixes = deserializeAws_json1_1RouteFilterPrefixList(
      output.routeFilterPrefixes,
      context
    );
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.tags = deserializeAws_json1_1TagList(output.tags, context);
  }
  if (
    output.virtualGatewayId !== undefined &&
    output.virtualGatewayId !== null
  ) {
    contents.virtualGatewayId = output.virtualGatewayId;
  }
  if (
    output.virtualInterfaceId !== undefined &&
    output.virtualInterfaceId !== null
  ) {
    contents.virtualInterfaceId = output.virtualInterfaceId;
  }
  if (
    output.virtualInterfaceName !== undefined &&
    output.virtualInterfaceName !== null
  ) {
    contents.virtualInterfaceName = output.virtualInterfaceName;
  }
  if (
    output.virtualInterfaceState !== undefined &&
    output.virtualInterfaceState !== null
  ) {
    contents.virtualInterfaceState = output.virtualInterfaceState;
  }
  if (
    output.virtualInterfaceType !== undefined &&
    output.virtualInterfaceType !== null
  ) {
    contents.virtualInterfaceType = output.virtualInterfaceType;
  }
  if (output.vlan !== undefined && output.vlan !== null) {
    contents.vlan = output.vlan;
  }
  return contents;
};

const deserializeAws_json1_1VirtualInterfaceList = (
  output: any,
  context: __SerdeContext
): Array<VirtualInterface> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1VirtualInterface(entry, context)
  );
};

const deserializeAws_json1_1VirtualInterfaces = (
  output: any,
  context: __SerdeContext
): VirtualInterfaces => {
  let contents: any = {
    __type: "VirtualInterfaces",
    virtualInterfaces: undefined
  };
  if (
    output.virtualInterfaces !== undefined &&
    output.virtualInterfaces !== null
  ) {
    contents.virtualInterfaces = deserializeAws_json1_1VirtualInterfaceList(
      output.virtualInterfaces,
      context
    );
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
