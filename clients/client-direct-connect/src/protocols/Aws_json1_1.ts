import {
  AcceptDirectConnectGatewayAssociationProposalCommandInput,
  AcceptDirectConnectGatewayAssociationProposalCommandOutput,
} from "../commands/AcceptDirectConnectGatewayAssociationProposalCommand";
import {
  AllocateConnectionOnInterconnectCommandInput,
  AllocateConnectionOnInterconnectCommandOutput,
} from "../commands/AllocateConnectionOnInterconnectCommand";
import {
  AllocateHostedConnectionCommandInput,
  AllocateHostedConnectionCommandOutput,
} from "../commands/AllocateHostedConnectionCommand";
import {
  AllocatePrivateVirtualInterfaceCommandInput,
  AllocatePrivateVirtualInterfaceCommandOutput,
} from "../commands/AllocatePrivateVirtualInterfaceCommand";
import {
  AllocatePublicVirtualInterfaceCommandInput,
  AllocatePublicVirtualInterfaceCommandOutput,
} from "../commands/AllocatePublicVirtualInterfaceCommand";
import {
  AllocateTransitVirtualInterfaceCommandInput,
  AllocateTransitVirtualInterfaceCommandOutput,
} from "../commands/AllocateTransitVirtualInterfaceCommand";
import {
  AssociateConnectionWithLagCommandInput,
  AssociateConnectionWithLagCommandOutput,
} from "../commands/AssociateConnectionWithLagCommand";
import {
  AssociateHostedConnectionCommandInput,
  AssociateHostedConnectionCommandOutput,
} from "../commands/AssociateHostedConnectionCommand";
import { AssociateMacSecKeyCommandInput, AssociateMacSecKeyCommandOutput } from "../commands/AssociateMacSecKeyCommand";
import {
  AssociateVirtualInterfaceCommandInput,
  AssociateVirtualInterfaceCommandOutput,
} from "../commands/AssociateVirtualInterfaceCommand";
import { ConfirmConnectionCommandInput, ConfirmConnectionCommandOutput } from "../commands/ConfirmConnectionCommand";
import {
  ConfirmPrivateVirtualInterfaceCommandInput,
  ConfirmPrivateVirtualInterfaceCommandOutput,
} from "../commands/ConfirmPrivateVirtualInterfaceCommand";
import {
  ConfirmPublicVirtualInterfaceCommandInput,
  ConfirmPublicVirtualInterfaceCommandOutput,
} from "../commands/ConfirmPublicVirtualInterfaceCommand";
import {
  ConfirmTransitVirtualInterfaceCommandInput,
  ConfirmTransitVirtualInterfaceCommandOutput,
} from "../commands/ConfirmTransitVirtualInterfaceCommand";
import { CreateBGPPeerCommandInput, CreateBGPPeerCommandOutput } from "../commands/CreateBGPPeerCommand";
import { CreateConnectionCommandInput, CreateConnectionCommandOutput } from "../commands/CreateConnectionCommand";
import {
  CreateDirectConnectGatewayAssociationCommandInput,
  CreateDirectConnectGatewayAssociationCommandOutput,
} from "../commands/CreateDirectConnectGatewayAssociationCommand";
import {
  CreateDirectConnectGatewayAssociationProposalCommandInput,
  CreateDirectConnectGatewayAssociationProposalCommandOutput,
} from "../commands/CreateDirectConnectGatewayAssociationProposalCommand";
import {
  CreateDirectConnectGatewayCommandInput,
  CreateDirectConnectGatewayCommandOutput,
} from "../commands/CreateDirectConnectGatewayCommand";
import { CreateInterconnectCommandInput, CreateInterconnectCommandOutput } from "../commands/CreateInterconnectCommand";
import { CreateLagCommandInput, CreateLagCommandOutput } from "../commands/CreateLagCommand";
import {
  CreatePrivateVirtualInterfaceCommandInput,
  CreatePrivateVirtualInterfaceCommandOutput,
} from "../commands/CreatePrivateVirtualInterfaceCommand";
import {
  CreatePublicVirtualInterfaceCommandInput,
  CreatePublicVirtualInterfaceCommandOutput,
} from "../commands/CreatePublicVirtualInterfaceCommand";
import {
  CreateTransitVirtualInterfaceCommandInput,
  CreateTransitVirtualInterfaceCommandOutput,
} from "../commands/CreateTransitVirtualInterfaceCommand";
import { DeleteBGPPeerCommandInput, DeleteBGPPeerCommandOutput } from "../commands/DeleteBGPPeerCommand";
import { DeleteConnectionCommandInput, DeleteConnectionCommandOutput } from "../commands/DeleteConnectionCommand";
import {
  DeleteDirectConnectGatewayAssociationCommandInput,
  DeleteDirectConnectGatewayAssociationCommandOutput,
} from "../commands/DeleteDirectConnectGatewayAssociationCommand";
import {
  DeleteDirectConnectGatewayAssociationProposalCommandInput,
  DeleteDirectConnectGatewayAssociationProposalCommandOutput,
} from "../commands/DeleteDirectConnectGatewayAssociationProposalCommand";
import {
  DeleteDirectConnectGatewayCommandInput,
  DeleteDirectConnectGatewayCommandOutput,
} from "../commands/DeleteDirectConnectGatewayCommand";
import { DeleteInterconnectCommandInput, DeleteInterconnectCommandOutput } from "../commands/DeleteInterconnectCommand";
import { DeleteLagCommandInput, DeleteLagCommandOutput } from "../commands/DeleteLagCommand";
import {
  DeleteVirtualInterfaceCommandInput,
  DeleteVirtualInterfaceCommandOutput,
} from "../commands/DeleteVirtualInterfaceCommand";
import {
  DescribeConnectionLoaCommandInput,
  DescribeConnectionLoaCommandOutput,
} from "../commands/DescribeConnectionLoaCommand";
import {
  DescribeConnectionsCommandInput,
  DescribeConnectionsCommandOutput,
} from "../commands/DescribeConnectionsCommand";
import {
  DescribeConnectionsOnInterconnectCommandInput,
  DescribeConnectionsOnInterconnectCommandOutput,
} from "../commands/DescribeConnectionsOnInterconnectCommand";
import {
  DescribeDirectConnectGatewayAssociationProposalsCommandInput,
  DescribeDirectConnectGatewayAssociationProposalsCommandOutput,
} from "../commands/DescribeDirectConnectGatewayAssociationProposalsCommand";
import {
  DescribeDirectConnectGatewayAssociationsCommandInput,
  DescribeDirectConnectGatewayAssociationsCommandOutput,
} from "../commands/DescribeDirectConnectGatewayAssociationsCommand";
import {
  DescribeDirectConnectGatewayAttachmentsCommandInput,
  DescribeDirectConnectGatewayAttachmentsCommandOutput,
} from "../commands/DescribeDirectConnectGatewayAttachmentsCommand";
import {
  DescribeDirectConnectGatewaysCommandInput,
  DescribeDirectConnectGatewaysCommandOutput,
} from "../commands/DescribeDirectConnectGatewaysCommand";
import {
  DescribeHostedConnectionsCommandInput,
  DescribeHostedConnectionsCommandOutput,
} from "../commands/DescribeHostedConnectionsCommand";
import {
  DescribeInterconnectLoaCommandInput,
  DescribeInterconnectLoaCommandOutput,
} from "../commands/DescribeInterconnectLoaCommand";
import {
  DescribeInterconnectsCommandInput,
  DescribeInterconnectsCommandOutput,
} from "../commands/DescribeInterconnectsCommand";
import { DescribeLagsCommandInput, DescribeLagsCommandOutput } from "../commands/DescribeLagsCommand";
import { DescribeLoaCommandInput, DescribeLoaCommandOutput } from "../commands/DescribeLoaCommand";
import { DescribeLocationsCommandInput, DescribeLocationsCommandOutput } from "../commands/DescribeLocationsCommand";
import { DescribeTagsCommandInput, DescribeTagsCommandOutput } from "../commands/DescribeTagsCommand";
import {
  DescribeVirtualGatewaysCommandInput,
  DescribeVirtualGatewaysCommandOutput,
} from "../commands/DescribeVirtualGatewaysCommand";
import {
  DescribeVirtualInterfacesCommandInput,
  DescribeVirtualInterfacesCommandOutput,
} from "../commands/DescribeVirtualInterfacesCommand";
import {
  DisassociateConnectionFromLagCommandInput,
  DisassociateConnectionFromLagCommandOutput,
} from "../commands/DisassociateConnectionFromLagCommand";
import {
  DisassociateMacSecKeyCommandInput,
  DisassociateMacSecKeyCommandOutput,
} from "../commands/DisassociateMacSecKeyCommand";
import {
  ListVirtualInterfaceTestHistoryCommandInput,
  ListVirtualInterfaceTestHistoryCommandOutput,
} from "../commands/ListVirtualInterfaceTestHistoryCommand";
import {
  StartBgpFailoverTestCommandInput,
  StartBgpFailoverTestCommandOutput,
} from "../commands/StartBgpFailoverTestCommand";
import {
  StopBgpFailoverTestCommandInput,
  StopBgpFailoverTestCommandOutput,
} from "../commands/StopBgpFailoverTestCommand";
import { TagResourceCommandInput, TagResourceCommandOutput } from "../commands/TagResourceCommand";
import { UntagResourceCommandInput, UntagResourceCommandOutput } from "../commands/UntagResourceCommand";
import { UpdateConnectionCommandInput, UpdateConnectionCommandOutput } from "../commands/UpdateConnectionCommand";
import {
  UpdateDirectConnectGatewayAssociationCommandInput,
  UpdateDirectConnectGatewayAssociationCommandOutput,
} from "../commands/UpdateDirectConnectGatewayAssociationCommand";
import { UpdateLagCommandInput, UpdateLagCommandOutput } from "../commands/UpdateLagCommand";
import {
  UpdateVirtualInterfaceAttributesCommandInput,
  UpdateVirtualInterfaceAttributesCommandOutput,
} from "../commands/UpdateVirtualInterfaceAttributesCommand";
import {
  AcceptDirectConnectGatewayAssociationProposalRequest,
  AcceptDirectConnectGatewayAssociationProposalResult,
  AllocateConnectionOnInterconnectRequest,
  AllocateHostedConnectionRequest,
  AllocatePrivateVirtualInterfaceRequest,
  AllocatePublicVirtualInterfaceRequest,
  AllocateTransitVirtualInterfaceRequest,
  AllocateTransitVirtualInterfaceResult,
  AssociateConnectionWithLagRequest,
  AssociateHostedConnectionRequest,
  AssociateMacSecKeyRequest,
  AssociateMacSecKeyResponse,
  AssociateVirtualInterfaceRequest,
  AssociatedGateway,
  BGPPeer,
  ConfirmConnectionRequest,
  ConfirmConnectionResponse,
  ConfirmPrivateVirtualInterfaceRequest,
  ConfirmPrivateVirtualInterfaceResponse,
  ConfirmPublicVirtualInterfaceRequest,
  ConfirmPublicVirtualInterfaceResponse,
  ConfirmTransitVirtualInterfaceRequest,
  ConfirmTransitVirtualInterfaceResponse,
  Connection,
  Connections,
  CreateBGPPeerRequest,
  CreateBGPPeerResponse,
  CreateConnectionRequest,
  CreateDirectConnectGatewayAssociationProposalRequest,
  CreateDirectConnectGatewayAssociationProposalResult,
  CreateDirectConnectGatewayAssociationRequest,
  CreateDirectConnectGatewayAssociationResult,
  CreateDirectConnectGatewayRequest,
  CreateDirectConnectGatewayResult,
  CreateInterconnectRequest,
  CreateLagRequest,
  CreatePrivateVirtualInterfaceRequest,
  CreatePublicVirtualInterfaceRequest,
  CreateTransitVirtualInterfaceRequest,
  CreateTransitVirtualInterfaceResult,
  DeleteBGPPeerRequest,
  DeleteBGPPeerResponse,
  DeleteConnectionRequest,
  DeleteDirectConnectGatewayAssociationProposalRequest,
  DeleteDirectConnectGatewayAssociationProposalResult,
  DeleteDirectConnectGatewayAssociationRequest,
  DeleteDirectConnectGatewayAssociationResult,
  DeleteDirectConnectGatewayRequest,
  DeleteDirectConnectGatewayResult,
  DeleteInterconnectRequest,
  DeleteInterconnectResponse,
  DeleteLagRequest,
  DeleteVirtualInterfaceRequest,
  DeleteVirtualInterfaceResponse,
  DescribeConnectionLoaRequest,
  DescribeConnectionLoaResponse,
  DescribeConnectionsOnInterconnectRequest,
  DescribeConnectionsRequest,
  DescribeDirectConnectGatewayAssociationProposalsRequest,
  DescribeDirectConnectGatewayAssociationProposalsResult,
  DescribeDirectConnectGatewayAssociationsRequest,
  DescribeDirectConnectGatewayAssociationsResult,
  DescribeDirectConnectGatewayAttachmentsRequest,
  DescribeDirectConnectGatewayAttachmentsResult,
  DescribeDirectConnectGatewaysRequest,
  DescribeDirectConnectGatewaysResult,
  DescribeHostedConnectionsRequest,
  DescribeInterconnectLoaRequest,
  DescribeInterconnectLoaResponse,
  DescribeInterconnectsRequest,
  DescribeLagsRequest,
  DescribeLoaRequest,
  DescribeTagsRequest,
  DescribeTagsResponse,
  DescribeVirtualInterfacesRequest,
  DirectConnectClientException,
  DirectConnectGateway,
  DirectConnectGatewayAssociation,
  DirectConnectGatewayAssociationProposal,
  DirectConnectGatewayAttachment,
  DirectConnectServerException,
  DisassociateConnectionFromLagRequest,
  DisassociateMacSecKeyRequest,
  DisassociateMacSecKeyResponse,
  DuplicateTagKeysException,
  Interconnect,
  Interconnects,
  Lag,
  Lags,
  ListVirtualInterfaceTestHistoryRequest,
  ListVirtualInterfaceTestHistoryResponse,
  Loa,
  Location,
  Locations,
  MacSecKey,
  NewBGPPeer,
  NewPrivateVirtualInterface,
  NewPrivateVirtualInterfaceAllocation,
  NewPublicVirtualInterface,
  NewPublicVirtualInterfaceAllocation,
  NewTransitVirtualInterface,
  NewTransitVirtualInterfaceAllocation,
  ResourceTag,
  RouteFilterPrefix,
  StartBgpFailoverTestRequest,
  StartBgpFailoverTestResponse,
  StopBgpFailoverTestRequest,
  StopBgpFailoverTestResponse,
  Tag,
  TagResourceRequest,
  TagResourceResponse,
  TooManyTagsException,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateConnectionRequest,
  UpdateDirectConnectGatewayAssociationRequest,
  UpdateDirectConnectGatewayAssociationResult,
  UpdateLagRequest,
  UpdateVirtualInterfaceAttributesRequest,
  VirtualGateway,
  VirtualGateways,
  VirtualInterface,
  VirtualInterfaceTestHistory,
  VirtualInterfaces,
} from "../models/models_0";
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@aws-sdk/protocol-http";
import {
  expectBoolean as __expectBoolean,
  expectInt32 as __expectInt32,
  expectLong as __expectLong,
  expectNonNull as __expectNonNull,
  expectNumber as __expectNumber,
  expectString as __expectString,
  parseEpochTimestamp as __parseEpochTimestamp,
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext,
  SmithyException as __SmithyException,
} from "@aws-sdk/types";

export const serializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalCommand = async (
  input: AcceptDirectConnectGatewayAssociationProposalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AcceptDirectConnectGatewayAssociationProposal",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AllocateConnectionOnInterconnectCommand = async (
  input: AllocateConnectionOnInterconnectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AllocateConnectionOnInterconnect",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AllocateConnectionOnInterconnectRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AllocateHostedConnectionCommand = async (
  input: AllocateHostedConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AllocateHostedConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AllocateHostedConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AllocatePrivateVirtualInterfaceCommand = async (
  input: AllocatePrivateVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AllocatePrivateVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AllocatePrivateVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AllocatePublicVirtualInterfaceCommand = async (
  input: AllocatePublicVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AllocatePublicVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AllocatePublicVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AllocateTransitVirtualInterfaceCommand = async (
  input: AllocateTransitVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AllocateTransitVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AllocateTransitVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AssociateConnectionWithLagCommand = async (
  input: AssociateConnectionWithLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AssociateConnectionWithLag",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AssociateConnectionWithLagRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AssociateHostedConnectionCommand = async (
  input: AssociateHostedConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AssociateHostedConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AssociateHostedConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AssociateMacSecKeyCommand = async (
  input: AssociateMacSecKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AssociateMacSecKey",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AssociateMacSecKeyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AssociateVirtualInterfaceCommand = async (
  input: AssociateVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.AssociateVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AssociateVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ConfirmConnectionCommand = async (
  input: ConfirmConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.ConfirmConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ConfirmConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ConfirmPrivateVirtualInterfaceCommand = async (
  input: ConfirmPrivateVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.ConfirmPrivateVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ConfirmPrivateVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ConfirmPublicVirtualInterfaceCommand = async (
  input: ConfirmPublicVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.ConfirmPublicVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ConfirmPublicVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ConfirmTransitVirtualInterfaceCommand = async (
  input: ConfirmTransitVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.ConfirmTransitVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ConfirmTransitVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateBGPPeerCommand = async (
  input: CreateBGPPeerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreateBGPPeer",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateBGPPeerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateConnectionCommand = async (
  input: CreateConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreateConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateDirectConnectGatewayCommand = async (
  input: CreateDirectConnectGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreateDirectConnectGateway",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateDirectConnectGatewayRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateDirectConnectGatewayAssociationCommand = async (
  input: CreateDirectConnectGatewayAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreateDirectConnectGatewayAssociation",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateDirectConnectGatewayAssociationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateDirectConnectGatewayAssociationProposalCommand = async (
  input: CreateDirectConnectGatewayAssociationProposalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreateDirectConnectGatewayAssociationProposal",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateDirectConnectGatewayAssociationProposalRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateInterconnectCommand = async (
  input: CreateInterconnectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreateInterconnect",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateInterconnectRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateLagCommand = async (
  input: CreateLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreateLag",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateLagRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreatePrivateVirtualInterfaceCommand = async (
  input: CreatePrivateVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreatePrivateVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreatePrivateVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreatePublicVirtualInterfaceCommand = async (
  input: CreatePublicVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreatePublicVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreatePublicVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateTransitVirtualInterfaceCommand = async (
  input: CreateTransitVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.CreateTransitVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateTransitVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteBGPPeerCommand = async (
  input: DeleteBGPPeerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DeleteBGPPeer",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteBGPPeerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteConnectionCommand = async (
  input: DeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DeleteConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteDirectConnectGatewayCommand = async (
  input: DeleteDirectConnectGatewayCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DeleteDirectConnectGateway",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteDirectConnectGatewayRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteDirectConnectGatewayAssociationCommand = async (
  input: DeleteDirectConnectGatewayAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DeleteDirectConnectGatewayAssociation",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteDirectConnectGatewayAssociationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalCommand = async (
  input: DeleteDirectConnectGatewayAssociationProposalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DeleteDirectConnectGatewayAssociationProposal",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteInterconnectCommand = async (
  input: DeleteInterconnectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DeleteInterconnect",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteInterconnectRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteLagCommand = async (
  input: DeleteLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DeleteLag",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteLagRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteVirtualInterfaceCommand = async (
  input: DeleteVirtualInterfaceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DeleteVirtualInterface",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteVirtualInterfaceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeConnectionLoaCommand = async (
  input: DescribeConnectionLoaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeConnectionLoa",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeConnectionLoaRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeConnectionsCommand = async (
  input: DescribeConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeConnections",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeConnectionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeConnectionsOnInterconnectCommand = async (
  input: DescribeConnectionsOnInterconnectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeConnectionsOnInterconnect",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeConnectionsOnInterconnectRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsCommand = async (
  input: DescribeDirectConnectGatewayAssociationProposalsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeDirectConnectGatewayAssociationProposals",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeDirectConnectGatewayAssociationsCommand = async (
  input: DescribeDirectConnectGatewayAssociationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeDirectConnectGatewayAssociations",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeDirectConnectGatewayAssociationsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeDirectConnectGatewayAttachmentsCommand = async (
  input: DescribeDirectConnectGatewayAttachmentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeDirectConnectGatewayAttachments",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeDirectConnectGatewayAttachmentsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeDirectConnectGatewaysCommand = async (
  input: DescribeDirectConnectGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeDirectConnectGateways",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeDirectConnectGatewaysRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeHostedConnectionsCommand = async (
  input: DescribeHostedConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeHostedConnections",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeHostedConnectionsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeInterconnectLoaCommand = async (
  input: DescribeInterconnectLoaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeInterconnectLoa",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeInterconnectLoaRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeInterconnectsCommand = async (
  input: DescribeInterconnectsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeInterconnects",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeInterconnectsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeLagsCommand = async (
  input: DescribeLagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeLags",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeLagsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeLoaCommand = async (
  input: DescribeLoaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeLoa",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeLoaRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeLocationsCommand = async (
  input: DescribeLocationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeLocations",
  };
  const body = "{}";
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeTagsCommand = async (
  input: DescribeTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeTags",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeTagsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeVirtualGatewaysCommand = async (
  input: DescribeVirtualGatewaysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeVirtualGateways",
  };
  const body = "{}";
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeVirtualInterfacesCommand = async (
  input: DescribeVirtualInterfacesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DescribeVirtualInterfaces",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeVirtualInterfacesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DisassociateConnectionFromLagCommand = async (
  input: DisassociateConnectionFromLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DisassociateConnectionFromLag",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DisassociateConnectionFromLagRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DisassociateMacSecKeyCommand = async (
  input: DisassociateMacSecKeyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.DisassociateMacSecKey",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DisassociateMacSecKeyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListVirtualInterfaceTestHistoryCommand = async (
  input: ListVirtualInterfaceTestHistoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.ListVirtualInterfaceTestHistory",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListVirtualInterfaceTestHistoryRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartBgpFailoverTestCommand = async (
  input: StartBgpFailoverTestCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.StartBgpFailoverTest",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartBgpFailoverTestRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StopBgpFailoverTestCommand = async (
  input: StopBgpFailoverTestCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.StopBgpFailoverTest",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StopBgpFailoverTestRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1TagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.TagResource",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.UntagResource",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UntagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateConnectionCommand = async (
  input: UpdateConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.UpdateConnection",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateConnectionRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateDirectConnectGatewayAssociationCommand = async (
  input: UpdateDirectConnectGatewayAssociationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.UpdateDirectConnectGatewayAssociation",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateDirectConnectGatewayAssociationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateLagCommand = async (
  input: UpdateLagCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.UpdateLag",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateLagRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateVirtualInterfaceAttributesCommand = async (
  input: UpdateVirtualInterfaceAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": "OvertureService.UpdateVirtualInterfaceAttributes",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateVirtualInterfaceAttributesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptDirectConnectGatewayAssociationProposalCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalResult(data, context);
  const response: AcceptDirectConnectGatewayAssociationProposalCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptDirectConnectGatewayAssociationProposalCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AllocateConnectionOnInterconnectCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateConnectionOnInterconnectCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AllocateConnectionOnInterconnectCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: AllocateConnectionOnInterconnectCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AllocateConnectionOnInterconnectCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateConnectionOnInterconnectCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AllocateHostedConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateHostedConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AllocateHostedConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: AllocateHostedConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AllocateHostedConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateHostedConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AllocatePrivateVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocatePrivateVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AllocatePrivateVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: AllocatePrivateVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AllocatePrivateVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocatePrivateVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AllocatePublicVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocatePublicVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AllocatePublicVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: AllocatePublicVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AllocatePublicVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocatePublicVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AllocateTransitVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateTransitVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AllocateTransitVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AllocateTransitVirtualInterfaceResult(data, context);
  const response: AllocateTransitVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AllocateTransitVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AllocateTransitVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AssociateConnectionWithLagCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateConnectionWithLagCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AssociateConnectionWithLagCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: AssociateConnectionWithLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AssociateConnectionWithLagCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateConnectionWithLagCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AssociateHostedConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateHostedConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AssociateHostedConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: AssociateHostedConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AssociateHostedConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateHostedConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AssociateMacSecKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateMacSecKeyCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AssociateMacSecKeyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AssociateMacSecKeyResponse(data, context);
  const response: AssociateMacSecKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AssociateMacSecKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateMacSecKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AssociateVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1AssociateVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: AssociateVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AssociateVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ConfirmConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1ConfirmConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ConfirmConnectionResponse(data, context);
  const response: ConfirmConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ConfirmConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ConfirmPrivateVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmPrivateVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1ConfirmPrivateVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ConfirmPrivateVirtualInterfaceResponse(data, context);
  const response: ConfirmPrivateVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ConfirmPrivateVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmPrivateVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ConfirmPublicVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmPublicVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1ConfirmPublicVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ConfirmPublicVirtualInterfaceResponse(data, context);
  const response: ConfirmPublicVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ConfirmPublicVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmPublicVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ConfirmTransitVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmTransitVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1ConfirmTransitVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ConfirmTransitVirtualInterfaceResponse(data, context);
  const response: ConfirmTransitVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ConfirmTransitVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmTransitVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateBGPPeerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBGPPeerCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreateBGPPeerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateBGPPeerResponse(data, context);
  const response: CreateBGPPeerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateBGPPeerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBGPPeerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreateConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: CreateConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateDirectConnectGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreateDirectConnectGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDirectConnectGatewayResult(data, context);
  const response: CreateDirectConnectGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateDirectConnectGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateDirectConnectGatewayAssociationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayAssociationCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreateDirectConnectGatewayAssociationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDirectConnectGatewayAssociationResult(data, context);
  const response: CreateDirectConnectGatewayAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateDirectConnectGatewayAssociationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayAssociationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayAssociationProposalCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalResult(data, context);
  const response: CreateDirectConnectGatewayAssociationProposalCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDirectConnectGatewayAssociationProposalCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateInterconnectCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInterconnectCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreateInterconnectCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Interconnect(data, context);
  const response: CreateInterconnectCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateInterconnectCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInterconnectCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateLagCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLagCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreateLagCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Lag(data, context);
  const response: CreateLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateLagCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLagCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreatePrivateVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePrivateVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreatePrivateVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: CreatePrivateVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreatePrivateVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePrivateVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreatePublicVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePublicVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreatePublicVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: CreatePublicVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreatePublicVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePublicVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateTransitVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1CreateTransitVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTransitVirtualInterfaceResult(data, context);
  const response: CreateTransitVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateTransitVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransitVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteBGPPeerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBGPPeerCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DeleteBGPPeerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteBGPPeerResponse(data, context);
  const response: DeleteBGPPeerCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteBGPPeerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBGPPeerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: DeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteDirectConnectGatewayCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DeleteDirectConnectGatewayCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDirectConnectGatewayResult(data, context);
  const response: DeleteDirectConnectGatewayCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteDirectConnectGatewayCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteDirectConnectGatewayAssociationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayAssociationCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DeleteDirectConnectGatewayAssociationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDirectConnectGatewayAssociationResult(data, context);
  const response: DeleteDirectConnectGatewayAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteDirectConnectGatewayAssociationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayAssociationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayAssociationProposalCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalResult(data, context);
  const response: DeleteDirectConnectGatewayAssociationProposalCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDirectConnectGatewayAssociationProposalCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteInterconnectCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInterconnectCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DeleteInterconnectCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteInterconnectResponse(data, context);
  const response: DeleteInterconnectCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteInterconnectCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInterconnectCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteLagCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLagCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DeleteLagCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Lag(data, context);
  const response: DeleteLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteLagCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLagCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteVirtualInterfaceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVirtualInterfaceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DeleteVirtualInterfaceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteVirtualInterfaceResponse(data, context);
  const response: DeleteVirtualInterfaceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteVirtualInterfaceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVirtualInterfaceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeConnectionLoaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionLoaCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeConnectionLoaCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeConnectionLoaResponse(data, context);
  const response: DescribeConnectionLoaCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeConnectionLoaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionLoaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeConnectionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connections(data, context);
  const response: DescribeConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeConnectionsOnInterconnectCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsOnInterconnectCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeConnectionsOnInterconnectCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connections(data, context);
  const response: DescribeConnectionsOnInterconnectCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeConnectionsOnInterconnectCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsOnInterconnectCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAssociationProposalsCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsResult(data, context);
  const response: DescribeDirectConnectGatewayAssociationProposalsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAssociationProposalsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAssociationsCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsResult(data, context);
  const response: DescribeDirectConnectGatewayAssociationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAssociationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAttachmentsCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsResult(data, context);
  const response: DescribeDirectConnectGatewayAttachmentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewayAttachmentsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeDirectConnectGatewaysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewaysCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeDirectConnectGatewaysCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDirectConnectGatewaysResult(data, context);
  const response: DescribeDirectConnectGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeDirectConnectGatewaysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDirectConnectGatewaysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeHostedConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostedConnectionsCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeHostedConnectionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connections(data, context);
  const response: DescribeHostedConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeHostedConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHostedConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeInterconnectLoaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInterconnectLoaCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeInterconnectLoaCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInterconnectLoaResponse(data, context);
  const response: DescribeInterconnectLoaCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeInterconnectLoaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInterconnectLoaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeInterconnectsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInterconnectsCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeInterconnectsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Interconnects(data, context);
  const response: DescribeInterconnectsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeInterconnectsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInterconnectsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeLagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLagsCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeLagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Lags(data, context);
  const response: DescribeLagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeLagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeLoaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLoaCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeLoaCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Loa(data, context);
  const response: DescribeLoaCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeLoaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLoaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeLocationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocationsCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeLocationsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Locations(data, context);
  const response: DescribeLocationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeLocationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLocationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTagsCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTagsResponse(data, context);
  const response: DescribeTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeVirtualGatewaysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVirtualGatewaysCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeVirtualGatewaysCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualGateways(data, context);
  const response: DescribeVirtualGatewaysCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeVirtualGatewaysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVirtualGatewaysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeVirtualInterfacesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVirtualInterfacesCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DescribeVirtualInterfacesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterfaces(data, context);
  const response: DescribeVirtualInterfacesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeVirtualInterfacesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVirtualInterfacesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DisassociateConnectionFromLagCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateConnectionFromLagCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DisassociateConnectionFromLagCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: DisassociateConnectionFromLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DisassociateConnectionFromLagCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateConnectionFromLagCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DisassociateMacSecKeyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateMacSecKeyCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1DisassociateMacSecKeyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisassociateMacSecKeyResponse(data, context);
  const response: DisassociateMacSecKeyCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DisassociateMacSecKeyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateMacSecKeyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListVirtualInterfaceTestHistoryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVirtualInterfaceTestHistoryCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1ListVirtualInterfaceTestHistoryCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListVirtualInterfaceTestHistoryResponse(data, context);
  const response: ListVirtualInterfaceTestHistoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListVirtualInterfaceTestHistoryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVirtualInterfaceTestHistoryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartBgpFailoverTestCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartBgpFailoverTestCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1StartBgpFailoverTestCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartBgpFailoverTestResponse(data, context);
  const response: StartBgpFailoverTestCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartBgpFailoverTestCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartBgpFailoverTestCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StopBgpFailoverTestCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopBgpFailoverTestCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1StopBgpFailoverTestCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopBgpFailoverTestResponse(data, context);
  const response: StopBgpFailoverTestCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StopBgpFailoverTestCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopBgpFailoverTestCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1TagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1TagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DuplicateTagKeysException":
    case "com.amazonaws.directconnect#DuplicateTagKeysException":
      response = {
        ...(await deserializeAws_json1_1DuplicateTagKeysExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TooManyTagsException":
    case "com.amazonaws.directconnect#TooManyTagsException":
      response = {
        ...(await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectionCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1UpdateConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Connection(data, context);
  const response: UpdateConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateDirectConnectGatewayAssociationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDirectConnectGatewayAssociationCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1UpdateDirectConnectGatewayAssociationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDirectConnectGatewayAssociationResult(data, context);
  const response: UpdateDirectConnectGatewayAssociationCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateDirectConnectGatewayAssociationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDirectConnectGatewayAssociationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateLagCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateLagCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1UpdateLagCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1Lag(data, context);
  const response: UpdateLagCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateLagCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateLagCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateVirtualInterfaceAttributesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVirtualInterfaceAttributesCommandOutput> => {
  if (output.statusCode >= 300) {
    return deserializeAws_json1_1UpdateVirtualInterfaceAttributesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1VirtualInterface(data, context);
  const response: UpdateVirtualInterfaceAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateVirtualInterfaceAttributesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVirtualInterfaceAttributesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DirectConnectClientException":
    case "com.amazonaws.directconnect#DirectConnectClientException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DirectConnectServerException":
    case "com.amazonaws.directconnect#DirectConnectServerException":
      response = {
        ...(await deserializeAws_json1_1DirectConnectServerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_json1_1DirectConnectClientExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectConnectClientException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectConnectClientException(body, context);
  const contents: DirectConnectClientException = {
    name: "DirectConnectClientException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1DirectConnectServerExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DirectConnectServerException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DirectConnectServerException(body, context);
  const contents: DirectConnectServerException = {
    name: "DirectConnectServerException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1DuplicateTagKeysExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DuplicateTagKeysException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1DuplicateTagKeysException(body, context);
  const contents: DuplicateTagKeysException = {
    name: "DuplicateTagKeysException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1TooManyTagsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTagsException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TooManyTagsException(body, context);
  const contents: TooManyTagsException = {
    name: "TooManyTagsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const serializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalRequest = (
  input: AcceptDirectConnectGatewayAssociationProposalRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.associatedGatewayOwnerAccount !== undefined &&
      input.associatedGatewayOwnerAccount !== null && {
        associatedGatewayOwnerAccount: input.associatedGatewayOwnerAccount,
      }),
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.overrideAllowedPrefixesToDirectConnectGateway !== undefined &&
      input.overrideAllowedPrefixesToDirectConnectGateway !== null && {
        overrideAllowedPrefixesToDirectConnectGateway: serializeAws_json1_1RouteFilterPrefixList(
          input.overrideAllowedPrefixesToDirectConnectGateway,
          context
        ),
      }),
    ...(input.proposalId !== undefined && input.proposalId !== null && { proposalId: input.proposalId }),
  };
};

const serializeAws_json1_1AllocateConnectionOnInterconnectRequest = (
  input: AllocateConnectionOnInterconnectRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.bandwidth !== undefined && input.bandwidth !== null && { bandwidth: input.bandwidth }),
    ...(input.connectionName !== undefined &&
      input.connectionName !== null && { connectionName: input.connectionName }),
    ...(input.interconnectId !== undefined &&
      input.interconnectId !== null && { interconnectId: input.interconnectId }),
    ...(input.ownerAccount !== undefined && input.ownerAccount !== null && { ownerAccount: input.ownerAccount }),
    ...(input.vlan !== undefined && input.vlan !== null && { vlan: input.vlan }),
  };
};

const serializeAws_json1_1AllocateHostedConnectionRequest = (
  input: AllocateHostedConnectionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.bandwidth !== undefined && input.bandwidth !== null && { bandwidth: input.bandwidth }),
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.connectionName !== undefined &&
      input.connectionName !== null && { connectionName: input.connectionName }),
    ...(input.ownerAccount !== undefined && input.ownerAccount !== null && { ownerAccount: input.ownerAccount }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    ...(input.vlan !== undefined && input.vlan !== null && { vlan: input.vlan }),
  };
};

const serializeAws_json1_1AllocatePrivateVirtualInterfaceRequest = (
  input: AllocatePrivateVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.newPrivateVirtualInterfaceAllocation !== undefined &&
      input.newPrivateVirtualInterfaceAllocation !== null && {
        newPrivateVirtualInterfaceAllocation: serializeAws_json1_1NewPrivateVirtualInterfaceAllocation(
          input.newPrivateVirtualInterfaceAllocation,
          context
        ),
      }),
    ...(input.ownerAccount !== undefined && input.ownerAccount !== null && { ownerAccount: input.ownerAccount }),
  };
};

const serializeAws_json1_1AllocatePublicVirtualInterfaceRequest = (
  input: AllocatePublicVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.newPublicVirtualInterfaceAllocation !== undefined &&
      input.newPublicVirtualInterfaceAllocation !== null && {
        newPublicVirtualInterfaceAllocation: serializeAws_json1_1NewPublicVirtualInterfaceAllocation(
          input.newPublicVirtualInterfaceAllocation,
          context
        ),
      }),
    ...(input.ownerAccount !== undefined && input.ownerAccount !== null && { ownerAccount: input.ownerAccount }),
  };
};

const serializeAws_json1_1AllocateTransitVirtualInterfaceRequest = (
  input: AllocateTransitVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.newTransitVirtualInterfaceAllocation !== undefined &&
      input.newTransitVirtualInterfaceAllocation !== null && {
        newTransitVirtualInterfaceAllocation: serializeAws_json1_1NewTransitVirtualInterfaceAllocation(
          input.newTransitVirtualInterfaceAllocation,
          context
        ),
      }),
    ...(input.ownerAccount !== undefined && input.ownerAccount !== null && { ownerAccount: input.ownerAccount }),
  };
};

const serializeAws_json1_1AssociateConnectionWithLagRequest = (
  input: AssociateConnectionWithLagRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.lagId !== undefined && input.lagId !== null && { lagId: input.lagId }),
  };
};

const serializeAws_json1_1AssociateHostedConnectionRequest = (
  input: AssociateHostedConnectionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.parentConnectionId !== undefined &&
      input.parentConnectionId !== null && { parentConnectionId: input.parentConnectionId }),
  };
};

const serializeAws_json1_1AssociateMacSecKeyRequest = (
  input: AssociateMacSecKeyRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.cak !== undefined && input.cak !== null && { cak: input.cak }),
    ...(input.ckn !== undefined && input.ckn !== null && { ckn: input.ckn }),
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.secretARN !== undefined && input.secretARN !== null && { secretARN: input.secretARN }),
  };
};

const serializeAws_json1_1AssociateVirtualInterfaceRequest = (
  input: AssociateVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1BGPPeerIdList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_json1_1ConfirmConnectionRequest = (
  input: ConfirmConnectionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
  };
};

const serializeAws_json1_1ConfirmPrivateVirtualInterfaceRequest = (
  input: ConfirmPrivateVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.virtualGatewayId !== undefined &&
      input.virtualGatewayId !== null && { virtualGatewayId: input.virtualGatewayId }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1ConfirmPublicVirtualInterfaceRequest = (
  input: ConfirmPublicVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1ConfirmTransitVirtualInterfaceRequest = (
  input: ConfirmTransitVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1CreateBGPPeerRequest = (input: CreateBGPPeerRequest, context: __SerdeContext): any => {
  return {
    ...(input.newBGPPeer !== undefined &&
      input.newBGPPeer !== null && { newBGPPeer: serializeAws_json1_1NewBGPPeer(input.newBGPPeer, context) }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1CreateConnectionRequest = (input: CreateConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.bandwidth !== undefined && input.bandwidth !== null && { bandwidth: input.bandwidth }),
    ...(input.connectionName !== undefined &&
      input.connectionName !== null && { connectionName: input.connectionName }),
    ...(input.lagId !== undefined && input.lagId !== null && { lagId: input.lagId }),
    ...(input.location !== undefined && input.location !== null && { location: input.location }),
    ...(input.providerName !== undefined && input.providerName !== null && { providerName: input.providerName }),
    ...(input.requestMACSec !== undefined && input.requestMACSec !== null && { requestMACSec: input.requestMACSec }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
  };
};

const serializeAws_json1_1CreateDirectConnectGatewayAssociationProposalRequest = (
  input: CreateDirectConnectGatewayAssociationProposalRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.addAllowedPrefixesToDirectConnectGateway !== undefined &&
      input.addAllowedPrefixesToDirectConnectGateway !== null && {
        addAllowedPrefixesToDirectConnectGateway: serializeAws_json1_1RouteFilterPrefixList(
          input.addAllowedPrefixesToDirectConnectGateway,
          context
        ),
      }),
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.directConnectGatewayOwnerAccount !== undefined &&
      input.directConnectGatewayOwnerAccount !== null && {
        directConnectGatewayOwnerAccount: input.directConnectGatewayOwnerAccount,
      }),
    ...(input.gatewayId !== undefined && input.gatewayId !== null && { gatewayId: input.gatewayId }),
    ...(input.removeAllowedPrefixesToDirectConnectGateway !== undefined &&
      input.removeAllowedPrefixesToDirectConnectGateway !== null && {
        removeAllowedPrefixesToDirectConnectGateway: serializeAws_json1_1RouteFilterPrefixList(
          input.removeAllowedPrefixesToDirectConnectGateway,
          context
        ),
      }),
  };
};

const serializeAws_json1_1CreateDirectConnectGatewayAssociationRequest = (
  input: CreateDirectConnectGatewayAssociationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.addAllowedPrefixesToDirectConnectGateway !== undefined &&
      input.addAllowedPrefixesToDirectConnectGateway !== null && {
        addAllowedPrefixesToDirectConnectGateway: serializeAws_json1_1RouteFilterPrefixList(
          input.addAllowedPrefixesToDirectConnectGateway,
          context
        ),
      }),
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.gatewayId !== undefined && input.gatewayId !== null && { gatewayId: input.gatewayId }),
    ...(input.virtualGatewayId !== undefined &&
      input.virtualGatewayId !== null && { virtualGatewayId: input.virtualGatewayId }),
  };
};

const serializeAws_json1_1CreateDirectConnectGatewayRequest = (
  input: CreateDirectConnectGatewayRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.amazonSideAsn !== undefined && input.amazonSideAsn !== null && { amazonSideAsn: input.amazonSideAsn }),
    ...(input.directConnectGatewayName !== undefined &&
      input.directConnectGatewayName !== null && { directConnectGatewayName: input.directConnectGatewayName }),
  };
};

const serializeAws_json1_1CreateInterconnectRequest = (
  input: CreateInterconnectRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.bandwidth !== undefined && input.bandwidth !== null && { bandwidth: input.bandwidth }),
    ...(input.interconnectName !== undefined &&
      input.interconnectName !== null && { interconnectName: input.interconnectName }),
    ...(input.lagId !== undefined && input.lagId !== null && { lagId: input.lagId }),
    ...(input.location !== undefined && input.location !== null && { location: input.location }),
    ...(input.providerName !== undefined && input.providerName !== null && { providerName: input.providerName }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
  };
};

const serializeAws_json1_1CreateLagRequest = (input: CreateLagRequest, context: __SerdeContext): any => {
  return {
    ...(input.childConnectionTags !== undefined &&
      input.childConnectionTags !== null && {
        childConnectionTags: serializeAws_json1_1TagList(input.childConnectionTags, context),
      }),
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.connectionsBandwidth !== undefined &&
      input.connectionsBandwidth !== null && { connectionsBandwidth: input.connectionsBandwidth }),
    ...(input.lagName !== undefined && input.lagName !== null && { lagName: input.lagName }),
    ...(input.location !== undefined && input.location !== null && { location: input.location }),
    ...(input.numberOfConnections !== undefined &&
      input.numberOfConnections !== null && { numberOfConnections: input.numberOfConnections }),
    ...(input.providerName !== undefined && input.providerName !== null && { providerName: input.providerName }),
    ...(input.requestMACSec !== undefined && input.requestMACSec !== null && { requestMACSec: input.requestMACSec }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
  };
};

const serializeAws_json1_1CreatePrivateVirtualInterfaceRequest = (
  input: CreatePrivateVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.newPrivateVirtualInterface !== undefined &&
      input.newPrivateVirtualInterface !== null && {
        newPrivateVirtualInterface: serializeAws_json1_1NewPrivateVirtualInterface(
          input.newPrivateVirtualInterface,
          context
        ),
      }),
  };
};

const serializeAws_json1_1CreatePublicVirtualInterfaceRequest = (
  input: CreatePublicVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.newPublicVirtualInterface !== undefined &&
      input.newPublicVirtualInterface !== null && {
        newPublicVirtualInterface: serializeAws_json1_1NewPublicVirtualInterface(
          input.newPublicVirtualInterface,
          context
        ),
      }),
  };
};

const serializeAws_json1_1CreateTransitVirtualInterfaceRequest = (
  input: CreateTransitVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.newTransitVirtualInterface !== undefined &&
      input.newTransitVirtualInterface !== null && {
        newTransitVirtualInterface: serializeAws_json1_1NewTransitVirtualInterface(
          input.newTransitVirtualInterface,
          context
        ),
      }),
  };
};

const serializeAws_json1_1DeleteBGPPeerRequest = (input: DeleteBGPPeerRequest, context: __SerdeContext): any => {
  return {
    ...(input.asn !== undefined && input.asn !== null && { asn: input.asn }),
    ...(input.bgpPeerId !== undefined && input.bgpPeerId !== null && { bgpPeerId: input.bgpPeerId }),
    ...(input.customerAddress !== undefined &&
      input.customerAddress !== null && { customerAddress: input.customerAddress }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1DeleteConnectionRequest = (input: DeleteConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
  };
};

const serializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalRequest = (
  input: DeleteDirectConnectGatewayAssociationProposalRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.proposalId !== undefined && input.proposalId !== null && { proposalId: input.proposalId }),
  };
};

const serializeAws_json1_1DeleteDirectConnectGatewayAssociationRequest = (
  input: DeleteDirectConnectGatewayAssociationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.associationId !== undefined && input.associationId !== null && { associationId: input.associationId }),
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.virtualGatewayId !== undefined &&
      input.virtualGatewayId !== null && { virtualGatewayId: input.virtualGatewayId }),
  };
};

const serializeAws_json1_1DeleteDirectConnectGatewayRequest = (
  input: DeleteDirectConnectGatewayRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
  };
};

const serializeAws_json1_1DeleteInterconnectRequest = (
  input: DeleteInterconnectRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.interconnectId !== undefined &&
      input.interconnectId !== null && { interconnectId: input.interconnectId }),
  };
};

const serializeAws_json1_1DeleteLagRequest = (input: DeleteLagRequest, context: __SerdeContext): any => {
  return {
    ...(input.lagId !== undefined && input.lagId !== null && { lagId: input.lagId }),
  };
};

const serializeAws_json1_1DeleteVirtualInterfaceRequest = (
  input: DeleteVirtualInterfaceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1DescribeConnectionLoaRequest = (
  input: DescribeConnectionLoaRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.loaContentType !== undefined &&
      input.loaContentType !== null && { loaContentType: input.loaContentType }),
    ...(input.providerName !== undefined && input.providerName !== null && { providerName: input.providerName }),
  };
};

const serializeAws_json1_1DescribeConnectionsOnInterconnectRequest = (
  input: DescribeConnectionsOnInterconnectRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.interconnectId !== undefined &&
      input.interconnectId !== null && { interconnectId: input.interconnectId }),
  };
};

const serializeAws_json1_1DescribeConnectionsRequest = (
  input: DescribeConnectionsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
  };
};

const serializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsRequest = (
  input: DescribeDirectConnectGatewayAssociationProposalsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.associatedGatewayId !== undefined &&
      input.associatedGatewayId !== null && { associatedGatewayId: input.associatedGatewayId }),
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
    ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
    ...(input.proposalId !== undefined && input.proposalId !== null && { proposalId: input.proposalId }),
  };
};

const serializeAws_json1_1DescribeDirectConnectGatewayAssociationsRequest = (
  input: DescribeDirectConnectGatewayAssociationsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.associatedGatewayId !== undefined &&
      input.associatedGatewayId !== null && { associatedGatewayId: input.associatedGatewayId }),
    ...(input.associationId !== undefined && input.associationId !== null && { associationId: input.associationId }),
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
    ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
    ...(input.virtualGatewayId !== undefined &&
      input.virtualGatewayId !== null && { virtualGatewayId: input.virtualGatewayId }),
  };
};

const serializeAws_json1_1DescribeDirectConnectGatewayAttachmentsRequest = (
  input: DescribeDirectConnectGatewayAttachmentsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
    ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1DescribeDirectConnectGatewaysRequest = (
  input: DescribeDirectConnectGatewaysRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
    ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
  };
};

const serializeAws_json1_1DescribeHostedConnectionsRequest = (
  input: DescribeHostedConnectionsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
  };
};

const serializeAws_json1_1DescribeInterconnectLoaRequest = (
  input: DescribeInterconnectLoaRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.interconnectId !== undefined &&
      input.interconnectId !== null && { interconnectId: input.interconnectId }),
    ...(input.loaContentType !== undefined &&
      input.loaContentType !== null && { loaContentType: input.loaContentType }),
    ...(input.providerName !== undefined && input.providerName !== null && { providerName: input.providerName }),
  };
};

const serializeAws_json1_1DescribeInterconnectsRequest = (
  input: DescribeInterconnectsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.interconnectId !== undefined &&
      input.interconnectId !== null && { interconnectId: input.interconnectId }),
  };
};

const serializeAws_json1_1DescribeLagsRequest = (input: DescribeLagsRequest, context: __SerdeContext): any => {
  return {
    ...(input.lagId !== undefined && input.lagId !== null && { lagId: input.lagId }),
  };
};

const serializeAws_json1_1DescribeLoaRequest = (input: DescribeLoaRequest, context: __SerdeContext): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.loaContentType !== undefined &&
      input.loaContentType !== null && { loaContentType: input.loaContentType }),
    ...(input.providerName !== undefined && input.providerName !== null && { providerName: input.providerName }),
  };
};

const serializeAws_json1_1DescribeTagsRequest = (input: DescribeTagsRequest, context: __SerdeContext): any => {
  return {
    ...(input.resourceArns !== undefined &&
      input.resourceArns !== null && {
        resourceArns: serializeAws_json1_1ResourceArnList(input.resourceArns, context),
      }),
  };
};

const serializeAws_json1_1DescribeVirtualInterfacesRequest = (
  input: DescribeVirtualInterfacesRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1DisassociateConnectionFromLagRequest = (
  input: DisassociateConnectionFromLagRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.lagId !== undefined && input.lagId !== null && { lagId: input.lagId }),
  };
};

const serializeAws_json1_1DisassociateMacSecKeyRequest = (
  input: DisassociateMacSecKeyRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.secretARN !== undefined && input.secretARN !== null && { secretARN: input.secretARN }),
  };
};

const serializeAws_json1_1ListVirtualInterfaceTestHistoryRequest = (
  input: ListVirtualInterfaceTestHistoryRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.bgpPeers !== undefined &&
      input.bgpPeers !== null && { bgpPeers: serializeAws_json1_1BGPPeerIdList(input.bgpPeers, context) }),
    ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
    ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
    ...(input.status !== undefined && input.status !== null && { status: input.status }),
    ...(input.testId !== undefined && input.testId !== null && { testId: input.testId }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1NewBGPPeer = (input: NewBGPPeer, context: __SerdeContext): any => {
  return {
    ...(input.addressFamily !== undefined && input.addressFamily !== null && { addressFamily: input.addressFamily }),
    ...(input.amazonAddress !== undefined && input.amazonAddress !== null && { amazonAddress: input.amazonAddress }),
    ...(input.asn !== undefined && input.asn !== null && { asn: input.asn }),
    ...(input.authKey !== undefined && input.authKey !== null && { authKey: input.authKey }),
    ...(input.customerAddress !== undefined &&
      input.customerAddress !== null && { customerAddress: input.customerAddress }),
  };
};

const serializeAws_json1_1NewPrivateVirtualInterface = (
  input: NewPrivateVirtualInterface,
  context: __SerdeContext
): any => {
  return {
    ...(input.addressFamily !== undefined && input.addressFamily !== null && { addressFamily: input.addressFamily }),
    ...(input.amazonAddress !== undefined && input.amazonAddress !== null && { amazonAddress: input.amazonAddress }),
    ...(input.asn !== undefined && input.asn !== null && { asn: input.asn }),
    ...(input.authKey !== undefined && input.authKey !== null && { authKey: input.authKey }),
    ...(input.customerAddress !== undefined &&
      input.customerAddress !== null && { customerAddress: input.customerAddress }),
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.mtu !== undefined && input.mtu !== null && { mtu: input.mtu }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    ...(input.virtualGatewayId !== undefined &&
      input.virtualGatewayId !== null && { virtualGatewayId: input.virtualGatewayId }),
    ...(input.virtualInterfaceName !== undefined &&
      input.virtualInterfaceName !== null && { virtualInterfaceName: input.virtualInterfaceName }),
    ...(input.vlan !== undefined && input.vlan !== null && { vlan: input.vlan }),
  };
};

const serializeAws_json1_1NewPrivateVirtualInterfaceAllocation = (
  input: NewPrivateVirtualInterfaceAllocation,
  context: __SerdeContext
): any => {
  return {
    ...(input.addressFamily !== undefined && input.addressFamily !== null && { addressFamily: input.addressFamily }),
    ...(input.amazonAddress !== undefined && input.amazonAddress !== null && { amazonAddress: input.amazonAddress }),
    ...(input.asn !== undefined && input.asn !== null && { asn: input.asn }),
    ...(input.authKey !== undefined && input.authKey !== null && { authKey: input.authKey }),
    ...(input.customerAddress !== undefined &&
      input.customerAddress !== null && { customerAddress: input.customerAddress }),
    ...(input.mtu !== undefined && input.mtu !== null && { mtu: input.mtu }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    ...(input.virtualInterfaceName !== undefined &&
      input.virtualInterfaceName !== null && { virtualInterfaceName: input.virtualInterfaceName }),
    ...(input.vlan !== undefined && input.vlan !== null && { vlan: input.vlan }),
  };
};

const serializeAws_json1_1NewPublicVirtualInterface = (
  input: NewPublicVirtualInterface,
  context: __SerdeContext
): any => {
  return {
    ...(input.addressFamily !== undefined && input.addressFamily !== null && { addressFamily: input.addressFamily }),
    ...(input.amazonAddress !== undefined && input.amazonAddress !== null && { amazonAddress: input.amazonAddress }),
    ...(input.asn !== undefined && input.asn !== null && { asn: input.asn }),
    ...(input.authKey !== undefined && input.authKey !== null && { authKey: input.authKey }),
    ...(input.customerAddress !== undefined &&
      input.customerAddress !== null && { customerAddress: input.customerAddress }),
    ...(input.routeFilterPrefixes !== undefined &&
      input.routeFilterPrefixes !== null && {
        routeFilterPrefixes: serializeAws_json1_1RouteFilterPrefixList(input.routeFilterPrefixes, context),
      }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    ...(input.virtualInterfaceName !== undefined &&
      input.virtualInterfaceName !== null && { virtualInterfaceName: input.virtualInterfaceName }),
    ...(input.vlan !== undefined && input.vlan !== null && { vlan: input.vlan }),
  };
};

const serializeAws_json1_1NewPublicVirtualInterfaceAllocation = (
  input: NewPublicVirtualInterfaceAllocation,
  context: __SerdeContext
): any => {
  return {
    ...(input.addressFamily !== undefined && input.addressFamily !== null && { addressFamily: input.addressFamily }),
    ...(input.amazonAddress !== undefined && input.amazonAddress !== null && { amazonAddress: input.amazonAddress }),
    ...(input.asn !== undefined && input.asn !== null && { asn: input.asn }),
    ...(input.authKey !== undefined && input.authKey !== null && { authKey: input.authKey }),
    ...(input.customerAddress !== undefined &&
      input.customerAddress !== null && { customerAddress: input.customerAddress }),
    ...(input.routeFilterPrefixes !== undefined &&
      input.routeFilterPrefixes !== null && {
        routeFilterPrefixes: serializeAws_json1_1RouteFilterPrefixList(input.routeFilterPrefixes, context),
      }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    ...(input.virtualInterfaceName !== undefined &&
      input.virtualInterfaceName !== null && { virtualInterfaceName: input.virtualInterfaceName }),
    ...(input.vlan !== undefined && input.vlan !== null && { vlan: input.vlan }),
  };
};

const serializeAws_json1_1NewTransitVirtualInterface = (
  input: NewTransitVirtualInterface,
  context: __SerdeContext
): any => {
  return {
    ...(input.addressFamily !== undefined && input.addressFamily !== null && { addressFamily: input.addressFamily }),
    ...(input.amazonAddress !== undefined && input.amazonAddress !== null && { amazonAddress: input.amazonAddress }),
    ...(input.asn !== undefined && input.asn !== null && { asn: input.asn }),
    ...(input.authKey !== undefined && input.authKey !== null && { authKey: input.authKey }),
    ...(input.customerAddress !== undefined &&
      input.customerAddress !== null && { customerAddress: input.customerAddress }),
    ...(input.directConnectGatewayId !== undefined &&
      input.directConnectGatewayId !== null && { directConnectGatewayId: input.directConnectGatewayId }),
    ...(input.mtu !== undefined && input.mtu !== null && { mtu: input.mtu }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    ...(input.virtualInterfaceName !== undefined &&
      input.virtualInterfaceName !== null && { virtualInterfaceName: input.virtualInterfaceName }),
    ...(input.vlan !== undefined && input.vlan !== null && { vlan: input.vlan }),
  };
};

const serializeAws_json1_1NewTransitVirtualInterfaceAllocation = (
  input: NewTransitVirtualInterfaceAllocation,
  context: __SerdeContext
): any => {
  return {
    ...(input.addressFamily !== undefined && input.addressFamily !== null && { addressFamily: input.addressFamily }),
    ...(input.amazonAddress !== undefined && input.amazonAddress !== null && { amazonAddress: input.amazonAddress }),
    ...(input.asn !== undefined && input.asn !== null && { asn: input.asn }),
    ...(input.authKey !== undefined && input.authKey !== null && { authKey: input.authKey }),
    ...(input.customerAddress !== undefined &&
      input.customerAddress !== null && { customerAddress: input.customerAddress }),
    ...(input.mtu !== undefined && input.mtu !== null && { mtu: input.mtu }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    ...(input.virtualInterfaceName !== undefined &&
      input.virtualInterfaceName !== null && { virtualInterfaceName: input.virtualInterfaceName }),
    ...(input.vlan !== undefined && input.vlan !== null && { vlan: input.vlan }),
  };
};

const serializeAws_json1_1ResourceArnList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_json1_1RouteFilterPrefix = (input: RouteFilterPrefix, context: __SerdeContext): any => {
  return {
    ...(input.cidr !== undefined && input.cidr !== null && { cidr: input.cidr }),
  };
};

const serializeAws_json1_1RouteFilterPrefixList = (input: RouteFilterPrefix[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_json1_1RouteFilterPrefix(entry, context);
    });
};

const serializeAws_json1_1StartBgpFailoverTestRequest = (
  input: StartBgpFailoverTestRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.bgpPeers !== undefined &&
      input.bgpPeers !== null && { bgpPeers: serializeAws_json1_1BGPPeerIdList(input.bgpPeers, context) }),
    ...(input.testDurationInMinutes !== undefined &&
      input.testDurationInMinutes !== null && { testDurationInMinutes: input.testDurationInMinutes }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1StopBgpFailoverTestRequest = (
  input: StopBgpFailoverTestRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  return {
    ...(input.key !== undefined && input.key !== null && { key: input.key }),
    ...(input.value !== undefined && input.value !== null && { value: input.value }),
  };
};

const serializeAws_json1_1TagKeyList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_json1_1TagList = (input: Tag[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_json1_1Tag(entry, context);
    });
};

const serializeAws_json1_1TagResourceRequest = (input: TagResourceRequest, context: __SerdeContext): any => {
  return {
    ...(input.resourceArn !== undefined && input.resourceArn !== null && { resourceArn: input.resourceArn }),
    ...(input.tags !== undefined && input.tags !== null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
  };
};

const serializeAws_json1_1UntagResourceRequest = (input: UntagResourceRequest, context: __SerdeContext): any => {
  return {
    ...(input.resourceArn !== undefined && input.resourceArn !== null && { resourceArn: input.resourceArn }),
    ...(input.tagKeys !== undefined &&
      input.tagKeys !== null && { tagKeys: serializeAws_json1_1TagKeyList(input.tagKeys, context) }),
  };
};

const serializeAws_json1_1UpdateConnectionRequest = (input: UpdateConnectionRequest, context: __SerdeContext): any => {
  return {
    ...(input.connectionId !== undefined && input.connectionId !== null && { connectionId: input.connectionId }),
    ...(input.connectionName !== undefined &&
      input.connectionName !== null && { connectionName: input.connectionName }),
    ...(input.encryptionMode !== undefined &&
      input.encryptionMode !== null && { encryptionMode: input.encryptionMode }),
  };
};

const serializeAws_json1_1UpdateDirectConnectGatewayAssociationRequest = (
  input: UpdateDirectConnectGatewayAssociationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.addAllowedPrefixesToDirectConnectGateway !== undefined &&
      input.addAllowedPrefixesToDirectConnectGateway !== null && {
        addAllowedPrefixesToDirectConnectGateway: serializeAws_json1_1RouteFilterPrefixList(
          input.addAllowedPrefixesToDirectConnectGateway,
          context
        ),
      }),
    ...(input.associationId !== undefined && input.associationId !== null && { associationId: input.associationId }),
    ...(input.removeAllowedPrefixesToDirectConnectGateway !== undefined &&
      input.removeAllowedPrefixesToDirectConnectGateway !== null && {
        removeAllowedPrefixesToDirectConnectGateway: serializeAws_json1_1RouteFilterPrefixList(
          input.removeAllowedPrefixesToDirectConnectGateway,
          context
        ),
      }),
  };
};

const serializeAws_json1_1UpdateLagRequest = (input: UpdateLagRequest, context: __SerdeContext): any => {
  return {
    ...(input.encryptionMode !== undefined &&
      input.encryptionMode !== null && { encryptionMode: input.encryptionMode }),
    ...(input.lagId !== undefined && input.lagId !== null && { lagId: input.lagId }),
    ...(input.lagName !== undefined && input.lagName !== null && { lagName: input.lagName }),
    ...(input.minimumLinks !== undefined && input.minimumLinks !== null && { minimumLinks: input.minimumLinks }),
  };
};

const serializeAws_json1_1UpdateVirtualInterfaceAttributesRequest = (
  input: UpdateVirtualInterfaceAttributesRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.mtu !== undefined && input.mtu !== null && { mtu: input.mtu }),
    ...(input.virtualInterfaceId !== undefined &&
      input.virtualInterfaceId !== null && { virtualInterfaceId: input.virtualInterfaceId }),
  };
};

const deserializeAws_json1_1AcceptDirectConnectGatewayAssociationProposalResult = (
  output: any,
  context: __SerdeContext
): AcceptDirectConnectGatewayAssociationProposalResult => {
  return {
    directConnectGatewayAssociation:
      output.directConnectGatewayAssociation !== undefined && output.directConnectGatewayAssociation !== null
        ? deserializeAws_json1_1DirectConnectGatewayAssociation(output.directConnectGatewayAssociation, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1AllocateTransitVirtualInterfaceResult = (
  output: any,
  context: __SerdeContext
): AllocateTransitVirtualInterfaceResult => {
  return {
    virtualInterface:
      output.virtualInterface !== undefined && output.virtualInterface !== null
        ? deserializeAws_json1_1VirtualInterface(output.virtualInterface, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1AssociatedGateway = (output: any, context: __SerdeContext): AssociatedGateway => {
  return {
    id: __expectString(output.id),
    ownerAccount: __expectString(output.ownerAccount),
    region: __expectString(output.region),
    type: __expectString(output.type),
  } as any;
};

const deserializeAws_json1_1AssociateMacSecKeyResponse = (
  output: any,
  context: __SerdeContext
): AssociateMacSecKeyResponse => {
  return {
    connectionId: __expectString(output.connectionId),
    macSecKeys:
      output.macSecKeys !== undefined && output.macSecKeys !== null
        ? deserializeAws_json1_1MacSecKeyList(output.macSecKeys, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1AvailableMacSecPortSpeeds = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_json1_1AvailablePortSpeeds = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_json1_1BGPPeer = (output: any, context: __SerdeContext): BGPPeer => {
  return {
    addressFamily: __expectString(output.addressFamily),
    amazonAddress: __expectString(output.amazonAddress),
    asn: __expectInt32(output.asn),
    authKey: __expectString(output.authKey),
    awsDeviceV2: __expectString(output.awsDeviceV2),
    awsLogicalDeviceId: __expectString(output.awsLogicalDeviceId),
    bgpPeerId: __expectString(output.bgpPeerId),
    bgpPeerState: __expectString(output.bgpPeerState),
    bgpStatus: __expectString(output.bgpStatus),
    customerAddress: __expectString(output.customerAddress),
  } as any;
};

const deserializeAws_json1_1BGPPeerIdList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_json1_1BGPPeerList = (output: any, context: __SerdeContext): BGPPeer[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1BGPPeer(entry, context);
    });
};

const deserializeAws_json1_1ConfirmConnectionResponse = (
  output: any,
  context: __SerdeContext
): ConfirmConnectionResponse => {
  return {
    connectionState: __expectString(output.connectionState),
  } as any;
};

const deserializeAws_json1_1ConfirmPrivateVirtualInterfaceResponse = (
  output: any,
  context: __SerdeContext
): ConfirmPrivateVirtualInterfaceResponse => {
  return {
    virtualInterfaceState: __expectString(output.virtualInterfaceState),
  } as any;
};

const deserializeAws_json1_1ConfirmPublicVirtualInterfaceResponse = (
  output: any,
  context: __SerdeContext
): ConfirmPublicVirtualInterfaceResponse => {
  return {
    virtualInterfaceState: __expectString(output.virtualInterfaceState),
  } as any;
};

const deserializeAws_json1_1ConfirmTransitVirtualInterfaceResponse = (
  output: any,
  context: __SerdeContext
): ConfirmTransitVirtualInterfaceResponse => {
  return {
    virtualInterfaceState: __expectString(output.virtualInterfaceState),
  } as any;
};

const deserializeAws_json1_1Connection = (output: any, context: __SerdeContext): Connection => {
  return {
    awsDevice: __expectString(output.awsDevice),
    awsDeviceV2: __expectString(output.awsDeviceV2),
    awsLogicalDeviceId: __expectString(output.awsLogicalDeviceId),
    bandwidth: __expectString(output.bandwidth),
    connectionId: __expectString(output.connectionId),
    connectionName: __expectString(output.connectionName),
    connectionState: __expectString(output.connectionState),
    encryptionMode: __expectString(output.encryptionMode),
    hasLogicalRedundancy: __expectString(output.hasLogicalRedundancy),
    jumboFrameCapable: __expectBoolean(output.jumboFrameCapable),
    lagId: __expectString(output.lagId),
    loaIssueTime:
      output.loaIssueTime !== undefined && output.loaIssueTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.loaIssueTime)))
        : undefined,
    location: __expectString(output.location),
    macSecCapable: __expectBoolean(output.macSecCapable),
    macSecKeys:
      output.macSecKeys !== undefined && output.macSecKeys !== null
        ? deserializeAws_json1_1MacSecKeyList(output.macSecKeys, context)
        : undefined,
    ownerAccount: __expectString(output.ownerAccount),
    partnerName: __expectString(output.partnerName),
    portEncryptionStatus: __expectString(output.portEncryptionStatus),
    providerName: __expectString(output.providerName),
    region: __expectString(output.region),
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_json1_1TagList(output.tags, context)
        : undefined,
    vlan: __expectInt32(output.vlan),
  } as any;
};

const deserializeAws_json1_1ConnectionList = (output: any, context: __SerdeContext): Connection[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1Connection(entry, context);
    });
};

const deserializeAws_json1_1Connections = (output: any, context: __SerdeContext): Connections => {
  return {
    connections:
      output.connections !== undefined && output.connections !== null
        ? deserializeAws_json1_1ConnectionList(output.connections, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateBGPPeerResponse = (output: any, context: __SerdeContext): CreateBGPPeerResponse => {
  return {
    virtualInterface:
      output.virtualInterface !== undefined && output.virtualInterface !== null
        ? deserializeAws_json1_1VirtualInterface(output.virtualInterface, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateDirectConnectGatewayAssociationProposalResult = (
  output: any,
  context: __SerdeContext
): CreateDirectConnectGatewayAssociationProposalResult => {
  return {
    directConnectGatewayAssociationProposal:
      output.directConnectGatewayAssociationProposal !== undefined &&
      output.directConnectGatewayAssociationProposal !== null
        ? deserializeAws_json1_1DirectConnectGatewayAssociationProposal(
            output.directConnectGatewayAssociationProposal,
            context
          )
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateDirectConnectGatewayAssociationResult = (
  output: any,
  context: __SerdeContext
): CreateDirectConnectGatewayAssociationResult => {
  return {
    directConnectGatewayAssociation:
      output.directConnectGatewayAssociation !== undefined && output.directConnectGatewayAssociation !== null
        ? deserializeAws_json1_1DirectConnectGatewayAssociation(output.directConnectGatewayAssociation, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateDirectConnectGatewayResult = (
  output: any,
  context: __SerdeContext
): CreateDirectConnectGatewayResult => {
  return {
    directConnectGateway:
      output.directConnectGateway !== undefined && output.directConnectGateway !== null
        ? deserializeAws_json1_1DirectConnectGateway(output.directConnectGateway, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateTransitVirtualInterfaceResult = (
  output: any,
  context: __SerdeContext
): CreateTransitVirtualInterfaceResult => {
  return {
    virtualInterface:
      output.virtualInterface !== undefined && output.virtualInterface !== null
        ? deserializeAws_json1_1VirtualInterface(output.virtualInterface, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteBGPPeerResponse = (output: any, context: __SerdeContext): DeleteBGPPeerResponse => {
  return {
    virtualInterface:
      output.virtualInterface !== undefined && output.virtualInterface !== null
        ? deserializeAws_json1_1VirtualInterface(output.virtualInterface, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteDirectConnectGatewayAssociationProposalResult = (
  output: any,
  context: __SerdeContext
): DeleteDirectConnectGatewayAssociationProposalResult => {
  return {
    directConnectGatewayAssociationProposal:
      output.directConnectGatewayAssociationProposal !== undefined &&
      output.directConnectGatewayAssociationProposal !== null
        ? deserializeAws_json1_1DirectConnectGatewayAssociationProposal(
            output.directConnectGatewayAssociationProposal,
            context
          )
        : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteDirectConnectGatewayAssociationResult = (
  output: any,
  context: __SerdeContext
): DeleteDirectConnectGatewayAssociationResult => {
  return {
    directConnectGatewayAssociation:
      output.directConnectGatewayAssociation !== undefined && output.directConnectGatewayAssociation !== null
        ? deserializeAws_json1_1DirectConnectGatewayAssociation(output.directConnectGatewayAssociation, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteDirectConnectGatewayResult = (
  output: any,
  context: __SerdeContext
): DeleteDirectConnectGatewayResult => {
  return {
    directConnectGateway:
      output.directConnectGateway !== undefined && output.directConnectGateway !== null
        ? deserializeAws_json1_1DirectConnectGateway(output.directConnectGateway, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteInterconnectResponse = (
  output: any,
  context: __SerdeContext
): DeleteInterconnectResponse => {
  return {
    interconnectState: __expectString(output.interconnectState),
  } as any;
};

const deserializeAws_json1_1DeleteVirtualInterfaceResponse = (
  output: any,
  context: __SerdeContext
): DeleteVirtualInterfaceResponse => {
  return {
    virtualInterfaceState: __expectString(output.virtualInterfaceState),
  } as any;
};

const deserializeAws_json1_1DescribeConnectionLoaResponse = (
  output: any,
  context: __SerdeContext
): DescribeConnectionLoaResponse => {
  return {
    loa: output.loa !== undefined && output.loa !== null ? deserializeAws_json1_1Loa(output.loa, context) : undefined,
  } as any;
};

const deserializeAws_json1_1DescribeDirectConnectGatewayAssociationProposalsResult = (
  output: any,
  context: __SerdeContext
): DescribeDirectConnectGatewayAssociationProposalsResult => {
  return {
    directConnectGatewayAssociationProposals:
      output.directConnectGatewayAssociationProposals !== undefined &&
      output.directConnectGatewayAssociationProposals !== null
        ? deserializeAws_json1_1DirectConnectGatewayAssociationProposalList(
            output.directConnectGatewayAssociationProposals,
            context
          )
        : undefined,
    nextToken: __expectString(output.nextToken),
  } as any;
};

const deserializeAws_json1_1DescribeDirectConnectGatewayAssociationsResult = (
  output: any,
  context: __SerdeContext
): DescribeDirectConnectGatewayAssociationsResult => {
  return {
    directConnectGatewayAssociations:
      output.directConnectGatewayAssociations !== undefined && output.directConnectGatewayAssociations !== null
        ? deserializeAws_json1_1DirectConnectGatewayAssociationList(output.directConnectGatewayAssociations, context)
        : undefined,
    nextToken: __expectString(output.nextToken),
  } as any;
};

const deserializeAws_json1_1DescribeDirectConnectGatewayAttachmentsResult = (
  output: any,
  context: __SerdeContext
): DescribeDirectConnectGatewayAttachmentsResult => {
  return {
    directConnectGatewayAttachments:
      output.directConnectGatewayAttachments !== undefined && output.directConnectGatewayAttachments !== null
        ? deserializeAws_json1_1DirectConnectGatewayAttachmentList(output.directConnectGatewayAttachments, context)
        : undefined,
    nextToken: __expectString(output.nextToken),
  } as any;
};

const deserializeAws_json1_1DescribeDirectConnectGatewaysResult = (
  output: any,
  context: __SerdeContext
): DescribeDirectConnectGatewaysResult => {
  return {
    directConnectGateways:
      output.directConnectGateways !== undefined && output.directConnectGateways !== null
        ? deserializeAws_json1_1DirectConnectGatewayList(output.directConnectGateways, context)
        : undefined,
    nextToken: __expectString(output.nextToken),
  } as any;
};

const deserializeAws_json1_1DescribeInterconnectLoaResponse = (
  output: any,
  context: __SerdeContext
): DescribeInterconnectLoaResponse => {
  return {
    loa: output.loa !== undefined && output.loa !== null ? deserializeAws_json1_1Loa(output.loa, context) : undefined,
  } as any;
};

const deserializeAws_json1_1DescribeTagsResponse = (output: any, context: __SerdeContext): DescribeTagsResponse => {
  return {
    resourceTags:
      output.resourceTags !== undefined && output.resourceTags !== null
        ? deserializeAws_json1_1ResourceTagList(output.resourceTags, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DirectConnectClientException = (
  output: any,
  context: __SerdeContext
): DirectConnectClientException => {
  return {
    message: __expectString(output.message),
  } as any;
};

const deserializeAws_json1_1DirectConnectGateway = (output: any, context: __SerdeContext): DirectConnectGateway => {
  return {
    amazonSideAsn: __expectLong(output.amazonSideAsn),
    directConnectGatewayId: __expectString(output.directConnectGatewayId),
    directConnectGatewayName: __expectString(output.directConnectGatewayName),
    directConnectGatewayState: __expectString(output.directConnectGatewayState),
    ownerAccount: __expectString(output.ownerAccount),
    stateChangeError: __expectString(output.stateChangeError),
  } as any;
};

const deserializeAws_json1_1DirectConnectGatewayAssociation = (
  output: any,
  context: __SerdeContext
): DirectConnectGatewayAssociation => {
  return {
    allowedPrefixesToDirectConnectGateway:
      output.allowedPrefixesToDirectConnectGateway !== undefined &&
      output.allowedPrefixesToDirectConnectGateway !== null
        ? deserializeAws_json1_1RouteFilterPrefixList(output.allowedPrefixesToDirectConnectGateway, context)
        : undefined,
    associatedGateway:
      output.associatedGateway !== undefined && output.associatedGateway !== null
        ? deserializeAws_json1_1AssociatedGateway(output.associatedGateway, context)
        : undefined,
    associationId: __expectString(output.associationId),
    associationState: __expectString(output.associationState),
    directConnectGatewayId: __expectString(output.directConnectGatewayId),
    directConnectGatewayOwnerAccount: __expectString(output.directConnectGatewayOwnerAccount),
    stateChangeError: __expectString(output.stateChangeError),
    virtualGatewayId: __expectString(output.virtualGatewayId),
    virtualGatewayOwnerAccount: __expectString(output.virtualGatewayOwnerAccount),
    virtualGatewayRegion: __expectString(output.virtualGatewayRegion),
  } as any;
};

const deserializeAws_json1_1DirectConnectGatewayAssociationList = (
  output: any,
  context: __SerdeContext
): DirectConnectGatewayAssociation[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1DirectConnectGatewayAssociation(entry, context);
    });
};

const deserializeAws_json1_1DirectConnectGatewayAssociationProposal = (
  output: any,
  context: __SerdeContext
): DirectConnectGatewayAssociationProposal => {
  return {
    associatedGateway:
      output.associatedGateway !== undefined && output.associatedGateway !== null
        ? deserializeAws_json1_1AssociatedGateway(output.associatedGateway, context)
        : undefined,
    directConnectGatewayId: __expectString(output.directConnectGatewayId),
    directConnectGatewayOwnerAccount: __expectString(output.directConnectGatewayOwnerAccount),
    existingAllowedPrefixesToDirectConnectGateway:
      output.existingAllowedPrefixesToDirectConnectGateway !== undefined &&
      output.existingAllowedPrefixesToDirectConnectGateway !== null
        ? deserializeAws_json1_1RouteFilterPrefixList(output.existingAllowedPrefixesToDirectConnectGateway, context)
        : undefined,
    proposalId: __expectString(output.proposalId),
    proposalState: __expectString(output.proposalState),
    requestedAllowedPrefixesToDirectConnectGateway:
      output.requestedAllowedPrefixesToDirectConnectGateway !== undefined &&
      output.requestedAllowedPrefixesToDirectConnectGateway !== null
        ? deserializeAws_json1_1RouteFilterPrefixList(output.requestedAllowedPrefixesToDirectConnectGateway, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DirectConnectGatewayAssociationProposalList = (
  output: any,
  context: __SerdeContext
): DirectConnectGatewayAssociationProposal[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1DirectConnectGatewayAssociationProposal(entry, context);
    });
};

const deserializeAws_json1_1DirectConnectGatewayAttachment = (
  output: any,
  context: __SerdeContext
): DirectConnectGatewayAttachment => {
  return {
    attachmentState: __expectString(output.attachmentState),
    attachmentType: __expectString(output.attachmentType),
    directConnectGatewayId: __expectString(output.directConnectGatewayId),
    stateChangeError: __expectString(output.stateChangeError),
    virtualInterfaceId: __expectString(output.virtualInterfaceId),
    virtualInterfaceOwnerAccount: __expectString(output.virtualInterfaceOwnerAccount),
    virtualInterfaceRegion: __expectString(output.virtualInterfaceRegion),
  } as any;
};

const deserializeAws_json1_1DirectConnectGatewayAttachmentList = (
  output: any,
  context: __SerdeContext
): DirectConnectGatewayAttachment[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1DirectConnectGatewayAttachment(entry, context);
    });
};

const deserializeAws_json1_1DirectConnectGatewayList = (
  output: any,
  context: __SerdeContext
): DirectConnectGateway[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1DirectConnectGateway(entry, context);
    });
};

const deserializeAws_json1_1DirectConnectServerException = (
  output: any,
  context: __SerdeContext
): DirectConnectServerException => {
  return {
    message: __expectString(output.message),
  } as any;
};

const deserializeAws_json1_1DisassociateMacSecKeyResponse = (
  output: any,
  context: __SerdeContext
): DisassociateMacSecKeyResponse => {
  return {
    connectionId: __expectString(output.connectionId),
    macSecKeys:
      output.macSecKeys !== undefined && output.macSecKeys !== null
        ? deserializeAws_json1_1MacSecKeyList(output.macSecKeys, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DuplicateTagKeysException = (
  output: any,
  context: __SerdeContext
): DuplicateTagKeysException => {
  return {
    message: __expectString(output.message),
  } as any;
};

const deserializeAws_json1_1Interconnect = (output: any, context: __SerdeContext): Interconnect => {
  return {
    awsDevice: __expectString(output.awsDevice),
    awsDeviceV2: __expectString(output.awsDeviceV2),
    awsLogicalDeviceId: __expectString(output.awsLogicalDeviceId),
    bandwidth: __expectString(output.bandwidth),
    hasLogicalRedundancy: __expectString(output.hasLogicalRedundancy),
    interconnectId: __expectString(output.interconnectId),
    interconnectName: __expectString(output.interconnectName),
    interconnectState: __expectString(output.interconnectState),
    jumboFrameCapable: __expectBoolean(output.jumboFrameCapable),
    lagId: __expectString(output.lagId),
    loaIssueTime:
      output.loaIssueTime !== undefined && output.loaIssueTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.loaIssueTime)))
        : undefined,
    location: __expectString(output.location),
    providerName: __expectString(output.providerName),
    region: __expectString(output.region),
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_json1_1TagList(output.tags, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1InterconnectList = (output: any, context: __SerdeContext): Interconnect[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1Interconnect(entry, context);
    });
};

const deserializeAws_json1_1Interconnects = (output: any, context: __SerdeContext): Interconnects => {
  return {
    interconnects:
      output.interconnects !== undefined && output.interconnects !== null
        ? deserializeAws_json1_1InterconnectList(output.interconnects, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1Lag = (output: any, context: __SerdeContext): Lag => {
  return {
    allowsHostedConnections: __expectBoolean(output.allowsHostedConnections),
    awsDevice: __expectString(output.awsDevice),
    awsDeviceV2: __expectString(output.awsDeviceV2),
    awsLogicalDeviceId: __expectString(output.awsLogicalDeviceId),
    connections:
      output.connections !== undefined && output.connections !== null
        ? deserializeAws_json1_1ConnectionList(output.connections, context)
        : undefined,
    connectionsBandwidth: __expectString(output.connectionsBandwidth),
    encryptionMode: __expectString(output.encryptionMode),
    hasLogicalRedundancy: __expectString(output.hasLogicalRedundancy),
    jumboFrameCapable: __expectBoolean(output.jumboFrameCapable),
    lagId: __expectString(output.lagId),
    lagName: __expectString(output.lagName),
    lagState: __expectString(output.lagState),
    location: __expectString(output.location),
    macSecCapable: __expectBoolean(output.macSecCapable),
    macSecKeys:
      output.macSecKeys !== undefined && output.macSecKeys !== null
        ? deserializeAws_json1_1MacSecKeyList(output.macSecKeys, context)
        : undefined,
    minimumLinks: __expectInt32(output.minimumLinks),
    numberOfConnections: __expectInt32(output.numberOfConnections),
    ownerAccount: __expectString(output.ownerAccount),
    providerName: __expectString(output.providerName),
    region: __expectString(output.region),
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_json1_1TagList(output.tags, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1LagList = (output: any, context: __SerdeContext): Lag[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1Lag(entry, context);
    });
};

const deserializeAws_json1_1Lags = (output: any, context: __SerdeContext): Lags => {
  return {
    lags:
      output.lags !== undefined && output.lags !== null
        ? deserializeAws_json1_1LagList(output.lags, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListVirtualInterfaceTestHistoryResponse = (
  output: any,
  context: __SerdeContext
): ListVirtualInterfaceTestHistoryResponse => {
  return {
    nextToken: __expectString(output.nextToken),
    virtualInterfaceTestHistory:
      output.virtualInterfaceTestHistory !== undefined && output.virtualInterfaceTestHistory !== null
        ? deserializeAws_json1_1VirtualInterfaceTestHistoryList(output.virtualInterfaceTestHistory, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1Loa = (output: any, context: __SerdeContext): Loa => {
  return {
    loaContent:
      output.loaContent !== undefined && output.loaContent !== null
        ? context.base64Decoder(output.loaContent)
        : undefined,
    loaContentType: __expectString(output.loaContentType),
  } as any;
};

const deserializeAws_json1_1Location = (output: any, context: __SerdeContext): Location => {
  return {
    availableMacSecPortSpeeds:
      output.availableMacSecPortSpeeds !== undefined && output.availableMacSecPortSpeeds !== null
        ? deserializeAws_json1_1AvailableMacSecPortSpeeds(output.availableMacSecPortSpeeds, context)
        : undefined,
    availablePortSpeeds:
      output.availablePortSpeeds !== undefined && output.availablePortSpeeds !== null
        ? deserializeAws_json1_1AvailablePortSpeeds(output.availablePortSpeeds, context)
        : undefined,
    availableProviders:
      output.availableProviders !== undefined && output.availableProviders !== null
        ? deserializeAws_json1_1ProviderList(output.availableProviders, context)
        : undefined,
    locationCode: __expectString(output.locationCode),
    locationName: __expectString(output.locationName),
    region: __expectString(output.region),
  } as any;
};

const deserializeAws_json1_1LocationList = (output: any, context: __SerdeContext): Location[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1Location(entry, context);
    });
};

const deserializeAws_json1_1Locations = (output: any, context: __SerdeContext): Locations => {
  return {
    locations:
      output.locations !== undefined && output.locations !== null
        ? deserializeAws_json1_1LocationList(output.locations, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1MacSecKey = (output: any, context: __SerdeContext): MacSecKey => {
  return {
    ckn: __expectString(output.ckn),
    secretARN: __expectString(output.secretARN),
    startOn: __expectString(output.startOn),
    state: __expectString(output.state),
  } as any;
};

const deserializeAws_json1_1MacSecKeyList = (output: any, context: __SerdeContext): MacSecKey[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1MacSecKey(entry, context);
    });
};

const deserializeAws_json1_1ProviderList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_json1_1ResourceTag = (output: any, context: __SerdeContext): ResourceTag => {
  return {
    resourceArn: __expectString(output.resourceArn),
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_json1_1TagList(output.tags, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ResourceTagList = (output: any, context: __SerdeContext): ResourceTag[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1ResourceTag(entry, context);
    });
};

const deserializeAws_json1_1RouteFilterPrefix = (output: any, context: __SerdeContext): RouteFilterPrefix => {
  return {
    cidr: __expectString(output.cidr),
  } as any;
};

const deserializeAws_json1_1RouteFilterPrefixList = (output: any, context: __SerdeContext): RouteFilterPrefix[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1RouteFilterPrefix(entry, context);
    });
};

const deserializeAws_json1_1StartBgpFailoverTestResponse = (
  output: any,
  context: __SerdeContext
): StartBgpFailoverTestResponse => {
  return {
    virtualInterfaceTest:
      output.virtualInterfaceTest !== undefined && output.virtualInterfaceTest !== null
        ? deserializeAws_json1_1VirtualInterfaceTestHistory(output.virtualInterfaceTest, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1StopBgpFailoverTestResponse = (
  output: any,
  context: __SerdeContext
): StopBgpFailoverTestResponse => {
  return {
    virtualInterfaceTest:
      output.virtualInterfaceTest !== undefined && output.virtualInterfaceTest !== null
        ? deserializeAws_json1_1VirtualInterfaceTestHistory(output.virtualInterfaceTest, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1Tag = (output: any, context: __SerdeContext): Tag => {
  return {
    key: __expectString(output.key),
    value: __expectString(output.value),
  } as any;
};

const deserializeAws_json1_1TagList = (output: any, context: __SerdeContext): Tag[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1Tag(entry, context);
    });
};

const deserializeAws_json1_1TagResourceResponse = (output: any, context: __SerdeContext): TagResourceResponse => {
  return {} as any;
};

const deserializeAws_json1_1TooManyTagsException = (output: any, context: __SerdeContext): TooManyTagsException => {
  return {
    message: __expectString(output.message),
  } as any;
};

const deserializeAws_json1_1UntagResourceResponse = (output: any, context: __SerdeContext): UntagResourceResponse => {
  return {} as any;
};

const deserializeAws_json1_1UpdateDirectConnectGatewayAssociationResult = (
  output: any,
  context: __SerdeContext
): UpdateDirectConnectGatewayAssociationResult => {
  return {
    directConnectGatewayAssociation:
      output.directConnectGatewayAssociation !== undefined && output.directConnectGatewayAssociation !== null
        ? deserializeAws_json1_1DirectConnectGatewayAssociation(output.directConnectGatewayAssociation, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1VirtualGateway = (output: any, context: __SerdeContext): VirtualGateway => {
  return {
    virtualGatewayId: __expectString(output.virtualGatewayId),
    virtualGatewayState: __expectString(output.virtualGatewayState),
  } as any;
};

const deserializeAws_json1_1VirtualGatewayList = (output: any, context: __SerdeContext): VirtualGateway[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1VirtualGateway(entry, context);
    });
};

const deserializeAws_json1_1VirtualGateways = (output: any, context: __SerdeContext): VirtualGateways => {
  return {
    virtualGateways:
      output.virtualGateways !== undefined && output.virtualGateways !== null
        ? deserializeAws_json1_1VirtualGatewayList(output.virtualGateways, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1VirtualInterface = (output: any, context: __SerdeContext): VirtualInterface => {
  return {
    addressFamily: __expectString(output.addressFamily),
    amazonAddress: __expectString(output.amazonAddress),
    amazonSideAsn: __expectLong(output.amazonSideAsn),
    asn: __expectInt32(output.asn),
    authKey: __expectString(output.authKey),
    awsDeviceV2: __expectString(output.awsDeviceV2),
    awsLogicalDeviceId: __expectString(output.awsLogicalDeviceId),
    bgpPeers:
      output.bgpPeers !== undefined && output.bgpPeers !== null
        ? deserializeAws_json1_1BGPPeerList(output.bgpPeers, context)
        : undefined,
    connectionId: __expectString(output.connectionId),
    customerAddress: __expectString(output.customerAddress),
    customerRouterConfig: __expectString(output.customerRouterConfig),
    directConnectGatewayId: __expectString(output.directConnectGatewayId),
    jumboFrameCapable: __expectBoolean(output.jumboFrameCapable),
    location: __expectString(output.location),
    mtu: __expectInt32(output.mtu),
    ownerAccount: __expectString(output.ownerAccount),
    region: __expectString(output.region),
    routeFilterPrefixes:
      output.routeFilterPrefixes !== undefined && output.routeFilterPrefixes !== null
        ? deserializeAws_json1_1RouteFilterPrefixList(output.routeFilterPrefixes, context)
        : undefined,
    tags:
      output.tags !== undefined && output.tags !== null
        ? deserializeAws_json1_1TagList(output.tags, context)
        : undefined,
    virtualGatewayId: __expectString(output.virtualGatewayId),
    virtualInterfaceId: __expectString(output.virtualInterfaceId),
    virtualInterfaceName: __expectString(output.virtualInterfaceName),
    virtualInterfaceState: __expectString(output.virtualInterfaceState),
    virtualInterfaceType: __expectString(output.virtualInterfaceType),
    vlan: __expectInt32(output.vlan),
  } as any;
};

const deserializeAws_json1_1VirtualInterfaceList = (output: any, context: __SerdeContext): VirtualInterface[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1VirtualInterface(entry, context);
    });
};

const deserializeAws_json1_1VirtualInterfaces = (output: any, context: __SerdeContext): VirtualInterfaces => {
  return {
    virtualInterfaces:
      output.virtualInterfaces !== undefined && output.virtualInterfaces !== null
        ? deserializeAws_json1_1VirtualInterfaceList(output.virtualInterfaces, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1VirtualInterfaceTestHistory = (
  output: any,
  context: __SerdeContext
): VirtualInterfaceTestHistory => {
  return {
    bgpPeers:
      output.bgpPeers !== undefined && output.bgpPeers !== null
        ? deserializeAws_json1_1BGPPeerIdList(output.bgpPeers, context)
        : undefined,
    endTime:
      output.endTime !== undefined && output.endTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.endTime)))
        : undefined,
    ownerAccount: __expectString(output.ownerAccount),
    startTime:
      output.startTime !== undefined && output.startTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startTime)))
        : undefined,
    status: __expectString(output.status),
    testDurationInMinutes: __expectInt32(output.testDurationInMinutes),
    testId: __expectString(output.testId),
    virtualInterfaceId: __expectString(output.virtualInterfaceId),
  } as any;
};

const deserializeAws_json1_1VirtualInterfaceTestHistoryList = (
  output: any,
  context: __SerdeContext
): VirtualInterfaceTestHistory[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_json1_1VirtualInterfaceTestHistory(entry, context);
    });
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"],
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody: any = new Uint8Array(), context: __SerdeContext): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody: any, context: __SerdeContext): Promise<string> =>
  collectBody(streamBody, context).then((body) => context.utf8Encoder(body));

const buildHttpRpcRequest = async (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents: any = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers,
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });

/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output: __HttpResponse, data: any): string => {
  const findKey = (object: any, key: string) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());

  const sanitizeErrorCode = (rawValue: string): string => {
    let cleanValue = rawValue;
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };

  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== undefined) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }

  if (data.code !== undefined) {
    return sanitizeErrorCode(data.code);
  }

  if (data["__type"] !== undefined) {
    return sanitizeErrorCode(data["__type"]);
  }

  return "";
};
